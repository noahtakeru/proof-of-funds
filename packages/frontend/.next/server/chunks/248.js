"use strict";exports.id=248,exports.ids=[248],exports.modules={248:(t,e,r)=>{r.d(e,{getEthers:()=>i,parseAmount:()=>o});let s=null,i=async()=>{if(!s)try{"undefined"==typeof require?s={ethers:await r.e(274).then(r.bind(r,2274))}:s={ethers:require("ethers")}}catch(t){s={ethers:{utils:{parseUnits:(t,e)=>({toString:()=>t}),formatUnits:(t,e)=>t.toString(),isAddress:t=>"string"==typeof t&&t.startsWith("0x"),getAddress:t=>t,keccak256:t=>"0x1234567890abcdef1234567890abcdef12345678",toUtf8Bytes:t=>t,hexlify:t=>"function"==typeof t.startsWith?t.startsWith("0x")?t:"0x"+t:"0x1234",arrayify:()=>new Uint8Array([1,2,3,4]),recoverPublicKey:()=>"0x1234",splitSignature:()=>({r:"0x1234",s:"0x5678",v:27}),defaultAbiCoder:{encode:()=>"0x1234"}},BigNumber:{from:t=>({toString:()=>String(t),lt:()=>!1,gt:()=>!1})},Wallet:class{constructor(){this.address="0x1234567890123456789012345678901234567890"}connect(){return this}signMessage(){return"0x1234"}}}}}return s},n=t=>{if(!t||""===t.trim())return!1;let e=Number(t);return!isNaN(e)&&!(e<0)},o=async(t,e=18)=>{try{let{ethers:r}=await i();if(!n(t))return console.warn(`Invalid amount provided: "${t}". Using 0 as fallback.`),"0";return r.utils.parseUnits(t,e).toString()}catch(t){throw console.error("Error parsing amount:",t),Error(`Failed to parse amount: ${t.message}`)}};"undefined"!=typeof module&&module.exports&&(module.exports={getEthers:i,isValidAmount:n,parseAmount:o})}};