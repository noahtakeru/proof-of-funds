"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["common_node_modules_ethers_lib_esm_index_js"],{

/***/ "../../node_modules/@adraffy/ens-normalize/dist/index.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@adraffy/ens-normalize/dist/index.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_beautify: function() { return /* binding */ ens_beautify; },\n/* harmony export */   ens_emoji: function() { return /* binding */ ens_emoji; },\n/* harmony export */   ens_normalize: function() { return /* binding */ ens_normalize; },\n/* harmony export */   ens_normalize_fragment: function() { return /* binding */ ens_normalize_fragment; },\n/* harmony export */   ens_split: function() { return /* binding */ ens_split; },\n/* harmony export */   ens_tokenize: function() { return /* binding */ ens_tokenize; },\n/* harmony export */   is_combining_mark: function() { return /* binding */ is_combining_mark; },\n/* harmony export */   nfc: function() { return /* binding */ nfc; },\n/* harmony export */   nfd: function() { return /* binding */ nfd; },\n/* harmony export */   safe_str_from_cps: function() { return /* binding */ safe_str_from_cps; },\n/* harmony export */   should_escape: function() { return /* binding */ should_escape; }\n/* harmony export */ });\n// created 2023-09-25T01:01:55.148Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32\nvar COMPRESSED$1 = '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';\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\r\n\r\n\r\nfunction read_trie(next) {\r\n\tlet ret = [];\r\n\tlet sorted = read_sorted(next); \r\n\texpand(decode([]), []);\r\n\treturn ret; // not sorted\r\n\tfunction decode(Q) { // characters that lead into this node\r\n\t\tlet S = next(); // state: valid, save, check\r\n\t\tlet B = read_array_while(() => { // buckets leading to new nodes\r\n\t\t\tlet cps = read_sorted(next).map(i => sorted[i]);\r\n\t\t\tif (cps.length) return decode(cps);\r\n\t\t});\r\n\t\treturn {S, B, Q};\r\n\t}\r\n\tfunction expand({S, B}, cps, saved) {\r\n\t\tif (S & 4 && saved === cps[cps.length-1]) return;\r\n\t\tif (S & 2) saved = cps[cps.length-1];\r\n\t\tif (S & 1) ret.push(cps); \r\n\t\tfor (let br of B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\texpand(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\n\n// created 2023-09-25T01:01:55.148Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\nvar COMPRESSED = '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';\n\n// https://unicode.org/reports/tr15/\r\n// for reference implementation\r\n// see: /derive/nf.js\r\n\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\r\n\r\nfunction init$1() {\r\n\t//console.time('nf');\r\n\tlet r = read_compressed_payload(COMPRESSED);\r\n\tSHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\n\tEXCLUSIONS = new Set(read_sorted(r));\r\n\tDECOMP = new Map();\r\n\tRECOMP = new Map();\r\n\tfor (let [cp, cps] of read_mapped(r)) {\r\n\t\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\t\tlet [a, b] = cps;\r\n\t\t\tlet bucket = RECOMP.get(a);\r\n\t\t\tif (!bucket) {\r\n\t\t\t\tbucket = new Map();\r\n\t\t\t\tRECOMP.set(a, bucket);\r\n\t\t\t}\r\n\t\t\tbucket.set(b, cp);\r\n\t\t}\r\n\t\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n\t}\r\n\t//console.timeEnd('nf');\r\n\t// 20230905: 11ms\r\n}\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tif (!SHIFTED_RANK) init$1();\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\nconst HYPHEN = 0x2D;\r\nconst STOP = 0x2E;\r\nconst STOP_CH = '.';\r\nconst FE0F = 0xFE0F;\r\nconst UNIQUE_PH = 1;\r\n\r\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\r\nconst Array_from = x => Array.from(x); // Array.from.bind(Array);\r\n\r\nfunction group_has_cp(g, cp) {\r\n\t// 20230913: keep primary and secondary distinct instead of creating valid union\r\n\treturn g.P.has(cp) || g.Q.has(cp);\r\n}\r\n\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; } // free tagging system\r\n}\r\n\r\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\r\n\r\nfunction init() {\r\n\tif (MAPPED) return;\r\n\t\r\n\tlet r = read_compressed_payload(COMPRESSED$1);\r\n\tconst read_sorted_array = () => read_sorted(r);\r\n\tconst read_sorted_set = () => new Set(read_sorted_array());\r\n\tconst set_add_many = (set, v) => v.forEach(x => set.add(x));\r\n\r\n\tMAPPED = new Map(read_mapped(r)); \r\n\tIGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\r\n\r\n\t/*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/\r\n\t// 20230217: we still need all CM for proper error formatting\r\n\t// but norm only needs NSM subset that are potentially-valid\r\n\tCM = read_sorted_array();\r\n\tNSM = new Set(read_sorted_array().map(i => CM[i]));\r\n\tCM = new Set(CM);\r\n\t\r\n\tESCAPE = read_sorted_set(); // characters that should not be printed\r\n\tNFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\r\n\r\n\tlet chunks = read_sorted_arrays(r);\r\n\tlet unrestricted = r();\r\n\t//const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\r\n\tconst read_chunked = () => {\r\n\t\t// 20230921: build set in parts, 2x faster\r\n\t\tlet set = new Set();\r\n\t\tread_sorted_array().forEach(i => set_add_many(set, chunks[i]));\r\n\t\tset_add_many(set, read_sorted_array());\r\n\t\treturn set; \r\n\t};\r\n\tGROUPS = read_array_while(i => {\r\n\t\t// minifier property mangling seems unsafe\r\n\t\t// so these are manually renamed to single chars\r\n\t\tlet N = read_array_while(r).map(x => x+0x60);\r\n\t\tif (N.length) {\r\n\t\t\tlet R = i >= unrestricted; // unrestricted then restricted\r\n\t\t\tN[0] -= 32; // capitalize\r\n\t\t\tN = str_from_cps(N);\r\n\t\t\tif (R) N=`Restricted[${N}]`;\r\n\t\t\tlet P = read_chunked(); // primary\r\n\t\t\tlet Q = read_chunked(); // secondary\r\n\t\t\tlet M = !r(); // not-whitelisted, check for NSM\r\n\t\t\t// *** this code currently isn't needed ***\r\n\t\t\t/*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/\r\n\t\t\treturn {N, P, Q, M, R};\r\n\t\t}\r\n\t});\r\n\r\n\t// decode compressed wholes\r\n\tWHOLE_VALID = read_sorted_set();\r\n\tWHOLE_MAP = new Map();\r\n\tlet wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted\r\n\twholes.forEach((cp, i) => {\r\n\t\tlet d = r(); \r\n\t\tlet w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};\r\n\t\tw.V.push(cp); // add to member set\r\n\t\tif (!WHOLE_VALID.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t\t}\r\n\t});\r\n\r\n\t// compute confusable-extent complements\r\n\t// usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\r\n\tfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t\t// connect all groups that have each whole character\r\n\t\tlet recs = [];\r\n\t\tfor (let cp of V) {\r\n\t\t\tlet gs = GROUPS.filter(g => group_has_cp(g, cp));\r\n\t\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\t\tif (!rec) {\r\n\t\t\t\trec = {G: new Set(), V: []};\r\n\t\t\t\trecs.push(rec);\r\n\t\t\t}\r\n\t\t\trec.V.push(cp);\r\n\t\t\tset_add_many(rec.G, gs);\r\n\t\t}\r\n\t\t// per character cache groups which are not a member of the extent\r\n\t\tlet union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole\r\n\t\tfor (let {G, V} of recs) {\r\n\t\t\tlet complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent\r\n\t\t\tfor (let cp of V) {\r\n\t\t\t\tM.set(cp, complement); // this is the same reference\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// compute valid set\r\n\t// 20230924: VALID was union but can be re-used\r\n\tVALID = new Set(); // exists in 1+ groups\r\n\tlet multi = new Set(); // exists in 2+ groups\r\n\tconst add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\r\n\tfor (let g of GROUPS) {\r\n\t\tfor (let cp of g.P) add_to_union(cp);\r\n\t\tfor (let cp of g.Q) add_to_union(cp);\r\n\t}\r\n\t// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\n\tfor (let cp of VALID) {\r\n\t\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t\t}\r\n\t}\r\n\t// add all decomposed parts\r\n\t// see derive: \"Valid is Closed (via Brute-force)\"\r\n\tset_add_many(VALID, nfd(VALID));\r\n\t\r\n\t// decode emoji\r\n\t// 20230719: emoji are now fully-expanded to avoid quirk logic \r\n\tEMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);\r\n\tEMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\r\n\tfor (let cps of EMOJI_LIST) {\r\n\t\t// 20230719: change to *slightly* stricter algorithm which disallows \r\n\t\t// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\r\n\t\t// example: beautified [A B] (eg. flag emoji) \r\n\t\t//  before: allow: [A FE0F B], error: [A FE0F FE0F B] \r\n\t\t//   after: error: both\r\n\t\t// note: this code now matches ENSNormalize.{cs,java} logic\r\n\t\tlet prev = [EMOJI_ROOT];\r\n\t\tfor (let cp of cps) {\r\n\t\t\tlet next = prev.map(node => {\r\n\t\t\t\tlet child = node.get(cp);\r\n\t\t\t\tif (!child) {\r\n\t\t\t\t\t// should this be object? \r\n\t\t\t\t\t// (most have 1-2 items, few have many)\r\n\t\t\t\t\t// 20230719: no, v8 default map is 4?\r\n\t\t\t\t\tchild = new Map();\r\n\t\t\t\t\tnode.set(cp, child);\r\n\t\t\t\t}\r\n\t\t\t\treturn child;\r\n\t\t\t});\r\n\t\t\tif (cp === FE0F) {\r\n\t\t\t\tprev.push(...next); // less than 20 elements\r\n\t\t\t} else {\r\n\t\t\t\tprev = next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let x of prev) {\r\n\t\t\tx.V = cps;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`); // this can only be ascii so cant be bidi\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// if cps exceed max, middle truncate with ellipsis\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('');\r\n\tif (cps.length > max) {\r\n\t\tmax >>= 1;\r\n\t\tcps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];\r\n\t}\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\n// note: Object.freeze() doesn't work\r\nfunction is_combining_mark(cp) {\r\n\tinit();\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\tinit();\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\tinit();\r\n\treturn EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tinit();\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(split(name, nfc, filter_fe0f));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet labels = split(name, nfc, x => x); // emoji not exposed\r\n\tfor (let {type, output, error} of labels) {\r\n\t\tif (error) break; // flatten will throw\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t//  =>  if not greek\r\n\t\tif (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t// https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(labels);\r\n}\r\n\r\nfunction array_replace(v, a, b) {\r\n\tlet prev = 0;\r\n\twhile (true) {\r\n\t\tlet next = v.indexOf(a, prev);\r\n\t\tif (next < 0) break;\r\n\t\tv[next] = b; \r\n\t\tprev = next + 1;\r\n\t}\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\treturn split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy\r\n}\r\n\r\nfunction split(name, nf, ef) {\r\n\tif (!name) return []; // 20230719: empty name allowance\r\n\tinit();\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = tokens_from_str(input, nf, ef);\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} \r\n\t\t\tlet norm = info.output = tokens.flat();\r\n\t\t\tcheck_leading_underscore(norm);\r\n\t\t\tlet emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\r\n\t\t\tif (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\tcheck_label_extension(norm); // only needed for ascii\r\n\t\t\t\t// cant have fenced\r\n\t\t\t\t// cant have cm\r\n\t\t\t\t// cant have wholes\r\n\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\ttype = 'ASCII';\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\tlet unique = Array_from(new Set(chars));\r\n\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = [];\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : Array_from(set);\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaining groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => group_has_cp(g, cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => group_has_cp(g, cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (!GROUPS.some(g => group_has_cp(g, cp))) { \r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\t// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\r\n\t\t\t\t// note: this doesn't have to be a composition\r\n\t\t\t\t// 20230720: change to full check\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp)); // only check primary\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tfor (let cp of cps) {\r\n\t\tif (!group_has_cp(g, cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (g.M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abcd\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\n// 20230818: rename for 'process' name collision h/t Javarome\r\n// https://github.com/adraffy/ens-normalize.js/issues/23\r\nfunction tokens_from_str(input, nf, ef) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(ef(emoji));\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps); // less than 10 elements\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\t// 20230912: unicode 15.1 changed the order of processing such that\r\n\t\t\t\t\t// disallowed parts are only rejected after NFC\r\n\t\t\t\t\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t\t\t\t\t// this doesn't impact normalization as of today\r\n\t\t\t\t\t// technically, this error can be removed as the group logic will apply similar logic\r\n\t\t\t\t\t// however the error type might be less clear\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet pos = cps.length;\r\n\twhile (pos) {\r\n\t\tnode = node.get(cps[--pos]);\r\n\t\tif (!node) break;\r\n\t\tlet {V} = node;\r\n\t\tif (V) { // this is a valid emoji (so far)\r\n\t\t\temoji = V;\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\treturn emoji;\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tinit();\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TY_EMOJI,\r\n\t\t\t\temoji: emoji.slice(), // copy emoji\r\n\t\t\t\tinput: eaten,\r\n\t\t\t\tcps: filter_fe0f(emoji)\r\n\t\t\t});\r\n\t\t\teaten = []; // reset buffer\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BhZHJhZmZ5L2Vucy1ub3JtYWxpemUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVU7QUFDVjtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEVBQUUsWUFBWSxHQUFHLDhCQUE4QixFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFD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QkFBaUI7QUFDakIsTUFBTTtBQUNOLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUssc0NBQXNDO0FBQzNDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBNEQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7O0FBRWtLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4Lm1qcz85ZDc1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNyZWF0ZWQgMjAyMy0wOS0yNVQwMTowMTo1NS4xNDhaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtZW5zIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogMDU2NWVkMDQ5YjljZjE2MTRiYjllMTFiYTdkOGFjNmE2ZmI5NmM4OTMyNTNkODkwZjdlMmIyODg0YjlkZWQzMlxudmFyIENPTVBSRVNTRUQkMSA9ICdBRUVVZHdtZ0RTOEJ4UUtLQVA0Qk9nRGpBVEFBbmdEVUFJTUFvQUJvQU9BQWFnQ09BRVFBaEFCTUFISUFPd0E5QUNzQU5nQW1BR0lBSGdBdUFDZ0FKd0FYQUMwQUdnQWpBQjhBTHdBVUFDa0FFZ0FlQUFrQUd3QVJBQmtBRmdBNUFDZ0FMUUFyQURjQUZRQXBBQkFBSGdBaUFCQUFHZ0FlQUJNQUdBVWhCZThCRnhSRU44c0Yyd0M1QUs1SEFXOEFyUWtEelFDdWh6YzNOemNCUDY4TkVmTUFCUWRIQnV3NUJWOEZZQUE5TXprSTlyNFpCZzdReVFBV0E5Q2VPd0xOQ2pjQ2pxa0NodUEvbG0rUkFzWFRBb1A2QVNmbkVRRHl0UUZKQWpXVkNrZVhBT3NBNmdvZEFCL2N3ZEFVRTBXbEJDTi9BUVVDUVJqRkQvTVJCakh4RFFTSmJ3MGpCelVBc3dCeG1lK3RuSWNBWXdhYkF5c0c4UUFqQUVNTW14Y0RxZ1BLUXlEWENNTXhBN2tVUXdEM05YT3JBS21GSUFBZkJDMEQzeDRCSlFEQkdkVUZBaEVnVkQ4Sm53bVFKaU5XWVV6cmcwb0FHd0FVQUIwQUZuTmNBQ2tBRmdCUDloM2dQZnNET1dES25lWTJDaGdsWDFVRFlEMzBBQnNBRkFBZEFCWnpJR1JBbndERDh3QWpBRUVNelJiRHFnTUIyc0FGWXdYcUF0Q25Bc1M0QXdwVUpLUnRGSHNhZFV6OUFNTVZid0xwQUJNMU5KRVgwWmtDZ1lNQkV5TUF4UlZ2QXVrQUV6VUJVRkF0bVV3U0F5NERCVEVSMzNFZnRRSGZTd0I1TXhKL0Fqa1dLUUx6TDhFL2N3QkI2UUg5TFFEUER0TzlBU05yaVFDNURRQU5Bd0NLMjFFRkk5MXpId0NvTDlrQnFRY0hCd2NIS3pVRG93QnZBUW9oUHZVM2ZBUWdId0N5QWM4Q0tRTUE1ek1TZXpyN1VMZ0ZtRHAvTHpWUUJnRUdBaThGWVFWZ3Q4QUZjVHRsUWhwQ1dFbWZlNXRtWjZJQUV4c0R6UTh0K1g4ckJLdFRBbHRiQW4wanN5OEJsNnV0UFdNRFRSOEVpMmtSQU5rREJyTkhOeXNEQnpFQ1FXVUFjd0ZwSjNrQWl5VWhBSjBCVWI4QUwzRWZBYmZOQXo4MUtVc0ZXd0YzWVFadEFtMEErVkVmQXpFSkRRQlJTUUN6QVFCbEFIc0FNNzBHRC92M0laV0hCd0FSS1FBeEFMc2pUd0haQWVNUEV6bVhnSUh3QUJJQUdRQThBRVVBUUR0M2dkdklFR2NRWkFrR1RSRk1kRUlWRXdLMEQ2NEw3UkVkRE5rcTA5UGdBRFN4Qi9NRFd3ZnpBMXNEV3dmekIvTURXd2Z6QTFzRFd3TmJBMXNjRXZBaTI4Z1FadzlRQkhVRmxnV1RCTjRJaXlaUkVZa0hNQWphVkJWMEpoeFBBMDBCQkNNdFNTUTdtek1USlVwTUZFMExDQVEyU215dmZVQURUekd6VlAyUXFnUFRNbGM1ZEFrR0hua1NxQUF5RDNza05iMU9obnBQY2FnS1UwKzJ0WWRKYWs1dkFzWTZzRUFBQ2lrSm0yL0RkMVlHUlJBZko2a1Erd3czQWJrQlB3M3hTOXdFOVFZL0JNMGZnUmtkRDlHVm9BaXBMZUVNOFNibkxxV0FYaVA1S29jRjhVdjRQT0VMVVZGc0QxMExhUW5uT21lQlVnTWxBUkVpandyaERUMEljUkQzQ3MxdkRla1JTUWM5QTlsSm5nQ3BCd1VMRlIwNUZia21GR0t3Q3cwNWV3Yi9Hdm9Ma3lhekV5MTdBQVhYR2lVR1VRRXRHd01BMHk3cmhiUmFOVndnVDJNR0J3c3BJOHNVckZBa0RTbEF1M2hNR2g4SEdTV3RBcFZEZEVxTFVUb2VseUg2UEVFTmFpNFhVWUFIK1R3SkdWTUxoVHlpUnE5RkVoSFdQcEU5VENKTlREQUVPWU1zTXllUENkTVBpUXk5ZkhZQlhRa2xDYlVNZFJNMUVSczN5UWc5QngweGx5Z25HUWdsUnBsZ25nVDdvd1AzRTlVRER3VkRDVVVIRndPNUhERVRNaFV0QlJHQktOc0M5emJaTHJjQ2sxYUVBUnNGenc4cEgrTVFWRWZrRHUwSW53SnBBNGNsN3dBeEZTVUFHeUtmQ0VkbkFHT1AzRk1KTHM4SXkycHdJM2dEYXhUclpSRjNCNVVPV3dlckhEY1Z3eHpsY014ZUQ0WU1LS2V6Q1Y4QmVRbWRBV01FNXdnTk5WK01wQ0JGWjFlTFhCaWZJR1ZCUTE0QUFqVU1hUldqUk1HSGZBS1BEMjhTSHdFNUFYY0hQUTBGQW5zUjhSRnZFSmtJNzRZSU5ia3ovRG9wQkZNaGh5QVZDaXNEVTJ6U0N5c20vUXo4YlFHbkVtWURFRFJCZC9KbnIyQzZLQmdCQngweXlVRmtJZlVMbGsvUkRLQWF4UmhHVkRJWjZBZkRBL2NhOXlmdVFWc0dBd09uQnhjNlVUUHlCTUVMYlFpUENVTUFUUTZuR3dmYkdHNEtkWXpVQVRXUEFidWRBMXVWaHdKemt3WTdCdzhBYXcrTEJYM3BBQ0VDcXdpbkFBa0Ewd05iQUQwQ3NRZWhBQjBBaVVVQlFRTXJNd0VsNlFLVEE1Y0lOYzhCbVRNQjl5MEVIOGNNR1FEN08yNU9Bc08xQW9CdVpxWUY0VndDa2dKTk9RRlJLUVFKVWt0VkE3TjE1UURmQUU4R0YrTkxBUm12VHM4ZTUwY0I0M012QU1zQS93QUpPUWNKUlFIUkFmZHhBTHNCWXdzMUNhYTN1UUZSN1MwQWh3QVpid0hiQW8wQTRRQTVBSVAxQVZjQVVRVmQvUVhYQWxOTkFSVTFIQzliWlFHL0F5TUJOd0VSQUgwR3o1R3B6UXNqQkhFSDF3SVFIeFhsQXU4eUI3a0ZBeUxqRTlGQ3lRSzk0bGtBTWhvS1BBcXJDcXBnWDJRM0NqVjJQVlFBRWgrc1Bzcy9VZ1ZWTzFjN1hEdFhPMXc3Vnp0Y08xYzdYRHRYTzF3RG04UG13K1lLY0Y5SlllOE1xZzNZUk13NlRSUGZZRlZnTmhQTUxic1V4UlhTSlZvWlFSckFKd2tsNkZVTkR3Z3QxMlkwQ0RBMGVSZkFBRU1wYklORlk0b2VOQXBQSE90VGxWVDhMUjhBdFV1bU03TU5zQnNaUkVRRlMzWHhZaTRXRWdvbUFtU0ZBbUpHWDFHekFWODNKQUtoK3dKb25BSm1EUUtmaURnZkR3Sm1Qd0ptS2dSeUJJTURmeGNEZnBZNUNqbDdHem1HT2ljbkFtd2hBakk2T0E0Q2Jjc0NiYkx6amdNM2Ewa3ZBV3NBNGdEbEFFNEpCNXdNa1FFQ0Q4WUFFYmtDZHpNQ2RxWkRBbmxQUndKNHZpRmczMFd5UnZjQ2ZFTUNlc3dDZlEwQ2ZQUklCRWlCWnlnQUx4bEpYRXBmR1J0SzBBTFJCUUxRMEVzckE0aFRBNGZxUk1tUk5nTHlwVjBIQXdPeVM5Sk1NU2tIMDAxUVRiTUNpME1DaXR6Rkh3c2hSMnNKdXdLT093S09ZRVNiaFFLTzNRS09ZSHhSdUZNNUFRNVMyRlNKQXBQL0FwTVFBTzBBSUZVaVZiTlYxQW9zSHltWmlqTGxlR3BGUHowQ2w2TUM3N1pZSmF3QVhTa0NscE1DbG9DZ0FLMVpzRm9OaFZFQVB3S1d1UUtXVWx4SVhOVUNtYzhDbVdoY3psMExIUUtjbnpuR09xRUNuQm9DbjU4Q25yeU9BQ0VUTlM0VEFwMzFBcDZXQUxsQllUaGg4d0tlMXdLZ2NnR3RBcDZqSXdLZVVxbGp6R1FyS1M4Q0o3TUNKb0lDb1A4Q29GRGJBcVl6QXFYU0FxZ0RBSUVDcC9ab2dHaTFBQWROYWlCcTFRS3M1d0tzc2dLdGF3S3RCZ0pYSVFKVjRBS3g1ZHNESDFKc213S3l3UkVDc3V3YmJPUnRaMjFNWXdNbDBRSzJZRDlEYnBRREtVa0N1R0lDdVVzWkFya3VlM0E2Y09VQ3ZSMERMYllETWhVQ3ZveHlCZ016ZFFLK0huTW1jMU1Ddzg4Q3d3aHpoblJQT1VsMDVBTThxd0VEUEo0RFBjTUN4WUFDeGtzQ3hoU05Bc2h0VlFMSVNBTEpVd0xKTWdKa29RTGQxbmg5WlhpeWVTbEwxQU1ZcDJjR0FtSDRHZmVWS0hzUFhwWmV2eFVDejI4Q3ozQXpUMWZXOXhlakFNcXhBczkzQVMzdUEwNFdmazhKQXR3ckF0dU9BdEpUQTFKZ0ExTmpBUVVEVlpDQWpVTUV6eHJ4WkVsNUE0TFNnNUVDMnNzQzJlS0VGSVJOcDBBRGhxa0FNd05rRW9aMVhmMEFXUUxmYVFMZXZIZDdBdUl6N1JnQjh6UXJBZlNmQWZMV2l3THI5d0xwZEgwREF1cjlBdXJvQVAxTEFiMEM3bzBDNjZDV3JwY0hBdTVEQTRYa21IMXc1SEdsQXZNSEFHMERqaHFabHdMM0Z3T1JjZ09TaXdMM25BTDUzUUw0YXBvZ21xKy9PNXNpQTUySEF2NytBUjhBUFo4Z0FaKzNBd1dSQTZadUE2YmRBTlhKQXdadW9ZeWlDUTBEREUwQkV3RWpCM0VHWmIxckNRQy9CRy9ERlk4ZXR4RUFHM2s5QUNjRE54SlJBNDJEQVdjckpRQ004d0FsQU9hbkM2T1ZDTHNHSTZmSkJnQ3ZCUm5EQnZFbFJVWUZGb0FGY0Q5R1NETkNLVUs4WDNrWlg4UUFsczBGT2dDUVZDR2J3VHN1WURvWnV0Y09OeGpPR0pISi9nVmZCV0FGWHdWZ0JXc0ZZQVZmQldBRlh3VmdCVjhGWUFWZkJXQk9IUWpmalc4S0Nnb0tiRjd4TXdUUkE3a0dOOFBEQU1NRXI4TUE3MGd4RnJvRlRqNXhQbmhDUjBLK1gzMC9YL0FBV0JrenN3Q05Cc3h6ekFTbTcwYUNSUzRyRERNZUx6NDlmblhmY3NINUdjb3NjUUZ6MTNZNEh3Vm5CWExKeWNuQUNOZFJZd2dJQ0FxRVhvV1R4Z0E3UDRrQUN4YlpCdTIxS3cwQWpNc1RBd2tWQU9WdEpVVXNKMUpDdVVMRVNVQXJYeTlnUGk5QUt3bkpSUVlLVEQ5TFBvQStpVDU0UG5rQ2tVTEVVVXBEWDlOV1YzSlZFalFBYzF3M0EzSUJFM1luWCtnN1FpTUpiNk1LYWlzelJDVXVRck5DeERQTUNjd0VYOUVXSnpZUkVCRUVCd0lIS242bDMzSkNOVklmeWJQSnRBbHR5ZFBVQ21oQlp3L3RFS3NaQUpPVkpVMUNMUnV4YlVIT1FBbzdQMHMrZUVKSEhBOFNKVlJQZEdNME5WcnB2Qm9LaGZVbE0wSkhIR1VRVWhFV08xeExTajhNTzB1Y05BcUpJelZDUnh2OUVGc3FLeUE0T1FnTmoybndaZ3A1Wk5GZ0UyQTFLM1lIUzJBaFFRb2pKbUM3RGdwekdHMVdZRlVaQ1FZSFpPOWdIV0NkWUlWZ3UyQlRZSmx3Rmg4R3ZSYmNYYkc4WWd0REhyTUJ3elBWeVFvbkhRZ2tDeVlCZ1FKMEFqYzRuVnFJQXdHU0NzQlBJZ0RzSzNTV0V0SVZCYTVOOGdHakFvK2tWd1ZJWndEL0FFVVNDRHdlWDRJVHJSUXNKOEszVHdCWEZEd0VBQjBUdnpWY0F0b1RTMjBSSXdEZ1ZnWjlCQkltWWdBNUFMNENvaThMRm5lek9rQ25JUUZqQVk0S0JBUGg5UmNHc2daU0JzRUFKY3Rkc1dJUnUya1RrUXN0Unc3REFjTUJLZ3BQQkdJR01EQXdLQ1luS1RRYUxnNEFLUlNWQUZ3Q2RsK1lVWjBKZGljRkQzbFBBZHQxRjlaWktDR3h1RTN5QnhrRlZHY0Evd0JGRWdpQ0J3QU9MSFFTanhPdFFEZzF6N2RlRlJNQVo4UVRBR3RLYjFBcElpUEhBRGtBdmdLaUx5MURGdFlDbUJpREFsRERXTkIwZW83ZnBhTU8vYUVWUlJ2MEFURVFaQklPRHlNRUFjOEpRaENiRFJnekZENFRBRU1BdTlZQkNnQ3NBT2tBbTVJM0FCd0FZeHZPTm5SK01oWEpBeGdLUXl4TDIra2tKaE1iaFFLREJNa1NzdkYwQUQ5Qk5RNnVRQzdXcVNRSHd4RUFFRUl1MWhraEFIMno0aVFQd3lKUEhOV3BkeVlCUlNwbkpBTHpvQkFFVlBQc0gyME14QTBDQ0VRS1JnQUZ5QXRGQWxNTnd3akVEVVFKUkFyRUx0YXBNZzdERFpnSkl3K1RHdWtFSXd2REZrTUFxQXRERU1NTUJoaW9lK1FBTzNNTVJBQUNyZ25FQlNQWTlRMEZEbmJTQm9NQUI4TVNZeGtTeEFFSkFQSUpBQUI4RldNT0Z0TWMvSGNYd3hoREFDN0RBdk9vd3dBZXd3SmRLREtIQUFIREFBTHJGVVFWd3dBYnd5dnpwV01Xdjh3QS9BQnBBeSsrYmNZRFVLUEQwS2hEQ3dLbUoxTUFBbU1BNStVWnd4QWFnd2lwQlJML2VBRGZ3NmZER09NQ0dzT2prM2w2QndPcG80c0FFc01PR3hNQUE1c0FiY01PQUF2RHAwTUpHa01Ed2dpcG5OSVBBd2ZJcVVNR0FPR0RBQVB6QUJYREFBY0RBQW5EQUdtVEFCckRBQTdEQ2hqRGpuRVdBd0FCWXdBT2N3QXVVeVlBQnNNQUY4TUlLUUFOVWdDNnd5NEFBOE1BRHFNcTh3Q3lZZ0FjSXdBQjh3cXBBQVhPQ3gwVjR3QUhvd0JDd3dFS0FHbkRBQXVEQUIzREFBakRDYWtBQmRJQWJxY1ozUUNaQ0NrQUJkSUFBQUZEQUFmakFCMmpDQ2tBQnFJQUNZTUFHek1BYlNNQTVzT0lBQWhqQUFoREFCVERCQWtwQUFiU0FPT1RBQWxEQzZrT3pQdG5BQWREQUc2a1FGQUFUd0FLd3d3QUEwTUFDYlVEUHdBSEl3QVpnd0FDRTZjREFBb2pBQXBEQUFvRHAvTUd3d0FKSXdBREV3QVFRd2dBRkVNQUVYTUFENU1BRGZNQURjTUFHUk1PRmlNQUZVTUFicU1XdXdIREFNSUFFME1MQUdrekVnRGhVd0FDUXdBRVdnQVhnd1VqQUFiWUFCakRCU1lCZ3pCYUFFRk5BTGNRQnhVTWVnQXdNbmdCckEwSVpnSjBLeFFIQlJFUGQxTjBaektSSndhSUhBWnFOVDREcVFxOEJ3bmdBQjREQXd0MkFYNTZUMW9jS1FOWEFoMUdBVFFHQzN0T3hZTmFna2dBTVFBNUNRQURBUUVBV3hMakFJT1lOQUV6QUg3dEZSazZUZ2xTQUY4TkFBbFlBUStTMUFDQVF3UW9yUUJpQU40ZEFKMXdQeWVUQU5WenVRRFgzQUllRU1wOWV5TWdYaVVBRWRrQmtKaXpLbHRiVlZBYVJNcVJBQUVBaHlRL1NERXo2Qm1mVndCNkFURXNPQ2xLSVJjRE9GMEUvODMyQUZOdDVBQnlBbmtDUnhHQ09zOTROalhkQXdJTkdCb25EQndQQUxXMkF3SUNBZ0FBQUFBQUFBWURCUU1EQVJyVUF3QXRBQUFBQWdFR0JnWUdCZ1lGQlFVRkJRVUVCUVlIQ0FrRUJRVUZCUVFBQUFJQ0FBQUFJZ0NOQUpBQWxUMEE2Z0M3QU53QXBFUUF3Z0N5QUswQXFBRHVBS1lBMmdDakFPY0JDQUVEQU1jQWdRQmlBTklBMUFFREFONEE4Z0NRQUtrQk1RRHFBTjhBM0FzQkNROHlPOXJhMnRxOHh1TFQxdFJKT0IwQlVnRmNOVTBCV2dGcEFXZ0JXd0ZNVVVsTGJoTUJVeHNORUFzNlBoTU9BQ2NVS3kwdk1qNUFRRU5EUTBSRkZFWUdKRmRYVjFkWldWaFpMMXBiWFZ4Y0kyTm5aMlpvWnlwc2JuWjFlSGg0ZUhoNGVucDZlbnA2ZW5wNmVucDhmSDE4ZTJJQVJQSUFTUUNhQUhnQU1nQm0rQUNPQUZjQVZ3QTNBbmJ2QUlzQUJmajRBR1FBay9JQW53QlBBR0lBWlAvL3NBQ0ZBSVVBYVFCV0FMRUFKQUMyQUlNQ1FBSkRBUHdBNXdEK0FQNEE2QUQvQU9rQTZRRG9BT1lBTHdKN0FWRUJRQUUrQVZRQlBnRStBVDRCT1FFNEFUZ0JPQUVjQVZnWEFERVFDQUVBVXg4U0hnc2RIaFlBamdDV0FLWUFVUUJxSUFJeEFIWUFid0NYQXhVREp6SURJVWxHVHpFQWtRSlBBTWNDVndLa0FNQUNsZ0tXQXBZQ2xnS1dBcFlDaXdLV0FwWUNsZ0tXQXBZQ2xnS1ZBcFVDbUFLZ0FwY0NsZ0tXQXBRQ2xBS1VBcFFDa2dLVkFuVUIxQUtYQXA4Q2xnS1dBcFVlQUlFVEJRRCtEUU9mQW1FQ09oOEJWQmc5QXVJWkVqTWJBVTQvRzFXWkFYdXNSQUZwWVFFRkEwRlBBUVlBbVRFZUlKZHlBREZvQUhFQU5nQ1JBNXpNay9DMmpHSU53ak1XeWdJWkNhWGRmRElMQkNzNWRBRTdZblFCdWdEbGhvaUhob2lHaVlxS2hvdU9qSWFOa0k2SWo0cVFpcEdHa29hVGhwU1NsWWFXaHBlS21JYVpocHFHbTRhY2k1MlFub3FmaHVJQzRYVHBBdDkwQUlwMExIU29BSXNBZEhRRVF3UkFCRUlFUlFSREJFa0VSZ1JCQkVjRVNRUklCRVFFUmdSSkFKNXVkQUNyQTQ5MEFMeHVBUTEwQU5GWmRIUUExM1FDRkhRQS9tSjBBUDRCSVFEK0FQd0EvQUQ5QVB3RGhHWjAzQVNNSzIzSEFQNEEvQUQ4QVAwQS9DUjBkQUNSWW5RQS9nQ1JBU0VBL2dDUkF2UUEvZ0NSQTRSbWROd0VqQ3R0eHlSMEFQOWlkQUVoQVA0QS9nRDhBUHdBL1FEOEFQOEEvQUQ4QVAwQS9BT0VablRjQkl3cmJjY2tkSFFBa1dKMEFTRUEvZ0NSQVA0QWtRTDBBUDRBa1FPRVpuVGNCSXdyYmNja2RBSkxBVDUwQWxJQlFYUUNVOGwwZEFKZmRIUURwZ0wwQTZZRHBnT25BNmNEcHdPbkE0Um1kTndFakN0dHh5UjBkQUNSWW5RQklRT21BSkVEcGdDUkF2UURwZ0NSQTRSbWROd0VqQ3R0eHlSMEJEaDBBSkVFT1FDUkRwVTVkU2dDQURSMDNnVjJDd0FyZEFFRkFNNWlDblIwQUYxaUFBWWNPZ3AwZEFDUkNuUUFYQUVJd1daMENuUm1kSFFBa1daMENuUm1kRVhnQUZGMDNncDBkRVkwdGxUMnUzU09BUVR3c2N3aGpaWktyaFljQlNmRnA5WE5iS2lWRE9EMmIrY3BlNC9aMTdtUW5idHp6aGFlUXRFMkdHajBJRE5UalJVU3lUeHh3L1JQSFcvK3ZTN2QxTmZSdDl6OVFQWmc0WDdRRmZoQ25rdmdOUElJdE9zQzJlVjZoUGFublpOSGxaOXhyd1pYSU1PbHUzalNvUVNxNzhXRWp3TGp3MUVMU2xGMWFCdmZ6d2s1Wlg3QVV2UXpqUFFLYkR1UStzbTR3Tk9wNEE2QWRWdVJTMHQxeS9EWnBnNFI2bTdGTmpNOUhndlc3Qmk4OHphTWpPbzZsTTh3dEJCZGo4TFA0eWx2M3pDWFBoZWJNS0pjMDY2bzlzRjcxb0ZXLzhKWHU4NkhKYndESUQ1bHp3NUdXTFIvTGhUMFFxbnAySlF4TlpOZmNiTEl6UHkrWXlwcVJtL2xCbUdtZXgrODIrUGlzeFV1bVNlSmtBTElUNnJKZXp4TUgrQ1RKbVF0dDV1d1RWYkwzcHRtakRVUXpsU0l2V2k4VGw3bmcxTnB1Um4xTmc0bjE0UWMrM0lpbDdPd2t2TldvZ0xTUGtuM3BpaElGeXR5SUdtTWhPZTNuMXRXc3VNeTlCZEt5cUY0WjN2MlNnZ2dUTDlLVnZNWFBuQ2JSZStvT3VGRlAzSGVqQkcvdzlndm1mTll2ZzZKdVdpYTJsY1NTTjF1SWpCa3R6b0lhek9IUEpaN2tLSFB6OG1SV1ZkVzNsQThXR0Y5ZFFGNkJtNjczYm9vdjNCVVdEVTJKTmNhaFIyM0d0ZkhLTE96L3ZpWityWW5aRmFJem5YTzY3Q1lFSjFmWHVUUnBaaFlaa0tlNTR4ZW9hZ2tOR0xzK05UWkhFMHJYNDUvWHZRMlJHQURYNnZjQXZkeElVQlYyN3d4R20yempabzRYM0lMZ0Fsck9GaGV1WjZ3dHN2YUlqNHlMWTdxcWF3bGxpYUljcnoyRytjM3ZzY0FuQ2tDdU16TW1adk1mdTlsTHdUdmZYKzNjVlN5UGROOVp3Z0RaaGZqUmdOSmNMaUo2N2I5eHg4Skhzd3ByYmlFM3Y5VXBob3RBUElnblhWSU41S21NYzBwaVhoYzZjQ2hQbk4rTVJoRzlhZHRkdHRRVFR3U0lwbDhJNC9qLy9kM3N6MTMyNnFUQlRwUFJNL0hnaDNrenFFWHM4WkFrNEVyUWhOTzhoenJRMERMa1dNQS9OKzkxdG4yTWRPSm5XQzJGQ1plaGtRcnd6d2JLT2podlpzYk05NVFvZUw5c2tZeU1mNHNyVlBWSlNnZzdwT0xVdHIvbjllVDk5b2U5bkx0RlJwakE5b2tWMktqOGg5azVIYUMwb2l2UkQ4VnlYa0o4MXRjZDRmSE5YUENmbG9JUWFzeHN1TzE4LzQ2ZFIyamd1bC9VSWV0Mkcwa1J2bnlPTk1LaEhzNkoyNkZFb3FTcWQrcmZZamVFR3dIV1ZEcFgxZmgxakJCY0tHTXFSZXBqdTlZMDBtRFZIQytYZGlqL2o0NHJLZnZmakdpbk5zMWpPLzBGM2pCODNYQ0RJTk4vSEI4NGF4bFArM0Uva2xrdFJvK3ZsM1UvYWl5TUpiSW9kRTFYU3NEbjZVQXpJb010VU9iWTIray80Z1kvbCtBa1pKNVNqMnZRcmt5TG0zRm94amhEWCszMVVYQkZmOVhyQUgzMWZGcW9CbURFWnZodnZwblo4N04rb1pFdTdVOU8vbm5rK1FXajN4OHV5b1JiRW5mK081VU1yOWkwbkhQMzhJRjVBdnpyQlc4WVdCVVIwbUlBekl2bmRRcTlOM3YvSnRvM2FQalBYVVBsOEFTZFBQeUFwN2pFTmY4Yms3Vk1NOW9sOVhHbWxCbWVETXVHcXQrV3p1TDZDWEF4WGpJaENQTTV2QUNjaGdNSi84WEJHTE8vRDFpc1Z2R2h3d0hIcjFETGFJNW1uMkpyL2IxcFVEOTB1Y2lEYVM4Y1hORHpDV3ZObVQvUGhRZTVlOG5Ubm5ua3Q4RHMvU0lqaWJjdW0vZnFEaEtvcHhBWThBa1NyUG4rSUdERUtPTytVM1hPUDZkakZzMkg1Tjkrb3JoT2FoaVFrNUtuRVVXYStDemtWemhwOGJNSFJiZzgxcWhqalh1SUtiSGpTTFNJQktXcW9ja0d0S2luWSt6NC9SZEJVRjZwY2MzSm1ubHhWY05nckk0U0V6S1VaU3djRDJRQ3l4ekt2ZStnQW1nNlp1U1JrcFBGYTZtZlRodTdMSk51M0g1SzQydUNwTnZQQXNvZWRvbEtWL0xIZS9lSitCYmFHNU1HME5hU0dWUFJVbU5GTUZGU1NwWEVjWHdiVmg3VUVUT1padG9WTlJHT0liYmtpZzNNY0V0UjY4Y0cwUlpBb0pldldZbzdEZy9sWjFDUXpibFdlVXZWSG1yOGZZNE5xZDlKSmlIL3pFWDI0bUp2aUg2MGZBeUZyMEEzYzRiQzFqM3laVTYwVmdKeFhuOEpnSlhMVUlzaUJubUttTVl6Kzd5QlFGQnZxYjJlWW51VzU5am9aQmY1Ni93WHZXSVI0Ujh3VG1WODBpMW1aeStTNCtCVUVTK2h6amswdVhwQy8vL3ovSWxxSFoxbW9uemxYcDhhQ2ZoR0tNdGk3M0ZJMUtiTDFxNklLTzRmdUJ1WjU5Z2Fnam41eFU3OW11TXBIWGc2UytlK2dETS9VOUJLTEhibDlsNm84Y3pRS2w0UlVrSkppcWZ0UUcyaTNCTWcvVFFsVVlGa0pEWUJPT3ZBdWdZdXpZU0RuWmJERGQvYVNkOXgwT2U2RitiSmNIZmw5K2dwNkw1L1RnQStCZEZGb3ZiZkNyUTQwczV2TVB3ODg2NnBOWDh6eUZHZUZXZHhJcFBWcDlSZzFVUE9WRmJGWnJ2YUZxL1lBekhRZ3FNV3BhaE1ZZnFIcG13WGZITDEva3BZbUd1SEZ3VDU1bVF1MGR5bGZOdXEyT3EwaFRNQ1B3cWZ4bnVCSVBMWGZjaTRZMUFOeSsxQ1VpcFF4bGQvaXpWaDE2V3lHMlEwQ1FROU5xdEFueDFIQ0h3RGo3c1l4T1NCMHdvcFpTbk96eFFPY0V4bXhyVlRGMkJrT3RoVnBHZnVoYUdFQ2ZDSnBKS3BqbmloWSt4T1QyUUp4TjYxKzlLNlFTcXR2MlNocjgySTNqZ0pycUJnMHdFTEZaUGp2SHB2elR0YUpuTEs2VmI5N1luOTMza29PL3NhTjdmc2p3Tkt6cDRsMmxKVngyb3JqQ0d6Qy80Wkw0ekN2ZXI2YVFZdEM1c2RveWNodUZFNnVmT2lvZytWV2k1VURrYm12bXRhaC8zYUFyRUJJaTM5czVJTFVubEZMZ2lsY0d1ejlDUXNoRVk3Zncyb3VvSUxBWVBWVC9neUFJcTNURkFJd1ZzbCtrdGtSei9xR2ZuQ0RHcm01Z3NsL2w5UWR2Q1dHc2pQejNkVTdYdXFLZmRVcnIvNlhJZ2pwNHJleTZBSkJtQ21VSk1qSVRIVmRGYjVtMXArZExNQ0w4dDU1ekQ0MmNtZnRtTEVKQzBEYTA0WWlSQ1ZVQkxMYThEMDcxL041VUJOQlhEaDBMRnNtaFYvNUI1RXhPQjRqM1dWRy9TM2xmSzVvK1Y2RUxIdnk2UlI5bjRhYytWc0s0VkU0eXBoUHZWK2tHOUZlZ1RCSDRaUlhMMkh5dFVIQ2R1SmF6Qi9LeWtqZmV0WXhPWFRMd3MyNjdhR09kK0krSmhLUC8vK1ZuWG1TOTBPRC9qdkxjVnUwYXN5cWN1WU4xbVNiNlhUbENrcXYxdmlnWlBJWXdORi96cFdjVDFHUi82YUVJUmpraDB5aGc0TFhKZmFHb2JZSlRZNEpJNThLaUFLZ21tZ0FLV2RsNW5ZQ2VMcWF2UkpHUU51WXVadFpGR3grSWtJNHc0TlMyeHdiZXROTXVuT2pCdS9obUtDSS93N3RmaWl5VWQvLzRyYlRlV3Q0aXpCWThZdkdJTjZ2eUtZbVAvOFg4d0hLQ2VOK1dSY0tNNzArdFhLTkd5ZXZVOUgyRGc1QnNsam5UZjhZYnNKMVRtTXM3NENlMlhsSGlzbGVndWh5ZWc0NHJRT0hadXcvNkhUa2hubnVySzJkNjJxNnlTNzIxMFNzQUlhUitqWE1RQStzdmtyTHBzVVkrRjMwVXc4OXVPZEdBUjZ2bzRGSU1FMEVmVlZlSFR1NmVLaWNmaFNxT2VYSmhiZnRjZDA4c1dFbk5VTDFDOWZucHJUZ2Q4M0lNdXQ4b25WVUYwaHZxelpmSGR1UGpiandFWEljb1lteStQNnRjSlpIbWVPdjZWcnZFZGtIREplY2pIdUhlV0FOZTc5Vkc2NjJxVGpBL0hDdnVtVnYzcUwrTHJPY3BxR3BzMlpHd1FkRko3UFU0aXV5UmxCcndmTyt4blB5cjQ3czJjWFZiV3pBeXpuRGlCR2pDTTNrc3hqanFNNjJHRTlDOGY1VTM4a0IzVmp0YWJLcC9uUmR2TUVTUEdERzkwYldSTEF0MVFrNUR5THVhelJSMVl6ZEMxYytoWlh2QVdWOHhBNzJTNEE4QjY3dmpWaGJiYTNNTW9wMjkzRmVFWHBlN3pJdE1XckpHL0xPSDlCeU9YbVluTkpmam1mdVg5S2JycGdMT2JhNG5aK2ZsOEdiZHYvaWh2KzZ3RkdLSENZclZ3bWhGQzBKM1YyYm4ydElCMXdDYzFDU1QzZDNYMk95eGhndVhjczRzbTY3OVVuZ3pvZnVTZUJld01GSmJvSVFIYlVoL20ySmhXMmhHOURJdkcydDd5Wkl6S0JUejl3QnRuTkMrMnBDUlloU0l1UTFqOHhzejVWdnFueVVJdGh2dW95eXU3Zk5JcmcvS1FVVm1HUWFxa3Faay9WeDViMzMvZ3NFczh5WDdTQzFKK05WNGljejZidklFN0M1RzZNY0JhSThyVmc1NnE1UUJKV3huLzg3UTFzUEs0K3NRYThmTFU1Z1hvNHBhYXE0Y09jUTR3UjBWQkhQR2pLaCtVbFBDYkExbkxYeUVVWDQ1cVo4SjcvTG40RlBKRTJUZHpEMFo4TUxTTlFpeWtNTW1TeU9DaUZmeTg0UnE2MGVtWUIydkQwOUtqWXdzb0lwZURjQkRURWxCYlh4TkQ3MnloZDlwQy8xQ01pZC81SFVNdkFMMjdPdGNJSkR6TktwUlBOcVBPcHl0MmFQR3o5UVdJczloUTlMaVg1czhtOWhqVFV1L2Y3TXlJYXRqamQrdFNmUTN1Zlp4UHBtSmhUYUJ0WnRLTFVjZk9DVXFBRHVPK1FvSDhCOXY2VStQMEhWMUdMUW10b05GVGIzczc0aXZaZ2pFUzBxZksrOFJkR2dCYmNDTVN5OGVCdmg5OCtldDFLSUZxU2UxS1FQeVhVTEJNVHNJWW55c0l3aVpCSllkSTIwdnNlVit3dUprY3FHZW1laEtqYUFiOUw1N3habTNnMnpYMGJaMnhrL2ZVK2JDbzdUbG5iVzdKdUYxWWRVUm8vMkd3N1ZjbERHMVc3TE90YXMyTFg0dXBpZlovMjNyenBzblkvQUxmUmdyY1dQNWhZbVY5VnhWT1FBMWZadnA5RjJVTlUrN2Q3eFJ5Vm01d2lMcDMvMGRsVjd2ZHcxUE1pWnJiREFZeklWcUVqUlkyWVUwM3NKaFBubHdJUGNaVUc1bHRMNlM4WEN4VTFlWVM1Y2pyMzR2ZUJtWEF2eTd5TjRaakFySUcwZGZELzVVcEJObFgxWlBveEpPd3lxUmkzd1FXdE96ZDRvTktoMExrb1RtOGN3cWdJZktocXFHT2h3bzcxSSt6WG5NZW1UdjJCMkFVekFCV3lGenRHZ0dVTGpERHpXWXdKVVZCVGpLQ241SzJRR01LMUNRVDdTenppT2pvK0JoQW1xQmp6dWMzeFl5bTJlZWRHZU9JUkpWeVR3RHczN2lDTWU0ZzVWYm5zYjVaQmR4T0FuTVQ3SFU0REhweFdHdVE3R2VpWTMwQ3BidnpzczU1KzVLbTFZc2JENWVhM05JOVFOWUlYb2w1YXBnU3U5ZFo4Zjh4UzVkdEhwaWRvNUJjbER1TFdZNGxoaWswdGJKYTA3eUpoSDBCT3lFdXQvR1JiWVRTNlJmaVRZV0dNQ2tOcGZTSGk3SHZkaVRnbEVWSEtaWGFWaGV6SDRra1hpSXZLb3BZQWxQdXNmdHBFNGE1SVp3dncxeC9lTHZvREloL3pwbzlGaVFJbnNUYjJTQWtLSFY0MlhZQmpwSkRnNDM3NFhpVmIzd3M0cU0wczllU1E1SHpzTVU0T1pKS3VvcEZqQk0rZEFaRWw4UlVNeDV1VTJONDg2S3IxNDF0VnNHUWZHak9SWU1DSkFNc3hFTGVOVDRSbVdqUmNwZFRHQndjeDZYTjlkcldxUG1KemNyR3JINCtEUmM3K24xdzNrUFp3dTBCa05yNmhRcnFnbzdKVEI5QTVrZEovSDdQNGNXQk13c211aXhBekpCM3lyUXBuR0lxOTBseEFYTHpEQ2RuMUxQaWJzUnQ3ckhOamdRQmtsUmdQWjh2VGJqWGRnWHJUV1FzSzVNZHJYWFFWUHAwUmlucTNmcnpaS0owcUQ2UWhjNDBWekFyYVVYbG9iMWd2a2hLM3ZwbUhnSTZGUmxRWk54NmVScWtwMHp5NEFRbFg4MTNmQVB0TDNqTVJhaXRHRkZqbzB6bUVybG9DK2grWVlkVlE2azRGL2VweEFvRjBCbXFFb0tOVHQ2ajR2UVpOUTJCb3FGOVZqNTNUT0lvTm1EaXU5WHAxNVJrSWdRSUdjb0xwZm9JYmVuenBHVUF0cUZKcDVXK0xMbngzOGpIZUVDVEovbmF2S1kxTldmTjBzWTFUOC9wQjhrSUgzRFUzRFgrdTZXM1l3cHlwQk1ZT2hiU3hHanE4NFJaODRmV0pvdzhweUhxbjRTLzlKMTVFY0NNc1hxcmZ3eWQ5bWhpdTMrckVvOXBQcG9Ka2RacUhqcmE0TnZ6Rnd1VGhOS3k2aGFvL1NsTHczWkFEVWNVcDN3M1NSVmZXMnJobDgwek9nVFluS0UwSHMycXAxSjZIM3hxUHFJa3ZVRFJNRkRZeVJic0ZJM005TUV5b3ZQazhybHc3LzBhODFjRFZMbUJzUjJ6ZTJwQnVLYjIzZmJlWkMwdVhvSXZEcHBmVHdJRHhrMU9xMmRHZXNHYytvSlhXSkxHa09oYTNDWCtEVW56Z0FwOUhHSDlSc1BaTjYzSG40Uk1BNWVTVmhQSE8rOVJjUmIvSU9ndFczMVYxUTVJUEd0b3hQakMrTUVKYlZsSU1ZQURkOWFIWVdVSVFLb3B1UE9IbW9xU2t1Ym5BS256Z0tIcWdJT2ZXNVJkQWdvdE42Qk4rTzJaWUhrdWVtTG52UThVOVRIVnJTMVJ0TG1LYmNDN1BlZURzWXpudnF6ZWc2VkNOd21yMFl5eDF3bkxqeVQ4NEJaejNFSnlDcHREM3lldWVBeURXSXMwTDJxcy9WUTNIVXlxZnJqYTBWMUxkRHpxQWlrZVd1VjRzYzdSTElCNjlqRUlCakNreVplZG9VSHFDck92U2hWenlkNzNPZHJKVzBoUE91UXYycU9vSERjOXhWYjZZdTZ1cTNYcXAyWmFINDZBN2x6ZXZieFFFbWZyenZBWVNKdVo0V0RrMUh6M1FYMUxWZGlVSzBFdmxBR0FZbEczTWQzMHI3ZGNQTjYzeXFCQ0lqMjVwcnB2WlAwbkk0K0VnV29GRzk1VjU5NkN1clhwS1JCR1JqUWxIQ3Z5NUliL2lXOG5aSld3ckVUM21nZDZtRWhmUDRLQ3VhTGpvcFdzN2grTWRYRmRJdjhkSFFKZ2cxeGkxZVlxQjB1RFlqeHdWbXJpMFN2NVhLdXQvb25xYXBDK0ZRaUMyQzFsdllKOU1WY282eURZc1MzQUFOVWZNdHZ0YllJMmhmd1phdGlTc25vVWVNWmQzNEdWamtNTUtBK1huakpwWGdSVzJTSFRacGxWb3dQbUpzdlh5NnczY2ZPMUFLMmR2dFpFS1RrQy9UWTlMRmlLSENHMERuck1RZEdtMmx6bEJITTlpRVl5bkgyVWNWTWhVRWpzYzBvREJUZ28yWlNRMWd6a0FIZVdlQlhZRmpZTHV1Zjh5elRDeTcvUkZSODFXRGpYTWJxMkJPSDVkVVJueG82b2l2bXhMM2NLektJbmxaa0QzMW52cEhCOUtrN0dmY2ZFMXQrMVY2NGI5THRnZUpHbHBSRnhRQ0FxV0o1RG9ZNzdza2k4Z3NPRU9yMnV5d1phb08vTkdhMFgweTFwTlFIQmkzYjJTVUdOcGNaeERUN3JMYkJmMUZTblE4Z3V4R1czVyszNkJXMGdCamU0RE96NkJhNlNWazB4aUtndCtxMkpPRnlyNFNZZm51K0ljMVFaWUl1d0hCcmd6cjZVdk9jU0N6UFRPbzdENklDNElTZVM3emtsNGgrMlZvZUhwbkcvdVdSMyt5c05nUGNPSVhRYnYwbjRtcjNCd1FjZEtKeGdQU2V5dVAvejFKamc0ZTluVXZvWGVncVFWSUUzMEVIeDVHSHYrRkFWVU5Ub3dZREpneUZoZjVJdmxZbUVxUmlmNitXTjFNa0VKbURjUUlUeDlGWDIzYTRteHkxQVFSc09ITy8rZUltWDlsOEVNSkkzb1BXelZYeFNPZUhVMWRVV1lyMnVBQTdBTWIrdkFFWlNiVTNxb2I5aWJDeVhleXBFTXBaNjg2M282UVBxbHFHSFprdVdBQlNUVk5kNGNPaDlodjNxRXBTeDJaeS9ESk1QNmNJdEVtaUJKNVBGcVFuREVJdDNOckEzQ09sT1NnejQzRDdncE5GTko1TUJoNG9GemhEUGlnbEMyeXBzTlU0SVN5d1kyZXJreWIxTkMzUWgvSWZXajBlRGdaSTQvbG44V1BmQnNUM21lVGpxMVVxdDFFN1psL3FmdHFreDZhTTlLdWVNQ2VrU25NcmNIajFDcVRXV3pFelBzWkdjRGUzVWU0V3MrWEZZVnhOYk9GRjhlemt2UUdSNlpPdE9MVTJsUUVuTUJTdHg0N3ZFNlBiN0FZTUJSajJPT2ZaWGZpc2pKbnBUZlNOam82c1o2cVN2TnhaTm1EZVM3R2szeVl5Q2sxSHRLTjJVbmhNSWpPWFV6QXFEdjkwbHg5Ty9xL0FUMVpNbml0NVhRZTl3bVF4bkUvV1NIMENxWjkvMkh5K1NmbXBlZzhSd3NISTVaOGtDOEgyOTNtL0xIVlZNL0JBN0hhVEpZZzVFbms3TS94V3BxMDE5MkFDZkJhaTJMQS9xckNqQ3I2RGgxQklNek1YSU5CbVg5Nk1KNUhuMm54bG4vUlhQRmh3SHhVbVNWMEVWMlYwam04Ni9keHh1WVNVMVc3c1ZrRWJOOUV6a0cwUUZ3UGh5SEt5YjN0K0ZqNVdvVVVURXJjYXpFL042RVc2THZwMGQvL1NEUGo3RVY5VWRKTitBbW5mM1d3azNBMFNsSjlaMDB5dlhaN24zejcwRzQ3SGZzb3c4V3ExSlhjZnduQStZeGE1bUZzZ1Y0NjRLS1A0VDMxd3FJZ3pGUGQzZUNlM2o1b3J5NWZCRjJoZ0NGeVZGckx6STllZXROWHZNN29RcXlGZ0RvNENUcC9oRFY5Tk1YOUpESFEvbnlIVEx2WkxOTEY2ZnRuMk94akdtOCtQcU93aHhuUEhXaXBrRS84d2J0eXJpODBTcjdwTU5rUUdNZm80WllLOU9jQ0M0RVNWRkZiTE1Jdmx4U29ScVdpZTB3eHFuTGZjTFNYTVNwTU1RRUpZRFZPYllzWElRTnY0VEdOd2pxMWt2VDFVT2tpY1RyRzNJYUJaM1hkU2NTM3U4c2dlWlBWcE9Ma2JpRjk0MEZqYkNlTlJJTk52RGJkMDFFUEJyVENQcG0xMm00M3plMWJCQjU5SWE2T3ZobnVyL052eDNJeHdTV29sKzNIMnFmQ0pSOGRmNmFRZjR2NldpT054a0srSXFUNHBLUXJaSy9McGxnREkvUEpaYk9lcDhkdGJWN29DcjZDZ2ZwV2E4TmN6T2tQeDgxaVNIYnNOaFZTSkJPdHJMSU1yTDMxTEs5VHFIcUFiQUhlMFJMbW1WODA2a1JMRExORWhVRUpmbTl1MHN4cGtMOTNaZ2Q2cncrdHFCZlRNaTU5eHFYSExYU0h3U2JTQmwwRUswK2xvRUNPUHRybCsvbnNhRmUxOTdkaTR5VWdvZTRqS29BSkRYYzZER0RqclFPb0ZEV1pKOUhYd3Q4eERyUVArN2FSd1dLV0kxR0Y4czhPNEt6eFdCQmN3bmwzdm5sMU9lejNvaDZFYTF2alI3L3o3RERUckZ0cVUyVy9LQUV6QXVYRE5aN01ZNzNNRjIxNmR6ZFNiV21VcDRsY203a2VKZldhTUhndXQ5eDVDOW1qNjZaMGxKK3loc2pWdnlpV3JmazFselBPVGRoRzE1WTdnUWxYdGFjdkk3cXYvWE5Tc2NEd3FrZ3dIVC9nVXNENXlCN0xkUlJ2SnhRR1lJTm45aFRwb2RLRlZTVFBydEd2eVF3K0hsUkZYSWtvZEVyQUd1OUl5MVlwZlNQYzNqa0ZoNUNYM2xQeHY3YXFqRS9KQWZUSXBFakdiL0g3TU8wZTJ2c1ZpU1cxcWEvTG1pNC9uNERFSTNnN2xZcmNhbnNwRGZFcEtrZFYxT2pTTE95MEJDVXFWb0VDYUI1NXZzMDZyWGw0anFtTHNQc0ZNLzd2WUowdnJCaERDbS8wMEEvSDgxbDF1ZWtKLzZMbWwzSGI5K05LaUxxQVRKbURweXpmWVpGSHVtRWpDNjYyTDBCd2t4aTdFOVU0Y1FBMFhNVkR1TVlBSWVMTVBnUWFNVk9kOGZtdDVTZmxGSWZ1Qm9zemVBdzdvdzVnWFBFMlkveUJjLzdqRXhBUlVmL0J4SUhRQkY1U24zaTYxdzR6NXhKZEN5TzFGMVgzKzNheCtKU3ZNZVo3UzZRU0twMUZwL3NqWXo2WitWZ0NaemliR2VFb3VqcnlmTXVsSDdSYWk1a0FmdDllYmNXNTBEeUpyMnVvMno5N21UV0l1NDVZc1NuTlNNcnJOVXVHMVhzWUJ0RDlURFl6UWZmS0I4N3ZXYmtNNEViUEFGZ29CVjRHUVMrdnRGRFVxT0ZBb2kxblR0bUlPdmczOE40aFQyU244cjhjbG1CQ1hzcEJsTUJZVG5ycUZKR0JUM3daT3pBeUpEcmU5ZEhINyt4N3FhYUtET0I0VVFBTEQ1ZWNTMERFNG9idWJRRWl1SlowRXBCVnBMdVljY2U4QWE0UFlkL1Y0RExEQUpCWUtRUENXVGNyRWFaNUhZYkppMTFHZDZoakdvbTFpaTE4VkhZbkcyOE5LcGt6MlVLVlB4bGhZU3A4dVpyMzY3aU9tb3k3enN4ZWhXOXd6Y3kyekcwYTgwUEJNQ1JRTWIzMmhuYUhlT1I4Zm5ORHpaaGFOWWhrT2REc0JVWjNsb0RNYTFZUDB1UzBjalVQM2IvNkRCbHFtWk9lTkFCRHNMbDVCSTVRSnVwczh1eEF1V0pka1VCL3BPNlpheDZ0c2c3Zk41bWpqRGdNR25nTytEUGNLcWlISURiRklHdWR4dFBUSXlEaTlTRk1LQkRjZmRHUVJ2NDFxMUFxbXhna1ZmSk1uUDh3L0JjN045L1RSNkM3bUdPYkZxRmtJRW9tOHNLaTJ4WXFKTFRDSEs3Y3h6YVp2cU9EbzIyYzN3aXNCQ1A0SGVBZ2NSYk5QQXNCa05SaFNtRDQ4ZEh1cGRCUnc0bUl2dFM1b2VGNnplVDFLTUN5aE1ubWhwa0ZBR1duR3Njb05rd3ZROFpNNWxFL3ZnVEhGWUw5OU91TnhkRkJ4VEVEZDV2MnFMUjh5OVdrWHNXZ0c2a1pObmRGRytwTy9VQWtPQ2lwcUloTDNocTdjUlNkckNxN1loVXNUb2NFY25hRmE2blZraG5TZVJZVUExWU8wejVpdEY5U2x5M1ZseFlEdzIzOVRKSkg2ZjNFVWZZTzVsYjdiY0ZjejhCcDdPbzhRbW5zVUhPei9mYWdWVUJ0S0V3MWlUODhqK2FLa3Y4Y3NjS05rTXhqWXI4MzQ0RDFrRm9aNy90ZDFXNkxDTllONTk0MzAxdFVHUm1GakF6ZVJnNXZ5b00xRjYrYkpaL1E1NGpOL2s4U0ZkM0R4UFRZYUFVc2l2c0JmZ1RuN014OEgyU3BQdDRHT2RZUm5FSk9INmpITTJwNlNnQjBneklScTZmSHhHTW1TbXFhUENtbGZ3eGl1bG9hVklpdExHTjh3aWUyQ0RXaGt6TG9DSmNPRGg3S0lPQXFiSEV2WGRVeGFTNFRUVHMwN0NsemovNkdtVnM5a2laRGVyTXhFbmhVQjZRUVBsY2Zxa0c5ODgyUnFIb0xpSEdCb0hmUXVYSXNBRzhHVEF0YW8yS1Z3Um52dmFtOGpvMWUzMTJHUUFLV0VhNHNVVkVBTUc0RzZja2NPTkR3UmNnMWUyRDMrb2hYZ1k0VUFXRjh3SEtRTXJTbnpDZ2ZGcHN4aCthSFhNR3RQUXJvUWFzUlk0VTZVZEcwcnoxVmpia2EwTWVrT0dSWlFFdnFRRmx4c2VGb3I4eldGZ0hlazN2MjkrV3FONmdhSzVnWk9UT01aenBRSUMxMjAxTGtNQ1hpbGQzdldYU2M1VVg5eGNGWWZiUlB6R0ZhMUZEY1BmUEIvalVFcS9GZUd0NDE5Q0kzWW1CbFZvSHNhNEtkY3dRUDVaU3dISGhGSjcvUGgvUmFwLzR2bUc5MWVEd1BQMGxEZkNEUkNMc3pUcWZ6TTcxeHBtaUtpMkh3UzRXbHF2R053dHZ3RjVEcXBuNktUcThheDAwVU1Qa3hEY1pyRUVFc0l2SGlVWFhFcGhkYjRHQjRGeW1sUHdCejRHcGVycXE1cFc3VFE2L3lOUmhXOFZUNU5odVAwdWRseG80Z0lMcTVaeEFaazhaR2gzZzRDcXhKbFBLWTdBUXh1cGZVY1ZwV1Q1Vkl0cDErMzBVcW95UDR3V3NSbzNvbFJSZ2tXWloyWk42VkMzT1pGZVhCOE5iblVyU2Rpa05wdEQxUWlHdUtrcjhFbVNSL0FLOVJ3K0ZGM3M1dXd1UGJ2SEdpUGVGT1ZpbHRNSzdBVWFPc3E5K3g5Y25kazNpSkVFNUxLWlJsV0piS09ad2VST3ptUE5WUGtqRTNLL1R5QTU3UnM2OFRrWjNNUjhha0twbTdjRmpualBkL0Rka1dqZ1lvS0hTcjVXdTVzc29CWVU0YWNSczVnMkRIeFVtZHE4VlhPWFJidW5EOFFOMExoZ2tzc2dhaGNkb1lzTnZ1WEdVSy9LWEQvN29GYitWR2RocUluMDJ2ZXVNNWJMdWRKT2MyS3kwR01hRzRXL3hXQnhJSmNMN3lsaUpPWE9weDBBa0JxVWd6bERjem1MVDRpSUxYRHh4dFJSMW9aYTJKV0ZnaUFiNDNvYnJKbkcvVFpDMktTSzJ3cU96UlpUWGF2WlpGTWIxZjNiWHZWYU5hSzgyOHc5VE82MTBnazhKTmYzZ01mRVR6WFhzYmN2UkdDRzlKV1FaNitjRFBxYzQ0NjZZbzJSY0tIK1BJTGVLT3F0bmxiSW5SM01tQmVHRzNGSDEweXpreWJ1cUVDMkhTUXdwQTBBbjdkOSs3M0JrRFVUbTMwYlptb1AvUkdiZ0ZOK0dyQ09mQURncXIwV2JJMWExb2twRm1zOGlIWXc5aG0welV2bEVNaXZCUnhNb2RyYkpKKzkvcDNqVWRRUTlCQ3RRZHhuT0dyVDVkelJVbXcwNTkzL21iUlNkQmcwblJ2UlpNNS9FMTZtN1pIbURFdFdod3ZmZFpDWjhKOE0xMlcweVJNc3pYYW1XZlFUd0laNGF5WWt0cm5zY1F1V3I4aWRwM1BqVDJlRi9qbXRkaElmY3BNbmIrSWZaWTJGZWJXNlVZL0FLM2pQNHUzVHU0ekU0cWxuUWdMRmJNMTlFQklzTmY3S2hqZGJxUS9ENnlpRGIrTmxFaTJTS0QraXZYVlVLOGliMG9CbzM2NmdYa1I4WnhHanBKSURjRWdaUGE5VGNZZTBUSWJpUGwvclBVUUR1M1hCSjlYL0dOcTNGQVVzS3NsbDU3RHphR01yamNUK2djdHArOU1MWVhDcStzcVA4MWVWUTByOWx0K2djUWZaYkFDUmJFanZsTXNrenRaRzhnYkM4UW45dHQyNlE3eTduRHJiWnEvTEV6N2tSNkpjNnBnM045clZYOFk1TUpyR2xNTDlwOWxVNGpiVGtLcUN2ZWVaVUpqSEIwM20yS1JLUjJUeXRvRmtUWE9MZzdrZVUxczFsclBNUUpwb09LTHVBQUMreTFIbEp1Y1U2eXNCNWhzWGh2U1BQTHE1SjdKdG5xSEtaNHZZakM0Vnk4MTUzUVkrNjc4MHhEdUdBUnNHYk9zMVdxekgwUVM3NjVyblNLRWJiS2xrTzhvSS9WRHdVZDBpczEzdEtwcUlMdTFtREpGTnkvaUpBV2N2RGdqeHZ1c0lUK1BHejNTVC9KOXI5TXRmZDBqcGFHZWlMWUlxWGM3RGlIU1M4VGNqRlZrc2k2NlBFa3hXMXo2dWpiTExVR05OWW56T1dwSDhCWkdLNGJDSzdpUitNYkl2OG5jREF6MXU0U3ROM3ZUVHpld3I5SVFqazl3eEZ4bis2TjFkZEtzMHZmZkppUzA4TjNhNEcxU1ZybFo5N1EvTSs4RzlmZTVBUDZkOS9RcTRXUm5PUlZob2ZQSUtFZENyM2xsc3BVZkUwb0tJSVlvQnlCUlBoK2JYMUhMUzNKV0dKUmhJdkUxYVc0TlRkOGVQaTRaK2tYYitaOHNuWWZTTmNxaWpoQWdWc3g0UkNNNTRjWFVpWWtqZUJtbUM0YWpPSHJDaG9FTHNjSkpDNys5ampNanc1QmFnWktsZ1JNaVNOWXo3aDd2dlpJb1FxYnRRbXNwYzBjVWsxRy83M2lYdFNwUk9sNXd0TGdRaTBtVzJFeDhpM1dVTGhjZ2d4NkUxTE1WSFVzZGM5R0hJMVBIM1UyS28wUHlHZG45S2RWT0xtN0ZQQnVpMGk5YTBIcEE2ME1zZXdWRTR6OENBdDVkNDAxR3Y2elhsSVQ1WWJpdDFWSUEwRkNzN3d0dllyZXJ1MWZVeVczb0xBWi8rYVRuWnJPY1lSTlZBOHNwb1J0bFJvV2Zsc1JDbEZjZ3prcWlIT3JmMC9TVncrRXBWYUZsSjBnNEt4cTFNTU9taVFkcE1OcHRlOGxNTVFxbTZjSUZYbG5HYmZKbGx5c0tEaSswSkpNb3RrcWdJeE9TUWdVOWRuL2xXa2VWZjhuVW0zaXdYMk5sM1dEdzlpNkFVSzN2QkFiWlpyY0pwRFEvTjY0QVZ3alQwN0plZjMwR1NTbXROdTJXbFc3WW95VzJGbFdmWkZRVXdrODY3RWRMWUtrOVZHNkpnRW5CaUJ4a1k3TE1vNFlMUUpKbEFvOWwvb1R2SmtTQVJERi9YdHlBek04TzJ0M2VUL2lYYTZ3RE4zV2V3Tm1RSGRQZnN4Q2hVL0t0TEcyTW44aTRacUtkU2xJYUJaYWR4Sm1SelZTL280eUE2NVJUU1ZpcTYwb2EzOTVMcXcwcHpZNFNpcHdFMFNYWHNLVitHWnJhR1Nrci9SVzA4d1BSdnF2U1VrWUJNQTlsUHg0bTI0YXorSUhtQ2JYQSswZmF4VFJFOXd1R2VPMDZESVhhNlFsS0ozcHVJeWl1QVZmUHI3MzZ2em8ycEJpclMrVnhlbDNUTW0zSktoejlvMlpvUnZhRlZwSWt5a2IwSGNtNG9IRkJNY05TTmo3LzRHSnQ0M29nb25ZMlZnNG5zRFFJV3hBY29ycFhBQ3pnQnFRUGpZc0UvVlVwWHB3Tk1hbkVydTROd01DRlBrWHZNb3F2b2VMTjNxeXUvTjFlV0VIdHRNRDY1djE5bC8wa0gybVIzNWl2L0ZJK3lqb0hKOWdQTXo2N2FmM01xL0JvV1hxdTNycGhpV01YVmttblBTRWtwR3BVSTJoMU1UaGlkZUdGRU9LNllaSFB3WXpNQnZwTkM3K1pIeFBiN2VwZmVmR3lJQjRKek85RFRORVluRExWVkhkUXl2T0VWZWZyazZVdjVrVFFZVllXV2RxcmRjSWw3eWxqd3dJV2RmUS95KzJRQjNlUi9xeFlPYnVZeUI0Z1RibzJpbjRQemFyVTFzTzluRVRrbWo5L0FveERBK0pNM0dNcVF0SlI0anRkdUh0bm9DTHhkMWdRVXNjSFJCL01vUllJRXNQMnBEWjlLdkhndGxrMWlUYldXYkhob2h3RkVZWDd5NTFmVVYybnVVbW5vVWNxbldJUUFBZ2w5TFRWWCtCYzBRR05FaENoeEhSNFlqZkU1MVBVZEdmc1NGRTZjazdCTDMvaFRmOWpMcTRHMUlhZklOeE9MS2VBdE83cXV1bFl2SDVZT0JjK3pYN0NyTWdXblc0Ny9qZlJzV25KallZb0U3eE1mV1YySE4yaXlJcUxJJztcbmNvbnN0IEZFTkNFRCA9IG5ldyBNYXAoW1s4MjE3LFwiYXBvc3Ryb3BoZVwiXSxbODI2MCxcImZyYWN0aW9uIHNsYXNoXCJdLFsxMjUzOSxcIm1pZGRsZSBkb3RcIl1dKTtcbmNvbnN0IE5TTV9NQVggPSA0O1xuXG5mdW5jdGlvbiBkZWNvZGVfYXJpdGhtZXRpYyhieXRlcykge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdGZ1bmN0aW9uIHUxNigpIHsgcmV0dXJuIChieXRlc1twb3MrK10gPDwgOCkgfCBieXRlc1twb3MrK107IH1cclxuXHRcclxuXHQvLyBkZWNvZGUgdGhlIGZyZXF1ZW5jeSB0YWJsZVxyXG5cdGxldCBzeW1ib2xfY291bnQgPSB1MTYoKTtcclxuXHRsZXQgdG90YWwgPSAxO1xyXG5cdGxldCBhY2MgPSBbMCwgMV07IC8vIGZpcnN0IHN5bWJvbCBoYXMgZnJlcXVlbmN5IDFcclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IHN5bWJvbF9jb3VudDsgaSsrKSB7XHJcblx0XHRhY2MucHVzaCh0b3RhbCArPSB1MTYoKSk7XHJcblx0fVxyXG5cclxuXHQvLyBza2lwIHRoZSBzaXplZC1wYXlsb2FkIHRoYXQgdGhlIGxhc3QgMyBzeW1ib2xzIGluZGV4IGludG9cclxuXHRsZXQgc2tpcCA9IHUxNigpO1xyXG5cdGxldCBwb3NfcGF5bG9hZCA9IHBvcztcclxuXHRwb3MgKz0gc2tpcDtcclxuXHJcblx0bGV0IHJlYWRfd2lkdGggPSAwO1xyXG5cdGxldCByZWFkX2J1ZmZlciA9IDA7IFxyXG5cdGZ1bmN0aW9uIHJlYWRfYml0KCkge1xyXG5cdFx0aWYgKHJlYWRfd2lkdGggPT0gMCkge1xyXG5cdFx0XHQvLyB0aGlzIHdpbGwgcmVhZCBiZXlvbmQgZW5kIG9mIGJ1ZmZlclxyXG5cdFx0XHQvLyBidXQgKHVuZGVmaW5lZHwwKSA9PiB6ZXJvIHBhZFxyXG5cdFx0XHRyZWFkX2J1ZmZlciA9IChyZWFkX2J1ZmZlciA8PCA4KSB8IGJ5dGVzW3BvcysrXTtcclxuXHRcdFx0cmVhZF93aWR0aCA9IDg7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHJlYWRfYnVmZmVyID4+IC0tcmVhZF93aWR0aCkgJiAxO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgTiA9IDMxO1xyXG5cdGNvbnN0IEZVTEwgPSAyKipOO1xyXG5cdGNvbnN0IEhBTEYgPSBGVUxMID4+PiAxO1xyXG5cdGNvbnN0IFFSVFIgPSBIQUxGID4+IDE7XHJcblx0Y29uc3QgTUFTSyA9IEZVTEwgLSAxO1xyXG5cclxuXHQvLyBmaWxsIHJlZ2lzdGVyXHJcblx0bGV0IHJlZ2lzdGVyID0gMDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgfCByZWFkX2JpdCgpO1xyXG5cclxuXHRsZXQgc3ltYm9scyA9IFtdO1xyXG5cdGxldCBsb3cgPSAwO1xyXG5cdGxldCByYW5nZSA9IEZVTEw7IC8vIHRyZWF0IGxpa2UgYSBmbG9hdFxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdmFsdWUgPSBNYXRoLmZsb29yKCgoKHJlZ2lzdGVyIC0gbG93ICsgMSkgKiB0b3RhbCkgLSAxKSAvIHJhbmdlKTtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gc3ltYm9sX2NvdW50O1xyXG5cdFx0d2hpbGUgKGVuZCAtIHN0YXJ0ID4gMSkgeyAvLyBiaW5hcnkgc2VhcmNoXHJcblx0XHRcdGxldCBtaWQgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG5cdFx0XHRpZiAodmFsdWUgPCBhY2NbbWlkXSkge1xyXG5cdFx0XHRcdGVuZCA9IG1pZDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFydCA9IG1pZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHN0YXJ0ID09IDApIGJyZWFrOyAvLyBmaXJzdCBzeW1ib2wgaXMgZW5kIG1hcmtcclxuXHRcdHN5bWJvbHMucHVzaChzdGFydCk7XHJcblx0XHRsZXQgYSA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnRdICAgLyB0b3RhbCk7XHJcblx0XHRsZXQgYiA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnQrMV0gLyB0b3RhbCkgLSAxO1xyXG5cdFx0d2hpbGUgKCgoYSBeIGIpICYgSEFMRikgPT0gMCkge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSAmIE1BU0sgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgJiBNQVNLO1xyXG5cdFx0XHRiID0gKGIgPDwgMSkgJiBNQVNLIHwgMTtcclxuXHRcdH1cclxuXHRcdHdoaWxlIChhICYgfmIgJiBRUlRSKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyICYgSEFMRikgfCAoKHJlZ2lzdGVyIDw8IDEpICYgKE1BU0sgPj4+IDEpKSB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSBeIEhBTEY7XHJcblx0XHRcdGIgPSAoKGIgXiBIQUxGKSA8PCAxKSB8IEhBTEYgfCAxO1xyXG5cdFx0fVxyXG5cdFx0bG93ID0gYTtcclxuXHRcdHJhbmdlID0gMSArIGIgLSBhO1xyXG5cdH1cclxuXHRsZXQgb2Zmc2V0ID0gc3ltYm9sX2NvdW50IC0gNDtcclxuXHRyZXR1cm4gc3ltYm9scy5tYXAoeCA9PiB7IC8vIGluZGV4IGludG8gcGF5bG9hZFxyXG5cdFx0c3dpdGNoICh4IC0gb2Zmc2V0KSB7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIG9mZnNldCArIDB4MTAxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDE2KSB8IChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiBvZmZzZXQgKyBieXRlc1twb3NfcGF5bG9hZCsrXTtcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIHggLSAxO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHRcclxuXHJcbi8vIHJldHVybnMgYW4gaXRlcmF0b3Igd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBzeW1ib2xcclxuZnVuY3Rpb24gcmVhZF9wYXlsb2FkKHYpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRyZXR1cm4gKCkgPT4gdltwb3MrK107XHJcbn1cclxuZnVuY3Rpb24gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQocykge1xyXG5cdHJldHVybiByZWFkX3BheWxvYWQoZGVjb2RlX2FyaXRobWV0aWModW5zYWZlX2F0b2IocykpKTtcclxufVxyXG5cclxuLy8gdW5zYWZlIGluIHRoZSBzZW5zZTpcclxuLy8gZXhwZWN0ZWQgd2VsbC1mb3JtZWQgQmFzZTY0IHcvbyBwYWRkaW5nIFxyXG4vLyAyMDIyMDkyMjogYWRkZWQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzRcclxuZnVuY3Rpb24gdW5zYWZlX2F0b2Iocykge1xyXG5cdGxldCBsb29rdXAgPSBbXTtcclxuXHRbLi4uJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXS5mb3JFYWNoKChjLCBpKSA9PiBsb29rdXBbYy5jaGFyQ29kZUF0KDApXSA9IGkpO1xyXG5cdGxldCBuID0gcy5sZW5ndGg7XHJcblx0bGV0IHJldCA9IG5ldyBVaW50OEFycmF5KCg2ICogbikgPj4gMyk7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIHdpZHRoID0gMCwgY2FycnkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjYXJyeSA9IChjYXJyeSA8PCA2KSB8IGxvb2t1cFtzLmNoYXJDb2RlQXQoaSldO1xyXG5cdFx0d2lkdGggKz0gNjtcclxuXHRcdGlmICh3aWR0aCA+PSA4KSB7XHJcblx0XHRcdHJldFtwb3MrK10gPSAoY2FycnkgPj4gKHdpZHRoIC09IDgpKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gZWcuIFswLDEsMiwzLi4uXSA9PiBbMCwtMSwxLC0yLC4uLl1cclxuZnVuY3Rpb24gc2lnbmVkKGkpIHsgXHJcblx0cmV0dXJuIChpICYgMSkgPyAofmkgPj4gMSkgOiAoaSA+PiAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9kZWx0YXMobiwgbmV4dCkge1xyXG5cdGxldCB2ID0gQXJyYXkobik7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHggPSAwOyBpIDwgbjsgaSsrKSB2W2ldID0geCArPSBzaWduZWQobmV4dCgpKTtcclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gWzEyM11bNV0gPT4gWzAgM10gWzEgMV0gWzAgMF1cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWQobmV4dCwgcHJldiA9IDApIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCgpO1xyXG5cdFx0bGV0IG4gPSBuZXh0KCk7XHJcblx0XHRpZiAoIW4pIGJyZWFrO1xyXG5cdFx0cHJldiArPSB4O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0cmV0LnB1c2gocHJldiArIGkpO1xyXG5cdFx0fVxyXG5cdFx0cHJldiArPSBuICsgMTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWRfYXJyYXlzKG5leHQpIHtcclxuXHRyZXR1cm4gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IFxyXG5cdFx0bGV0IHYgPSByZWFkX3NvcnRlZChuZXh0KTtcclxuXHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHY7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybnMgbWFwIG9mIHggPT4geXNcclxuZnVuY3Rpb24gcmVhZF9tYXBwZWQobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCk7XHJcblx0XHRpZiAodyA9PSAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpIC0gMTtcclxuXHRcdGlmICh3IDwgMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldC5mbGF0KCk7XHJcbn1cclxuXHJcbi8vIHJlYWQgdW50aWwgbmV4dCBpcyBmYWxzeVxyXG4vLyByZXR1cm4gYXJyYXkgb2YgcmVhZCB2YWx1ZXNcclxuZnVuY3Rpb24gcmVhZF9hcnJheV93aGlsZShuZXh0KSB7XHJcblx0bGV0IHYgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KHYubGVuZ3RoKTtcclxuXHRcdGlmICgheCkgYnJlYWs7XHJcblx0XHR2LnB1c2goeCk7XHJcblx0fVxyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyByZWFkIHcgY29sdW1ucyBvZiBsZW5ndGggblxyXG4vLyByZXR1cm4gYXMgbiByb3dzIG9mIGxlbmd0aCB3XHJcbmZ1bmN0aW9uIHJlYWRfdHJhbnNwb3NlZChuLCB3LCBuZXh0KSB7XHJcblx0bGV0IG0gPSBBcnJheShuKS5maWxsKCkubWFwKCgpID0+IFtdKTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykge1xyXG5cdFx0cmVhZF9kZWx0YXMobiwgbmV4dCkuZm9yRWFjaCgoeCwgaikgPT4gbVtqXS5wdXNoKHgpKTtcclxuXHR9XHJcblx0cmV0dXJuIG07XHJcbn1cclxuIFxyXG4vLyByZXR1cm5zIFtbeCwgeXNdLCBbeCtkeCwgeXMrZHldLCBbeCsyKmR4LCB5cysyKmR5XSwgLi4uXVxyXG4vLyB3aGVyZSBkeC9keSA9IHN0ZXBzLCBuID0gcnVuIHNpemUsIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSB7XHJcblx0bGV0IGR4ID0gMSArIG5leHQoKTtcclxuXHRsZXQgZHkgPSBuZXh0KCk7XHJcblx0bGV0IHZOID0gcmVhZF9hcnJheV93aGlsZShuZXh0KTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZCh2Ti5sZW5ndGgsIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0uZmxhdE1hcCgodiwgaSkgPT4ge1xyXG5cdFx0bGV0IFt4LCAuLi55c10gPSB2O1xyXG5cdFx0cmV0dXJuIEFycmF5KHZOW2ldKS5maWxsKCkubWFwKChfLCBqKSA9PiB7XHJcblx0XHRcdGxldCBqX2R5ID0gaiAqIGR5O1xyXG5cdFx0XHRyZXR1cm4gW3ggKyBqICogZHgsIHlzLm1hcCh5ID0+IHkgKyBqX2R5KV07XHJcblx0XHR9KTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJuIFtbeCwgeXMuLi5dLCAuLi5dXHJcbi8vIHdoZXJlIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpIHsgXHJcblx0bGV0IG4gPSAxICsgbmV4dCgpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKG4sIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0ubWFwKHYgPT4gW3ZbMF0sIHYuc2xpY2UoMSldKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlYWRfdHJpZShuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBzb3J0ZWQgPSByZWFkX3NvcnRlZChuZXh0KTsgXHJcblx0ZXhwYW5kKGRlY29kZShbXSksIFtdKTtcclxuXHRyZXR1cm4gcmV0OyAvLyBub3Qgc29ydGVkXHJcblx0ZnVuY3Rpb24gZGVjb2RlKFEpIHsgLy8gY2hhcmFjdGVycyB0aGF0IGxlYWQgaW50byB0aGlzIG5vZGVcclxuXHRcdGxldCBTID0gbmV4dCgpOyAvLyBzdGF0ZTogdmFsaWQsIHNhdmUsIGNoZWNrXHJcblx0XHRsZXQgQiA9IHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4geyAvLyBidWNrZXRzIGxlYWRpbmcgdG8gbmV3IG5vZGVzXHJcblx0XHRcdGxldCBjcHMgPSByZWFkX3NvcnRlZChuZXh0KS5tYXAoaSA9PiBzb3J0ZWRbaV0pO1xyXG5cdFx0XHRpZiAoY3BzLmxlbmd0aCkgcmV0dXJuIGRlY29kZShjcHMpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4ge1MsIEIsIFF9O1xyXG5cdH1cclxuXHRmdW5jdGlvbiBleHBhbmQoe1MsIEJ9LCBjcHMsIHNhdmVkKSB7XHJcblx0XHRpZiAoUyAmIDQgJiYgc2F2ZWQgPT09IGNwc1tjcHMubGVuZ3RoLTFdKSByZXR1cm47XHJcblx0XHRpZiAoUyAmIDIpIHNhdmVkID0gY3BzW2Nwcy5sZW5ndGgtMV07XHJcblx0XHRpZiAoUyAmIDEpIHJldC5wdXNoKGNwcyk7IFxyXG5cdFx0Zm9yIChsZXQgYnIgb2YgQikge1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBici5RKSB7XHJcblx0XHRcdFx0ZXhwYW5kKGJyLCBbLi4uY3BzLCBjcF0sIHNhdmVkKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxuXG5mdW5jdGlvbiBoZXhfY3AoY3ApIHtcclxuXHRyZXR1cm4gY3AudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgJzAnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVvdGVfY3AoY3ApIHtcclxuXHRyZXR1cm4gYHske2hleF9jcChjcCl9fWA7IC8vIHJhZmZ5IGNvbnZlbnRpb246IGxpa2UgXCJcXHV7WH1cIiB3L28gdGhlIFwiXFx1XCJcclxufVxyXG5cclxuLypcclxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxvZGVfY3Aocykge1xyXG5cdHJldHVybiBbLi4uc10ubWFwKGMgPT4gYy5jb2RlUG9pbnRBdCgwKSk7XHJcbn1cclxuKi9cclxuZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7IC8vIHRoaXMgaXMgYWJvdXQgMnggZmFzdGVyXHJcblx0bGV0IGNwcyA9IFtdO1xyXG5cdGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47ICkge1xyXG5cdFx0bGV0IGNwID0gcy5jb2RlUG9pbnRBdChwb3MpO1xyXG5cdFx0cG9zICs9IGNwIDwgMHgxMDAwMCA/IDEgOiAyO1xyXG5cdFx0Y3BzLnB1c2goY3ApO1xyXG5cdH1cclxuXHRyZXR1cm4gY3BzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJfZnJvbV9jcHMoY3BzKSB7XHJcblx0Y29uc3QgY2h1bmsgPSA0MDk2O1xyXG5cdGxldCBsZW4gPSBjcHMubGVuZ3RoO1xyXG5cdGlmIChsZW4gPCBjaHVuaykgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcyk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyApIHtcclxuXHRcdGJ1Zi5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNwcy5zbGljZShpLCBpICs9IGNodW5rKSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlX2FycmF5cyhhLCBiKSB7XHJcblx0bGV0IG4gPSBhLmxlbmd0aDtcclxuXHRsZXQgYyA9IG4gLSBiLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgYyA9PSAwICYmIGkgPCBuOyBpKyspIGMgPSBhW2ldIC0gYltpXTtcclxuXHRyZXR1cm4gYztcclxufVxuXG4vLyBjcmVhdGVkIDIwMjMtMDktMjVUMDE6MDE6NTUuMTQ4WlxuLy8gY29tcHJlc3NlZCBiYXNlNjQtZW5jb2RlZCBibG9iIGZvciBpbmNsdWRlLW5mIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogYTk3NGI2Zjg1NDFmYzI5ZDkxOWJjODUxMThhZjBhNDQwMTU4NTFmYWI1MzQzZjg2NzljYjMxYmUyYmRiMjA5ZVxudmFyIENPTVBSRVNTRUQgPSAnQUVVRFRBSEJDRlFBVFFEUkFEQUFjZ0FnQURRQUZBQXNBQlFBSHdBT0FDUUFEUUFSQUFvQUZ3QUhBQklBQ0FBUEFBVUFDd0FGQUF3QUJBQVFBQU1BQndBRUFBb0FCUUFJQUFJQUNnQUJBQVFBRkFBTEFBSUFDd0FCQUFJQUFRQUhBQU1BQXdBRUFBc0FEQUFNQUF3QUNnQU5BQTBBQXdBS0FBa0FCQUFkQUFZQVp3RFNBZHNESmdDMENrTUI4eGhaQXFmb0MxOTBVR2NUaGdCdXJ3ZjdQVDA5UGIwOUFqZ0p1bThPakRsbHhIWVVLWEFQeHpxNnRBQkF4Z0s4eXNVdldBZ01QVDA5UFQwOVBTczZMVDJIY2dXWFd3RkxvU01FRUVsNVJGVk1Ldk8wWFE4RXhEZEpNbklnc2oyNlBUUXl5OEZmRVE4QVk4SVBBR2NFYndSd0JIRUVjZ1J6QkhRRWRRUjJCSGNFZUFSNkJIc0VmQVIrQklBRWdmbmRCUW9CWWdVTEFXSUZEQUZpQk5jRTJBVFpCUkFGRVFVdkJkQUxGQXNWRFBjTkJ3MTNEWWNPTUE0eERqTUI0QmxsSEkwQjJncmJBTURwSExrUTdRSFZBUFJOUVFGbkdSVUVnMHlFQjJ1YUpGOEFKcElCcG9iNUFFUlNNQUtOb0FYcWFRTFVCTUN6RWlBQ253UlpFa2tWc1M3dEFOQXNCRzBSdUFRTEVQQUJ2OUhJQ1RVQlhpZ1Bad1JCQXBNRE93QWFtaHRhQUJxRUFZOEt2S3gzTFE0QXJBQjhVaHdFQkFWU2FnRDhBRUZaQURrQklhZFZqMlVNVWd4NUlsNEFOUUM5QXhJQjFCbGJFUE1BczMwQ0d4bFhBaHdaS1FJRUNCYzZFYnNDb3huZ3p2N1V6UlFBOE0wQmF3TDZad2tON3dBQkFEMzNPUVJjc2dMSkNqTUNqcVVDaHR3L2ttK05Bc1hQQW9QMkJUODRQd1VSQUswUkF2cHRiNmNBcFFTL09NTWV5NUhKUzg0VWR4cHhUUGtDb2dWRklUYVRPd0VSQUs1cEF2a05CT1Z5QTdxM0JLbE9KU0FMQWdVSUJSY0VkQVNwQlhxekFCWEZTV1pPYXdMQ09xdy8vQW9sQ1pkdnYzZFNCa0VRR3llbEVQY01Nd0cxQVRzTjdVdllCUEVHT3dUSkgzMFpHUS9ObFp3SXBTM2RETzBtNHk2aGdGb2o5U3FEQmUxTDlEemRDMDFSYUE5WkMyVUo0enBqZ1U0RElRRU5Jb3NLM1EwNUNHMFE4d3JKYXczbEVVVUhPUVBWU1pvQXBRY0JDeEVkTlJXMUpoQmlyQXNKT1hjRyt4cjJDNDhtcnhNcGV2d0YweG9oQmswQktSci9BTTh1NTRXd1dqRmNIRTlmQmdNTEpTUEhGS2hRSUEwbFFMZDRTQm9iQnhVbHFRS1JRM0JLaDFFMkhwTWg5anc5RFdZdUUxRjhCL1U4QlJsUEM0RThua2FyUlE0UjBqNk5QVWdpU1V3c0JEVi9MQzhuaXduUEQ0VU11WHh5QVZrSklRbXhESEVUTVJFWE44VUlPUWNaTFpja0p4VUlJVWFWWUpvRTk1OEQ4eFBSQXdzRlB3bEJCeE1EdFJ3dEV5NFZLUVVOZ1NUWEF2TTIxUzZ6QW85V2dBRVhCY3NQSlIvZkVGQkg0QTdwQ0pzQ1pRT0RKZXNBTFJVaEFCY2ltd2hEWXdCZmo5aFRCUzdMQ01kcWJDTjBBMmNVNTJFUmN3ZVJEbGNIcHh3ekZiOGM0WERJWGd1R0NDaWpyd2xiQVhVSm1RRmZCT01JQ1RWYmpLQWdRV2RUaTFnWW15QmhRVDlkL0FJeERHVVZuMFM5aDNnQ2l3OXJFaHNCTlFGekJ6a05BUUozRWUwUmF4Q1ZDT3VHQkRXMU0vZzZKUVJQSVlNZ0VRb25BMDlzemdzbkp2a00rR2tCb3hKaUF3dzBQWGZ1WjZ0Z3RpUVgvUWNaTXNWQllDSHhDNUpQelF5Y0dzRVlRbFF1R2VRSHZ3UHpHdk1uNmtGWEJmOERvd01UT2swejdnUzlDMmtJaXdrL0FFa09veGNIMXhocUNuR00wQUV4aXdHM21RTlhrWU1DYjQ4R053Y0xBR2NMaHdWNTVRQWRBcWNJb3dBRkFNOERWd0E1QXEwSG5RQVpBSVZCQVQwREp5OEJJZVVDandPVENESExBWlV2QWZNcEJCdkREQlVBOXpkdVNnTERzUUtBYW1haUJkMVlBbzRDU1RVQlRTVUVCVTVIVVFPdmNlRUEyd0JMQmhQZlJ3RVZxMHJMR3VOREFkOXZLd0RIQVBzQUJUVUhCVUVCelFIemJRQzNBVjhMTVFtaXM3VUJUZWtwQUlNQUZXc0Ixd0tKQU4wQU5RQi84UUZUQUUwRldma0Ywd0pQU1FFUk1SZ3JWMkVCdXdNZkFUTUJEUUI1QnN1TnBja0hId1J0QjlNQ0VCc1Y0UUx2TGdlMUFRTWkzeFBOUXNVQ3ZkNVZvV0FDWklFQ1lrSmJUYTliTnlBQ29mY0NhSmdDWmdrQ240UTRHd3NDWmpzQ1ppWUViZ1IvQTM4VEEzNlNPUVk1ZHhjNWdqb2pJd0pzSFFJeU5qZ0tBbTNIQW0ydTc0b3paMFVyQVdjQTNnRGhBRW9GQjVnTWpRRCtDOElBRGJVQ2R5OENkcUkvQW5sTFF3SjR1aDFjMjBXdVJ0Y0NmRDhDZXNnQ2ZRa0NmUEFGV1FVZ1NBQklmV01rQW9GdEFvQUFBb0FGQW4rdVNWaEtXeFVYU3N3QzBRRUMwTXhMSndPSVR3T0g1a1RGa1RJQzhxRmRBd01Ecmt2T1RDMGxBODlOVEUydkFvcy9Bb3JZd1JzSEhVTm5CYmNDampjQ2pseEFsNEVDanRrQ2pseDRVYlJUTlFwUzFGU0ZBcFA3QXBNTUFPa0FIRlVlVmE5VjBBWXNHeW1WaGpMaGVHWkZPemtDbDU4Qzc3SllJYWdBV1NVQ2xvOENsbnljQUtsWnJGb0pnVTBBT3dLV3RRS1dUbHhFWE5FQ21jc0NtV1JjeWwwSEdRS2Ntem5DT3AwQ25CWUNuNXNDbnJpS0FCMFBNU29QQXAzeEFwNlNBTFU5WVRSaDd3S2Uwd0tnYmdHcEFwNmZId0tlVHFWanlHUW5KU3NDSjY4Q0puNENvUHNDb0V3Q290MENvY1FDcGk4Q3BjNENwLzhBZlFLbjhtaDhhTEVBQTBscUhHclJBcXpqQXF5dUFxMW5BcTBDQWxjZEFsWGNBckhoMXdNZlRteVhBcks5RFFLeTZCZHM0RzFqYlVoZkF5WE5BclpjT3o5dWtBTXBSUUs0WGdLNVJ4VUN1U3AzY0RadzRRSzlHUUs3Mm5DV0F6SVJBcjZJY2dJRE0zRUN2aHB6SW5OUEFzUExBc01FYzRKMFN6VkZkT0FEUEtjRFBKb0RQYjhDeFh3Q3hrY0N4aENKQXNocFVRTElSQUxKVHdMSkxnSmtuUUxkMG5oNVlYaXVlU1ZMMEFNWW8yY0NBbUgwR2ZPVkpIc0xYcEpldXhFQ3oyc0N6Mnd2UzFQUzh4T2ZBTWF0QXM5ekFTbnFBMDRTZmtzRkF0d25BdHVLQXRKUEExSmNBMU5mQVFFRFZZeUFpVDhBeXhidFlFV0NISUxUZ3M2RGpRTGF4d0xaM29RUWhFbW5QQU9HcFFBdkEyUU9obkZaK1FCVkF0OWxBdDY0YzNjQzRpL3RGQUh6TUNjQjlKc0I4dEtIQXV2ekF1bHdlUUxxK1FMcTVBRDVSd0c1QXU2SkF1dWNscXFYQXdMdVB3T0Y0Smg1Y09CeG9RTHpBd0JwQTQ0V21aTUM5eE1Ea1c0RGtvY0M5NWdDK2RrQytHYWFISnFydXplYkhnT2Rnd0wrK2dFYkFEbWZISit6QXdXTkE2WnFBNmJaQU5IRkF3WnFvWWlpQlFrRERFa0N3QUEvQXdEaFFSZFRBUkh6QTJzSGwyY0ZBSk10SzdldnZkc0JpWmtVZnhFRU9RSDdLUVVoRHAwSm53Q1MvU2xYeFFMM0FaMEF0d1c1QUc4TGJVRXVGQ2FOTGdGREFZRDhBYlVtQUhVRERnUnRBQ3dDRmd5aEFBQUtBajBDYWdQZEEzNEVrUUVnUlFVaGZBb0FCUUJFQUJNQU5oSUNkd0VBQmRVRGErOEt4UUlBOXdxZko3K3h0K1VCa1NGQlFnSHBGSDhSTk1DSkFBUUFHd0JhQWtVQ2hJc0FCanBUT3BTTmJRQzRPbzg2MEFDTk9NRTYzQUNsQU9nQXl3RTZnVG83T2Z3NStUdDJpVHBiTzU2Sk9tODVHQUZXQVRNQmJBVXZOVjAxbmpXdE5XWTFkVFcyTmNVMWdqV1JOZEkxNFRXZU5hMDE3alg5TmJJMXdUWUNOaEUxeGpYVk5oWTJKelhlTmUwMkxqWTlOaTQxTFNFMk9qWTlOancyeVRjSUJKQThWelk0TnQwM0lEY1BOc29nTjRrM01Bb0VzRHhuTmlRM0dUZHNPbzAzSVVMVVF3ZEM0RU1MSEE4UENac29iU2hSVlFZQTZYOEE2YkFCRkNuWEF1a0Jvd0M5QmJjQWJ3TnpCTDhNREFNTUFRZ0RBQWtLQ3dzTENRb0dCQVZWQkkvRHZ3RHo5YjI5a2FVQ2IwUXRzUlROTHQ0ZUdCY1NIQU1aRmhZWkVoWUVBUkFFQlVFY1FSeEJIRUVjUVJ4QkhFRWFRUnhCSEVGQ1NUeEJQRWxJU1VoQk5rTTJRVFliTmtsSVNWbUJWSWdCRkxXWkF1MEJoUUNqQmNFQWJ5a0J2d0dKQWFRY0VaMGVQQ2tsTUFBaE12QUlNQUw1NGdDN0JtOEVlc2NqelFNcEFSUXBLZ0RVQUJhdkFqNjI2eFFBSlAwQTNldHp1ZjROTlJBN2VmeTJaOU5RckNuQzBPU3lBTno1QkJJYko1SUZEUjZtaUlhdllTNnRwcmpqbXVLZWJ4bTVDNzRRMjI1WDFwa2FZWVBiNmYxREs0azN4TUVCYjlTMldNakVpYlROV2hzUkpJQSt2d05WRWlYVEU1aVhzL3dlelY2Nm9GTGZwOU5aR1lXK0drMTlKMitiQ1Q2WWUydzZMRFlkZ3pLTVVhYms1OTVlTEJDWEFOejlIVXBXYkFUcTl2cVhWeDlYRGcrUGM5WHA0K2JzUzAwNVNWTS9CSkJNNDY4N1dVdWYrVWo5ZEVpOGFETmFQeHRwYkR4Y0cxVEhUSW1VTVpxNFVDYWFOWXBzVnFyYU55S0xKWERZc0ZaLzVqbDdiTFJ0Tzg4dDdQM3haYUF4aGI1T2RQTVhxc1NrcDFXQ2llRzhqWG0xVTk5K2JsdkxsWHpQQ1MrTTkzVm5KQ2lLKzA5TGZhU2FCQVZCb215RGdKdWE4ZGZVelI3Z2EzNEl2UjJOdmorQTloZUo2bHNsMUtHNE5rSTEwMzJDbmZmMW0xd29mMkI5b0hKSzRiaTZKa0VkU3FlTmVpdW82UW9aWmluY29jNzMvVEg5U1hGOHNDRTdYeXVZeVc4V1NnYkdGQ2pQVjBpaExLaGRQczA4VHg4MmZZQWtMTGM0STJ3ZGw0YXBZN0dVNWxIUkZ6UldKZXA3V3czd2JlQTNxbWQ1OS84NlA0eHVOYXFEcHlnWHQ2TTg1Z2xTQkhPQ0dnSkRudCtwTjliSzdIQXBNZ3VYNiswNlJaTmp6Vm1jWkord2NVcko5Ly9icFJOeE51S3BObDl1RmRzK1M5dGR4N0xhTTVaa0lyUGo2bklVOW1uYkZ0VmJzOXMvdUxnbDhNVmN6QXdldCtpT0V6ekJsWVc3UkNNZ0U2Z3lOTGVxNisxdEl4NGRwZ1puZDBEa3NKUzVmK0pORHB3d2NQTlhhYVZzcHExZmJRYWpPckpnSzBvZkt0SjFOZTkwTDZWTzRNT2w1Uzg4NnA3dTZ4bzdPTGpHOFRHTCtIVTFKWEdKZ3BwZzRuTmJOSjVubHpTcHVQWXkyMUpVRWNVQTk0UG9GaVpmalp1ZStRbnlRODBla091WlZreHg0ZytjdmhKZkhnTmw0aHkxL2E2K1JLY0tsYXIvSjI5eS8vRXp0bGJWUEhWVWVRMXpYODZlUVZBalIvTTNkQTl3NFc4TGZhWHA0RWdNODV3T1dhc2xpODM3UHpWTU9uc0x6UitrM283NS9sUlBBSlNFMXhBS1F6RWk1djEwa2UrVkJ2UnQxY3dRUk1kK1U1bUxDVEdWZDZYaVp0Z0JHNWNEaTB3MjJHS2NWTnZIaXU1TFFiWkVEVnR6MG9ubjdrNStoZXVLWFZzWnRTemlsa0xSQVVtak1YRU1CM0o5WUM1MFhCeFBpejUzU0MrRWhuUGw5V3NLQ3Y5MlNNL09GRklNSlpZZmwwV1c4dElPM1V4WWN3ZE1BajdGU21ncnNaMmFBWk8wM0JPaFAxYk5OWkl0eVhZUUZUcEMzU0cxVnVQRHFIOUdraUNEbUUrSnd4eUlWU081c2lERXJBT3BFWEZnank2UFF0T1ZEaitzNmUxcjhoZVdWdm1ablRjaXVmNEVpTlp6Q0FkN1NPTWhYRVJJT2xzSElNRzM5OWk5YUxUeTNtMmhSTFpqSlZETkxTNTNpR0lLMTFkUHFRdDB6QkR5ZzZxYzdZcWtEbTJNNVZlNmRDV0NhQ2JUWFgyclRvYUlnejYremg0bFlVaS8rNm5xY0ZNQWtRSktIWUxLMHdZazVOOXN6VjZ4aWhEYkRERnI0NWxOMUs0YUNYQnEvRml0UFN1ZDlnTHQ1WlZuK1pxR1g3Y3dtMno1RUdNZ2ZGcElGeWhHR3VEUG1zbzZUSXRUTXdueSs3dVBuTENmNFc2Z29GUUZWMG9RU3NjOVZmTW1WTGNMcjZaZXREWmJhU0ZUTHFuU08vYklQakEzL3pBVW9xZ0dGQUVRUzRJaHVNekVwMkkzakp6Ynpray9JRW15YXgrcmhaVHdkNmYrQ0d0d1BpeHU4SXZ6QUNxdVBXUFJFdTladkdrVXpwUnd2UlJ1YU5ONmNyMFcxd1dpdHM5SUNkWUo3bHRiZ01pU0wzc1RQZXVmZ05jVnFNVldGa0NQREg0akcyakEwWGNWZ1FqNjJDYjI5djlmL3ovKzJLYll2SXYvenpqcFFBUGtsaWFWRHpOclc1N1RaL1pPeVpEMG5sZk1tQUlCSUFHQUkwRDNrL21kTjR4cjl2ODVaYlpiYnFmSDJqR2Q1aFVxTlpXd2w1U1Bmb0dtZkVsbWF6VUllTkwxai9ta0Y3Vk5BelRxNGpOdDhKb1ExMU5RT2NtaHByWG94U3hmUkdKOUxERU9BUStkbXhBUUg5MGl0aTllMnUvTW9ldWFHY0RUSG9DK3hzbUVlV214RUtlZlF1SXpIYnB3NVRjNWNFb2Nib0FEMDlvaXBXUWh0VE8xd2l2Zi9PK0RSZTJycGwvRTl3bHJ6Qm9yakpzT2VHMUIvWFBXNEVhSkVGZE5sRUNFWmdhNVpvR1JIWGdZb3VHUnVWa204dERFU2lFeUZObyszczVNNXB1U2RUeVVMMmxsbklOVkhFdDkxWFVOVzRld2RNZ0o0Ym9KZkV5dC9pWTVXWHFiQStBMkZrdDVaMGx1dGlXaGU5blpJeUlVanlYREMzVXNhRzF0K2VOeDZ6NFcvT1lvVEI3QTZ4K2ROU1RPaTlBSW5jdGJFU3FtNWd2T0x3dzdPV1hQcm1Id1ZaYXNybDRlRDExM3BtK0p0VDdKVk92bkNYcWR6emRUUkhnSjBQaUdURllXNUd2dDlSOUxENkx6ZnMwdi9UWlpIU215Vk5xN3ZpSUhFNkRCSzdRcDA3SXo1NUVNOFNZdFF2WmYvb2JCbmlUV2k1QzIvb3ZIZnc0Vm5ka0U1WFlkak9oQ01SakRlT0VmWGVOL0N3ZkdkdWlVSWZzb0ZlVXhYZVFYYmE3Yzc5NzJYTnY4dytkVGpqVU0wUWVOQVJlVytKMDE0ZEtBRC9NY1FZWFQ3YzBHUVBJa24zTGw2UjdnR2p1aVFvWkQwVEVlRXFRcEtvWjE1Zy8wT1BRSTE3UWlTdjlBVVJPYS9WL1RRTjNkdkxBcmVjM1Jyc1lsdkJtMWI4TFd6bHRkdWdzQzUwbE5LWUxFcDJhK1paWXFQZWpVTFJsT0poNXpqL0xWTXlURHZ3S2hNeHh3dURreEoxUXBvTkkwT1RXTG9tNFo3MVNOekk5VFYxaVhKckl1OVdjbmQrTUNhQXc4bzFqU1hkOTRZVS8xZ25rckM5QlVFT3RRdkVJUTdnMGk2aCtLTDJKS2s4WWRsN0hydXZnV01TQW1OZStMc2hHaFY0cW5XSGhPOS9SSVBRelkxdEhSajJWcU95TnNEcEswY3d3KzU2QWREQzRnc1d3WTBYeG91Y0lXSXFzL0djd25XcWxhVDBLUHI4bWJLNVU5NC8zMDFpMVdMdDRZSU5UVnZDRkJyRlpiSWJZOGV5Y09kZUoydGVENUlmUExDUmc3ampjRlR3bE1GTmw5emRoL28zRS9oSFB3ajdCV2cwTVUwOXBQckJMYnJDZ201NEE2SCtJNnYyNytqTDVna2pXZy9pWWRrczlqYmZWUDV5L24wZGxnV0VNbEthc2w3SnZGWmQ1NkxmeWJXMWVlYVZPMGd4VGZYWndEOEc0U0kxMTZ5eDdVS1ZSZ3VpNllhMVlwaXhxWGVOTGM4SXh0QXdDVTVJaHdRZ24rTnFIblJhRHY2MUN4S2hPcTRwT1g3TTZwa0ErUG1wZDRqMXZuNkFDVUFMb0xMYzR2cFhjaThWaWRMeHptN3FGQmU3cytxdXVKczZFVFltbnBnUzNMd1NaeFBJbHRnQkRYejhNMWsvVzJ5U052MmY5L05QaHhMR0syRDIxZGtIZVNHbWVuUlQzWXFjZGwwbS9oM09ZcjhWK2xYTllHZjhhQ0NwZDRiV2pFNFFJUGo3dlVLTjROcmZzN01MNlkyT3lTODMwSkNub2ZnL2s3bHBGcHQ0U3FaYzVIR2cxSENPckh2T2RDOGJQNkZHRGJFL1ZWMG1YNElha3piZFMvb3ArS3QzRzI0LzhRYkJWN3k4NnNHU1Evdlp6VThGWHM3dTZqSXZ3Y2hzRVAyQnBJaFczRzh1V053YTNIbWpmSC9aamhoQ1d2bHVBY0Yrbk1mMTRDbEtnNWhHZ3RQTEo5OHVlTkFrYzVIczJXWmxrMlFIdmZyZUNLMUNDR082bk1aVlNiOTlWTS9hanI4V0hUdGU5SlNta1hxL2kvVTk0M0hFYmR6VzZSZS9TODhkS2dnOHBHT0xsQWVOaXFyY0xrVVIzL2FDbEZwTVhjT1VQM3JtRVRjV1NmTVhaRTNUVU9pOGkrZnFSblRZTGZsVngvVmIvNkdKN2VJUlpVQTZrM1JZUjNpRlNLOWM0aURkTndKdVpMMkZLei9JSzVWaW1jTldFcWRYalNveFNnbUYwVVBsRG9VbE5yUGNNN2Z0bUE4WTlnS2lxS0VIdVdOK0FaUkl3dFZTeHllMktmOHJNM2xoSjVYY0JYVTluNHYwT3kxUlUyTSs0cU04QVFQVndzZThFck5Tb2I1b0ZQV3h1cVpuVnpvMXFCL0lCeGtNM0VWVUtGVVVsTzNlNTEyNTlHZ05jSmJDbWx2cmRqdG9UVzdyQ2htMXd5Q0t6cENUd296VVVFT0ljV0xuZVJMZ01YaCtTakdTRmtBbGx6YkdTNUhLN0xsZkNNUk5SRFN2YlFQamNYYWVuTll4Q3Z1MlF5em56NlN0dXhWajY2U2dJMFQ4QjYvc2ZIQUpZWmFaNzh0aGpPU0lGdW1OV0xRYmVaaXhEQ0NDK3YwWUJ0a3hpQkIzamVmSHFaL2RGSFUrY3JiajZPdlMxeC9KREQ3dmxtN3pPVlB3cFVDMDFuaHhadVkvNjNFN2cnO1xuXG4vLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIxNS9cclxuLy8gZm9yIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvblxyXG4vLyBzZWU6IC9kZXJpdmUvbmYuanNcclxuXHJcblxyXG4vLyBhbGdvcml0aG1pYyBoYW5ndWxcclxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvdmVyc2lvbnMvVW5pY29kZTE1LjAuMC9jaDAzLnBkZiAocGFnZSAxNDQpXHJcbmNvbnN0IFMwID0gMHhBQzAwO1xyXG5jb25zdCBMMCA9IDB4MTEwMDtcclxuY29uc3QgVjAgPSAweDExNjE7XHJcbmNvbnN0IFQwID0gMHgxMUE3O1xyXG5jb25zdCBMX0NPVU5UID0gMTk7XHJcbmNvbnN0IFZfQ09VTlQgPSAyMTtcclxuY29uc3QgVF9DT1VOVCA9IDI4O1xyXG5jb25zdCBOX0NPVU5UID0gVl9DT1VOVCAqIFRfQ09VTlQ7XHJcbmNvbnN0IFNfQ09VTlQgPSBMX0NPVU5UICogTl9DT1VOVDtcclxuY29uc3QgUzEgPSBTMCArIFNfQ09VTlQ7XHJcbmNvbnN0IEwxID0gTDAgKyBMX0NPVU5UO1xyXG5jb25zdCBWMSA9IFYwICsgVl9DT1VOVDtcclxuY29uc3QgVDEgPSBUMCArIFRfQ09VTlQ7XHJcblxyXG5mdW5jdGlvbiB1bnBhY2tfY2MocGFja2VkKSB7XHJcblx0cmV0dXJuIChwYWNrZWQgPj4gMjQpICYgMHhGRjtcclxufVxyXG5mdW5jdGlvbiB1bnBhY2tfY3AocGFja2VkKSB7XHJcblx0cmV0dXJuIHBhY2tlZCAmIDB4RkZGRkZGO1xyXG59XHJcblxyXG5sZXQgU0hJRlRFRF9SQU5LLCBFWENMVVNJT05TLCBERUNPTVAsIFJFQ09NUDtcclxuXHJcbmZ1bmN0aW9uIGluaXQkMSgpIHtcclxuXHQvL2NvbnNvbGUudGltZSgnbmYnKTtcclxuXHRsZXQgciA9IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKENPTVBSRVNTRUQpO1xyXG5cdFNISUZURURfUkFOSyA9IG5ldyBNYXAocmVhZF9zb3J0ZWRfYXJyYXlzKHIpLmZsYXRNYXAoKHYsIGkpID0+IHYubWFwKHggPT4gW3gsIChpKzEpIDw8IDI0XSkpKTsgLy8gcHJlLXNoaWZ0ZWRcclxuXHRFWENMVVNJT05TID0gbmV3IFNldChyZWFkX3NvcnRlZChyKSk7XHJcblx0REVDT01QID0gbmV3IE1hcCgpO1xyXG5cdFJFQ09NUCA9IG5ldyBNYXAoKTtcclxuXHRmb3IgKGxldCBbY3AsIGNwc10gb2YgcmVhZF9tYXBwZWQocikpIHtcclxuXHRcdGlmICghRVhDTFVTSU9OUy5oYXMoY3ApICYmIGNwcy5sZW5ndGggPT0gMikge1xyXG5cdFx0XHRsZXQgW2EsIGJdID0gY3BzO1xyXG5cdFx0XHRsZXQgYnVja2V0ID0gUkVDT01QLmdldChhKTtcclxuXHRcdFx0aWYgKCFidWNrZXQpIHtcclxuXHRcdFx0XHRidWNrZXQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0UkVDT01QLnNldChhLCBidWNrZXQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJ1Y2tldC5zZXQoYiwgY3ApO1xyXG5cdFx0fVxyXG5cdFx0REVDT01QLnNldChjcCwgY3BzLnJldmVyc2UoKSk7IC8vIHN0b3JlZCByZXZlcnNlZFxyXG5cdH1cclxuXHQvL2NvbnNvbGUudGltZUVuZCgnbmYnKTtcclxuXHQvLyAyMDIzMDkwNTogMTFtc1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc19oYW5ndWwoY3ApIHtcclxuXHRyZXR1cm4gY3AgPj0gUzAgJiYgY3AgPCBTMTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZV9wYWlyKGEsIGIpIHtcclxuXHRpZiAoYSA+PSBMMCAmJiBhIDwgTDEgJiYgYiA+PSBWMCAmJiBiIDwgVjEpIHtcclxuXHRcdHJldHVybiBTMCArIChhIC0gTDApICogTl9DT1VOVCArIChiIC0gVjApICogVF9DT1VOVDtcclxuXHR9IGVsc2UgaWYgKGlzX2hhbmd1bChhKSAmJiBiID4gVDAgJiYgYiA8IFQxICYmIChhIC0gUzApICUgVF9DT1VOVCA9PSAwKSB7XHJcblx0XHRyZXR1cm4gYSArIChiIC0gVDApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRsZXQgcmVjb21wID0gUkVDT01QLmdldChhKTtcclxuXHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0cmVjb21wID0gcmVjb21wLmdldChiKTtcclxuXHRcdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRcdHJldHVybiByZWNvbXA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY29tcG9zZWQoY3BzKSB7XHJcblx0aWYgKCFTSElGVEVEX1JBTkspIGluaXQkMSgpO1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0bGV0IGNoZWNrX29yZGVyID0gZmFsc2U7XHJcblx0ZnVuY3Rpb24gYWRkKGNwKSB7XHJcblx0XHRsZXQgY2MgPSBTSElGVEVEX1JBTksuZ2V0KGNwKTtcclxuXHRcdGlmIChjYykge1xyXG5cdFx0XHRjaGVja19vcmRlciA9IHRydWU7XHJcblx0XHRcdGNwIHw9IGNjO1xyXG5cdFx0fVxyXG5cdFx0cmV0LnB1c2goY3ApO1xyXG5cdH1cclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGlmIChjcCA8IDB4ODApIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGNwKSkge1xyXG5cdFx0XHRcdGxldCBzX2luZGV4ID0gY3AgLSBTMDtcclxuXHRcdFx0XHRsZXQgbF9pbmRleCA9IHNfaW5kZXggLyBOX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdl9pbmRleCA9IChzX2luZGV4ICUgTl9DT1VOVCkgLyBUX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdF9pbmRleCA9IHNfaW5kZXggJSBUX0NPVU5UO1xyXG5cdFx0XHRcdGFkZChMMCArIGxfaW5kZXgpO1xyXG5cdFx0XHRcdGFkZChWMCArIHZfaW5kZXgpO1xyXG5cdFx0XHRcdGlmICh0X2luZGV4ID4gMCkgYWRkKFQwICsgdF9pbmRleCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IG1hcHBlZCA9IERFQ09NUC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChtYXBwZWQpIHtcclxuXHRcdFx0XHRcdGJ1Zi5wdXNoKC4uLm1hcHBlZCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGFkZChjcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghYnVmLmxlbmd0aCkgYnJlYWs7XHJcblx0XHRcdGNwID0gYnVmLnBvcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hlY2tfb3JkZXIgJiYgcmV0Lmxlbmd0aCA+IDEpIHtcclxuXHRcdGxldCBwcmV2X2NjID0gdW5wYWNrX2NjKHJldFswXSk7XHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdFx0aWYgKGNjID09IDAgfHwgcHJldl9jYyA8PSBjYykge1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgaiA9IGktMTtcclxuXHRcdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0XHRsZXQgdG1wID0gcmV0W2orMV07XHJcblx0XHRcdFx0cmV0W2orMV0gPSByZXRbal07XHJcblx0XHRcdFx0cmV0W2pdID0gdG1wO1xyXG5cdFx0XHRcdGlmICghaikgYnJlYWs7XHJcblx0XHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbLS1qXSk7XHJcblx0XHRcdFx0aWYgKHByZXZfY2MgPD0gY2MpIGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkKHYpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHN0YWNrID0gW107XHJcblx0bGV0IHByZXZfY3AgPSAtMTtcclxuXHRsZXQgcHJldl9jYyA9IDA7XHJcblx0Zm9yIChsZXQgcGFja2VkIG9mIHYpIHtcclxuXHRcdGxldCBjYyA9IHVucGFja19jYyhwYWNrZWQpO1xyXG5cdFx0bGV0IGNwID0gdW5wYWNrX2NwKHBhY2tlZCk7XHJcblx0XHRpZiAocHJldl9jcCA9PSAtMSkge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAocHJldl9jYyA+IDAgJiYgcHJldl9jYyA+PSBjYykge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3AsIC4uLnN0YWNrKTtcclxuXHRcdFx0XHRzdGFjay5sZW5ndGggPSAwO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY29tcG9zZWQgPSBjb21wb3NlX3BhaXIocHJldl9jcCwgY3ApO1xyXG5cdFx0XHRpZiAoY29tcG9zZWQgPj0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjb21wb3NlZDtcclxuXHRcdFx0fSBlbHNlIGlmIChwcmV2X2NjID09IDAgJiYgY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3ApO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXZfY3AgPj0gMCkge1xyXG5cdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1x0XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIG5vdGU6IGNwcyBjYW4gYmUgaXRlcmFibGVcclxuZnVuY3Rpb24gbmZkKGNwcykge1xyXG5cdHJldHVybiBkZWNvbXBvc2VkKGNwcykubWFwKHVucGFja19jcCk7XHJcbn1cclxuZnVuY3Rpb24gbmZjKGNwcykge1xyXG5cdHJldHVybiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQoZGVjb21wb3NlZChjcHMpKTtcclxufVxuXG5jb25zdCBIWVBIRU4gPSAweDJEO1xyXG5jb25zdCBTVE9QID0gMHgyRTtcclxuY29uc3QgU1RPUF9DSCA9ICcuJztcclxuY29uc3QgRkUwRiA9IDB4RkUwRjtcclxuY29uc3QgVU5JUVVFX1BIID0gMTtcclxuXHJcbi8vIDIwMjMwOTEzOiByZXBsYWNlIFsuLi52XSB3aXRoIEFycmF5X2Zyb20odikgdG8gYXZvaWQgbGFyZ2Ugc3ByZWFkc1xyXG5jb25zdCBBcnJheV9mcm9tID0geCA9PiBBcnJheS5mcm9tKHgpOyAvLyBBcnJheS5mcm9tLmJpbmQoQXJyYXkpO1xyXG5cclxuZnVuY3Rpb24gZ3JvdXBfaGFzX2NwKGcsIGNwKSB7XHJcblx0Ly8gMjAyMzA5MTM6IGtlZXAgcHJpbWFyeSBhbmQgc2Vjb25kYXJ5IGRpc3RpbmN0IGluc3RlYWQgb2YgY3JlYXRpbmcgdmFsaWQgdW5pb25cclxuXHRyZXR1cm4gZy5QLmhhcyhjcCkgfHwgZy5RLmhhcyhjcCk7XHJcbn1cclxuXHJcbmNsYXNzIEVtb2ppIGV4dGVuZHMgQXJyYXkge1xyXG5cdGdldCBpc19lbW9qaSgpIHsgcmV0dXJuIHRydWU7IH0gLy8gZnJlZSB0YWdnaW5nIHN5c3RlbVxyXG59XHJcblxyXG5sZXQgTUFQUEVELCBJR05PUkVELCBDTSwgTlNNLCBFU0NBUEUsIE5GQ19DSEVDSywgR1JPVVBTLCBXSE9MRV9WQUxJRCwgV0hPTEVfTUFQLCBWQUxJRCwgRU1PSklfTElTVCwgRU1PSklfUk9PVDtcclxuXHJcbmZ1bmN0aW9uIGluaXQoKSB7XHJcblx0aWYgKE1BUFBFRCkgcmV0dXJuO1xyXG5cdFxyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCQxKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9hcnJheSA9ICgpID0+IHJlYWRfc29ydGVkKHIpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX3NldCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblx0Y29uc3Qgc2V0X2FkZF9tYW55ID0gKHNldCwgdikgPT4gdi5mb3JFYWNoKHggPT4gc2V0LmFkZCh4KSk7XHJcblxyXG5cdE1BUFBFRCA9IG5ldyBNYXAocmVhZF9tYXBwZWQocikpOyBcclxuXHRJR05PUkVEID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGlnbm9yZWQgY2hhcmFjdGVycyBhcmUgbm90IHZhbGlkLCBzbyBqdXN0IHJlYWQgcmF3IGNvZGVwb2ludHNcclxuXHJcblx0LypcclxuXHQvLyBkaXJlY3QgaW5jbHVkZSBmcm9tIHBheWxvYWQgaXMgc21hbGxlciB0aGFuIHRoZSBkZWNvbXByZXNzaW9uIGNvZGVcclxuXHRjb25zdCBGRU5DRUQgPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0bGV0IGNwID0gcigpO1xyXG5cdFx0aWYgKGNwKSByZXR1cm4gW2NwLCByZWFkX3N0cihyKCkpXTtcclxuXHR9KSk7XHJcblx0Ki9cclxuXHQvLyAyMDIzMDIxNzogd2Ugc3RpbGwgbmVlZCBhbGwgQ00gZm9yIHByb3BlciBlcnJvciBmb3JtYXR0aW5nXHJcblx0Ly8gYnV0IG5vcm0gb25seSBuZWVkcyBOU00gc3Vic2V0IHRoYXQgYXJlIHBvdGVudGlhbGx5LXZhbGlkXHJcblx0Q00gPSByZWFkX3NvcnRlZF9hcnJheSgpO1xyXG5cdE5TTSA9IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5tYXAoaSA9PiBDTVtpXSkpO1xyXG5cdENNID0gbmV3IFNldChDTSk7XHJcblx0XHJcblx0RVNDQVBFID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByaW50ZWRcclxuXHRORkNfQ0hFQ0sgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gb25seSBuZWVkZWQgdG8gaWxsdXN0cmF0ZSBlbnNfdG9rZW5pemUoKSB0cmFuc2Zvcm1hdGlvbnNcclxuXHJcblx0bGV0IGNodW5rcyA9IHJlYWRfc29ydGVkX2FycmF5cyhyKTtcclxuXHRsZXQgdW5yZXN0cmljdGVkID0gcigpO1xyXG5cdC8vY29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLmZsYXRNYXAoaSA9PiBjaHVua3NbaV0pLmNvbmNhdChyZWFkX3NvcnRlZF9hcnJheSgpKSk7XHJcblx0Y29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4ge1xyXG5cdFx0Ly8gMjAyMzA5MjE6IGJ1aWxkIHNldCBpbiBwYXJ0cywgMnggZmFzdGVyXHJcblx0XHRsZXQgc2V0ID0gbmV3IFNldCgpO1xyXG5cdFx0cmVhZF9zb3J0ZWRfYXJyYXkoKS5mb3JFYWNoKGkgPT4gc2V0X2FkZF9tYW55KHNldCwgY2h1bmtzW2ldKSk7XHJcblx0XHRzZXRfYWRkX21hbnkoc2V0LCByZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRcdHJldHVybiBzZXQ7IFxyXG5cdH07XHJcblx0R1JPVVBTID0gcmVhZF9hcnJheV93aGlsZShpID0+IHtcclxuXHRcdC8vIG1pbmlmaWVyIHByb3BlcnR5IG1hbmdsaW5nIHNlZW1zIHVuc2FmZVxyXG5cdFx0Ly8gc28gdGhlc2UgYXJlIG1hbnVhbGx5IHJlbmFtZWQgdG8gc2luZ2xlIGNoYXJzXHJcblx0XHRsZXQgTiA9IHJlYWRfYXJyYXlfd2hpbGUocikubWFwKHggPT4geCsweDYwKTtcclxuXHRcdGlmIChOLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgUiA9IGkgPj0gdW5yZXN0cmljdGVkOyAvLyB1bnJlc3RyaWN0ZWQgdGhlbiByZXN0cmljdGVkXHJcblx0XHRcdE5bMF0gLT0gMzI7IC8vIGNhcGl0YWxpemVcclxuXHRcdFx0TiA9IHN0cl9mcm9tX2NwcyhOKTtcclxuXHRcdFx0aWYgKFIpIE49YFJlc3RyaWN0ZWRbJHtOfV1gO1xyXG5cdFx0XHRsZXQgUCA9IHJlYWRfY2h1bmtlZCgpOyAvLyBwcmltYXJ5XHJcblx0XHRcdGxldCBRID0gcmVhZF9jaHVua2VkKCk7IC8vIHNlY29uZGFyeVxyXG5cdFx0XHRsZXQgTSA9ICFyKCk7IC8vIG5vdC13aGl0ZWxpc3RlZCwgY2hlY2sgZm9yIE5TTVxyXG5cdFx0XHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0XHRcdC8qXHJcblx0XHRcdGxldCBWID0gWy4uLlAsIC4uLlFdLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIGRlcml2ZTogc29ydGVkIHZhbGlkXHJcblx0XHRcdGxldCBNID0gcigpLTE7IC8vIG51bWJlciBvZiBjb21iaW5pbmcgbWFya1xyXG5cdFx0XHRpZiAoTSA8IDApIHsgLy8gd2hpdGVsaXN0ZWRcclxuXHRcdFx0XHRNID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdGxldCBpID0gcigpO1xyXG5cdFx0XHRcdFx0aWYgKGkpIHJldHVybiBbVltpLTFdLCByZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IHYgPSByZWFkX2FycmF5X3doaWxlKHIpO1xyXG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2Lm1hcCh4ID0+IHgtMSk7XHJcblx0XHRcdFx0XHR9KV07XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9Ki9cclxuXHRcdFx0cmV0dXJuIHtOLCBQLCBRLCBNLCBSfTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gZGVjb2RlIGNvbXByZXNzZWQgd2hvbGVzXHJcblx0V0hPTEVfVkFMSUQgPSByZWFkX3NvcnRlZF9zZXQoKTtcclxuXHRXSE9MRV9NQVAgPSBuZXcgTWFwKCk7XHJcblx0bGV0IHdob2xlcyA9IHJlYWRfc29ydGVkX2FycmF5KCkuY29uY2F0KEFycmF5X2Zyb20oV0hPTEVfVkFMSUQpKS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBtdXN0IGJlIHNvcnRlZFxyXG5cdHdob2xlcy5mb3JFYWNoKChjcCwgaSkgPT4ge1xyXG5cdFx0bGV0IGQgPSByKCk7IFxyXG5cdFx0bGV0IHcgPSB3aG9sZXNbaV0gPSBkID8gd2hvbGVzW2ktZF0gOiB7VjogW10sIE06IG5ldyBNYXAoKX07XHJcblx0XHR3LlYucHVzaChjcCk7IC8vIGFkZCB0byBtZW1iZXIgc2V0XHJcblx0XHRpZiAoIVdIT0xFX1ZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgdyk7ICAvLyByZWdpc3RlciB3aXRoIHdob2xlIG1hcFxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBjb21wdXRlIGNvbmZ1c2FibGUtZXh0ZW50IGNvbXBsZW1lbnRzXHJcblx0Ly8gdXNhZ2U6IFdIT0xFX01BUC5nZXQoY3ApLk0uZ2V0KGNwKSA9IGNvbXBsZW1lbnQgc2V0XHJcblx0Zm9yIChsZXQge1YsIE19IG9mIG5ldyBTZXQoV0hPTEVfTUFQLnZhbHVlcygpKSkge1xyXG5cdFx0Ly8gY29ubmVjdCBhbGwgZ3JvdXBzIHRoYXQgaGF2ZSBlYWNoIHdob2xlIGNoYXJhY3RlclxyXG5cdFx0bGV0IHJlY3MgPSBbXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0bGV0IGdzID0gR1JPVVBTLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0XHRsZXQgcmVjID0gcmVjcy5maW5kKCh7R30pID0+IGdzLnNvbWUoZyA9PiBHLmhhcyhnKSkpO1xyXG5cdFx0XHRpZiAoIXJlYykge1xyXG5cdFx0XHRcdHJlYyA9IHtHOiBuZXcgU2V0KCksIFY6IFtdfTtcclxuXHRcdFx0XHRyZWNzLnB1c2gocmVjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZWMuVi5wdXNoKGNwKTtcclxuXHRcdFx0c2V0X2FkZF9tYW55KHJlYy5HLCBncyk7XHJcblx0XHR9XHJcblx0XHQvLyBwZXIgY2hhcmFjdGVyIGNhY2hlIGdyb3VwcyB3aGljaCBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSBleHRlbnRcclxuXHRcdGxldCB1bmlvbiA9IHJlY3MuZmxhdE1hcCh4ID0+IEFycmF5X2Zyb20oeC5HKSk7IC8vIGFsbCBvZiB0aGUgZ3JvdXBzIHVzZWQgYnkgdGhpcyB3aG9sZVxyXG5cdFx0Zm9yIChsZXQge0csIFZ9IG9mIHJlY3MpIHtcclxuXHRcdFx0bGV0IGNvbXBsZW1lbnQgPSBuZXcgU2V0KHVuaW9uLmZpbHRlcihnID0+ICFHLmhhcyhnKSkpOyAvLyBncm91cHMgbm90IGNvdmVyZWQgYnkgdGhlIGV4dGVudFxyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdFx0TS5zZXQoY3AsIGNvbXBsZW1lbnQpOyAvLyB0aGlzIGlzIHRoZSBzYW1lIHJlZmVyZW5jZVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBjb21wdXRlIHZhbGlkIHNldFxyXG5cdC8vIDIwMjMwOTI0OiBWQUxJRCB3YXMgdW5pb24gYnV0IGNhbiBiZSByZS11c2VkXHJcblx0VkFMSUQgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAxKyBncm91cHNcclxuXHRsZXQgbXVsdGkgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAyKyBncm91cHNcclxuXHRjb25zdCBhZGRfdG9fdW5pb24gPSBjcCA9PiBWQUxJRC5oYXMoY3ApID8gbXVsdGkuYWRkKGNwKSA6IFZBTElELmFkZChjcCk7XHJcblx0Zm9yIChsZXQgZyBvZiBHUk9VUFMpIHtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUCkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUSkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHR9XHJcblx0Ly8gZHVhbCBwdXJwb3NlIFdIT0xFX01BUDogcmV0dXJuIHBsYWNlaG9sZGVyIGlmIHVuaXF1ZSBub24tY29uZnVzYWJsZVxyXG5cdGZvciAobGV0IGNwIG9mIFZBTElEKSB7XHJcblx0XHRpZiAoIVdIT0xFX01BUC5oYXMoY3ApICYmICFtdWx0aS5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIFVOSVFVRV9QSCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIGFkZCBhbGwgZGVjb21wb3NlZCBwYXJ0c1xyXG5cdC8vIHNlZSBkZXJpdmU6IFwiVmFsaWQgaXMgQ2xvc2VkICh2aWEgQnJ1dGUtZm9yY2UpXCJcclxuXHRzZXRfYWRkX21hbnkoVkFMSUQsIG5mZChWQUxJRCkpO1xyXG5cdFxyXG5cdC8vIGRlY29kZSBlbW9qaVxyXG5cdC8vIDIwMjMwNzE5OiBlbW9qaSBhcmUgbm93IGZ1bGx5LWV4cGFuZGVkIHRvIGF2b2lkIHF1aXJrIGxvZ2ljIFxyXG5cdEVNT0pJX0xJU1QgPSByZWFkX3RyaWUocikubWFwKHYgPT4gRW1vamkuZnJvbSh2KSkuc29ydChjb21wYXJlX2FycmF5cyk7XHJcblx0RU1PSklfUk9PVCA9IG5ldyBNYXAoKTsgLy8gdGhpcyBoYXMgYXBwcm94IDdLIG5vZGVzICgyKyBwZXIgZW1vamkpXHJcblx0Zm9yIChsZXQgY3BzIG9mIEVNT0pJX0xJU1QpIHtcclxuXHRcdC8vIDIwMjMwNzE5OiBjaGFuZ2UgdG8gKnNsaWdodGx5KiBzdHJpY3RlciBhbGdvcml0aG0gd2hpY2ggZGlzYWxsb3dzIFxyXG5cdFx0Ly8gaW5zZXJ0aW9uIG9mIG1pc3BsYWNlZCBGRTBGIGluIGVtb2ppIHNlcXVlbmNlcyAobWF0Y2hpbmcgRU5TSVAtMTUpXHJcblx0XHQvLyBleGFtcGxlOiBiZWF1dGlmaWVkIFtBIEJdIChlZy4gZmxhZyBlbW9qaSkgXHJcblx0XHQvLyAgYmVmb3JlOiBhbGxvdzogW0EgRkUwRiBCXSwgZXJyb3I6IFtBIEZFMEYgRkUwRiBCXSBcclxuXHRcdC8vICAgYWZ0ZXI6IGVycm9yOiBib3RoXHJcblx0XHQvLyBub3RlOiB0aGlzIGNvZGUgbm93IG1hdGNoZXMgRU5TTm9ybWFsaXplLntjcyxqYXZhfSBsb2dpY1xyXG5cdFx0bGV0IHByZXYgPSBbRU1PSklfUk9PVF07XHJcblx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0bGV0IG5leHQgPSBwcmV2Lm1hcChub2RlID0+IHtcclxuXHRcdFx0XHRsZXQgY2hpbGQgPSBub2RlLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKCFjaGlsZCkge1xyXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHRoaXMgYmUgb2JqZWN0PyBcclxuXHRcdFx0XHRcdC8vIChtb3N0IGhhdmUgMS0yIGl0ZW1zLCBmZXcgaGF2ZSBtYW55KVxyXG5cdFx0XHRcdFx0Ly8gMjAyMzA3MTk6IG5vLCB2OCBkZWZhdWx0IG1hcCBpcyA0P1xyXG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0XHRub2RlLnNldChjcCwgY2hpbGQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoY3AgPT09IEZFMEYpIHtcclxuXHRcdFx0XHRwcmV2LnB1c2goLi4ubmV4dCk7IC8vIGxlc3MgdGhhbiAyMCBlbGVtZW50c1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHByZXYgPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB4IG9mIHByZXYpIHtcclxuXHRcdFx0eC5WID0gY3BzO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gaWYgZXNjYXBlZDoge0hFWH1cclxuLy8gICAgICAgZWxzZTogXCJ4XCIge0hFWH1cclxuZnVuY3Rpb24gcXVvdGVkX2NwKGNwKSB7XHJcblx0cmV0dXJuIChzaG91bGRfZXNjYXBlKGNwKSA/ICcnIDogYCR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhbY3BdKSl9IGApICsgcXVvdGVfY3AoY3ApO1xyXG59XHJcblxyXG4vLyAyMDIzMDIxMTogc29tZSBtZXNzYWdlcyBjYW4gYmUgbWl4ZWQtZGlyZWN0aW9uYWwgYW5kIHJlc3VsdCBpbiBzcGlsbG92ZXJcclxuLy8gdXNlIDIwMEUgYWZ0ZXIgYSBxdW90ZWQgc3RyaW5nIHRvIGZvcmNlIHRoZSByZW1haW5kZXIgb2YgYSBzdHJpbmcgZnJvbSBcclxuLy8gYWNxdXJpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcXVvdGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9scyNleGNlcHRpb25zXHJcbmZ1bmN0aW9uIGJpZGlfcXEocykge1xyXG5cdHJldHVybiBgXCIke3N9XCJcXHUyMDBFYDsgLy8gc3Ryb25nIExUUlxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja19sYWJlbF9leHRlbnNpb24oY3BzKSB7XHJcblx0aWYgKGNwcy5sZW5ndGggPj0gNCAmJiBjcHNbMl0gPT0gSFlQSEVOICYmIGNwc1szXSA9PSBIWVBIRU4pIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBsYWJlbCBleHRlbnNpb246IFwiJHtzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKDAsIDQpKX1cImApOyAvLyB0aGlzIGNhbiBvbmx5IGJlIGFzY2lpIHNvIGNhbnQgYmUgYmlkaVxyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUoY3BzKSB7XHJcblx0Y29uc3QgVU5ERVJTQ09SRSA9IDB4NUY7XHJcblx0Zm9yIChsZXQgaSA9IGNwcy5sYXN0SW5kZXhPZihVTkRFUlNDT1JFKTsgaSA+IDA7ICkge1xyXG5cdFx0aWYgKGNwc1stLWldICE9PSBVTkRFUlNDT1JFKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigndW5kZXJzY29yZSBhbGxvd2VkIG9ubHkgYXQgc3RhcnQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuLy8gY2hlY2sgdGhhdCBhIGZlbmNlZCBjcCBpcyBub3QgbGVhZGluZywgdHJhaWxpbmcsIG9yIHRvdWNoaW5nIGFub3RoZXIgZmVuY2VkIGNwXHJcbmZ1bmN0aW9uIGNoZWNrX2ZlbmNlZChjcHMpIHtcclxuXHRsZXQgY3AgPSBjcHNbMF07XHJcblx0bGV0IHByZXYgPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRpZiAocHJldikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGBsZWFkaW5nICR7cHJldn1gKTtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0bGV0IGxhc3QgPSAtMTsgLy8gcHJldmVudHMgdHJhaWxpbmcgZnJvbSB0aHJvd2luZ1xyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjcCA9IGNwc1tpXTtcclxuXHRcdGxldCBtYXRjaCA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdC8vIHNpbmNlIGNwc1swXSBpc24ndCBmZW5jZWQsIGNwc1sxXSBjYW5ub3QgdGhyb3dcclxuXHRcdFx0aWYgKGxhc3QgPT0gaSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGAke3ByZXZ9ICsgJHttYXRjaH1gKTtcclxuXHRcdFx0bGFzdCA9IGkgKyAxO1xyXG5cdFx0XHRwcmV2ID0gbWF0Y2g7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYXN0ID09IG4pIHRocm93IGVycm9yX3BsYWNlbWVudChgdHJhaWxpbmcgJHtwcmV2fWApO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBzYWZlIHRvIHByaW50IHN0cmluZyBcclxuLy8gaW52aXNpYmxlcyBhcmUgZXNjYXBlZFxyXG4vLyBsZWFkaW5nIGNtIHVzZXMgcGxhY2Vob2xkZXJcclxuLy8gaWYgY3BzIGV4Y2VlZCBtYXgsIG1pZGRsZSB0cnVuY2F0ZSB3aXRoIGVsbGlwc2lzXHJcbi8vIHF1b3RlcihjcCkgPT4gc3RyaW5nLCBlZy4gMzAwMCA9PiBcInszMDAwfVwiXHJcbi8vIG5vdGU6IGluIGh0bWwsIHlvdSdkIGNhbGwgdGhpcyBmdW5jdGlvbiB0aGVuIHJlcGxhY2UgWzw+Jl0gd2l0aCBlbnRpdGllc1xyXG5mdW5jdGlvbiBzYWZlX3N0cl9mcm9tX2NwcyhjcHMsIG1heCA9IEluZmluaXR5LCBxdW90ZXIgPSBxdW90ZV9jcCkge1xyXG5cdC8vaWYgKE51bWJlci5pc0ludGVnZXIoY3BzKSkgY3BzID0gW2Nwc107XHJcblx0Ly9pZiAoIUFycmF5LmlzQXJyYXkoY3BzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgY29kZXBvaW50c2ApO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRpZiAoaXNfY29tYmluaW5nX21hcmsoY3BzWzBdKSkgYnVmLnB1c2goJ+KXjCcpO1xyXG5cdGlmIChjcHMubGVuZ3RoID4gbWF4KSB7XHJcblx0XHRtYXggPj49IDE7XHJcblx0XHRjcHMgPSBbLi4uY3BzLnNsaWNlKDAsIG1heCksIDB4MjAyNiwgLi4uY3BzLnNsaWNlKC1tYXgpXTtcclxuXHR9XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0bGV0IGNwID0gY3BzW2ldO1xyXG5cdFx0aWYgKHNob3VsZF9lc2NhcGUoY3ApKSB7XHJcblx0XHRcdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgaSkpKTtcclxuXHRcdFx0YnVmLnB1c2gocXVvdGVyKGNwKSk7XHJcblx0XHRcdHByZXYgPSBpICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBuKSkpO1xyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbi8vIG5vdGU6IHNldChzKSBjYW5ub3QgYmUgZXhwb3NlZCBiZWNhdXNlIHRoZXkgY2FuIGJlIG1vZGlmaWVkXHJcbi8vIG5vdGU6IE9iamVjdC5mcmVlemUoKSBkb2Vzbid0IHdvcmtcclxuZnVuY3Rpb24gaXNfY29tYmluaW5nX21hcmsoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIENNLmhhcyhjcCk7XHJcbn1cclxuZnVuY3Rpb24gc2hvdWxkX2VzY2FwZShjcCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRVNDQVBFLmhhcyhjcCk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBhbGwgc3VwcG9ydGVkIGVtb2ppIGFzIGZ1bGx5LXF1YWxpZmllZCBlbW9qaSBcclxuLy8gb3JkZXJlZCBieSBsZW5ndGggdGhlbiBsZXhpY29ncmFwaGljIFxyXG5mdW5jdGlvbiBlbnNfZW1vamkoKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBFTU9KSV9MSVNULm1hcCh4ID0+IHguc2xpY2UoKSk7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZV9mcmFnbWVudChmcmFnLCBkZWNvbXBvc2UpIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IG5mID0gZGVjb21wb3NlID8gbmZkIDogbmZjO1xyXG5cdHJldHVybiBmcmFnLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiBzdHJfZnJvbV9jcHModG9rZW5zX2Zyb21fc3RyKGV4cGxvZGVfY3AobGFiZWwpLCBuZiwgZmlsdGVyX2ZlMGYpLmZsYXQoKSkpLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemUobmFtZSkge1xyXG5cdHJldHVybiBmbGF0dGVuKHNwbGl0KG5hbWUsIG5mYywgZmlsdGVyX2ZlMGYpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX2JlYXV0aWZ5KG5hbWUpIHtcclxuXHRsZXQgbGFiZWxzID0gc3BsaXQobmFtZSwgbmZjLCB4ID0+IHgpOyAvLyBlbW9qaSBub3QgZXhwb3NlZFxyXG5cdGZvciAobGV0IHt0eXBlLCBvdXRwdXQsIGVycm9yfSBvZiBsYWJlbHMpIHtcclxuXHRcdGlmIChlcnJvcikgYnJlYWs7IC8vIGZsYXR0ZW4gd2lsbCB0aHJvd1xyXG5cclxuXHRcdC8vIHJlcGxhY2UgbGVhZGluZy90cmFpbGluZyBoeXBoZW5cclxuXHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBiZWF1dGlmaW5nIGFsbCBvciBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlbiB0byB1bmljb2RlIHZhcmlhbnRcclxuXHRcdC8vIG5vdCBleGFjdGx5IHRoZSBzYW1lIGluIGV2ZXJ5IGZvbnQsIGJ1dCB2ZXJ5IHNpbWlsYXI6IFwiLVwiIHZzIFwi4oCQXCJcclxuXHRcdC8qXHJcblx0XHRjb25zdCBVTklDT0RFX0hZUEhFTiA9IDB4MjAxMDtcclxuXHRcdC8vIG1heWJlIHRoaXMgc2hvdWxkIHJlcGxhY2UgYWxsIGZvciB2aXN1YWwgY29uc2lzdGFuY3k/XHJcblx0XHQvLyBgbm9kZSB0b29scy9yZWctY291bnQuanMgcmVnZXggXi1cXHsyLFxcfWAgPT4gNTkyXHJcblx0XHQvL2ZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSsrKSBpZiAob3V0cHV0W2ldID09IDB4MkQpIG91dHB1dFtpXSA9IDB4MjAxMDtcclxuXHRcdGlmIChvdXRwdXRbMF0gPT0gSFlQSEVOKSBvdXRwdXRbMF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdGxldCBlbmQgPSBvdXRwdXQubGVuZ3RoLTE7XHJcblx0XHRpZiAob3V0cHV0W2VuZF0gPT0gSFlQSEVOKSBvdXRwdXRbZW5kXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0Ki9cclxuXHRcdC8vIDIwMjMwMTIzOiBXSEFUV0cgVVJMIHVzZXMgXCJDaGVja0h5cGhlbnNcIiBmYWxzZVxyXG5cdFx0Ly8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpZG5hXHJcblxyXG5cdFx0Ly8gdXBkYXRlIGV0aGVyZXVtIHN5bWJvbFxyXG5cdFx0Ly8gzr4gPT4gzp4gaWYgbm90IGdyZWVrXHJcblx0XHRpZiAodHlwZSAhPT0gJ0dyZWVrJykgYXJyYXlfcmVwbGFjZShvdXRwdXQsIDB4M0JFLCAweDM5RSk7XHJcblxyXG5cdFx0Ly8gMjAyMjEyMTM6IGZpeGVzIGJpZGkgc3ViZG9tYWluIGlzc3VlLCBidXQgYnJlYWtzIGludmFyaWFudCAoMjAwRSBpcyBkaXNhbGxvd2VkKVxyXG5cdFx0Ly8gY291bGQgYmUgZml4ZWQgd2l0aCBzcGVjaWFsIGNhc2UgZm9yOiAyRCAoLikgKyAyMDBFIChMVFIpXHJcblx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9iaWRpLWxhYmVsLW9yZGVyaW5nLXNwb29mLzE1ODI0XHJcblx0XHQvL291dHB1dC5zcGxpY2UoMCwgMCwgMHgyMDBFKTtcclxuXHR9XHJcblx0cmV0dXJuIGZsYXR0ZW4obGFiZWxzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlfcmVwbGFjZSh2LCBhLCBiKSB7XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgbmV4dCA9IHYuaW5kZXhPZihhLCBwcmV2KTtcclxuXHRcdGlmIChuZXh0IDwgMCkgYnJlYWs7XHJcblx0XHR2W25leHRdID0gYjsgXHJcblx0XHRwcmV2ID0gbmV4dCArIDE7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfc3BsaXQobmFtZSwgcHJlc2VydmVfZW1vamkpIHtcclxuXHRyZXR1cm4gc3BsaXQobmFtZSwgbmZjLCBwcmVzZXJ2ZV9lbW9qaSA/IHggPT4geC5zbGljZSgpIDogZmlsdGVyX2ZlMGYpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwbGl0KG5hbWUsIG5mLCBlZikge1xyXG5cdGlmICghbmFtZSkgcmV0dXJuIFtdOyAvLyAyMDIzMDcxOTogZW1wdHkgbmFtZSBhbGxvd2FuY2VcclxuXHRpbml0KCk7XHJcblx0bGV0IG9mZnNldCA9IDA7XHJcblx0Ly8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYvI1ZhbGlkaXR5X0NyaXRlcmlhXHJcblx0Ly8gNC4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGNvbnRhaW4gYSBVKzAwMkUgKCAuICkgRlVMTCBTVE9QLlwiXHJcblx0cmV0dXJuIG5hbWUuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHtcclxuXHRcdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobGFiZWwpO1xyXG5cdFx0bGV0IGluZm8gPSB7XHJcblx0XHRcdGlucHV0LFxyXG5cdFx0XHRvZmZzZXQsIC8vIGNvZGVwb2ludCwgbm90IHN1YnN0cmluZyFcclxuXHRcdH07XHJcblx0XHRvZmZzZXQgKz0gaW5wdXQubGVuZ3RoICsgMTsgLy8gKyBzdG9wXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyAxLikgXCJUaGUgbGFiZWwgbXVzdCBiZSBpbiBVbmljb2RlIE5vcm1hbGl6YXRpb24gRm9ybSBORkNcIlxyXG5cdFx0XHRsZXQgdG9rZW5zID0gaW5mby50b2tlbnMgPSB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZik7XHJcblx0XHRcdGxldCB0b2tlbl9jb3VudCA9IHRva2Vucy5sZW5ndGg7XHJcblx0XHRcdGxldCB0eXBlO1xyXG5cdFx0XHRpZiAoIXRva2VuX2NvdW50KSB7IC8vIHRoZSBsYWJlbCB3YXMgZWZmZWN0aXZlbHkgZW1wdHkgKGNvdWxkIG9mIGhhZCBpZ25vcmVkIGNoYXJhY3RlcnMpXHJcblx0XHRcdFx0Ly9ub3JtID0gW107XHJcblx0XHRcdFx0Ly90eXBlID0gJ05vbmUnOyAvLyB1c2UgdGhpcyBpbnN0ZWFkIG9mIG5leHQgbWF0Y2gsIFwiQVNDSUlcIlxyXG5cdFx0XHRcdC8vIDIwMjMwMTIwOiBjaGFuZ2UgdG8gc3RyaWN0XHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvZW5zLW5hbWUtbm9ybWFsaXphdGlvbi0ybmQvMTQ1NjQvNTlcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGVtcHR5IGxhYmVsYCk7XHJcblx0XHRcdH0gXHJcblx0XHRcdGxldCBub3JtID0gaW5mby5vdXRwdXQgPSB0b2tlbnMuZmxhdCgpO1xyXG5cdFx0XHRjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUobm9ybSk7XHJcblx0XHRcdGxldCBlbW9qaSA9IGluZm8uZW1vamkgPSB0b2tlbl9jb3VudCA+IDEgfHwgdG9rZW5zWzBdLmlzX2Vtb2ppOyAvLyBzYW1lIGFzOiB0b2tlbnMuc29tZSh4ID0+IHguaXNfZW1vamkpO1xyXG5cdFx0XHRpZiAoIWVtb2ppICYmIG5vcm0uZXZlcnkoY3AgPT4gY3AgPCAweDgwKSkgeyAvLyBzcGVjaWFsIGNhc2UgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjM6IG1hdGNoZXMgbWF0Y2hlcyBXSEFUV0csIHNlZSBub3RlIDMuM1xyXG5cdFx0XHRcdGNoZWNrX2xhYmVsX2V4dGVuc2lvbihub3JtKTsgLy8gb25seSBuZWVkZWQgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGZlbmNlZFxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBjbVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSB3aG9sZXNcclxuXHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIkZhc3RwYXRoIEFTQ0lJXCJcclxuXHRcdFx0XHR0eXBlID0gJ0FTQ0lJJztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY2hhcnMgPSB0b2tlbnMuZmxhdE1hcCh4ID0+IHguaXNfZW1vamkgPyBbXSA6IHgpOyAvLyBhbGwgb2YgdGhlIG5mYyB0b2tlbnMgY29uY2F0IHRvZ2V0aGVyXHJcblx0XHRcdFx0aWYgKCFjaGFycy5sZW5ndGgpIHsgLy8gdGhlcmVzIG5vIHRleHQsIGp1c3QgZW1vamlcclxuXHRcdFx0XHRcdHR5cGUgPSAnRW1vamknO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyA1LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgYmVnaW4gd2l0aCBhIGNvbWJpbmluZyBtYXJrLCB0aGF0IGlzOiBHZW5lcmFsX0NhdGVnb3J5PU1hcmsuXCJcclxuXHRcdFx0XHRcdGlmIChDTS5oYXMobm9ybVswXSkpIHRocm93IGVycm9yX3BsYWNlbWVudCgnbGVhZGluZyBjb21iaW5pbmcgbWFyaycpO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0b2tlbl9jb3VudDsgaSsrKSB7IC8vIHdlJ3ZlIGFscmVhZHkgY2hlY2tlZCB0aGUgZmlyc3QgdG9rZW5cclxuXHRcdFx0XHRcdFx0bGV0IGNwcyA9IHRva2Vuc1tpXTtcclxuXHRcdFx0XHRcdFx0aWYgKCFjcHMuaXNfZW1vamkgJiYgQ00uaGFzKGNwc1swXSkpIHsgLy8gZXZlcnkgdGV4dCB0b2tlbiBoYXMgZW1vamkgbmVpZ2hib3JzLCBlZy4gRXRFRUV0RXQuLi5cclxuXHRcdFx0XHRcdFx0XHQvLyBiaWRpX3FxKCkgbm90IG5lZWRlZCBzaW5jZSBlbW9qaSBpcyBMVFIgYW5kIGNwcyBpcyBhIENNXHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgZXJyb3JfcGxhY2VtZW50KGBlbW9qaSArIGNvbWJpbmluZyBtYXJrOiBcIiR7c3RyX2Zyb21fY3BzKHRva2Vuc1tpLTFdKX0gKyAke3NhZmVfc3RyX2Zyb21fY3BzKFtjcHNbMF1dKX1cImApOyBcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2hlY2tfZmVuY2VkKG5vcm0pO1xyXG5cdFx0XHRcdFx0bGV0IHVuaXF1ZSA9IEFycmF5X2Zyb20obmV3IFNldChjaGFycykpO1xyXG5cdFx0XHRcdFx0bGV0IFtnXSA9IGRldGVybWluZV9ncm91cCh1bmlxdWUpOyAvLyB0YWtlIHRoZSBmaXJzdCBtYXRjaFxyXG5cdFx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJNYXRjaGluZyBHcm91cHMgaGF2ZSBTYW1lIENNIFN0eWxlXCJcclxuXHRcdFx0XHRcdC8vIGFsdGVybmF0aXZlOiBjb3VsZCBmb3JtIGEgaHlicmlkIHR5cGU6IExhdGluL0phcGFuZXNlLy4uLlx0XHJcblx0XHRcdFx0XHRjaGVja19ncm91cChnLCBjaGFycyk7IC8vIG5lZWQgdGV4dCBpbiBvcmRlclxyXG5cdFx0XHRcdFx0Y2hlY2tfd2hvbGUoZywgdW5pcXVlKTsgLy8gb25seSBuZWVkIHVuaXF1ZSB0ZXh0IChvcmRlciB3b3VsZCBiZSByZXF1aXJlZCBmb3IgbXVsdGlwbGUtY2hhciBjb25mdXNhYmxlcylcclxuXHRcdFx0XHRcdHR5cGUgPSBnLk47XHJcblx0XHRcdFx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgZXhwb3NpbmcgcmVzdHJpY3RlZCBmbGFnXHJcblx0XHRcdFx0XHQvLyBpdCdzIHNpbXBsZXIgdG8ganVzdCBjaGVjayBmb3IgJ1Jlc3RyaWN0ZWQnXHJcblx0XHRcdFx0XHQvLyBvciBldmVuIGJldHRlcjogdHlwZS5lbmRzV2l0aCgnXScpXHJcblx0XHRcdFx0XHQvL2lmIChnLlIpIGluZm8ucmVzdHJpY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGluZm8udHlwZSA9IHR5cGU7XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0aW5mby5lcnJvciA9IGVycjsgLy8gdXNlIGZ1bGwgZXJyb3Igb2JqZWN0XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW5mbztcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tfd2hvbGUoZ3JvdXAsIHVuaXF1ZSkge1xyXG5cdGxldCBtYWtlcjtcclxuXHRsZXQgc2hhcmVkID0gW107XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHRsZXQgd2hvbGUgPSBXSE9MRV9NQVAuZ2V0KGNwKTtcclxuXHRcdGlmICh3aG9sZSA9PT0gVU5JUVVFX1BIKSByZXR1cm47IC8vIHVuaXF1ZSwgbm9uLWNvbmZ1c2FibGVcclxuXHRcdGlmICh3aG9sZSkge1xyXG5cdFx0XHRsZXQgc2V0ID0gd2hvbGUuTS5nZXQoY3ApOyAvLyBncm91cHMgd2hpY2ggaGF2ZSBhIGNoYXJhY3RlciB0aGF0IGxvb2stbGlrZSB0aGlzIGNoYXJhY3RlclxyXG5cdFx0XHRtYWtlciA9IG1ha2VyID8gbWFrZXIuZmlsdGVyKGcgPT4gc2V0LmhhcyhnKSkgOiBBcnJheV9mcm9tKHNldCk7XHJcblx0XHRcdGlmICghbWFrZXIubGVuZ3RoKSByZXR1cm47IC8vIGNvbmZ1c2FibGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzaGFyZWQucHVzaChjcCk7IFxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobWFrZXIpIHtcclxuXHRcdC8vIHdlIGhhdmUgMSsgY29uZnVzYWJsZVxyXG5cdFx0Ly8gY2hlY2sgaWYgYW55IG9mIHRoZSByZW1haW5pbmcgZ3JvdXBzXHJcblx0XHQvLyBjb250YWluIHRoZSBzaGFyZWQgY2hhcmFjdGVycyB0b29cclxuXHRcdGZvciAobGV0IGcgb2YgbWFrZXIpIHtcclxuXHRcdFx0aWYgKHNoYXJlZC5ldmVyeShjcCA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgd2hvbGUtc2NyaXB0IGNvbmZ1c2FibGU6ICR7Z3JvdXAuTn0vJHtnLk59YCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IHVuaXF1ZS5zaXplID4gMFxyXG4vLyByZXR1cm5zIGxpc3Qgb2YgbWF0Y2hpbmcgZ3JvdXBzXHJcbmZ1bmN0aW9uIGRldGVybWluZV9ncm91cCh1bmlxdWUpIHtcclxuXHRsZXQgZ3JvdXBzID0gR1JPVVBTO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0Ly8gbm90ZTogd2UgbmVlZCB0byBkb2RnZSBDTSB0aGF0IGFyZSB3aGl0ZWxpc3RlZFxyXG5cdFx0Ly8gYnV0IHRoYXQgY29kZSBpc24ndCBjdXJyZW50bHkgbmVjZXNzYXJ5XHJcblx0XHRsZXQgZ3MgPSBncm91cHMuZmlsdGVyKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSk7XHJcblx0XHRpZiAoIWdzLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAoIUdST1VQUy5zb21lKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHsgXHJcblx0XHRcdFx0Ly8gdGhlIGNoYXJhY3RlciB3YXMgY29tcG9zZWQgb2YgdmFsaWQgcGFydHNcclxuXHRcdFx0XHQvLyBidXQgaXQncyBORkMgZm9ybSBpcyBpbnZhbGlkXHJcblx0XHRcdFx0Ly8gMjAyMzA3MTY6IGNoYW5nZSB0byBtb3JlIGV4YWN0IHN0YXRlbWVudCwgc2VlOiBFTlNOb3JtYWxpemUue2NzLGphdmF9XHJcblx0XHRcdFx0Ly8gbm90ZTogdGhpcyBkb2Vzbid0IGhhdmUgdG8gYmUgYSBjb21wb3NpdGlvblxyXG5cdFx0XHRcdC8vIDIwMjMwNzIwOiBjaGFuZ2UgdG8gZnVsbCBjaGVja1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApOyAvLyB0aGlzIHNob3VsZCBiZSByYXJlXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gdGhlcmUgaXMgbm8gZ3JvdXAgdGhhdCBjb250YWlucyBhbGwgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdFx0XHRcdC8vIHRocm93IHVzaW5nIHRoZSBoaWdoZXN0IHByaW9yaXR5IGdyb3VwIHRoYXQgbWF0Y2hlZFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jbWl4ZWRfc2NyaXB0X2NvbmZ1c2FibGVzXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGdyb3Vwc1swXSwgY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRncm91cHMgPSBncztcclxuXHRcdGlmIChncy5sZW5ndGggPT0gMSkgYnJlYWs7IC8vIHRoZXJlIGlzIG9ubHkgb25lIGdyb3VwIGxlZnRcclxuXHR9XHJcblx0Ly8gdGhlcmUgYXJlIGF0IGxlYXN0IDEgZ3JvdXAocykgd2l0aCBhbGwgb2YgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdHJldHVybiBncm91cHM7XHJcbn1cclxuXHJcbi8vIHRocm93IG9uIGZpcnN0IGVycm9yXHJcbmZ1bmN0aW9uIGZsYXR0ZW4oc3BsaXQpIHtcclxuXHRyZXR1cm4gc3BsaXQubWFwKCh7aW5wdXQsIGVycm9yLCBvdXRwdXR9KSA9PiB7XHJcblx0XHRpZiAoZXJyb3IpIHtcclxuXHRcdFx0Ly8gZG9uJ3QgcHJpbnQgbGFiZWwgYWdhaW4gaWYganVzdCBhIHNpbmdsZSBsYWJlbFxyXG5cdFx0XHRsZXQgbXNnID0gZXJyb3IubWVzc2FnZTtcclxuXHRcdFx0Ly8gYmlkaV9xcSgpIG9ubHkgbmVjZXNzYXJ5IGlmIG1zZyBpcyBkaWdpdHNcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHNwbGl0Lmxlbmd0aCA9PSAxID8gbXNnIDogYEludmFsaWQgbGFiZWwgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKGlucHV0LCA2MykpfTogJHttc2d9YCk7IFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cl9mcm9tX2NwcyhvdXRwdXQpO1xyXG5cdH0pLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVycm9yX2Rpc2FsbG93ZWQoY3ApIHtcclxuXHQvLyBUT0RPOiBhZGQgY3AgdG8gZXJyb3I/XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkX2NwKGNwKX1gKTsgXHJcbn1cclxuZnVuY3Rpb24gZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKSB7XHJcblx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0bGV0IGdnID0gR1JPVVBTLmZpbmQoZyA9PiBnLlAuaGFzKGNwKSk7IC8vIG9ubHkgY2hlY2sgcHJpbWFyeVxyXG5cdGlmIChnZykge1xyXG5cdFx0cXVvdGVkID0gYCR7Z2cuTn0gJHtxdW90ZWR9YDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBtaXh0dXJlOiAke2cuTn0gKyAke3F1b3RlZH1gKTtcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9wbGFjZW1lbnQod2hlcmUpIHtcclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIHBsYWNlbWVudDogJHt3aGVyZX1gKTtcclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogY3BzLmxlbmd0aCA+IDBcclxuLy8gYXNzdW1wdGlvbjogY3BzWzBdIGlzbid0IGEgQ01cclxuLy8gYXNzdW1wdGlvbjogdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpc24ndCBhbiBlbW9qaVxyXG5mdW5jdGlvbiBjaGVja19ncm91cChnLCBjcHMpIHtcclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdGlmICghZ3JvdXBfaGFzX2NwKGcsIGNwKSkge1xyXG5cdFx0XHQvLyBmb3Igd2hpdGVsaXN0ZWQgc2NyaXB0cywgdGhpcyB3aWxsIHRocm93IGlsbGVnYWwgbWl4dHVyZSBvbiBpbnZhbGlkIGNtLCBlZy4gXCJlezMwMH17MzAwfVwiXHJcblx0XHRcdC8vIGF0IHRoZSBtb21lbnQsIGl0J3MgdW5uZWNlc3NhcnkgdG8gaW50cm9kdWNlIGFuIGV4dHJhIGVycm9yIHR5cGVcclxuXHRcdFx0Ly8gdW50aWwgdGhlcmUgZXhpc3RzIGEgd2hpdGVsaXN0ZWQgbXVsdGktY2hhcmFjdGVyXHJcblx0XHRcdC8vICAgZWcuIGlmIChNIDwgMCAmJiBpc19jb21iaW5pbmdfbWFyayhjcCkpIHsgLi4uIH1cclxuXHRcdFx0Ly8gdGhlcmUgYXJlIDMgY2FzZXM6XHJcblx0XHRcdC8vICAgMS4gaWxsZWdhbCBjbSBmb3Igd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHQvLyAgIDIuIGlsbGVnYWwgY20gZm9yIHNhbWUgZ3JvdXAgPT4gY20gZXJyb3JcclxuXHRcdFx0Ly8gICAgICAgcmVxdWlyZXMgc2V0IG9mIHdoaXRlbGlzdCBjbSBwZXIgZ3JvdXA6IFxyXG5cdFx0XHQvLyAgICAgICAgZWcuIG5ldyBTZXQoWy4uLmcuUCwgLi4uZy5RXS5mbGF0TWFwKG5mYykuZmlsdGVyKGNwID0+IENNLmhhcyhjcCkpKVxyXG5cdFx0XHQvLyAgIDMuIHdyb25nIGdyb3VwID0+IG1peHR1cmUgZXJyb3JcclxuXHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGcsIGNwKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly9pZiAoTSA+PSAwKSB7IC8vIHdlIGhhdmUgYSBrbm93biBmaXhlZCBjbSBjb3VudFxyXG5cdGlmIChnLk0pIHsgLy8gd2UgbmVlZCB0byBjaGVjayBmb3IgTlNNXHJcblx0XHRsZXQgZGVjb21wb3NlZCA9IG5mZChjcHMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGUgPSBkZWNvbXBvc2VkLmxlbmd0aDsgaSA8IGU7IGkrKykgeyAvLyBzZWU6IGFzc3VtcHRpb25cclxuXHRcdFx0Ly8gMjAyMzAyMTA6IGJ1Z2ZpeDogdXNpbmcgY3BzIGluc3RlYWQgb2YgZGVjb21wb3NlZCBoL3QgQ2FyYm9uMjI1XHJcblx0XHRcdC8qXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogJHtnLk59ICR7YmlkaV9xcShzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdFx0Ki9cclxuXHRcdFx0Ly8gMjAyMzAyMTc6IHN3aXRjaCB0byBOU00gY291bnRpbmdcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNPcHRpb25hbF9EZXRlY3Rpb25cclxuXHRcdFx0aWYgKE5TTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdGZvciAobGV0IGNwOyBqIDwgZSAmJiBOU00uaGFzKGNwID0gZGVjb21wb3NlZFtqXSk7IGorKykge1xyXG5cdFx0XHRcdFx0Ly8gYS4gRm9yYmlkIHNlcXVlbmNlcyBvZiB0aGUgc2FtZSBub25zcGFjaW5nIG1hcmsuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBrID0gaTsgayA8IGo7IGsrKykgeyAvLyBPKG5eMikgYnV0IG4gPCAxMDBcclxuXHRcdFx0XHRcdFx0aWYgKGRlY29tcG9zZWRba10gPT0gY3ApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBub24tc3BhY2luZyBtYXJrczogJHtxdW90ZWRfY3AoY3ApfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHBhcnNlIHRvIGVuZCBzbyB3ZSBoYXZlIGZ1bGwgbnNtIGNvdW50XHJcblx0XHRcdFx0Ly8gYi4gRm9yYmlkIHNlcXVlbmNlcyBvZiBtb3JlIHRoYW4gNCBub25zcGFjaW5nIG1hcmtzIChnYz1NbiBvciBnYz1NZSkuXHJcblx0XHRcdFx0aWYgKGogLSBpID4gTlNNX01BWCkge1xyXG5cdFx0XHRcdFx0Ly8gbm90ZTogdGhpcyBzbGljZSBzdGFydHMgd2l0aCBhIGJhc2UgY2hhciBvciBzcGFjaW5nLW1hcmsgY21cclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZXhjZXNzaXZlIG5vbi1zcGFjaW5nIG1hcmtzOiAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtOU01fTUFYfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdC8qXHJcblx0bGV0IGNtX3doaXRlbGlzdCA9IE0gaW5zdGFuY2VvZiBNYXA7XHJcblx0Zm9yIChsZXQgaSA9IDAsIGUgPSBjcHMubGVuZ3RoOyBpIDwgZTsgKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaSsrXTtcclxuXHRcdGxldCBzZXFzID0gY21fd2hpdGVsaXN0ICYmIE0uZ2V0KGNwKTtcclxuXHRcdGlmIChzZXFzKSB7IFxyXG5cdFx0XHQvLyBsaXN0IG9mIGNvZGVwb2ludHMgdGhhdCBjYW4gZm9sbG93XHJcblx0XHRcdC8vIGlmIHRoaXMgZXhpc3RzLCB0aGlzIHdpbGwgYWx3YXlzIGJlIDErXHJcblx0XHRcdGxldCBqID0gaTtcclxuXHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhjcHNbal0pKSBqKys7XHJcblx0XHRcdGxldCBjbXMgPSBjcHMuc2xpY2UoaSwgaik7XHJcblx0XHRcdGxldCBtYXRjaCA9IHNlcXMuZmluZChzZXEgPT4gIWNvbXBhcmVfYXJyYXlzKHNlcSwgY21zKSk7XHJcblx0XHRcdGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjb21iaW5pbmcgbWFyayBzZXF1ZW5jZTogXCIke3NhZmVfc3RyX2Zyb21fY3BzKFtjcCwgLi4uY21zXSl9XCJgKTtcclxuXHRcdFx0aSA9IGo7XHJcblx0XHR9IGVsc2UgaWYgKCFWLmhhcyhjcCkpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRcdGxldCB1ID0gVU5JUVVFLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKHUgJiYgdSAhPT0gZykge1xyXG5cdFx0XHRcdFx0Ly8gaWYgYm90aCBzY3JpcHRzIGFyZSByZXN0cmljdGVkIHRoaXMgZXJyb3IgaXMgY29uZnVzaW5nXHJcblx0XHRcdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IGRpZmZlcmVudGlhdGUgUmVzdHJpY3RlZEEgZnJvbSBSZXN0cmljdGVkQiBcclxuXHRcdFx0XHRcdGlmICghdS5SKSBxdW90ZWQgPSBgJHtxdW90ZWR9IGlzICR7dS5OfWA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkICR7Zy5OfSBjaGFyYWN0ZXI6ICR7cXVvdGVkfWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkfSAoZXhwZWN0ZWQgJHtnLk59KWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgJHtnLk59IGRvZXMgbm90IGFsbG93OiAke3F1b3RlZH1gKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKCFjbV93aGl0ZWxpc3QpIHtcclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHdlIGtub3cgaXQgY2FuJ3QgYmUgY20gbGVhZGluZ1xyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6IFwiJHtzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKX1cIiAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdCovXHJcbn1cclxuXHJcbi8vIGdpdmVuIGEgbGlzdCBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzLCB3aGVyZSBlbW9qaSBhcmUgYSBmdWxseS1xdWFsaWZpZWQgKGFzIEFycmF5IHN1YmNsYXNzKVxyXG4vLyBlZy4gZXhwbG9kZV9jcChcImFiY/CfkqlkXCIpID0+IFtbNjEsIDYyLCA2M10sIEVtb2ppWzFGNEE5LCBGRTBGXSwgWzY0XV1cclxuLy8gMjAyMzA4MTg6IHJlbmFtZSBmb3IgJ3Byb2Nlc3MnIG5hbWUgY29sbGlzaW9uIGgvdCBKYXZhcm9tZVxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2lzc3Vlcy8yM1xyXG5mdW5jdGlvbiB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgY2hhcnMgPSBbXTtcclxuXHRpbnB1dCA9IGlucHV0LnNsaWNlKCkucmV2ZXJzZSgpOyAvLyBmbGlwIHNvIHdlIGNhbiBwb3BcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0KTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHRcdFx0XHRjaGFycyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldC5wdXNoKGVmKGVtb2ppKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKFZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRjaGFycy5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0Y2hhcnMucHVzaCguLi5jcHMpOyAvLyBsZXNzIHRoYW4gMTAgZWxlbWVudHNcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCFJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRcdC8vIDIwMjMwOTEyOiB1bmljb2RlIDE1LjEgY2hhbmdlZCB0aGUgb3JkZXIgb2YgcHJvY2Vzc2luZyBzdWNoIHRoYXRcclxuXHRcdFx0XHRcdC8vIGRpc2FsbG93ZWQgcGFydHMgYXJlIG9ubHkgcmVqZWN0ZWQgYWZ0ZXIgTkZDXHJcblx0XHRcdFx0XHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHRcdFx0XHRcdC8vIHRoaXMgZG9lc24ndCBpbXBhY3Qgbm9ybWFsaXphdGlvbiBhcyBvZiB0b2RheVxyXG5cdFx0XHRcdFx0Ly8gdGVjaG5pY2FsbHksIHRoaXMgZXJyb3IgY2FuIGJlIHJlbW92ZWQgYXMgdGhlIGdyb3VwIGxvZ2ljIHdpbGwgYXBwbHkgc2ltaWxhciBsb2dpY1xyXG5cdFx0XHRcdFx0Ly8gaG93ZXZlciB0aGUgZXJyb3IgdHlwZSBtaWdodCBiZSBsZXNzIGNsZWFyXHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0cmV0LnB1c2gobmYoY2hhcnMpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gRkUwRik7XHJcbn1cclxuXHJcbi8vIGdpdmVuIGFycmF5IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyB0aGUgbG9uZ2VzdCB2YWxpZCBlbW9qaSBzZXF1ZW5jZSAob3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoKVxyXG4vLyAqTVVUQVRFUyogdGhlIHN1cHBsaWVkIGFycmF5XHJcbi8vIGRpc2FsbG93cyBpbnRlcmxlYXZlZCBpZ25vcmVkIGNoYXJhY3RlcnNcclxuLy8gZmlsbHMgKG9wdGlvbmFsKSBlYXRlbiBhcnJheSB3aXRoIG1hdGNoZWQgY29kZXBvaW50c1xyXG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcclxuXHRsZXQgbm9kZSA9IEVNT0pJX1JPT1Q7XHJcblx0bGV0IGVtb2ppO1xyXG5cdGxldCBwb3MgPSBjcHMubGVuZ3RoO1xyXG5cdHdoaWxlIChwb3MpIHtcclxuXHRcdG5vZGUgPSBub2RlLmdldChjcHNbLS1wb3NdKTtcclxuXHRcdGlmICghbm9kZSkgYnJlYWs7XHJcblx0XHRsZXQge1Z9ID0gbm9kZTtcclxuXHRcdGlmIChWKSB7IC8vIHRoaXMgaXMgYSB2YWxpZCBlbW9qaSAoc28gZmFyKVxyXG5cdFx0XHRlbW9qaSA9IFY7XHJcblx0XHRcdGlmIChlYXRlbikgZWF0ZW4ucHVzaCguLi5jcHMuc2xpY2UocG9zKS5yZXZlcnNlKCkpOyAvLyAob3B0aW9uYWwpIGNvcHkgaW5wdXQsIHVzZWQgZm9yIGVuc190b2tlbml6ZSgpXHJcblx0XHRcdGNwcy5sZW5ndGggPSBwb3M7IC8vIHRydW5jYXRlXHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBlbW9qaTtcclxufVxyXG5cclxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vIHRva2VuaXplciBcclxuXHJcbmNvbnN0IFRZX1ZBTElEID0gJ3ZhbGlkJztcclxuY29uc3QgVFlfTUFQUEVEID0gJ21hcHBlZCc7XHJcbmNvbnN0IFRZX0lHTk9SRUQgPSAnaWdub3JlZCc7XHJcbmNvbnN0IFRZX0RJU0FMTE9XRUQgPSAnZGlzYWxsb3dlZCc7XHJcbmNvbnN0IFRZX0VNT0pJID0gJ2Vtb2ppJztcclxuY29uc3QgVFlfTkZDID0gJ25mYyc7XHJcbmNvbnN0IFRZX1NUT1AgPSAnc3RvcCc7XHJcblxyXG5mdW5jdGlvbiBlbnNfdG9rZW5pemUobmFtZSwge1xyXG5cdG5mID0gdHJ1ZSwgLy8gY29sbGFwc2UgdW5ub3JtYWxpemVkIHJ1bnMgaW50byBhIHNpbmdsZSB0b2tlblxyXG59ID0ge30pIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChuYW1lKS5yZXZlcnNlKCk7XHJcblx0bGV0IGVhdGVuID0gW107XHJcblx0bGV0IHRva2VucyA9IFtdO1xyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQsIGVhdGVuKTtcclxuXHRcdGlmIChlbW9qaSkge1xyXG5cdFx0XHR0b2tlbnMucHVzaCh7XHJcblx0XHRcdFx0dHlwZTogVFlfRU1PSkksXHJcblx0XHRcdFx0ZW1vamk6IGVtb2ppLnNsaWNlKCksIC8vIGNvcHkgZW1vamlcclxuXHRcdFx0XHRpbnB1dDogZWF0ZW4sXHJcblx0XHRcdFx0Y3BzOiBmaWx0ZXJfZmUwZihlbW9qaSlcclxuXHRcdFx0fSk7XHJcblx0XHRcdGVhdGVuID0gW107IC8vIHJlc2V0IGJ1ZmZlclxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNwID0gaW5wdXQucG9wKCk7XHJcblx0XHRcdGlmIChjcCA9PSBTVE9QKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1NUT1AsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9WQUxJRCwgY3BzOiBbY3BdfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0lHTk9SRUQsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNwcyA9IE1BUFBFRC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChjcHMpIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9NQVBQRUQsIGNwLCBjcHM6IGNwcy5zbGljZSgpfSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9ESVNBTExPV0VELCBjcH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobmYpIHtcclxuXHRcdGZvciAobGV0IGkgPSAwLCBzdGFydCA9IC0xOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCB0b2tlbiA9IHRva2Vuc1tpXTtcclxuXHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0b2tlbi50eXBlKSkge1xyXG5cdFx0XHRcdGlmIChyZXF1aXJlc19jaGVjayh0b2tlbi5jcHMpKSB7IC8vIG5vcm1hbGl6YXRpb24gbWlnaHQgYmUgbmVlZGVkXHJcblx0XHRcdFx0XHRsZXQgZW5kID0gaSArIDE7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBwb3MgPSBlbmQ7IHBvcyA8IHRva2Vucy5sZW5ndGg7IHBvcysrKSB7IC8vIGZpbmQgYWRqYWNlbnQgdGV4dFxyXG5cdFx0XHRcdFx0XHRsZXQge3R5cGUsIGNwc30gPSB0b2tlbnNbcG9zXTtcclxuXHRcdFx0XHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0eXBlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICghcmVxdWlyZXNfY2hlY2soY3BzKSkgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0ZW5kID0gcG9zICsgMTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlICE9PSBUWV9JR05PUkVEKSB7IC8vIHx8IHR5cGUgIT09IFRZX0RJU0FMTE9XRUQpIHsgXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChzdGFydCA8IDApIHN0YXJ0ID0gaTtcclxuXHRcdFx0XHRcdGxldCBzbGljZSA9IHRva2Vucy5zbGljZShzdGFydCwgZW5kKTtcclxuXHRcdFx0XHRcdGxldCBjcHMwID0gc2xpY2UuZmxhdE1hcCh4ID0+IGlzX3ZhbGlkX29yX21hcHBlZCh4LnR5cGUpID8geC5jcHMgOiBbXSk7IC8vIHN0cmlwIGp1bmsgdG9rZW5zXHJcblx0XHRcdFx0XHRsZXQgY3BzID0gbmZjKGNwczApO1xyXG5cdFx0XHRcdFx0aWYgKGNvbXBhcmVfYXJyYXlzKGNwcywgY3BzMCkpIHsgLy8gYnVuZGxlIGludG8gYW4gbmZjIHRva2VuXHJcblx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0LCB7XHJcblx0XHRcdFx0XHRcdFx0dHlwZTogVFlfTkZDLCBcclxuXHRcdFx0XHRcdFx0XHRpbnB1dDogY3BzMCwgLy8gdGhlcmUgYXJlIDMgc3RhdGVzOiB0b2tlbnMwID09KHByb2Nlc3MpPT4gaW5wdXQgPT0obmZjKT0+IHRva2Vucy9jcHNcclxuXHRcdFx0XHRcdFx0XHRjcHMsIFxyXG5cdFx0XHRcdFx0XHRcdHRva2VuczA6IGNvbGxhcHNlX3ZhbGlkX3Rva2VucyhzbGljZSksXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zOiBlbnNfdG9rZW5pemUoc3RyX2Zyb21fY3BzKGNwcyksIHtuZjogZmFsc2V9KVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0aSA9IHN0YXJ0O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHsgXHJcblx0XHRcdFx0XHRcdGkgPSBlbmQgLSAxOyAvLyBza2lwIHRvIGVuZCBvZiBzbGljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RhcnQgPSAtMTsgLy8gcmVzZXRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBpOyAvLyByZW1lbWJlciBsYXN0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gMjAyMjEwMjQ6IGlzIHRoaXMgY29ycmVjdD9cclxuXHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpIHtcclxuXHRyZXR1cm4gdHlwZSA9PSBUWV9WQUxJRCB8fCB0eXBlID09IFRZX01BUFBFRDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWlyZXNfY2hlY2soY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5zb21lKGNwID0+IE5GQ19DSEVDSy5oYXMoY3ApKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29sbGFwc2VfdmFsaWRfdG9rZW5zKHRva2Vucykge1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAodG9rZW5zW2ldLnR5cGUgPT0gVFlfVkFMSUQpIHtcclxuXHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0d2hpbGUgKGogPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tqXS50eXBlID09IFRZX1ZBTElEKSBqKys7XHJcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwgaiAtIGksIHt0eXBlOiBUWV9WQUxJRCwgY3BzOiB0b2tlbnMuc2xpY2UoaSwgaikuZmxhdE1hcCh4ID0+IHguY3BzKX0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdG9rZW5zO1xyXG59XG5cbmV4cG9ydCB7IGVuc19iZWF1dGlmeSwgZW5zX2Vtb2ppLCBlbnNfbm9ybWFsaXplLCBlbnNfbm9ybWFsaXplX2ZyYWdtZW50LCBlbnNfc3BsaXQsIGVuc190b2tlbml6ZSwgaXNfY29tYmluaW5nX21hcmssIG5mYywgbmZkLCBzYWZlX3N0cl9mcm9tX2Nwcywgc2hvdWxkX2VzY2FwZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@adraffy/ens-normalize/dist/index.mjs\n"));

/***/ }),

/***/ "../../node_modules/@noble/hashes/esm/pbkdf2.js":
/*!******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: function() { return /* binding */ pbkdf2; },\n/* harmony export */   pbkdf2Async: function() { return /* binding */ pbkdf2Async; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"../../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"../../node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(c);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(dkLen);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3Bia2RmMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwRTtBQUN6QztBQUNzQztBQUN2RTtBQUNBO0FBQ0EsSUFBSSxnREFBVTtBQUNkLGlCQUFpQixvREFBUyxHQUFHLDBCQUEwQjtBQUN2RCxZQUFZLHNCQUFzQjtBQUNsQyxJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQjtBQUNBO0FBQ0EscUJBQXFCLGtEQUFPO0FBQzVCLGlCQUFpQixrREFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQUk7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ087QUFDUCxZQUFZLDZCQUE2QjtBQUN6QyxjQUFjO0FBQ2Q7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksd0NBQXdDO0FBQ3BELGNBQWM7QUFDZDtBQUNBLGlCQUFpQixxREFBVTtBQUMzQjtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3Bia2RmMi5qcz8xYzEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgbnVtYmVyIGFzIGFzc2VydE51bWJlciB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcbmltcG9ydCB7IGNyZWF0ZVZpZXcsIHRvQnl0ZXMsIGNoZWNrT3B0cywgYXN5bmNMb29wIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gcGJrZGYySW5pdChoYXNoLCBfcGFzc3dvcmQsIF9zYWx0LCBfb3B0cykge1xuICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgY29uc3Qgb3B0cyA9IGNoZWNrT3B0cyh7IGRrTGVuOiAzMiwgYXN5bmNUaWNrOiAxMCB9LCBfb3B0cyk7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrIH0gPSBvcHRzO1xuICAgIGFzc2VydE51bWJlcihjKTtcbiAgICBhc3NlcnROdW1iZXIoZGtMZW4pO1xuICAgIGFzc2VydE51bWJlcihhc3luY1RpY2spO1xuICAgIGlmIChjIDwgMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQktERjI6IGl0ZXJhdGlvbnMgKGMpIHNob3VsZCBiZSA+PSAxJyk7XG4gICAgY29uc3QgcGFzc3dvcmQgPSB0b0J5dGVzKF9wYXNzd29yZCk7XG4gICAgY29uc3Qgc2FsdCA9IHRvQnl0ZXMoX3NhbHQpO1xuICAgIC8vIERLID0gUEJLREYyKFBSRiwgUGFzc3dvcmQsIFNhbHQsIGMsIGRrTGVuKTtcbiAgICBjb25zdCBESyA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcbiAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICBjb25zdCBQUkYgPSBobWFjLmNyZWF0ZShoYXNoLCBwYXNzd29yZCk7XG4gICAgY29uc3QgUFJGU2FsdCA9IFBSRi5fY2xvbmVJbnRvKCkudXBkYXRlKHNhbHQpO1xuICAgIHJldHVybiB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfTtcbn1cbmZ1bmN0aW9uIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KSB7XG4gICAgUFJGLmRlc3Ryb3koKTtcbiAgICBQUkZTYWx0LmRlc3Ryb3koKTtcbiAgICBpZiAocHJmVylcbiAgICAgICAgcHJmVy5kZXN0cm95KCk7XG4gICAgdS5maWxsKDApO1xuICAgIHJldHVybiBESztcbn1cbi8qKlxuICogUEJLREYyLUhNQUM6IFJGQyAyODk4IGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBwYXNzd29yZCBmcm9tIHdoaWNoIGEgZGVyaXZlZCBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBAcGFyYW0gc2FsdCAtIGNyeXB0b2dyYXBoaWMgc2FsdFxuICogQHBhcmFtIG9wdHMgLSB7YywgZGtMZW59IHdoZXJlIGMgaXMgd29yayBmYWN0b3IgYW5kIGRrTGVuIGlzIG91dHB1dCBtZXNzYWdlIHNpemVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMihoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBjOyB1aSsrKSB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYmtkZjJBc3luYyhoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgYXdhaXQgYXN5bmNMb29wKGMgLSAxLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXG4gICAgICAgICAgICBQUkYuX2Nsb25lSW50byhwcmZXKS51cGRhdGUodSkuZGlnZXN0SW50byh1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYmtkZjIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@noble/hashes/esm/pbkdf2.js\n"));

/***/ }),

/***/ "../../node_modules/@noble/hashes/esm/scrypt.js":
/*!******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/scrypt.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scrypt: function() { return /* binding */ scrypt; },\n/* harmony export */   scryptAsync: function() { return /* binding */ scryptAsync; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"../../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _sha256_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sha256.js */ \"../../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _pbkdf2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pbkdf2.js */ \"../../node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n\n// RFC 7914 Scrypt KDF\n// Left rotate for uint32\nconst rotl = (a, b) => (a << b) | (a >>> (32 - b));\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\n    // Based on https://cr.yp.to/salsa20.html\n    // Xor blocks\n    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n    // Save state to temporary variables (salsa)\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    // Main loop (salsa)\n    for (let i = 0; i < 8; i += 2) {\n        x04 ^= rotl(x00 + x12 | 0, 7);\n        x08 ^= rotl(x04 + x00 | 0, 9);\n        x12 ^= rotl(x08 + x04 | 0, 13);\n        x00 ^= rotl(x12 + x08 | 0, 18);\n        x09 ^= rotl(x05 + x01 | 0, 7);\n        x13 ^= rotl(x09 + x05 | 0, 9);\n        x01 ^= rotl(x13 + x09 | 0, 13);\n        x05 ^= rotl(x01 + x13 | 0, 18);\n        x14 ^= rotl(x10 + x06 | 0, 7);\n        x02 ^= rotl(x14 + x10 | 0, 9);\n        x06 ^= rotl(x02 + x14 | 0, 13);\n        x10 ^= rotl(x06 + x02 | 0, 18);\n        x03 ^= rotl(x15 + x11 | 0, 7);\n        x07 ^= rotl(x03 + x15 | 0, 9);\n        x11 ^= rotl(x07 + x03 | 0, 13);\n        x15 ^= rotl(x11 + x07 | 0, 18);\n        x01 ^= rotl(x00 + x03 | 0, 7);\n        x02 ^= rotl(x01 + x00 | 0, 9);\n        x03 ^= rotl(x02 + x01 | 0, 13);\n        x00 ^= rotl(x03 + x02 | 0, 18);\n        x06 ^= rotl(x05 + x04 | 0, 7);\n        x07 ^= rotl(x06 + x05 | 0, 9);\n        x04 ^= rotl(x07 + x06 | 0, 13);\n        x05 ^= rotl(x04 + x07 | 0, 18);\n        x11 ^= rotl(x10 + x09 | 0, 7);\n        x08 ^= rotl(x11 + x10 | 0, 9);\n        x09 ^= rotl(x08 + x11 | 0, 13);\n        x10 ^= rotl(x09 + x08 | 0, 18);\n        x12 ^= rotl(x15 + x14 | 0, 7);\n        x13 ^= rotl(x12 + x15 | 0, 9);\n        x14 ^= rotl(x13 + x12 | 0, 13);\n        x15 ^= rotl(x14 + x13 | 0, 18);\n    }\n    // Write output (salsa)\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\nfunction BlockMix(input, ii, out, oi, r) {\n    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n    let head = oi + 0;\n    let tail = oi + 16 * r;\n    for (let i = 0; i < 16; i++)\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\n        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n        if (i > 0)\n            tail += 16; // First iteration overwrites tmp value in tail\n        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n    }\n}\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password, salt, _opts) {\n    // Maxmem - 1GB+1KB by default\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10,\n        maxmem: 1024 ** 3 + 1024,\n    }, _opts);\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(N);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(r);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(p);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(dkLen);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(asyncTick);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(maxmem);\n    if (onProgress !== undefined && typeof onProgress !== 'function')\n        throw new Error('progressCb should be function');\n    const blockSize = 128 * r;\n    const blockSize32 = blockSize / 4;\n    if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\n        // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function\n        // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.\n        throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');\n    }\n    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\n        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');\n    }\n    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\n        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');\n    }\n    const memUsed = blockSize * (N + p);\n    if (memUsed > maxmem) {\n        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);\n    }\n    // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n    // Since it has only one iteration there is no reason to use async variant\n    const B = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_2__.pbkdf2)(_sha256_js__WEBPACK_IMPORTED_MODULE_3__.sha256, password, salt, { c: 1, dkLen: blockSize * p });\n    const B32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(B);\n    // Re-used between parallel iterations. Array(iterations) of B\n    const V = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(new Uint8Array(blockSize * N));\n    const tmp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(new Uint8Array(blockSize));\n    let blockMixCb = () => { };\n    if (onProgress) {\n        const totalBlockMix = 2 * N * p;\n        // Invoke callback if progress changes from 10.01 to 10.02\n        // Allows to draw smooth progress bar on up to 8K screen\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n        let blockMixCnt = 0;\n        blockMixCb = () => {\n            blockMixCnt++;\n            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\n                onProgress(blockMixCnt / totalBlockMix);\n        };\n    }\n    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\n}\nfunction scryptOutput(password, dkLen, B, V, tmp) {\n    const res = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_2__.pbkdf2)(_sha256_js__WEBPACK_IMPORTED_MODULE_3__.sha256, password, B, { c: 1, dkLen });\n    B.fill(0);\n    V.fill(0);\n    tmp.fill(0);\n    return res;\n}\n/**\n * Scrypt KDF from RFC 7914.\n * @param password - pass\n * @param salt - salt\n * @param opts - parameters\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\n * - `p` is parallelization factor (1 is common)\n * - `dkLen` is output key length in bytes e.g. 32.\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\n * - `onProgress` - callback function that would be executed for progress report\n * @returns Derived key\n */\nfunction scrypt(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        for (let i = 0, pos = 0; i < N - 1; i++) {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        }\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        for (let i = 0; i < N; i++) {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        }\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\n/**\n * Scrypt KDF from RFC 7914.\n */\nasync function scryptAsync(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        let pos = 0;\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.asyncLoop)(N - 1, asyncTick, () => {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        });\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.asyncLoop)(N, asyncTick, () => {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        });\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\n//# sourceMappingURL=scrypt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NjcnlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0Q7QUFDakI7QUFDQTtBQUNrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QiwwREFBMEQ7QUFDMUQsb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSx3QkFBd0I7QUFDeEIsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksZ0RBQWdEO0FBQzVELElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUyx3QkFBd0IsUUFBUTtBQUNsRztBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFNLENBQUMsOENBQU0sb0JBQW9CLDRCQUE0QjtBQUMzRSxnQkFBZ0IsOENBQUc7QUFDbkI7QUFDQSxjQUFjLDhDQUFHO0FBQ2pCLGdCQUFnQiw4Q0FBRztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFNLENBQUMsOENBQU0saUJBQWlCLGFBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksMERBQTBEO0FBQ3RFLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QyxnQ0FBZ0M7QUFDaEMsaUNBQWlDLFdBQVc7QUFDNUMsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLHNEQUFzRDtBQUN0RCw0QkFBNEIsaUJBQWlCO0FBQzdDLCtEQUErRDtBQUMvRCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxxRUFBcUU7QUFDakYscUJBQXFCLFFBQVE7QUFDN0I7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLGdDQUFnQztBQUNoQztBQUNBLGNBQWMsb0RBQVM7QUFDdkIsMERBQTBEO0FBQzFEO0FBQ0EsU0FBUztBQUNULHdEQUF3RDtBQUN4RDtBQUNBLGNBQWMsb0RBQVM7QUFDdkI7QUFDQSxzREFBc0Q7QUFDdEQsNEJBQTRCLGlCQUFpQjtBQUM3QywrREFBK0Q7QUFDL0QsMENBQTBDO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2NyeXB0LmpzP2JjYTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbnVtYmVyIGFzIGFzc2VydE51bWJlciB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICcuL3NoYTI1Ni5qcyc7XG5pbXBvcnQgeyBwYmtkZjIgfSBmcm9tICcuL3Bia2RmMi5qcyc7XG5pbXBvcnQgeyBhc3luY0xvb3AsIGNoZWNrT3B0cywgdTMyIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBSRkMgNzkxNCBTY3J5cHQgS0RGXG4vLyBMZWZ0IHJvdGF0ZSBmb3IgdWludDMyXG5jb25zdCByb3RsID0gKGEsIGIpID0+IChhIDw8IGIpIHwgKGEgPj4+ICgzMiAtIGIpKTtcbi8vIFRoZSBtYWluIFNjcnlwdCBsb29wOiB1c2VzIFNhbHNhIGV4dGVuc2l2ZWx5LlxuLy8gU2l4IHZlcnNpb25zIG9mIHRoZSBmdW5jdGlvbiB3ZXJlIHRyaWVkLCB0aGlzIGlzIHRoZSBmYXN0ZXN0IG9uZS5cbi8vIHByZXR0aWVyLWlnbm9yZVxuZnVuY3Rpb24gWG9yQW5kU2Fsc2EocHJldiwgcGksIGlucHV0LCBpaSwgb3V0LCBvaSkge1xuICAgIC8vIEJhc2VkIG9uIGh0dHBzOi8vY3IueXAudG8vc2Fsc2EyMC5odG1sXG4gICAgLy8gWG9yIGJsb2Nrc1xuICAgIGxldCB5MDAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTAyID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDMgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwNCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTA1ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDYgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTA4ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDkgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkxMCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTExID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MTIgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTE0ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MTUgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgLy8gU2F2ZSBzdGF0ZSB0byB0ZW1wb3JhcnkgdmFyaWFibGVzIChzYWxzYSlcbiAgICBsZXQgeDAwID0geTAwLCB4MDEgPSB5MDEsIHgwMiA9IHkwMiwgeDAzID0geTAzLCB4MDQgPSB5MDQsIHgwNSA9IHkwNSwgeDA2ID0geTA2LCB4MDcgPSB5MDcsIHgwOCA9IHkwOCwgeDA5ID0geTA5LCB4MTAgPSB5MTAsIHgxMSA9IHkxMSwgeDEyID0geTEyLCB4MTMgPSB5MTMsIHgxNCA9IHkxNCwgeDE1ID0geTE1O1xuICAgIC8vIE1haW4gbG9vcCAoc2Fsc2EpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDIpIHtcbiAgICAgICAgeDA0IF49IHJvdGwoeDAwICsgeDEyIHwgMCwgNyk7XG4gICAgICAgIHgwOCBePSByb3RsKHgwNCArIHgwMCB8IDAsIDkpO1xuICAgICAgICB4MTIgXj0gcm90bCh4MDggKyB4MDQgfCAwLCAxMyk7XG4gICAgICAgIHgwMCBePSByb3RsKHgxMiArIHgwOCB8IDAsIDE4KTtcbiAgICAgICAgeDA5IF49IHJvdGwoeDA1ICsgeDAxIHwgMCwgNyk7XG4gICAgICAgIHgxMyBePSByb3RsKHgwOSArIHgwNSB8IDAsIDkpO1xuICAgICAgICB4MDEgXj0gcm90bCh4MTMgKyB4MDkgfCAwLCAxMyk7XG4gICAgICAgIHgwNSBePSByb3RsKHgwMSArIHgxMyB8IDAsIDE4KTtcbiAgICAgICAgeDE0IF49IHJvdGwoeDEwICsgeDA2IHwgMCwgNyk7XG4gICAgICAgIHgwMiBePSByb3RsKHgxNCArIHgxMCB8IDAsIDkpO1xuICAgICAgICB4MDYgXj0gcm90bCh4MDIgKyB4MTQgfCAwLCAxMyk7XG4gICAgICAgIHgxMCBePSByb3RsKHgwNiArIHgwMiB8IDAsIDE4KTtcbiAgICAgICAgeDAzIF49IHJvdGwoeDE1ICsgeDExIHwgMCwgNyk7XG4gICAgICAgIHgwNyBePSByb3RsKHgwMyArIHgxNSB8IDAsIDkpO1xuICAgICAgICB4MTEgXj0gcm90bCh4MDcgKyB4MDMgfCAwLCAxMyk7XG4gICAgICAgIHgxNSBePSByb3RsKHgxMSArIHgwNyB8IDAsIDE4KTtcbiAgICAgICAgeDAxIF49IHJvdGwoeDAwICsgeDAzIHwgMCwgNyk7XG4gICAgICAgIHgwMiBePSByb3RsKHgwMSArIHgwMCB8IDAsIDkpO1xuICAgICAgICB4MDMgXj0gcm90bCh4MDIgKyB4MDEgfCAwLCAxMyk7XG4gICAgICAgIHgwMCBePSByb3RsKHgwMyArIHgwMiB8IDAsIDE4KTtcbiAgICAgICAgeDA2IF49IHJvdGwoeDA1ICsgeDA0IHwgMCwgNyk7XG4gICAgICAgIHgwNyBePSByb3RsKHgwNiArIHgwNSB8IDAsIDkpO1xuICAgICAgICB4MDQgXj0gcm90bCh4MDcgKyB4MDYgfCAwLCAxMyk7XG4gICAgICAgIHgwNSBePSByb3RsKHgwNCArIHgwNyB8IDAsIDE4KTtcbiAgICAgICAgeDExIF49IHJvdGwoeDEwICsgeDA5IHwgMCwgNyk7XG4gICAgICAgIHgwOCBePSByb3RsKHgxMSArIHgxMCB8IDAsIDkpO1xuICAgICAgICB4MDkgXj0gcm90bCh4MDggKyB4MTEgfCAwLCAxMyk7XG4gICAgICAgIHgxMCBePSByb3RsKHgwOSArIHgwOCB8IDAsIDE4KTtcbiAgICAgICAgeDEyIF49IHJvdGwoeDE1ICsgeDE0IHwgMCwgNyk7XG4gICAgICAgIHgxMyBePSByb3RsKHgxMiArIHgxNSB8IDAsIDkpO1xuICAgICAgICB4MTQgXj0gcm90bCh4MTMgKyB4MTIgfCAwLCAxMyk7XG4gICAgICAgIHgxNSBePSByb3RsKHgxNCArIHgxMyB8IDAsIDE4KTtcbiAgICB9XG4gICAgLy8gV3JpdGUgb3V0cHV0IChzYWxzYSlcbiAgICBvdXRbb2krK10gPSAoeTAwICsgeDAwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMSArIHgwMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDIgKyB4MDIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAzICsgeDAzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNCArIHgwNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDUgKyB4MDUpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA2ICsgeDA2KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNyArIHgwNykgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDggKyB4MDgpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA5ICsgeDA5KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMCArIHgxMCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTEgKyB4MTEpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEyICsgeDEyKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMyArIHgxMykgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTQgKyB4MTQpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTE1ICsgeDE1KSB8IDA7XG59XG5mdW5jdGlvbiBCbG9ja01peChpbnB1dCwgaWksIG91dCwgb2ksIHIpIHtcbiAgICAvLyBUaGUgYmxvY2sgQiBpcyByIDEyOC1ieXRlIGNodW5rcyAod2hpY2ggaXMgZXF1aXZhbGVudCBvZiAyciA2NC1ieXRlIGNodW5rcylcbiAgICBsZXQgaGVhZCA9IG9pICsgMDtcbiAgICBsZXQgdGFpbCA9IG9pICsgMTYgKiByO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICAgICAgb3V0W3RhaWwgKyBpXSA9IGlucHV0W2lpICsgKDIgKiByIC0gMSkgKiAxNiArIGldOyAvLyBYIOKGkCBCWzJy4oiSMV1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHI7IGkrKywgaGVhZCArPSAxNiwgaWkgKz0gMTYpIHtcbiAgICAgICAgLy8gV2Ugd3JpdGUgb2RkICYgZXZlbiBZaSBhdCBzYW1lIHRpbWUuIEV2ZW46IDBiWFhYWFgwIE9kZDogIDBiWFhYWFgxXG4gICAgICAgIFhvckFuZFNhbHNhKG91dCwgdGFpbCwgaW5wdXQsIGlpLCBvdXQsIGhlYWQpOyAvLyBoZWFkW2ldID0gU2Fsc2EoYmxvY2tJblsyKmldIF4gdGFpbFtpLTFdKVxuICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICB0YWlsICs9IDE2OyAvLyBGaXJzdCBpdGVyYXRpb24gb3ZlcndyaXRlcyB0bXAgdmFsdWUgaW4gdGFpbFxuICAgICAgICBYb3JBbmRTYWxzYShvdXQsIGhlYWQsIGlucHV0LCAoaWkgKz0gMTYpLCBvdXQsIHRhaWwpOyAvLyB0YWlsW2ldID0gU2Fsc2EoYmxvY2tJblsyKmkrMV0gXiBoZWFkW2ldKVxuICAgIH1cbn1cbi8vIENvbW1vbiBwcm9sb2d1ZSBhbmQgZXBpbG9ndWUgZm9yIHN5bmMvYXN5bmMgZnVuY3Rpb25zXG5mdW5jdGlvbiBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBfb3B0cykge1xuICAgIC8vIE1heG1lbSAtIDFHQisxS0IgYnkgZGVmYXVsdFxuICAgIGNvbnN0IG9wdHMgPSBjaGVja09wdHMoe1xuICAgICAgICBka0xlbjogMzIsXG4gICAgICAgIGFzeW5jVGljazogMTAsXG4gICAgICAgIG1heG1lbTogMTAyNCAqKiAzICsgMTAyNCxcbiAgICB9LCBfb3B0cyk7XG4gICAgY29uc3QgeyBOLCByLCBwLCBka0xlbiwgYXN5bmNUaWNrLCBtYXhtZW0sIG9uUHJvZ3Jlc3MgfSA9IG9wdHM7XG4gICAgYXNzZXJ0TnVtYmVyKE4pO1xuICAgIGFzc2VydE51bWJlcihyKTtcbiAgICBhc3NlcnROdW1iZXIocCk7XG4gICAgYXNzZXJ0TnVtYmVyKGRrTGVuKTtcbiAgICBhc3NlcnROdW1iZXIoYXN5bmNUaWNrKTtcbiAgICBhc3NlcnROdW1iZXIobWF4bWVtKTtcbiAgICBpZiAob25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvblByb2dyZXNzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2dyZXNzQ2Igc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgY29uc3QgYmxvY2tTaXplID0gMTI4ICogcjtcbiAgICBjb25zdCBibG9ja1NpemUzMiA9IGJsb2NrU2l6ZSAvIDQ7XG4gICAgaWYgKE4gPD0gMSB8fCAoTiAmIChOIC0gMSkpICE9PSAwIHx8IE4gPj0gMiAqKiAoYmxvY2tTaXplIC8gOCkgfHwgTiA+IDIgKiogMzIpIHtcbiAgICAgICAgLy8gTk9URTogd2UgbGltaXQgTiB0byBiZSBsZXNzIHRoYW4gMioqMzIgYmVjYXVzZSBvZiAzMiBiaXQgdmFyaWFudCBvZiBJbnRlZ3JpZnkgZnVuY3Rpb25cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gSlMgZW5naW5lcyB0aGF0IGFsbG93cyBhbG9jYXRlIG1vcmUgdGhhbiA0R0IgcGVyIHNpbmdsZSBVaW50OEFycmF5IGZvciBub3csIGJ1dCBjYW4gY2hhbmdlIGluIGZ1dHVyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY3J5cHQ6IE4gbXVzdCBiZSBsYXJnZXIgdGhhbiAxLCBhIHBvd2VyIG9mIDIsIGxlc3MgdGhhbiAyXigxMjggKiByIC8gOCkgYW5kIGxlc3MgdGhhbiAyXjMyJyk7XG4gICAgfVxuICAgIGlmIChwIDwgMCB8fCBwID4gKCgyICoqIDMyIC0gMSkgKiAzMikgLyBibG9ja1NpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY3J5cHQ6IHAgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICgoMl4zMiAtIDEpICogMzIpIC8gKDEyOCAqIHIpJyk7XG4gICAgfVxuICAgIGlmIChka0xlbiA8IDAgfHwgZGtMZW4gPiAoMiAqKiAzMiAtIDEpICogMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY3J5cHQ6IGRrTGVuIHNob3VsZCBiZSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiBvciBlcXVhbCB0byAoMl4zMiAtIDEpICogMzInKTtcbiAgICB9XG4gICAgY29uc3QgbWVtVXNlZCA9IGJsb2NrU2l6ZSAqIChOICsgcCk7XG4gICAgaWYgKG1lbVVzZWQgPiBtYXhtZW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY3J5cHQ6IHBhcmFtZXRlcnMgdG9vIGxhcmdlLCAke21lbVVzZWR9ICgxMjggKiByICogKE4gKyBwKSkgPiAke21heG1lbX0gKG1heG1lbSlgKTtcbiAgICB9XG4gICAgLy8gW0IwLi4uQnDiiJIxXSDihpAgUEJLREYySE1BQy1TSEEyNTYoUGFzc3BocmFzZSwgU2FsdCwgMSwgYmxvY2tTaXplKlBhcmFsbGVsaXphdGlvbkZhY3RvcilcbiAgICAvLyBTaW5jZSBpdCBoYXMgb25seSBvbmUgaXRlcmF0aW9uIHRoZXJlIGlzIG5vIHJlYXNvbiB0byB1c2UgYXN5bmMgdmFyaWFudFxuICAgIGNvbnN0IEIgPSBwYmtkZjIoc2hhMjU2LCBwYXNzd29yZCwgc2FsdCwgeyBjOiAxLCBka0xlbjogYmxvY2tTaXplICogcCB9KTtcbiAgICBjb25zdCBCMzIgPSB1MzIoQik7XG4gICAgLy8gUmUtdXNlZCBiZXR3ZWVuIHBhcmFsbGVsIGl0ZXJhdGlvbnMuIEFycmF5KGl0ZXJhdGlvbnMpIG9mIEJcbiAgICBjb25zdCBWID0gdTMyKG5ldyBVaW50OEFycmF5KGJsb2NrU2l6ZSAqIE4pKTtcbiAgICBjb25zdCB0bXAgPSB1MzIobmV3IFVpbnQ4QXJyYXkoYmxvY2tTaXplKSk7XG4gICAgbGV0IGJsb2NrTWl4Q2IgPSAoKSA9PiB7IH07XG4gICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgY29uc3QgdG90YWxCbG9ja01peCA9IDIgKiBOICogcDtcbiAgICAgICAgLy8gSW52b2tlIGNhbGxiYWNrIGlmIHByb2dyZXNzIGNoYW5nZXMgZnJvbSAxMC4wMSB0byAxMC4wMlxuICAgICAgICAvLyBBbGxvd3MgdG8gZHJhdyBzbW9vdGggcHJvZ3Jlc3MgYmFyIG9uIHVwIHRvIDhLIHNjcmVlblxuICAgICAgICBjb25zdCBjYWxsYmFja1BlciA9IE1hdGgubWF4KE1hdGguZmxvb3IodG90YWxCbG9ja01peCAvIDEwMDAwKSwgMSk7XG4gICAgICAgIGxldCBibG9ja01peENudCA9IDA7XG4gICAgICAgIGJsb2NrTWl4Q2IgPSAoKSA9PiB7XG4gICAgICAgICAgICBibG9ja01peENudCsrO1xuICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgKCEoYmxvY2tNaXhDbnQgJSBjYWxsYmFja1BlcikgfHwgYmxvY2tNaXhDbnQgPT09IHRvdGFsQmxvY2tNaXgpKVxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoYmxvY2tNaXhDbnQgLyB0b3RhbEJsb2NrTWl4KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgTiwgciwgcCwgZGtMZW4sIGJsb2NrU2l6ZTMyLCBWLCBCMzIsIEIsIHRtcCwgYmxvY2tNaXhDYiwgYXN5bmNUaWNrIH07XG59XG5mdW5jdGlvbiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApIHtcbiAgICBjb25zdCByZXMgPSBwYmtkZjIoc2hhMjU2LCBwYXNzd29yZCwgQiwgeyBjOiAxLCBka0xlbiB9KTtcbiAgICBCLmZpbGwoMCk7XG4gICAgVi5maWxsKDApO1xuICAgIHRtcC5maWxsKDApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3NcbiAqIEBwYXJhbSBzYWx0IC0gc2FsdFxuICogQHBhcmFtIG9wdHMgLSBwYXJhbWV0ZXJzXG4gKiAtIGBOYCBpcyBjcHUvbWVtIHdvcmsgZmFjdG9yIChwb3dlciBvZiAyIGUuZy4gMioqMTgpXG4gKiAtIGByYCBpcyBibG9jayBzaXplICg4IGlzIGNvbW1vbiksIGZpbmUtdHVuZXMgc2VxdWVudGlhbCBtZW1vcnkgcmVhZCBzaXplIGFuZCBwZXJmb3JtYW5jZVxuICogLSBgcGAgaXMgcGFyYWxsZWxpemF0aW9uIGZhY3RvciAoMSBpcyBjb21tb24pXG4gKiAtIGBka0xlbmAgaXMgb3V0cHV0IGtleSBsZW5ndGggaW4gYnl0ZXMgZS5nLiAzMi5cbiAqIC0gYGFzeW5jVGlja2AgLSAoZGVmYXVsdDogMTApIG1heCB0aW1lIGluIG1zIGZvciB3aGljaCBhc3luYyBmdW5jdGlvbiBjYW4gYmxvY2sgZXhlY3V0aW9uXG4gKiAtIGBtYXhtZW1gIC0gKGRlZmF1bHQ6IGAxMDI0ICoqIDMgKyAxMDI0YCBha2EgMUdCKzFLQikuIEEgbGltaXQgdGhhdCB0aGUgYXBwIGNvdWxkIHVzZSBmb3Igc2NyeXB0XG4gKiAtIGBvblByb2dyZXNzYCAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgZXhlY3V0ZWQgZm9yIHByb2dyZXNzIHJlcG9ydFxuICogQHJldHVybnMgRGVyaXZlZCBrZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcnlwdChwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgTiwgciwgcCwgZGtMZW4sIGJsb2NrU2l6ZTMyLCBWLCBCMzIsIEIsIHRtcCwgYmxvY2tNaXhDYiB9ID0gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcbiAgICAgICAgY29uc3QgUGkgPSBibG9ja1NpemUzMiAqIHBpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTMyOyBpKyspXG4gICAgICAgICAgICBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgTiAtIDE7IGkrKykge1xuICAgICAgICAgICAgQmxvY2tNaXgoViwgcG9zLCBWLCAocG9zICs9IGJsb2NrU2l6ZTMyKSwgcik7IC8vIFZbaV0gPSBCbG9ja01peChWW2ktMV0pO1xuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICB9XG4gICAgICAgIEJsb2NrTWl4KFYsIChOIC0gMSkgKiBibG9ja1NpemUzMiwgQjMyLCBQaSwgcik7IC8vIFByb2Nlc3MgbGFzdCBlbGVtZW50XG4gICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHUzMiBvZiB0aGUgbGFzdCA2NC1ieXRlIGJsb2NrICh1MzIgaXMgTEUpXG4gICAgICAgICAgICBjb25zdCBqID0gQjMyW1BpICsgYmxvY2tTaXplMzIgLSAxNl0gJSBOOyAvLyBqID0gSW50ZWdyaWZ5KFgpICUgaXRlcmF0aW9uc1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBibG9ja1NpemUzMjsgaysrKVxuICAgICAgICAgICAgICAgIHRtcFtrXSA9IEIzMltQaSArIGtdIF4gVltqICogYmxvY2tTaXplMzIgKyBrXTsgLy8gdG1wID0gQiBeIFZbal1cbiAgICAgICAgICAgIEJsb2NrTWl4KHRtcCwgMCwgQjMyLCBQaSwgcik7IC8vIEIgPSBCbG9ja01peChCIF4gVltqXSlcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NyeXB0T3V0cHV0KHBhc3N3b3JkLCBka0xlbiwgQiwgViwgdG1wKTtcbn1cbi8qKlxuICogU2NyeXB0IEtERiBmcm9tIFJGQyA3OTE0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2NyeXB0QXN5bmMocGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9ID0gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcbiAgICAgICAgY29uc3QgUGkgPSBibG9ja1NpemUzMiAqIHBpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTMyOyBpKyspXG4gICAgICAgICAgICBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBhd2FpdCBhc3luY0xvb3AoTiAtIDEsIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgQmxvY2tNaXgoViwgcG9zLCBWLCAocG9zICs9IGJsb2NrU2l6ZTMyKSwgcik7IC8vIFZbaV0gPSBCbG9ja01peChWW2ktMV0pO1xuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICB9KTtcbiAgICAgICAgQmxvY2tNaXgoViwgKE4gLSAxKSAqIGJsb2NrU2l6ZTMyLCBCMzIsIFBpLCByKTsgLy8gUHJvY2VzcyBsYXN0IGVsZW1lbnRcbiAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICBhd2FpdCBhc3luY0xvb3AoTiwgYXN5bmNUaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBGaXJzdCB1MzIgb2YgdGhlIGxhc3QgNjQtYnl0ZSBibG9jayAodTMyIGlzIExFKVxuICAgICAgICAgICAgY29uc3QgaiA9IEIzMltQaSArIGJsb2NrU2l6ZTMyIC0gMTZdICUgTjsgLy8gaiA9IEludGVncmlmeShYKSAlIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYmxvY2tTaXplMzI7IGsrKylcbiAgICAgICAgICAgICAgICB0bXBba10gPSBCMzJbUGkgKyBrXSBeIFZbaiAqIGJsb2NrU2l6ZTMyICsga107IC8vIHRtcCA9IEIgXiBWW2pdXG4gICAgICAgICAgICBCbG9ja01peCh0bXAsIDAsIEIzMiwgUGksIHIpOyAvLyBCID0gQmxvY2tNaXgoQiBeIFZbal0pXG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2NyeXB0T3V0cHV0KHBhc3N3b3JkLCBka0xlbiwgQiwgViwgdG1wKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcnlwdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@noble/hashes/esm/scrypt.js\n"));

/***/ }),

/***/ "../../node_modules/@noble/hashes/esm/sha512.js":
/*!******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/sha512.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: function() { return /* binding */ SHA512; },\n/* harmony export */   sha384: function() { return /* binding */ sha384; },\n/* harmony export */   sha512: function() { return /* binding */ sha512; },\n/* harmony export */   sha512_224: function() { return /* binding */ sha512_224; },\n/* harmony export */   sha512_256: function() { return /* binding */ sha512_256; }\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"../../node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"../../node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTUxMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFrQztBQUNOO0FBQ2lCO0FBQzdDO0FBQ0E7QUFDQSxzREFBc0QscURBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDBDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlFQUFpRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVLGtCQUFrQixzREFBVSxrQkFBa0IscURBQVM7QUFDekYsd0JBQXdCLHNEQUFVLGtCQUFrQixzREFBVSxrQkFBa0IscURBQVM7QUFDekY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVLGlCQUFpQixzREFBVSxpQkFBaUIscURBQVM7QUFDdkYsd0JBQXdCLHNEQUFVLGlCQUFpQixzREFBVSxpQkFBaUIscURBQVM7QUFDdkY7QUFDQSx5QkFBeUIscURBQVM7QUFDbEMseUJBQXlCLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWlFO0FBQy9FO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBUztBQUNsQyx3QkFBd0IscURBQVM7QUFDakM7QUFDQTtBQUNBLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEYsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlLEVBQUUsbURBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFTO0FBQ2pDLGlCQUFpQixxREFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLG1DQUFtQywwREFBZTtBQUNsRCxtQ0FBbUMsMERBQWU7QUFDbEQsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzPzM4NGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHU2NCBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBSb3VuZCBjb250YW50cyAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFtTSEE1MTJfS2gsIFNIQTUxMl9LbF0gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmV4cG9ydCBjbGFzcyBTSEE1MTIgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMTI4LCA2NCwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZSB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIEFsc28gbG9va3MgY2xlYW5lciBhbmQgZWFzaWVyIHRvIHZlcmlmeSB3aXRoIHNwZWMuXG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg2YTA5ZTY2NyB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGYzYmNjOTA4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4YmI2N2FlODUgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4NGNhYTczYiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDNjNmVmMzcyIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4ZmU5NGY4MmIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHhhNTRmZjUzYSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDVmMWQzNmYxIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NTEwZTUyN2YgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhZGU2ODJkMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDliMDU2ODhjIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MmIzZTZjMWYgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgxZjgzZDlhYiB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweGZiNDFiZDZiIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NWJlMGNkMTkgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHgxMzdlMjE3OSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEE1MTJfV19ILmZpbGwoMCk7XG4gICAgICAgIFNIQTUxMl9XX0wuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDhjM2QzN2M4IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4MTk1NDRkYTIgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg3M2UxOTk2NiB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg5ZGNkNGQ2IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MWRmYWI3YWUgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMmZmOWM4MiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDY3OWRkNTE0IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTgyZjlmY2YgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHgwZjZkMmI2OSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweDdiZDQ0ZGE4IHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4NzdlMzZmNzMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgwNGM0ODk0MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDNmOWQ4NWE4IHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NmExZDM2YzggfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgxMTEyZTZhZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDkxZDY5MmExIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4MjIzMTIxOTQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmYzJiZjcyYyB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDlmNTU1ZmEzIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4Yzg0YzY0YzIgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgyMzkzYjg2YiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDZmNTNiMTUxIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4OTYzODc3MTkgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1OTQwZWFiZCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDk2MjgzZWUyIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YTg4ZWZmZTMgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHhiZTVlMWUyNSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDUzODYzOTkyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MmIwMTk5ZmMgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHgyYzg1YjhhYSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDBlYjcyZGRjIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4ODFjNTJjYTIgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDMyO1xuICAgIH1cbn1cbmNsYXNzIFNIQTM4NCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweGNiYmI5ZDVkIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg2MjlhMjkyYSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4OTE1OTAxNWEgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDE1MmZlY2Q4IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg2NzMzMjY2NyB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OGViNDRhODcgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweGRiMGMyZTBkIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg0N2I1NDgxZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSA0ODtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2hhNTEyID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyKCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTM4NCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTUxMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "../common/node_modules/aes-js/lib.esm/aes.js":
/*!****************************************************!*\
  !*** ../common/node_modules/aes-js/lib.esm/aes.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AES: function() { return /* binding */ AES; }\n/* harmony export */ });\n/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _AES_key, _AES_Kd, _AES_Ke;\n// Number of rounds by keysize\nconst numberOfRounds = { 16: 10, 24: 12, 32: 14 };\n// Round constant words\nconst rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];\n// S-box and Inverse S-box (S is for Substitution)\nconst S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];\nconst Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];\n// Transformations for encryption\nconst T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];\nconst T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];\nconst T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];\nconst T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];\n// Transformations for decryption\nconst T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];\nconst T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];\nconst T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];\nconst T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];\n// Transformations for decryption key expansion\nconst U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];\nconst U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];\nconst U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];\nconst U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];\nfunction convertToInt32(bytes) {\n    const result = [];\n    for (let i = 0; i < bytes.length; i += 4) {\n        result.push((bytes[i] << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | bytes[i + 3]);\n    }\n    return result;\n}\nclass AES {\n    get key() { return __classPrivateFieldGet(this, _AES_key, \"f\").slice(); }\n    constructor(key) {\n        _AES_key.set(this, void 0);\n        _AES_Kd.set(this, void 0);\n        _AES_Ke.set(this, void 0);\n        if (!(this instanceof AES)) {\n            throw Error('AES must be instanitated with `new`');\n        }\n        __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), \"f\");\n        const rounds = numberOfRounds[this.key.length];\n        if (rounds == null) {\n            throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');\n        }\n        // encryption round keys\n        __classPrivateFieldSet(this, _AES_Ke, [], \"f\");\n        // decryption round keys\n        __classPrivateFieldSet(this, _AES_Kd, [], \"f\");\n        for (let i = 0; i <= rounds; i++) {\n            __classPrivateFieldGet(this, _AES_Ke, \"f\").push([0, 0, 0, 0]);\n            __classPrivateFieldGet(this, _AES_Kd, \"f\").push([0, 0, 0, 0]);\n        }\n        const roundKeyCount = (rounds + 1) * 4;\n        const KC = this.key.length / 4;\n        // convert the key into ints\n        const tk = convertToInt32(this.key);\n        // copy values into round key arrays\n        let index;\n        for (let i = 0; i < KC; i++) {\n            index = i >> 2;\n            __classPrivateFieldGet(this, _AES_Ke, \"f\")[index][i % 4] = tk[i];\n            __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds - index][i % 4] = tk[i];\n        }\n        // key expansion (fips-197 section 5.2)\n        let rconpointer = 0;\n        let t = KC, tt;\n        while (t < roundKeyCount) {\n            tt = tk[KC - 1];\n            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\n                (S[(tt >> 8) & 0xFF] << 16) ^\n                (S[tt & 0xFF] << 8) ^\n                S[(tt >> 24) & 0xFF] ^\n                (rcon[rconpointer] << 24));\n            rconpointer += 1;\n            // key expansion (for non-256 bit)\n            if (KC != 8) {\n                for (let i = 1; i < KC; i++) {\n                    tk[i] ^= tk[i - 1];\n                }\n                // key expansion for 256-bit keys is \"slightly different\" (fips-197)\n            }\n            else {\n                for (let i = 1; i < (KC / 2); i++) {\n                    tk[i] ^= tk[i - 1];\n                }\n                tt = tk[(KC / 2) - 1];\n                tk[KC / 2] ^= (S[tt & 0xFF] ^\n                    (S[(tt >> 8) & 0xFF] << 8) ^\n                    (S[(tt >> 16) & 0xFF] << 16) ^\n                    (S[(tt >> 24) & 0xFF] << 24));\n                for (let i = (KC / 2) + 1; i < KC; i++) {\n                    tk[i] ^= tk[i - 1];\n                }\n            }\n            // copy values into round key arrays\n            let i = 0, r, c;\n            while (i < KC && t < roundKeyCount) {\n                r = t >> 2;\n                c = t % 4;\n                __classPrivateFieldGet(this, _AES_Ke, \"f\")[r][c] = tk[i];\n                __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds - r][c] = tk[i++];\n                t++;\n            }\n        }\n        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n        for (let r = 1; r < rounds; r++) {\n            for (let c = 0; c < 4; c++) {\n                tt = __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][c];\n                __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][c] = (U1[(tt >> 24) & 0xFF] ^\n                    U2[(tt >> 16) & 0xFF] ^\n                    U3[(tt >> 8) & 0xFF] ^\n                    U4[tt & 0xFF]);\n            }\n        }\n    }\n    encrypt(plaintext) {\n        if (plaintext.length != 16) {\n            throw new TypeError('invalid plaintext size (must be 16 bytes)');\n        }\n        const rounds = __classPrivateFieldGet(this, _AES_Ke, \"f\").length - 1;\n        const a = [0, 0, 0, 0];\n        // convert plaintext to (ints ^ key)\n        let t = convertToInt32(plaintext);\n        for (let i = 0; i < 4; i++) {\n            t[i] ^= __classPrivateFieldGet(this, _AES_Ke, \"f\")[0][i];\n        }\n        // apply round transforms\n        for (let r = 1; r < rounds; r++) {\n            for (let i = 0; i < 4; i++) {\n                a[i] = (T1[(t[i] >> 24) & 0xff] ^\n                    T2[(t[(i + 1) % 4] >> 16) & 0xff] ^\n                    T3[(t[(i + 2) % 4] >> 8) & 0xff] ^\n                    T4[t[(i + 3) % 4] & 0xff] ^\n                    __classPrivateFieldGet(this, _AES_Ke, \"f\")[r][i]);\n            }\n            t = a.slice();\n        }\n        // the last round is special\n        const result = new Uint8Array(16);\n        let tt = 0;\n        for (let i = 0; i < 4; i++) {\n            tt = __classPrivateFieldGet(this, _AES_Ke, \"f\")[rounds][i];\n            result[4 * i] = (S[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n            result[4 * i + 2] = (S[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;\n            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;\n        }\n        return result;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length != 16) {\n            throw new TypeError('invalid ciphertext size (must be 16 bytes)');\n        }\n        const rounds = __classPrivateFieldGet(this, _AES_Kd, \"f\").length - 1;\n        const a = [0, 0, 0, 0];\n        // convert plaintext to (ints ^ key)\n        let t = convertToInt32(ciphertext);\n        for (let i = 0; i < 4; i++) {\n            t[i] ^= __classPrivateFieldGet(this, _AES_Kd, \"f\")[0][i];\n        }\n        // apply round transforms\n        for (let r = 1; r < rounds; r++) {\n            for (let i = 0; i < 4; i++) {\n                a[i] = (T5[(t[i] >> 24) & 0xff] ^\n                    T6[(t[(i + 3) % 4] >> 16) & 0xff] ^\n                    T7[(t[(i + 2) % 4] >> 8) & 0xff] ^\n                    T8[t[(i + 1) % 4] & 0xff] ^\n                    __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][i]);\n            }\n            t = a.slice();\n        }\n        // the last round is special\n        const result = new Uint8Array(16);\n        let tt = 0;\n        for (let i = 0; i < 4; i++) {\n            tt = __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds][i];\n            result[4 * i] = (Si[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;\n            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;\n        }\n        return result;\n    }\n}\n_AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap();\n//# sourceMappingURL=aes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9hZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuZXNtL2Flcy5qcz80NWQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBNSVQgTGljZW5zZS4gQ29weXJpZ2h0IDIwMTUtMjAyMiBSaWNoYXJkIE1vb3JlIDxtZUByaWNtb28uY29tPi4gU2VlIExJQ0VOU0UudHh0LiAqL1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9BRVNfa2V5LCBfQUVTX0tkLCBfQUVTX0tlO1xuLy8gTnVtYmVyIG9mIHJvdW5kcyBieSBrZXlzaXplXG5jb25zdCBudW1iZXJPZlJvdW5kcyA9IHsgMTY6IDEwLCAyNDogMTIsIDMyOiAxNCB9O1xuLy8gUm91bmQgY29uc3RhbnQgd29yZHNcbmNvbnN0IHJjb24gPSBbMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNiwgMHg2YywgMHhkOCwgMHhhYiwgMHg0ZCwgMHg5YSwgMHgyZiwgMHg1ZSwgMHhiYywgMHg2MywgMHhjNiwgMHg5NywgMHgzNSwgMHg2YSwgMHhkNCwgMHhiMywgMHg3ZCwgMHhmYSwgMHhlZiwgMHhjNSwgMHg5MV07XG4vLyBTLWJveCBhbmQgSW52ZXJzZSBTLWJveCAoUyBpcyBmb3IgU3Vic3RpdHV0aW9uKVxuY29uc3QgUyA9IFsweDYzLCAweDdjLCAweDc3LCAweDdiLCAweGYyLCAweDZiLCAweDZmLCAweGM1LCAweDMwLCAweDAxLCAweDY3LCAweDJiLCAweGZlLCAweGQ3LCAweGFiLCAweDc2LCAweGNhLCAweDgyLCAweGM5LCAweDdkLCAweGZhLCAweDU5LCAweDQ3LCAweGYwLCAweGFkLCAweGQ0LCAweGEyLCAweGFmLCAweDljLCAweGE0LCAweDcyLCAweGMwLCAweGI3LCAweGZkLCAweDkzLCAweDI2LCAweDM2LCAweDNmLCAweGY3LCAweGNjLCAweDM0LCAweGE1LCAweGU1LCAweGYxLCAweDcxLCAweGQ4LCAweDMxLCAweDE1LCAweDA0LCAweGM3LCAweDIzLCAweGMzLCAweDE4LCAweDk2LCAweDA1LCAweDlhLCAweDA3LCAweDEyLCAweDgwLCAweGUyLCAweGViLCAweDI3LCAweGIyLCAweDc1LCAweDA5LCAweDgzLCAweDJjLCAweDFhLCAweDFiLCAweDZlLCAweDVhLCAweGEwLCAweDUyLCAweDNiLCAweGQ2LCAweGIzLCAweDI5LCAweGUzLCAweDJmLCAweDg0LCAweDUzLCAweGQxLCAweDAwLCAweGVkLCAweDIwLCAweGZjLCAweGIxLCAweDViLCAweDZhLCAweGNiLCAweGJlLCAweDM5LCAweDRhLCAweDRjLCAweDU4LCAweGNmLCAweGQwLCAweGVmLCAweGFhLCAweGZiLCAweDQzLCAweDRkLCAweDMzLCAweDg1LCAweDQ1LCAweGY5LCAweDAyLCAweDdmLCAweDUwLCAweDNjLCAweDlmLCAweGE4LCAweDUxLCAweGEzLCAweDQwLCAweDhmLCAweDkyLCAweDlkLCAweDM4LCAweGY1LCAweGJjLCAweGI2LCAweGRhLCAweDIxLCAweDEwLCAweGZmLCAweGYzLCAweGQyLCAweGNkLCAweDBjLCAweDEzLCAweGVjLCAweDVmLCAweDk3LCAweDQ0LCAweDE3LCAweGM0LCAweGE3LCAweDdlLCAweDNkLCAweDY0LCAweDVkLCAweDE5LCAweDczLCAweDYwLCAweDgxLCAweDRmLCAweGRjLCAweDIyLCAweDJhLCAweDkwLCAweDg4LCAweDQ2LCAweGVlLCAweGI4LCAweDE0LCAweGRlLCAweDVlLCAweDBiLCAweGRiLCAweGUwLCAweDMyLCAweDNhLCAweDBhLCAweDQ5LCAweDA2LCAweDI0LCAweDVjLCAweGMyLCAweGQzLCAweGFjLCAweDYyLCAweDkxLCAweDk1LCAweGU0LCAweDc5LCAweGU3LCAweGM4LCAweDM3LCAweDZkLCAweDhkLCAweGQ1LCAweDRlLCAweGE5LCAweDZjLCAweDU2LCAweGY0LCAweGVhLCAweDY1LCAweDdhLCAweGFlLCAweDA4LCAweGJhLCAweDc4LCAweDI1LCAweDJlLCAweDFjLCAweGE2LCAweGI0LCAweGM2LCAweGU4LCAweGRkLCAweDc0LCAweDFmLCAweDRiLCAweGJkLCAweDhiLCAweDhhLCAweDcwLCAweDNlLCAweGI1LCAweDY2LCAweDQ4LCAweDAzLCAweGY2LCAweDBlLCAweDYxLCAweDM1LCAweDU3LCAweGI5LCAweDg2LCAweGMxLCAweDFkLCAweDllLCAweGUxLCAweGY4LCAweDk4LCAweDExLCAweDY5LCAweGQ5LCAweDhlLCAweDk0LCAweDliLCAweDFlLCAweDg3LCAweGU5LCAweGNlLCAweDU1LCAweDI4LCAweGRmLCAweDhjLCAweGExLCAweDg5LCAweDBkLCAweGJmLCAweGU2LCAweDQyLCAweDY4LCAweDQxLCAweDk5LCAweDJkLCAweDBmLCAweGIwLCAweDU0LCAweGJiLCAweDE2XTtcbmNvbnN0IFNpID0gWzB4NTIsIDB4MDksIDB4NmEsIDB4ZDUsIDB4MzAsIDB4MzYsIDB4YTUsIDB4MzgsIDB4YmYsIDB4NDAsIDB4YTMsIDB4OWUsIDB4ODEsIDB4ZjMsIDB4ZDcsIDB4ZmIsIDB4N2MsIDB4ZTMsIDB4MzksIDB4ODIsIDB4OWIsIDB4MmYsIDB4ZmYsIDB4ODcsIDB4MzQsIDB4OGUsIDB4NDMsIDB4NDQsIDB4YzQsIDB4ZGUsIDB4ZTksIDB4Y2IsIDB4NTQsIDB4N2IsIDB4OTQsIDB4MzIsIDB4YTYsIDB4YzIsIDB4MjMsIDB4M2QsIDB4ZWUsIDB4NGMsIDB4OTUsIDB4MGIsIDB4NDIsIDB4ZmEsIDB4YzMsIDB4NGUsIDB4MDgsIDB4MmUsIDB4YTEsIDB4NjYsIDB4MjgsIDB4ZDksIDB4MjQsIDB4YjIsIDB4NzYsIDB4NWIsIDB4YTIsIDB4NDksIDB4NmQsIDB4OGIsIDB4ZDEsIDB4MjUsIDB4NzIsIDB4ZjgsIDB4ZjYsIDB4NjQsIDB4ODYsIDB4NjgsIDB4OTgsIDB4MTYsIDB4ZDQsIDB4YTQsIDB4NWMsIDB4Y2MsIDB4NWQsIDB4NjUsIDB4YjYsIDB4OTIsIDB4NmMsIDB4NzAsIDB4NDgsIDB4NTAsIDB4ZmQsIDB4ZWQsIDB4YjksIDB4ZGEsIDB4NWUsIDB4MTUsIDB4NDYsIDB4NTcsIDB4YTcsIDB4OGQsIDB4OWQsIDB4ODQsIDB4OTAsIDB4ZDgsIDB4YWIsIDB4MDAsIDB4OGMsIDB4YmMsIDB4ZDMsIDB4MGEsIDB4ZjcsIDB4ZTQsIDB4NTgsIDB4MDUsIDB4YjgsIDB4YjMsIDB4NDUsIDB4MDYsIDB4ZDAsIDB4MmMsIDB4MWUsIDB4OGYsIDB4Y2EsIDB4M2YsIDB4MGYsIDB4MDIsIDB4YzEsIDB4YWYsIDB4YmQsIDB4MDMsIDB4MDEsIDB4MTMsIDB4OGEsIDB4NmIsIDB4M2EsIDB4OTEsIDB4MTEsIDB4NDEsIDB4NGYsIDB4NjcsIDB4ZGMsIDB4ZWEsIDB4OTcsIDB4ZjIsIDB4Y2YsIDB4Y2UsIDB4ZjAsIDB4YjQsIDB4ZTYsIDB4NzMsIDB4OTYsIDB4YWMsIDB4NzQsIDB4MjIsIDB4ZTcsIDB4YWQsIDB4MzUsIDB4ODUsIDB4ZTIsIDB4ZjksIDB4MzcsIDB4ZTgsIDB4MWMsIDB4NzUsIDB4ZGYsIDB4NmUsIDB4NDcsIDB4ZjEsIDB4MWEsIDB4NzEsIDB4MWQsIDB4MjksIDB4YzUsIDB4ODksIDB4NmYsIDB4YjcsIDB4NjIsIDB4MGUsIDB4YWEsIDB4MTgsIDB4YmUsIDB4MWIsIDB4ZmMsIDB4NTYsIDB4M2UsIDB4NGIsIDB4YzYsIDB4ZDIsIDB4NzksIDB4MjAsIDB4OWEsIDB4ZGIsIDB4YzAsIDB4ZmUsIDB4NzgsIDB4Y2QsIDB4NWEsIDB4ZjQsIDB4MWYsIDB4ZGQsIDB4YTgsIDB4MzMsIDB4ODgsIDB4MDcsIDB4YzcsIDB4MzEsIDB4YjEsIDB4MTIsIDB4MTAsIDB4NTksIDB4MjcsIDB4ODAsIDB4ZWMsIDB4NWYsIDB4NjAsIDB4NTEsIDB4N2YsIDB4YTksIDB4MTksIDB4YjUsIDB4NGEsIDB4MGQsIDB4MmQsIDB4ZTUsIDB4N2EsIDB4OWYsIDB4OTMsIDB4YzksIDB4OWMsIDB4ZWYsIDB4YTAsIDB4ZTAsIDB4M2IsIDB4NGQsIDB4YWUsIDB4MmEsIDB4ZjUsIDB4YjAsIDB4YzgsIDB4ZWIsIDB4YmIsIDB4M2MsIDB4ODMsIDB4NTMsIDB4OTksIDB4NjEsIDB4MTcsIDB4MmIsIDB4MDQsIDB4N2UsIDB4YmEsIDB4NzcsIDB4ZDYsIDB4MjYsIDB4ZTEsIDB4NjksIDB4MTQsIDB4NjMsIDB4NTUsIDB4MjEsIDB4MGMsIDB4N2RdO1xuLy8gVHJhbnNmb3JtYXRpb25zIGZvciBlbmNyeXB0aW9uXG5jb25zdCBUMSA9IFsweGM2NjM2M2E1LCAweGY4N2M3Yzg0LCAweGVlNzc3Nzk5LCAweGY2N2I3YjhkLCAweGZmZjJmMjBkLCAweGQ2NmI2YmJkLCAweGRlNmY2ZmIxLCAweDkxYzVjNTU0LCAweDYwMzAzMDUwLCAweDAyMDEwMTAzLCAweGNlNjc2N2E5LCAweDU2MmIyYjdkLCAweGU3ZmVmZTE5LCAweGI1ZDdkNzYyLCAweDRkYWJhYmU2LCAweGVjNzY3NjlhLCAweDhmY2FjYTQ1LCAweDFmODI4MjlkLCAweDg5YzljOTQwLCAweGZhN2Q3ZDg3LCAweGVmZmFmYTE1LCAweGIyNTk1OWViLCAweDhlNDc0N2M5LCAweGZiZjBmMDBiLCAweDQxYWRhZGVjLCAweGIzZDRkNDY3LCAweDVmYTJhMmZkLCAweDQ1YWZhZmVhLCAweDIzOWM5Y2JmLCAweDUzYTRhNGY3LCAweGU0NzI3Mjk2LCAweDliYzBjMDViLCAweDc1YjdiN2MyLCAweGUxZmRmZDFjLCAweDNkOTM5M2FlLCAweDRjMjYyNjZhLCAweDZjMzYzNjVhLCAweDdlM2YzZjQxLCAweGY1ZjdmNzAyLCAweDgzY2NjYzRmLCAweDY4MzQzNDVjLCAweDUxYTVhNWY0LCAweGQxZTVlNTM0LCAweGY5ZjFmMTA4LCAweGUyNzE3MTkzLCAweGFiZDhkODczLCAweDYyMzEzMTUzLCAweDJhMTUxNTNmLCAweDA4MDQwNDBjLCAweDk1YzdjNzUyLCAweDQ2MjMyMzY1LCAweDlkYzNjMzVlLCAweDMwMTgxODI4LCAweDM3OTY5NmExLCAweDBhMDUwNTBmLCAweDJmOWE5YWI1LCAweDBlMDcwNzA5LCAweDI0MTIxMjM2LCAweDFiODA4MDliLCAweGRmZTJlMjNkLCAweGNkZWJlYjI2LCAweDRlMjcyNzY5LCAweDdmYjJiMmNkLCAweGVhNzU3NTlmLCAweDEyMDkwOTFiLCAweDFkODM4MzllLCAweDU4MmMyYzc0LCAweDM0MWExYTJlLCAweDM2MWIxYjJkLCAweGRjNmU2ZWIyLCAweGI0NWE1YWVlLCAweDViYTBhMGZiLCAweGE0NTI1MmY2LCAweDc2M2IzYjRkLCAweGI3ZDZkNjYxLCAweDdkYjNiM2NlLCAweDUyMjkyOTdiLCAweGRkZTNlMzNlLCAweDVlMmYyZjcxLCAweDEzODQ4NDk3LCAweGE2NTM1M2Y1LCAweGI5ZDFkMTY4LCAweDAwMDAwMDAwLCAweGMxZWRlZDJjLCAweDQwMjAyMDYwLCAweGUzZmNmYzFmLCAweDc5YjFiMWM4LCAweGI2NWI1YmVkLCAweGQ0NmE2YWJlLCAweDhkY2JjYjQ2LCAweDY3YmViZWQ5LCAweDcyMzkzOTRiLCAweDk0NGE0YWRlLCAweDk4NGM0Y2Q0LCAweGIwNTg1OGU4LCAweDg1Y2ZjZjRhLCAweGJiZDBkMDZiLCAweGM1ZWZlZjJhLCAweDRmYWFhYWU1LCAweGVkZmJmYjE2LCAweDg2NDM0M2M1LCAweDlhNGQ0ZGQ3LCAweDY2MzMzMzU1LCAweDExODU4NTk0LCAweDhhNDU0NWNmLCAweGU5ZjlmOTEwLCAweDA0MDIwMjA2LCAweGZlN2Y3ZjgxLCAweGEwNTA1MGYwLCAweDc4M2MzYzQ0LCAweDI1OWY5ZmJhLCAweDRiYThhOGUzLCAweGEyNTE1MWYzLCAweDVkYTNhM2ZlLCAweDgwNDA0MGMwLCAweDA1OGY4ZjhhLCAweDNmOTI5MmFkLCAweDIxOWQ5ZGJjLCAweDcwMzgzODQ4LCAweGYxZjVmNTA0LCAweDYzYmNiY2RmLCAweDc3YjZiNmMxLCAweGFmZGFkYTc1LCAweDQyMjEyMTYzLCAweDIwMTAxMDMwLCAweGU1ZmZmZjFhLCAweGZkZjNmMzBlLCAweGJmZDJkMjZkLCAweDgxY2RjZDRjLCAweDE4MGMwYzE0LCAweDI2MTMxMzM1LCAweGMzZWNlYzJmLCAweGJlNWY1ZmUxLCAweDM1OTc5N2EyLCAweDg4NDQ0NGNjLCAweDJlMTcxNzM5LCAweDkzYzRjNDU3LCAweDU1YTdhN2YyLCAweGZjN2U3ZTgyLCAweDdhM2QzZDQ3LCAweGM4NjQ2NGFjLCAweGJhNWQ1ZGU3LCAweDMyMTkxOTJiLCAweGU2NzM3Mzk1LCAweGMwNjA2MGEwLCAweDE5ODE4MTk4LCAweDllNGY0ZmQxLCAweGEzZGNkYzdmLCAweDQ0MjIyMjY2LCAweDU0MmEyYTdlLCAweDNiOTA5MGFiLCAweDBiODg4ODgzLCAweDhjNDY0NmNhLCAweGM3ZWVlZTI5LCAweDZiYjhiOGQzLCAweDI4MTQxNDNjLCAweGE3ZGVkZTc5LCAweGJjNWU1ZWUyLCAweDE2MGIwYjFkLCAweGFkZGJkYjc2LCAweGRiZTBlMDNiLCAweDY0MzIzMjU2LCAweDc0M2EzYTRlLCAweDE0MGEwYTFlLCAweDkyNDk0OWRiLCAweDBjMDYwNjBhLCAweDQ4MjQyNDZjLCAweGI4NWM1Y2U0LCAweDlmYzJjMjVkLCAweGJkZDNkMzZlLCAweDQzYWNhY2VmLCAweGM0NjI2MmE2LCAweDM5OTE5MWE4LCAweDMxOTU5NWE0LCAweGQzZTRlNDM3LCAweGYyNzk3OThiLCAweGQ1ZTdlNzMyLCAweDhiYzhjODQzLCAweDZlMzczNzU5LCAweGRhNmQ2ZGI3LCAweDAxOGQ4ZDhjLCAweGIxZDVkNTY0LCAweDljNGU0ZWQyLCAweDQ5YTlhOWUwLCAweGQ4NmM2Y2I0LCAweGFjNTY1NmZhLCAweGYzZjRmNDA3LCAweGNmZWFlYTI1LCAweGNhNjU2NWFmLCAweGY0N2E3YThlLCAweDQ3YWVhZWU5LCAweDEwMDgwODE4LCAweDZmYmFiYWQ1LCAweGYwNzg3ODg4LCAweDRhMjUyNTZmLCAweDVjMmUyZTcyLCAweDM4MWMxYzI0LCAweDU3YTZhNmYxLCAweDczYjRiNGM3LCAweDk3YzZjNjUxLCAweGNiZThlODIzLCAweGExZGRkZDdjLCAweGU4NzQ3NDljLCAweDNlMWYxZjIxLCAweDk2NGI0YmRkLCAweDYxYmRiZGRjLCAweDBkOGI4Yjg2LCAweDBmOGE4YTg1LCAweGUwNzA3MDkwLCAweDdjM2UzZTQyLCAweDcxYjViNWM0LCAweGNjNjY2NmFhLCAweDkwNDg0OGQ4LCAweDA2MDMwMzA1LCAweGY3ZjZmNjAxLCAweDFjMGUwZTEyLCAweGMyNjE2MWEzLCAweDZhMzUzNTVmLCAweGFlNTc1N2Y5LCAweDY5YjliOWQwLCAweDE3ODY4NjkxLCAweDk5YzFjMTU4LCAweDNhMWQxZDI3LCAweDI3OWU5ZWI5LCAweGQ5ZTFlMTM4LCAweGViZjhmODEzLCAweDJiOTg5OGIzLCAweDIyMTExMTMzLCAweGQyNjk2OWJiLCAweGE5ZDlkOTcwLCAweDA3OGU4ZTg5LCAweDMzOTQ5NGE3LCAweDJkOWI5YmI2LCAweDNjMWUxZTIyLCAweDE1ODc4NzkyLCAweGM5ZTllOTIwLCAweDg3Y2VjZTQ5LCAweGFhNTU1NWZmLCAweDUwMjgyODc4LCAweGE1ZGZkZjdhLCAweDAzOGM4YzhmLCAweDU5YTFhMWY4LCAweDA5ODk4OTgwLCAweDFhMGQwZDE3LCAweDY1YmZiZmRhLCAweGQ3ZTZlNjMxLCAweDg0NDI0MmM2LCAweGQwNjg2OGI4LCAweDgyNDE0MWMzLCAweDI5OTk5OWIwLCAweDVhMmQyZDc3LCAweDFlMGYwZjExLCAweDdiYjBiMGNiLCAweGE4NTQ1NGZjLCAweDZkYmJiYmQ2LCAweDJjMTYxNjNhXTtcbmNvbnN0IFQyID0gWzB4YTVjNjYzNjMsIDB4ODRmODdjN2MsIDB4OTllZTc3NzcsIDB4OGRmNjdiN2IsIDB4MGRmZmYyZjIsIDB4YmRkNjZiNmIsIDB4YjFkZTZmNmYsIDB4NTQ5MWM1YzUsIDB4NTA2MDMwMzAsIDB4MDMwMjAxMDEsIDB4YTljZTY3NjcsIDB4N2Q1NjJiMmIsIDB4MTllN2ZlZmUsIDB4NjJiNWQ3ZDcsIDB4ZTY0ZGFiYWIsIDB4OWFlYzc2NzYsIDB4NDU4ZmNhY2EsIDB4OWQxZjgyODIsIDB4NDA4OWM5YzksIDB4ODdmYTdkN2QsIDB4MTVlZmZhZmEsIDB4ZWJiMjU5NTksIDB4Yzk4ZTQ3NDcsIDB4MGJmYmYwZjAsIDB4ZWM0MWFkYWQsIDB4NjdiM2Q0ZDQsIDB4ZmQ1ZmEyYTIsIDB4ZWE0NWFmYWYsIDB4YmYyMzljOWMsIDB4Zjc1M2E0YTQsIDB4OTZlNDcyNzIsIDB4NWI5YmMwYzAsIDB4YzI3NWI3YjcsIDB4MWNlMWZkZmQsIDB4YWUzZDkzOTMsIDB4NmE0YzI2MjYsIDB4NWE2YzM2MzYsIDB4NDE3ZTNmM2YsIDB4MDJmNWY3ZjcsIDB4NGY4M2NjY2MsIDB4NWM2ODM0MzQsIDB4ZjQ1MWE1YTUsIDB4MzRkMWU1ZTUsIDB4MDhmOWYxZjEsIDB4OTNlMjcxNzEsIDB4NzNhYmQ4ZDgsIDB4NTM2MjMxMzEsIDB4M2YyYTE1MTUsIDB4MGMwODA0MDQsIDB4NTI5NWM3YzcsIDB4NjU0NjIzMjMsIDB4NWU5ZGMzYzMsIDB4MjgzMDE4MTgsIDB4YTEzNzk2OTYsIDB4MGYwYTA1MDUsIDB4YjUyZjlhOWEsIDB4MDkwZTA3MDcsIDB4MzYyNDEyMTIsIDB4OWIxYjgwODAsIDB4M2RkZmUyZTIsIDB4MjZjZGViZWIsIDB4Njk0ZTI3MjcsIDB4Y2Q3ZmIyYjIsIDB4OWZlYTc1NzUsIDB4MWIxMjA5MDksIDB4OWUxZDgzODMsIDB4NzQ1ODJjMmMsIDB4MmUzNDFhMWEsIDB4MmQzNjFiMWIsIDB4YjJkYzZlNmUsIDB4ZWViNDVhNWEsIDB4ZmI1YmEwYTAsIDB4ZjZhNDUyNTIsIDB4NGQ3NjNiM2IsIDB4NjFiN2Q2ZDYsIDB4Y2U3ZGIzYjMsIDB4N2I1MjI5MjksIDB4M2VkZGUzZTMsIDB4NzE1ZTJmMmYsIDB4OTcxMzg0ODQsIDB4ZjVhNjUzNTMsIDB4NjhiOWQxZDEsIDB4MDAwMDAwMDAsIDB4MmNjMWVkZWQsIDB4NjA0MDIwMjAsIDB4MWZlM2ZjZmMsIDB4Yzg3OWIxYjEsIDB4ZWRiNjViNWIsIDB4YmVkNDZhNmEsIDB4NDY4ZGNiY2IsIDB4ZDk2N2JlYmUsIDB4NGI3MjM5MzksIDB4ZGU5NDRhNGEsIDB4ZDQ5ODRjNGMsIDB4ZThiMDU4NTgsIDB4NGE4NWNmY2YsIDB4NmJiYmQwZDAsIDB4MmFjNWVmZWYsIDB4ZTU0ZmFhYWEsIDB4MTZlZGZiZmIsIDB4YzU4NjQzNDMsIDB4ZDc5YTRkNGQsIDB4NTU2NjMzMzMsIDB4OTQxMTg1ODUsIDB4Y2Y4YTQ1NDUsIDB4MTBlOWY5ZjksIDB4MDYwNDAyMDIsIDB4ODFmZTdmN2YsIDB4ZjBhMDUwNTAsIDB4NDQ3ODNjM2MsIDB4YmEyNTlmOWYsIDB4ZTM0YmE4YTgsIDB4ZjNhMjUxNTEsIDB4ZmU1ZGEzYTMsIDB4YzA4MDQwNDAsIDB4OGEwNThmOGYsIDB4YWQzZjkyOTIsIDB4YmMyMTlkOWQsIDB4NDg3MDM4MzgsIDB4MDRmMWY1ZjUsIDB4ZGY2M2JjYmMsIDB4YzE3N2I2YjYsIDB4NzVhZmRhZGEsIDB4NjM0MjIxMjEsIDB4MzAyMDEwMTAsIDB4MWFlNWZmZmYsIDB4MGVmZGYzZjMsIDB4NmRiZmQyZDIsIDB4NGM4MWNkY2QsIDB4MTQxODBjMGMsIDB4MzUyNjEzMTMsIDB4MmZjM2VjZWMsIDB4ZTFiZTVmNWYsIDB4YTIzNTk3OTcsIDB4Y2M4ODQ0NDQsIDB4MzkyZTE3MTcsIDB4NTc5M2M0YzQsIDB4ZjI1NWE3YTcsIDB4ODJmYzdlN2UsIDB4NDc3YTNkM2QsIDB4YWNjODY0NjQsIDB4ZTdiYTVkNWQsIDB4MmIzMjE5MTksIDB4OTVlNjczNzMsIDB4YTBjMDYwNjAsIDB4OTgxOTgxODEsIDB4ZDE5ZTRmNGYsIDB4N2ZhM2RjZGMsIDB4NjY0NDIyMjIsIDB4N2U1NDJhMmEsIDB4YWIzYjkwOTAsIDB4ODMwYjg4ODgsIDB4Y2E4YzQ2NDYsIDB4MjljN2VlZWUsIDB4ZDM2YmI4YjgsIDB4M2MyODE0MTQsIDB4NzlhN2RlZGUsIDB4ZTJiYzVlNWUsIDB4MWQxNjBiMGIsIDB4NzZhZGRiZGIsIDB4M2JkYmUwZTAsIDB4NTY2NDMyMzIsIDB4NGU3NDNhM2EsIDB4MWUxNDBhMGEsIDB4ZGI5MjQ5NDksIDB4MGEwYzA2MDYsIDB4NmM0ODI0MjQsIDB4ZTRiODVjNWMsIDB4NWQ5ZmMyYzIsIDB4NmViZGQzZDMsIDB4ZWY0M2FjYWMsIDB4YTZjNDYyNjIsIDB4YTgzOTkxOTEsIDB4YTQzMTk1OTUsIDB4MzdkM2U0ZTQsIDB4OGJmMjc5NzksIDB4MzJkNWU3ZTcsIDB4NDM4YmM4YzgsIDB4NTk2ZTM3MzcsIDB4YjdkYTZkNmQsIDB4OGMwMThkOGQsIDB4NjRiMWQ1ZDUsIDB4ZDI5YzRlNGUsIDB4ZTA0OWE5YTksIDB4YjRkODZjNmMsIDB4ZmFhYzU2NTYsIDB4MDdmM2Y0ZjQsIDB4MjVjZmVhZWEsIDB4YWZjYTY1NjUsIDB4OGVmNDdhN2EsIDB4ZTk0N2FlYWUsIDB4MTgxMDA4MDgsIDB4ZDU2ZmJhYmEsIDB4ODhmMDc4NzgsIDB4NmY0YTI1MjUsIDB4NzI1YzJlMmUsIDB4MjQzODFjMWMsIDB4ZjE1N2E2YTYsIDB4Yzc3M2I0YjQsIDB4NTE5N2M2YzYsIDB4MjNjYmU4ZTgsIDB4N2NhMWRkZGQsIDB4OWNlODc0NzQsIDB4MjEzZTFmMWYsIDB4ZGQ5NjRiNGIsIDB4ZGM2MWJkYmQsIDB4ODYwZDhiOGIsIDB4ODUwZjhhOGEsIDB4OTBlMDcwNzAsIDB4NDI3YzNlM2UsIDB4YzQ3MWI1YjUsIDB4YWFjYzY2NjYsIDB4ZDg5MDQ4NDgsIDB4MDUwNjAzMDMsIDB4MDFmN2Y2ZjYsIDB4MTIxYzBlMGUsIDB4YTNjMjYxNjEsIDB4NWY2YTM1MzUsIDB4ZjlhZTU3NTcsIDB4ZDA2OWI5YjksIDB4OTExNzg2ODYsIDB4NTg5OWMxYzEsIDB4MjczYTFkMWQsIDB4YjkyNzllOWUsIDB4MzhkOWUxZTEsIDB4MTNlYmY4ZjgsIDB4YjMyYjk4OTgsIDB4MzMyMjExMTEsIDB4YmJkMjY5NjksIDB4NzBhOWQ5ZDksIDB4ODkwNzhlOGUsIDB4YTczMzk0OTQsIDB4YjYyZDliOWIsIDB4MjIzYzFlMWUsIDB4OTIxNTg3ODcsIDB4MjBjOWU5ZTksIDB4NDk4N2NlY2UsIDB4ZmZhYTU1NTUsIDB4Nzg1MDI4MjgsIDB4N2FhNWRmZGYsIDB4OGYwMzhjOGMsIDB4Zjg1OWExYTEsIDB4ODAwOTg5ODksIDB4MTcxYTBkMGQsIDB4ZGE2NWJmYmYsIDB4MzFkN2U2ZTYsIDB4YzY4NDQyNDIsIDB4YjhkMDY4NjgsIDB4YzM4MjQxNDEsIDB4YjAyOTk5OTksIDB4Nzc1YTJkMmQsIDB4MTExZTBmMGYsIDB4Y2I3YmIwYjAsIDB4ZmNhODU0NTQsIDB4ZDY2ZGJiYmIsIDB4M2EyYzE2MTZdO1xuY29uc3QgVDMgPSBbMHg2M2E1YzY2MywgMHg3Yzg0Zjg3YywgMHg3Nzk5ZWU3NywgMHg3YjhkZjY3YiwgMHhmMjBkZmZmMiwgMHg2YmJkZDY2YiwgMHg2ZmIxZGU2ZiwgMHhjNTU0OTFjNSwgMHgzMDUwNjAzMCwgMHgwMTAzMDIwMSwgMHg2N2E5Y2U2NywgMHgyYjdkNTYyYiwgMHhmZTE5ZTdmZSwgMHhkNzYyYjVkNywgMHhhYmU2NGRhYiwgMHg3NjlhZWM3NiwgMHhjYTQ1OGZjYSwgMHg4MjlkMWY4MiwgMHhjOTQwODljOSwgMHg3ZDg3ZmE3ZCwgMHhmYTE1ZWZmYSwgMHg1OWViYjI1OSwgMHg0N2M5OGU0NywgMHhmMDBiZmJmMCwgMHhhZGVjNDFhZCwgMHhkNDY3YjNkNCwgMHhhMmZkNWZhMiwgMHhhZmVhNDVhZiwgMHg5Y2JmMjM5YywgMHhhNGY3NTNhNCwgMHg3Mjk2ZTQ3MiwgMHhjMDViOWJjMCwgMHhiN2MyNzViNywgMHhmZDFjZTFmZCwgMHg5M2FlM2Q5MywgMHgyNjZhNGMyNiwgMHgzNjVhNmMzNiwgMHgzZjQxN2UzZiwgMHhmNzAyZjVmNywgMHhjYzRmODNjYywgMHgzNDVjNjgzNCwgMHhhNWY0NTFhNSwgMHhlNTM0ZDFlNSwgMHhmMTA4ZjlmMSwgMHg3MTkzZTI3MSwgMHhkODczYWJkOCwgMHgzMTUzNjIzMSwgMHgxNTNmMmExNSwgMHgwNDBjMDgwNCwgMHhjNzUyOTVjNywgMHgyMzY1NDYyMywgMHhjMzVlOWRjMywgMHgxODI4MzAxOCwgMHg5NmExMzc5NiwgMHgwNTBmMGEwNSwgMHg5YWI1MmY5YSwgMHgwNzA5MGUwNywgMHgxMjM2MjQxMiwgMHg4MDliMWI4MCwgMHhlMjNkZGZlMiwgMHhlYjI2Y2RlYiwgMHgyNzY5NGUyNywgMHhiMmNkN2ZiMiwgMHg3NTlmZWE3NSwgMHgwOTFiMTIwOSwgMHg4MzllMWQ4MywgMHgyYzc0NTgyYywgMHgxYTJlMzQxYSwgMHgxYjJkMzYxYiwgMHg2ZWIyZGM2ZSwgMHg1YWVlYjQ1YSwgMHhhMGZiNWJhMCwgMHg1MmY2YTQ1MiwgMHgzYjRkNzYzYiwgMHhkNjYxYjdkNiwgMHhiM2NlN2RiMywgMHgyOTdiNTIyOSwgMHhlMzNlZGRlMywgMHgyZjcxNWUyZiwgMHg4NDk3MTM4NCwgMHg1M2Y1YTY1MywgMHhkMTY4YjlkMSwgMHgwMDAwMDAwMCwgMHhlZDJjYzFlZCwgMHgyMDYwNDAyMCwgMHhmYzFmZTNmYywgMHhiMWM4NzliMSwgMHg1YmVkYjY1YiwgMHg2YWJlZDQ2YSwgMHhjYjQ2OGRjYiwgMHhiZWQ5NjdiZSwgMHgzOTRiNzIzOSwgMHg0YWRlOTQ0YSwgMHg0Y2Q0OTg0YywgMHg1OGU4YjA1OCwgMHhjZjRhODVjZiwgMHhkMDZiYmJkMCwgMHhlZjJhYzVlZiwgMHhhYWU1NGZhYSwgMHhmYjE2ZWRmYiwgMHg0M2M1ODY0MywgMHg0ZGQ3OWE0ZCwgMHgzMzU1NjYzMywgMHg4NTk0MTE4NSwgMHg0NWNmOGE0NSwgMHhmOTEwZTlmOSwgMHgwMjA2MDQwMiwgMHg3ZjgxZmU3ZiwgMHg1MGYwYTA1MCwgMHgzYzQ0NzgzYywgMHg5ZmJhMjU5ZiwgMHhhOGUzNGJhOCwgMHg1MWYzYTI1MSwgMHhhM2ZlNWRhMywgMHg0MGMwODA0MCwgMHg4ZjhhMDU4ZiwgMHg5MmFkM2Y5MiwgMHg5ZGJjMjE5ZCwgMHgzODQ4NzAzOCwgMHhmNTA0ZjFmNSwgMHhiY2RmNjNiYywgMHhiNmMxNzdiNiwgMHhkYTc1YWZkYSwgMHgyMTYzNDIyMSwgMHgxMDMwMjAxMCwgMHhmZjFhZTVmZiwgMHhmMzBlZmRmMywgMHhkMjZkYmZkMiwgMHhjZDRjODFjZCwgMHgwYzE0MTgwYywgMHgxMzM1MjYxMywgMHhlYzJmYzNlYywgMHg1ZmUxYmU1ZiwgMHg5N2EyMzU5NywgMHg0NGNjODg0NCwgMHgxNzM5MmUxNywgMHhjNDU3OTNjNCwgMHhhN2YyNTVhNywgMHg3ZTgyZmM3ZSwgMHgzZDQ3N2EzZCwgMHg2NGFjYzg2NCwgMHg1ZGU3YmE1ZCwgMHgxOTJiMzIxOSwgMHg3Mzk1ZTY3MywgMHg2MGEwYzA2MCwgMHg4MTk4MTk4MSwgMHg0ZmQxOWU0ZiwgMHhkYzdmYTNkYywgMHgyMjY2NDQyMiwgMHgyYTdlNTQyYSwgMHg5MGFiM2I5MCwgMHg4ODgzMGI4OCwgMHg0NmNhOGM0NiwgMHhlZTI5YzdlZSwgMHhiOGQzNmJiOCwgMHgxNDNjMjgxNCwgMHhkZTc5YTdkZSwgMHg1ZWUyYmM1ZSwgMHgwYjFkMTYwYiwgMHhkYjc2YWRkYiwgMHhlMDNiZGJlMCwgMHgzMjU2NjQzMiwgMHgzYTRlNzQzYSwgMHgwYTFlMTQwYSwgMHg0OWRiOTI0OSwgMHgwNjBhMGMwNiwgMHgyNDZjNDgyNCwgMHg1Y2U0Yjg1YywgMHhjMjVkOWZjMiwgMHhkMzZlYmRkMywgMHhhY2VmNDNhYywgMHg2MmE2YzQ2MiwgMHg5MWE4Mzk5MSwgMHg5NWE0MzE5NSwgMHhlNDM3ZDNlNCwgMHg3OThiZjI3OSwgMHhlNzMyZDVlNywgMHhjODQzOGJjOCwgMHgzNzU5NmUzNywgMHg2ZGI3ZGE2ZCwgMHg4ZDhjMDE4ZCwgMHhkNTY0YjFkNSwgMHg0ZWQyOWM0ZSwgMHhhOWUwNDlhOSwgMHg2Y2I0ZDg2YywgMHg1NmZhYWM1NiwgMHhmNDA3ZjNmNCwgMHhlYTI1Y2ZlYSwgMHg2NWFmY2E2NSwgMHg3YThlZjQ3YSwgMHhhZWU5NDdhZSwgMHgwODE4MTAwOCwgMHhiYWQ1NmZiYSwgMHg3ODg4ZjA3OCwgMHgyNTZmNGEyNSwgMHgyZTcyNWMyZSwgMHgxYzI0MzgxYywgMHhhNmYxNTdhNiwgMHhiNGM3NzNiNCwgMHhjNjUxOTdjNiwgMHhlODIzY2JlOCwgMHhkZDdjYTFkZCwgMHg3NDljZTg3NCwgMHgxZjIxM2UxZiwgMHg0YmRkOTY0YiwgMHhiZGRjNjFiZCwgMHg4Yjg2MGQ4YiwgMHg4YTg1MGY4YSwgMHg3MDkwZTA3MCwgMHgzZTQyN2MzZSwgMHhiNWM0NzFiNSwgMHg2NmFhY2M2NiwgMHg0OGQ4OTA0OCwgMHgwMzA1MDYwMywgMHhmNjAxZjdmNiwgMHgwZTEyMWMwZSwgMHg2MWEzYzI2MSwgMHgzNTVmNmEzNSwgMHg1N2Y5YWU1NywgMHhiOWQwNjliOSwgMHg4NjkxMTc4NiwgMHhjMTU4OTljMSwgMHgxZDI3M2ExZCwgMHg5ZWI5Mjc5ZSwgMHhlMTM4ZDllMSwgMHhmODEzZWJmOCwgMHg5OGIzMmI5OCwgMHgxMTMzMjIxMSwgMHg2OWJiZDI2OSwgMHhkOTcwYTlkOSwgMHg4ZTg5MDc4ZSwgMHg5NGE3MzM5NCwgMHg5YmI2MmQ5YiwgMHgxZTIyM2MxZSwgMHg4NzkyMTU4NywgMHhlOTIwYzllOSwgMHhjZTQ5ODdjZSwgMHg1NWZmYWE1NSwgMHgyODc4NTAyOCwgMHhkZjdhYTVkZiwgMHg4YzhmMDM4YywgMHhhMWY4NTlhMSwgMHg4OTgwMDk4OSwgMHgwZDE3MWEwZCwgMHhiZmRhNjViZiwgMHhlNjMxZDdlNiwgMHg0MmM2ODQ0MiwgMHg2OGI4ZDA2OCwgMHg0MWMzODI0MSwgMHg5OWIwMjk5OSwgMHgyZDc3NWEyZCwgMHgwZjExMWUwZiwgMHhiMGNiN2JiMCwgMHg1NGZjYTg1NCwgMHhiYmQ2NmRiYiwgMHgxNjNhMmMxNl07XG5jb25zdCBUNCA9IFsweDYzNjNhNWM2LCAweDdjN2M4NGY4LCAweDc3Nzc5OWVlLCAweDdiN2I4ZGY2LCAweGYyZjIwZGZmLCAweDZiNmJiZGQ2LCAweDZmNmZiMWRlLCAweGM1YzU1NDkxLCAweDMwMzA1MDYwLCAweDAxMDEwMzAyLCAweDY3NjdhOWNlLCAweDJiMmI3ZDU2LCAweGZlZmUxOWU3LCAweGQ3ZDc2MmI1LCAweGFiYWJlNjRkLCAweDc2NzY5YWVjLCAweGNhY2E0NThmLCAweDgyODI5ZDFmLCAweGM5Yzk0MDg5LCAweDdkN2Q4N2ZhLCAweGZhZmExNWVmLCAweDU5NTllYmIyLCAweDQ3NDdjOThlLCAweGYwZjAwYmZiLCAweGFkYWRlYzQxLCAweGQ0ZDQ2N2IzLCAweGEyYTJmZDVmLCAweGFmYWZlYTQ1LCAweDljOWNiZjIzLCAweGE0YTRmNzUzLCAweDcyNzI5NmU0LCAweGMwYzA1YjliLCAweGI3YjdjMjc1LCAweGZkZmQxY2UxLCAweDkzOTNhZTNkLCAweDI2MjY2YTRjLCAweDM2MzY1YTZjLCAweDNmM2Y0MTdlLCAweGY3ZjcwMmY1LCAweGNjY2M0ZjgzLCAweDM0MzQ1YzY4LCAweGE1YTVmNDUxLCAweGU1ZTUzNGQxLCAweGYxZjEwOGY5LCAweDcxNzE5M2UyLCAweGQ4ZDg3M2FiLCAweDMxMzE1MzYyLCAweDE1MTUzZjJhLCAweDA0MDQwYzA4LCAweGM3Yzc1Mjk1LCAweDIzMjM2NTQ2LCAweGMzYzM1ZTlkLCAweDE4MTgyODMwLCAweDk2OTZhMTM3LCAweDA1MDUwZjBhLCAweDlhOWFiNTJmLCAweDA3MDcwOTBlLCAweDEyMTIzNjI0LCAweDgwODA5YjFiLCAweGUyZTIzZGRmLCAweGViZWIyNmNkLCAweDI3Mjc2OTRlLCAweGIyYjJjZDdmLCAweDc1NzU5ZmVhLCAweDA5MDkxYjEyLCAweDgzODM5ZTFkLCAweDJjMmM3NDU4LCAweDFhMWEyZTM0LCAweDFiMWIyZDM2LCAweDZlNmViMmRjLCAweDVhNWFlZWI0LCAweGEwYTBmYjViLCAweDUyNTJmNmE0LCAweDNiM2I0ZDc2LCAweGQ2ZDY2MWI3LCAweGIzYjNjZTdkLCAweDI5Mjk3YjUyLCAweGUzZTMzZWRkLCAweDJmMmY3MTVlLCAweDg0ODQ5NzEzLCAweDUzNTNmNWE2LCAweGQxZDE2OGI5LCAweDAwMDAwMDAwLCAweGVkZWQyY2MxLCAweDIwMjA2MDQwLCAweGZjZmMxZmUzLCAweGIxYjFjODc5LCAweDViNWJlZGI2LCAweDZhNmFiZWQ0LCAweGNiY2I0NjhkLCAweGJlYmVkOTY3LCAweDM5Mzk0YjcyLCAweDRhNGFkZTk0LCAweDRjNGNkNDk4LCAweDU4NThlOGIwLCAweGNmY2Y0YTg1LCAweGQwZDA2YmJiLCAweGVmZWYyYWM1LCAweGFhYWFlNTRmLCAweGZiZmIxNmVkLCAweDQzNDNjNTg2LCAweDRkNGRkNzlhLCAweDMzMzM1NTY2LCAweDg1ODU5NDExLCAweDQ1NDVjZjhhLCAweGY5ZjkxMGU5LCAweDAyMDIwNjA0LCAweDdmN2Y4MWZlLCAweDUwNTBmMGEwLCAweDNjM2M0NDc4LCAweDlmOWZiYTI1LCAweGE4YThlMzRiLCAweDUxNTFmM2EyLCAweGEzYTNmZTVkLCAweDQwNDBjMDgwLCAweDhmOGY4YTA1LCAweDkyOTJhZDNmLCAweDlkOWRiYzIxLCAweDM4Mzg0ODcwLCAweGY1ZjUwNGYxLCAweGJjYmNkZjYzLCAweGI2YjZjMTc3LCAweGRhZGE3NWFmLCAweDIxMjE2MzQyLCAweDEwMTAzMDIwLCAweGZmZmYxYWU1LCAweGYzZjMwZWZkLCAweGQyZDI2ZGJmLCAweGNkY2Q0YzgxLCAweDBjMGMxNDE4LCAweDEzMTMzNTI2LCAweGVjZWMyZmMzLCAweDVmNWZlMWJlLCAweDk3OTdhMjM1LCAweDQ0NDRjYzg4LCAweDE3MTczOTJlLCAweGM0YzQ1NzkzLCAweGE3YTdmMjU1LCAweDdlN2U4MmZjLCAweDNkM2Q0NzdhLCAweDY0NjRhY2M4LCAweDVkNWRlN2JhLCAweDE5MTkyYjMyLCAweDczNzM5NWU2LCAweDYwNjBhMGMwLCAweDgxODE5ODE5LCAweDRmNGZkMTllLCAweGRjZGM3ZmEzLCAweDIyMjI2NjQ0LCAweDJhMmE3ZTU0LCAweDkwOTBhYjNiLCAweDg4ODg4MzBiLCAweDQ2NDZjYThjLCAweGVlZWUyOWM3LCAweGI4YjhkMzZiLCAweDE0MTQzYzI4LCAweGRlZGU3OWE3LCAweDVlNWVlMmJjLCAweDBiMGIxZDE2LCAweGRiZGI3NmFkLCAweGUwZTAzYmRiLCAweDMyMzI1NjY0LCAweDNhM2E0ZTc0LCAweDBhMGExZTE0LCAweDQ5NDlkYjkyLCAweDA2MDYwYTBjLCAweDI0MjQ2YzQ4LCAweDVjNWNlNGI4LCAweGMyYzI1ZDlmLCAweGQzZDM2ZWJkLCAweGFjYWNlZjQzLCAweDYyNjJhNmM0LCAweDkxOTFhODM5LCAweDk1OTVhNDMxLCAweGU0ZTQzN2QzLCAweDc5Nzk4YmYyLCAweGU3ZTczMmQ1LCAweGM4Yzg0MzhiLCAweDM3Mzc1OTZlLCAweDZkNmRiN2RhLCAweDhkOGQ4YzAxLCAweGQ1ZDU2NGIxLCAweDRlNGVkMjljLCAweGE5YTllMDQ5LCAweDZjNmNiNGQ4LCAweDU2NTZmYWFjLCAweGY0ZjQwN2YzLCAweGVhZWEyNWNmLCAweDY1NjVhZmNhLCAweDdhN2E4ZWY0LCAweGFlYWVlOTQ3LCAweDA4MDgxODEwLCAweGJhYmFkNTZmLCAweDc4Nzg4OGYwLCAweDI1MjU2ZjRhLCAweDJlMmU3MjVjLCAweDFjMWMyNDM4LCAweGE2YTZmMTU3LCAweGI0YjRjNzczLCAweGM2YzY1MTk3LCAweGU4ZTgyM2NiLCAweGRkZGQ3Y2ExLCAweDc0NzQ5Y2U4LCAweDFmMWYyMTNlLCAweDRiNGJkZDk2LCAweGJkYmRkYzYxLCAweDhiOGI4NjBkLCAweDhhOGE4NTBmLCAweDcwNzA5MGUwLCAweDNlM2U0MjdjLCAweGI1YjVjNDcxLCAweDY2NjZhYWNjLCAweDQ4NDhkODkwLCAweDAzMDMwNTA2LCAweGY2ZjYwMWY3LCAweDBlMGUxMjFjLCAweDYxNjFhM2MyLCAweDM1MzU1ZjZhLCAweDU3NTdmOWFlLCAweGI5YjlkMDY5LCAweDg2ODY5MTE3LCAweGMxYzE1ODk5LCAweDFkMWQyNzNhLCAweDllOWViOTI3LCAweGUxZTEzOGQ5LCAweGY4ZjgxM2ViLCAweDk4OThiMzJiLCAweDExMTEzMzIyLCAweDY5NjliYmQyLCAweGQ5ZDk3MGE5LCAweDhlOGU4OTA3LCAweDk0OTRhNzMzLCAweDliOWJiNjJkLCAweDFlMWUyMjNjLCAweDg3ODc5MjE1LCAweGU5ZTkyMGM5LCAweGNlY2U0OTg3LCAweDU1NTVmZmFhLCAweDI4Mjg3ODUwLCAweGRmZGY3YWE1LCAweDhjOGM4ZjAzLCAweGExYTFmODU5LCAweDg5ODk4MDA5LCAweDBkMGQxNzFhLCAweGJmYmZkYTY1LCAweGU2ZTYzMWQ3LCAweDQyNDJjNjg0LCAweDY4NjhiOGQwLCAweDQxNDFjMzgyLCAweDk5OTliMDI5LCAweDJkMmQ3NzVhLCAweDBmMGYxMTFlLCAweGIwYjBjYjdiLCAweDU0NTRmY2E4LCAweGJiYmJkNjZkLCAweDE2MTYzYTJjXTtcbi8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjcnlwdGlvblxuY29uc3QgVDUgPSBbMHg1MWY0YTc1MCwgMHg3ZTQxNjU1MywgMHgxYTE3YTRjMywgMHgzYTI3NWU5NiwgMHgzYmFiNmJjYiwgMHgxZjlkNDVmMSwgMHhhY2ZhNThhYiwgMHg0YmUzMDM5MywgMHgyMDMwZmE1NSwgMHhhZDc2NmRmNiwgMHg4OGNjNzY5MSwgMHhmNTAyNGMyNSwgMHg0ZmU1ZDdmYywgMHhjNTJhY2JkNywgMHgyNjM1NDQ4MCwgMHhiNTYyYTM4ZiwgMHhkZWIxNWE0OSwgMHgyNWJhMWI2NywgMHg0NWVhMGU5OCwgMHg1ZGZlYzBlMSwgMHhjMzJmNzUwMiwgMHg4MTRjZjAxMiwgMHg4ZDQ2OTdhMywgMHg2YmQzZjljNiwgMHgwMzhmNWZlNywgMHgxNTkyOWM5NSwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHhkNGJlODMyZCwgMHg1ODc0MjFkMywgMHg0OWUwNjkyOSwgMHg4ZWM5Yzg0NCwgMHg3NWMyODk2YSwgMHhmNDhlNzk3OCwgMHg5OTU4M2U2YiwgMHgyN2I5NzFkZCwgMHhiZWUxNGZiNiwgMHhmMDg4YWQxNywgMHhjOTIwYWM2NiwgMHg3ZGNlM2FiNCwgMHg2M2RmNGExOCwgMHhlNTFhMzE4MiwgMHg5NzUxMzM2MCwgMHg2MjUzN2Y0NSwgMHhiMTY0NzdlMCwgMHhiYjZiYWU4NCwgMHhmZTgxYTAxYywgMHhmOTA4MmI5NCwgMHg3MDQ4Njg1OCwgMHg4ZjQ1ZmQxOSwgMHg5NGRlNmM4NywgMHg1MjdiZjhiNywgMHhhYjczZDMyMywgMHg3MjRiMDJlMiwgMHhlMzFmOGY1NywgMHg2NjU1YWIyYSwgMHhiMmViMjgwNywgMHgyZmI1YzIwMywgMHg4NmM1N2I5YSwgMHhkMzM3MDhhNSwgMHgzMDI4ODdmMiwgMHgyM2JmYTViMiwgMHgwMjAzNmFiYSwgMHhlZDE2ODI1YywgMHg4YWNmMWMyYiwgMHhhNzc5YjQ5MiwgMHhmMzA3ZjJmMCwgMHg0ZTY5ZTJhMSwgMHg2NWRhZjRjZCwgMHgwNjA1YmVkNSwgMHhkMTM0NjIxZiwgMHhjNGE2ZmU4YSwgMHgzNDJlNTM5ZCwgMHhhMmYzNTVhMCwgMHgwNThhZTEzMiwgMHhhNGY2ZWI3NSwgMHgwYjgzZWMzOSwgMHg0MDYwZWZhYSwgMHg1ZTcxOWYwNiwgMHhiZDZlMTA1MSwgMHgzZTIxOGFmOSwgMHg5NmRkMDYzZCwgMHhkZDNlMDVhZSwgMHg0ZGU2YmQ0NiwgMHg5MTU0OGRiNSwgMHg3MWM0NWQwNSwgMHgwNDA2ZDQ2ZiwgMHg2MDUwMTVmZiwgMHgxOTk4ZmIyNCwgMHhkNmJkZTk5NywgMHg4OTQwNDNjYywgMHg2N2Q5OWU3NywgMHhiMGU4NDJiZCwgMHgwNzg5OGI4OCwgMHhlNzE5NWIzOCwgMHg3OWM4ZWVkYiwgMHhhMTdjMGE0NywgMHg3YzQyMGZlOSwgMHhmODg0MWVjOSwgMHgwMDAwMDAwMCwgMHgwOTgwODY4MywgMHgzMjJiZWQ0OCwgMHgxZTExNzBhYywgMHg2YzVhNzI0ZSwgMHhmZDBlZmZmYiwgMHgwZjg1Mzg1NiwgMHgzZGFlZDUxZSwgMHgzNjJkMzkyNywgMHgwYTBmZDk2NCwgMHg2ODVjYTYyMSwgMHg5YjViNTRkMSwgMHgyNDM2MmUzYSwgMHgwYzBhNjdiMSwgMHg5MzU3ZTcwZiwgMHhiNGVlOTZkMiwgMHgxYjliOTE5ZSwgMHg4MGMwYzU0ZiwgMHg2MWRjMjBhMiwgMHg1YTc3NGI2OSwgMHgxYzEyMWExNiwgMHhlMjkzYmEwYSwgMHhjMGEwMmFlNSwgMHgzYzIyZTA0MywgMHgxMjFiMTcxZCwgMHgwZTA5MGQwYiwgMHhmMjhiYzdhZCwgMHgyZGI2YThiOSwgMHgxNDFlYTljOCwgMHg1N2YxMTk4NSwgMHhhZjc1MDc0YywgMHhlZTk5ZGRiYiwgMHhhMzdmNjBmZCwgMHhmNzAxMjY5ZiwgMHg1YzcyZjViYywgMHg0NDY2M2JjNSwgMHg1YmZiN2UzNCwgMHg4YjQzMjk3NiwgMHhjYjIzYzZkYywgMHhiNmVkZmM2OCwgMHhiOGU0ZjE2MywgMHhkNzMxZGNjYSwgMHg0MjYzODUxMCwgMHgxMzk3MjI0MCwgMHg4NGM2MTEyMCwgMHg4NTRhMjQ3ZCwgMHhkMmJiM2RmOCwgMHhhZWY5MzIxMSwgMHhjNzI5YTE2ZCwgMHgxZDllMmY0YiwgMHhkY2IyMzBmMywgMHgwZDg2NTJlYywgMHg3N2MxZTNkMCwgMHgyYmIzMTY2YywgMHhhOTcwYjk5OSwgMHgxMTk0NDhmYSwgMHg0N2U5NjQyMiwgMHhhOGZjOGNjNCwgMHhhMGYwM2YxYSwgMHg1NjdkMmNkOCwgMHgyMjMzOTBlZiwgMHg4NzQ5NGVjNywgMHhkOTM4ZDFjMSwgMHg4Y2NhYTJmZSwgMHg5OGQ0MGIzNiwgMHhhNmY1ODFjZiwgMHhhNTdhZGUyOCwgMHhkYWI3OGUyNiwgMHgzZmFkYmZhNCwgMHgyYzNhOWRlNCwgMHg1MDc4OTIwZCwgMHg2YTVmY2M5YiwgMHg1NDdlNDY2MiwgMHhmNjhkMTNjMiwgMHg5MGQ4YjhlOCwgMHgyZTM5Zjc1ZSwgMHg4MmMzYWZmNSwgMHg5ZjVkODBiZSwgMHg2OWQwOTM3YywgMHg2ZmQ1MmRhOSwgMHhjZjI1MTJiMywgMHhjOGFjOTkzYiwgMHgxMDE4N2RhNywgMHhlODljNjM2ZSwgMHhkYjNiYmI3YiwgMHhjZDI2NzgwOSwgMHg2ZTU5MThmNCwgMHhlYzlhYjcwMSwgMHg4MzRmOWFhOCwgMHhlNjk1NmU2NSwgMHhhYWZmZTY3ZSwgMHgyMWJjY2YwOCwgMHhlZjE1ZThlNiwgMHhiYWU3OWJkOSwgMHg0YTZmMzZjZSwgMHhlYTlmMDlkNCwgMHgyOWIwN2NkNiwgMHgzMWE0YjJhZiwgMHgyYTNmMjMzMSwgMHhjNmE1OTQzMCwgMHgzNWEyNjZjMCwgMHg3NDRlYmMzNywgMHhmYzgyY2FhNiwgMHhlMDkwZDBiMCwgMHgzM2E3ZDgxNSwgMHhmMTA0OTg0YSwgMHg0MWVjZGFmNywgMHg3ZmNkNTAwZSwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg0M2VmYjA0ZCwgMHhjY2FhNGQ1NCwgMHhlNDk2MDRkZiwgMHg5ZWQxYjVlMywgMHg0YzZhODgxYiwgMHhjMTJjMWZiOCwgMHg0NjY1NTE3ZiwgMHg5ZDVlZWEwNCwgMHgwMThjMzU1ZCwgMHhmYTg3NzQ3MywgMHhmYjBiNDEyZSwgMHhiMzY3MWQ1YSwgMHg5MmRiZDI1MiwgMHhlOTEwNTYzMywgMHg2ZGQ2NDcxMywgMHg5YWQ3NjE4YywgMHgzN2ExMGM3YSwgMHg1OWY4MTQ4ZSwgMHhlYjEzM2M4OSwgMHhjZWE5MjdlZSwgMHhiNzYxYzkzNSwgMHhlMTFjZTVlZCwgMHg3YTQ3YjEzYywgMHg5Y2QyZGY1OSwgMHg1NWYyNzMzZiwgMHgxODE0Y2U3OSwgMHg3M2M3MzdiZiwgMHg1M2Y3Y2RlYSwgMHg1ZmZkYWE1YiwgMHhkZjNkNmYxNCwgMHg3ODQ0ZGI4NiwgMHhjYWFmZjM4MSwgMHhiOTY4YzQzZSwgMHgzODI0MzQyYywgMHhjMmEzNDA1ZiwgMHgxNjFkYzM3MiwgMHhiY2UyMjUwYywgMHgyODNjNDk4YiwgMHhmZjBkOTU0MSwgMHgzOWE4MDE3MSwgMHgwODBjYjNkZSwgMHhkOGI0ZTQ5YywgMHg2NDU2YzE5MCwgMHg3YmNiODQ2MSwgMHhkNTMyYjY3MCwgMHg0ODZjNWM3NCwgMHhkMGI4NTc0Ml07XG5jb25zdCBUNiA9IFsweDUwNTFmNGE3LCAweDUzN2U0MTY1LCAweGMzMWExN2E0LCAweDk2M2EyNzVlLCAweGNiM2JhYjZiLCAweGYxMWY5ZDQ1LCAweGFiYWNmYTU4LCAweDkzNGJlMzAzLCAweDU1MjAzMGZhLCAweGY2YWQ3NjZkLCAweDkxODhjYzc2LCAweDI1ZjUwMjRjLCAweGZjNGZlNWQ3LCAweGQ3YzUyYWNiLCAweDgwMjYzNTQ0LCAweDhmYjU2MmEzLCAweDQ5ZGViMTVhLCAweDY3MjViYTFiLCAweDk4NDVlYTBlLCAweGUxNWRmZWMwLCAweDAyYzMyZjc1LCAweDEyODE0Y2YwLCAweGEzOGQ0Njk3LCAweGM2NmJkM2Y5LCAweGU3MDM4ZjVmLCAweDk1MTU5MjljLCAweGViYmY2ZDdhLCAweGRhOTU1MjU5LCAweDJkZDRiZTgzLCAweGQzNTg3NDIxLCAweDI5NDllMDY5LCAweDQ0OGVjOWM4LCAweDZhNzVjMjg5LCAweDc4ZjQ4ZTc5LCAweDZiOTk1ODNlLCAweGRkMjdiOTcxLCAweGI2YmVlMTRmLCAweDE3ZjA4OGFkLCAweDY2YzkyMGFjLCAweGI0N2RjZTNhLCAweDE4NjNkZjRhLCAweDgyZTUxYTMxLCAweDYwOTc1MTMzLCAweDQ1NjI1MzdmLCAweGUwYjE2NDc3LCAweDg0YmI2YmFlLCAweDFjZmU4MWEwLCAweDk0ZjkwODJiLCAweDU4NzA0ODY4LCAweDE5OGY0NWZkLCAweDg3OTRkZTZjLCAweGI3NTI3YmY4LCAweDIzYWI3M2QzLCAweGUyNzI0YjAyLCAweDU3ZTMxZjhmLCAweDJhNjY1NWFiLCAweDA3YjJlYjI4LCAweDAzMmZiNWMyLCAweDlhODZjNTdiLCAweGE1ZDMzNzA4LCAweGYyMzAyODg3LCAweGIyMjNiZmE1LCAweGJhMDIwMzZhLCAweDVjZWQxNjgyLCAweDJiOGFjZjFjLCAweDkyYTc3OWI0LCAweGYwZjMwN2YyLCAweGExNGU2OWUyLCAweGNkNjVkYWY0LCAweGQ1MDYwNWJlLCAweDFmZDEzNDYyLCAweDhhYzRhNmZlLCAweDlkMzQyZTUzLCAweGEwYTJmMzU1LCAweDMyMDU4YWUxLCAweDc1YTRmNmViLCAweDM5MGI4M2VjLCAweGFhNDA2MGVmLCAweDA2NWU3MTlmLCAweDUxYmQ2ZTEwLCAweGY5M2UyMThhLCAweDNkOTZkZDA2LCAweGFlZGQzZTA1LCAweDQ2NGRlNmJkLCAweGI1OTE1NDhkLCAweDA1NzFjNDVkLCAweDZmMDQwNmQ0LCAweGZmNjA1MDE1LCAweDI0MTk5OGZiLCAweDk3ZDZiZGU5LCAweGNjODk0MDQzLCAweDc3NjdkOTllLCAweGJkYjBlODQyLCAweDg4MDc4OThiLCAweDM4ZTcxOTViLCAweGRiNzljOGVlLCAweDQ3YTE3YzBhLCAweGU5N2M0MjBmLCAweGM5Zjg4NDFlLCAweDAwMDAwMDAwLCAweDgzMDk4MDg2LCAweDQ4MzIyYmVkLCAweGFjMWUxMTcwLCAweDRlNmM1YTcyLCAweGZiZmQwZWZmLCAweDU2MGY4NTM4LCAweDFlM2RhZWQ1LCAweDI3MzYyZDM5LCAweDY0MGEwZmQ5LCAweDIxNjg1Y2E2LCAweGQxOWI1YjU0LCAweDNhMjQzNjJlLCAweGIxMGMwYTY3LCAweDBmOTM1N2U3LCAweGQyYjRlZTk2LCAweDllMWI5YjkxLCAweDRmODBjMGM1LCAweGEyNjFkYzIwLCAweDY5NWE3NzRiLCAweDE2MWMxMjFhLCAweDBhZTI5M2JhLCAweGU1YzBhMDJhLCAweDQzM2MyMmUwLCAweDFkMTIxYjE3LCAweDBiMGUwOTBkLCAweGFkZjI4YmM3LCAweGI5MmRiNmE4LCAweGM4MTQxZWE5LCAweDg1NTdmMTE5LCAweDRjYWY3NTA3LCAweGJiZWU5OWRkLCAweGZkYTM3ZjYwLCAweDlmZjcwMTI2LCAweGJjNWM3MmY1LCAweGM1NDQ2NjNiLCAweDM0NWJmYjdlLCAweDc2OGI0MzI5LCAweGRjY2IyM2M2LCAweDY4YjZlZGZjLCAweDYzYjhlNGYxLCAweGNhZDczMWRjLCAweDEwNDI2Mzg1LCAweDQwMTM5NzIyLCAweDIwODRjNjExLCAweDdkODU0YTI0LCAweGY4ZDJiYjNkLCAweDExYWVmOTMyLCAweDZkYzcyOWExLCAweDRiMWQ5ZTJmLCAweGYzZGNiMjMwLCAweGVjMGQ4NjUyLCAweGQwNzdjMWUzLCAweDZjMmJiMzE2LCAweDk5YTk3MGI5LCAweGZhMTE5NDQ4LCAweDIyNDdlOTY0LCAweGM0YThmYzhjLCAweDFhYTBmMDNmLCAweGQ4NTY3ZDJjLCAweGVmMjIzMzkwLCAweGM3ODc0OTRlLCAweGMxZDkzOGQxLCAweGZlOGNjYWEyLCAweDM2OThkNDBiLCAweGNmYTZmNTgxLCAweDI4YTU3YWRlLCAweDI2ZGFiNzhlLCAweGE0M2ZhZGJmLCAweGU0MmMzYTlkLCAweDBkNTA3ODkyLCAweDliNmE1ZmNjLCAweDYyNTQ3ZTQ2LCAweGMyZjY4ZDEzLCAweGU4OTBkOGI4LCAweDVlMmUzOWY3LCAweGY1ODJjM2FmLCAweGJlOWY1ZDgwLCAweDdjNjlkMDkzLCAweGE5NmZkNTJkLCAweGIzY2YyNTEyLCAweDNiYzhhYzk5LCAweGE3MTAxODdkLCAweDZlZTg5YzYzLCAweDdiZGIzYmJiLCAweDA5Y2QyNjc4LCAweGY0NmU1OTE4LCAweDAxZWM5YWI3LCAweGE4ODM0ZjlhLCAweDY1ZTY5NTZlLCAweDdlYWFmZmU2LCAweDA4MjFiY2NmLCAweGU2ZWYxNWU4LCAweGQ5YmFlNzliLCAweGNlNGE2ZjM2LCAweGQ0ZWE5ZjA5LCAweGQ2MjliMDdjLCAweGFmMzFhNGIyLCAweDMxMmEzZjIzLCAweDMwYzZhNTk0LCAweGMwMzVhMjY2LCAweDM3NzQ0ZWJjLCAweGE2ZmM4MmNhLCAweGIwZTA5MGQwLCAweDE1MzNhN2Q4LCAweDRhZjEwNDk4LCAweGY3NDFlY2RhLCAweDBlN2ZjZDUwLCAweDJmMTc5MWY2LCAweDhkNzY0ZGQ2LCAweDRkNDNlZmIwLCAweDU0Y2NhYTRkLCAweGRmZTQ5NjA0LCAweGUzOWVkMWI1LCAweDFiNGM2YTg4LCAweGI4YzEyYzFmLCAweDdmNDY2NTUxLCAweDA0OWQ1ZWVhLCAweDVkMDE4YzM1LCAweDczZmE4Nzc0LCAweDJlZmIwYjQxLCAweDVhYjM2NzFkLCAweDUyOTJkYmQyLCAweDMzZTkxMDU2LCAweDEzNmRkNjQ3LCAweDhjOWFkNzYxLCAweDdhMzdhMTBjLCAweDhlNTlmODE0LCAweDg5ZWIxMzNjLCAweGVlY2VhOTI3LCAweDM1Yjc2MWM5LCAweGVkZTExY2U1LCAweDNjN2E0N2IxLCAweDU5OWNkMmRmLCAweDNmNTVmMjczLCAweDc5MTgxNGNlLCAweGJmNzNjNzM3LCAweGVhNTNmN2NkLCAweDViNWZmZGFhLCAweDE0ZGYzZDZmLCAweDg2Nzg0NGRiLCAweDgxY2FhZmYzLCAweDNlYjk2OGM0LCAweDJjMzgyNDM0LCAweDVmYzJhMzQwLCAweDcyMTYxZGMzLCAweDBjYmNlMjI1LCAweDhiMjgzYzQ5LCAweDQxZmYwZDk1LCAweDcxMzlhODAxLCAweGRlMDgwY2IzLCAweDljZDhiNGU0LCAweDkwNjQ1NmMxLCAweDYxN2JjYjg0LCAweDcwZDUzMmI2LCAweDc0NDg2YzVjLCAweDQyZDBiODU3XTtcbmNvbnN0IFQ3ID0gWzB4YTc1MDUxZjQsIDB4NjU1MzdlNDEsIDB4YTRjMzFhMTcsIDB4NWU5NjNhMjcsIDB4NmJjYjNiYWIsIDB4NDVmMTFmOWQsIDB4NThhYmFjZmEsIDB4MDM5MzRiZTMsIDB4ZmE1NTIwMzAsIDB4NmRmNmFkNzYsIDB4NzY5MTg4Y2MsIDB4NGMyNWY1MDIsIDB4ZDdmYzRmZTUsIDB4Y2JkN2M1MmEsIDB4NDQ4MDI2MzUsIDB4YTM4ZmI1NjIsIDB4NWE0OWRlYjEsIDB4MWI2NzI1YmEsIDB4MGU5ODQ1ZWEsIDB4YzBlMTVkZmUsIDB4NzUwMmMzMmYsIDB4ZjAxMjgxNGMsIDB4OTdhMzhkNDYsIDB4ZjljNjZiZDMsIDB4NWZlNzAzOGYsIDB4OWM5NTE1OTIsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4ODMyZGQ0YmUsIDB4MjFkMzU4NzQsIDB4NjkyOTQ5ZTAsIDB4Yzg0NDhlYzksIDB4ODk2YTc1YzIsIDB4Nzk3OGY0OGUsIDB4M2U2Yjk5NTgsIDB4NzFkZDI3YjksIDB4NGZiNmJlZTEsIDB4YWQxN2YwODgsIDB4YWM2NmM5MjAsIDB4M2FiNDdkY2UsIDB4NGExODYzZGYsIDB4MzE4MmU1MWEsIDB4MzM2MDk3NTEsIDB4N2Y0NTYyNTMsIDB4NzdlMGIxNjQsIDB4YWU4NGJiNmIsIDB4YTAxY2ZlODEsIDB4MmI5NGY5MDgsIDB4Njg1ODcwNDgsIDB4ZmQxOThmNDUsIDB4NmM4Nzk0ZGUsIDB4ZjhiNzUyN2IsIDB4ZDMyM2FiNzMsIDB4MDJlMjcyNGIsIDB4OGY1N2UzMWYsIDB4YWIyYTY2NTUsIDB4MjgwN2IyZWIsIDB4YzIwMzJmYjUsIDB4N2I5YTg2YzUsIDB4MDhhNWQzMzcsIDB4ODdmMjMwMjgsIDB4YTViMjIzYmYsIDB4NmFiYTAyMDMsIDB4ODI1Y2VkMTYsIDB4MWMyYjhhY2YsIDB4YjQ5MmE3NzksIDB4ZjJmMGYzMDcsIDB4ZTJhMTRlNjksIDB4ZjRjZDY1ZGEsIDB4YmVkNTA2MDUsIDB4NjIxZmQxMzQsIDB4ZmU4YWM0YTYsIDB4NTM5ZDM0MmUsIDB4NTVhMGEyZjMsIDB4ZTEzMjA1OGEsIDB4ZWI3NWE0ZjYsIDB4ZWMzOTBiODMsIDB4ZWZhYTQwNjAsIDB4OWYwNjVlNzEsIDB4MTA1MWJkNmUsIDB4OGFmOTNlMjEsIDB4MDYzZDk2ZGQsIDB4MDVhZWRkM2UsIDB4YmQ0NjRkZTYsIDB4OGRiNTkxNTQsIDB4NWQwNTcxYzQsIDB4ZDQ2ZjA0MDYsIDB4MTVmZjYwNTAsIDB4ZmIyNDE5OTgsIDB4ZTk5N2Q2YmQsIDB4NDNjYzg5NDAsIDB4OWU3NzY3ZDksIDB4NDJiZGIwZTgsIDB4OGI4ODA3ODksIDB4NWIzOGU3MTksIDB4ZWVkYjc5YzgsIDB4MGE0N2ExN2MsIDB4MGZlOTdjNDIsIDB4MWVjOWY4ODQsIDB4MDAwMDAwMDAsIDB4ODY4MzA5ODAsIDB4ZWQ0ODMyMmIsIDB4NzBhYzFlMTEsIDB4NzI0ZTZjNWEsIDB4ZmZmYmZkMGUsIDB4Mzg1NjBmODUsIDB4ZDUxZTNkYWUsIDB4MzkyNzM2MmQsIDB4ZDk2NDBhMGYsIDB4YTYyMTY4NWMsIDB4NTRkMTliNWIsIDB4MmUzYTI0MzYsIDB4NjdiMTBjMGEsIDB4ZTcwZjkzNTcsIDB4OTZkMmI0ZWUsIDB4OTE5ZTFiOWIsIDB4YzU0ZjgwYzAsIDB4MjBhMjYxZGMsIDB4NGI2OTVhNzcsIDB4MWExNjFjMTIsIDB4YmEwYWUyOTMsIDB4MmFlNWMwYTAsIDB4ZTA0MzNjMjIsIDB4MTcxZDEyMWIsIDB4MGQwYjBlMDksIDB4YzdhZGYyOGIsIDB4YThiOTJkYjYsIDB4YTljODE0MWUsIDB4MTk4NTU3ZjEsIDB4MDc0Y2FmNzUsIDB4ZGRiYmVlOTksIDB4NjBmZGEzN2YsIDB4MjY5ZmY3MDEsIDB4ZjViYzVjNzIsIDB4M2JjNTQ0NjYsIDB4N2UzNDViZmIsIDB4Mjk3NjhiNDMsIDB4YzZkY2NiMjMsIDB4ZmM2OGI2ZWQsIDB4ZjE2M2I4ZTQsIDB4ZGNjYWQ3MzEsIDB4ODUxMDQyNjMsIDB4MjI0MDEzOTcsIDB4MTEyMDg0YzYsIDB4MjQ3ZDg1NGEsIDB4M2RmOGQyYmIsIDB4MzIxMWFlZjksIDB4YTE2ZGM3MjksIDB4MmY0YjFkOWUsIDB4MzBmM2RjYjIsIDB4NTJlYzBkODYsIDB4ZTNkMDc3YzEsIDB4MTY2YzJiYjMsIDB4Yjk5OWE5NzAsIDB4NDhmYTExOTQsIDB4NjQyMjQ3ZTksIDB4OGNjNGE4ZmMsIDB4M2YxYWEwZjAsIDB4MmNkODU2N2QsIDB4OTBlZjIyMzMsIDB4NGVjNzg3NDksIDB4ZDFjMWQ5MzgsIDB4YTJmZThjY2EsIDB4MGIzNjk4ZDQsIDB4ODFjZmE2ZjUsIDB4ZGUyOGE1N2EsIDB4OGUyNmRhYjcsIDB4YmZhNDNmYWQsIDB4OWRlNDJjM2EsIDB4OTIwZDUwNzgsIDB4Y2M5YjZhNWYsIDB4NDY2MjU0N2UsIDB4MTNjMmY2OGQsIDB4YjhlODkwZDgsIDB4Zjc1ZTJlMzksIDB4YWZmNTgyYzMsIDB4ODBiZTlmNWQsIDB4OTM3YzY5ZDAsIDB4MmRhOTZmZDUsIDB4MTJiM2NmMjUsIDB4OTkzYmM4YWMsIDB4N2RhNzEwMTgsIDB4NjM2ZWU4OWMsIDB4YmI3YmRiM2IsIDB4NzgwOWNkMjYsIDB4MThmNDZlNTksIDB4YjcwMWVjOWEsIDB4OWFhODgzNGYsIDB4NmU2NWU2OTUsIDB4ZTY3ZWFhZmYsIDB4Y2YwODIxYmMsIDB4ZThlNmVmMTUsIDB4OWJkOWJhZTcsIDB4MzZjZTRhNmYsIDB4MDlkNGVhOWYsIDB4N2NkNjI5YjAsIDB4YjJhZjMxYTQsIDB4MjMzMTJhM2YsIDB4OTQzMGM2YTUsIDB4NjZjMDM1YTIsIDB4YmMzNzc0NGUsIDB4Y2FhNmZjODIsIDB4ZDBiMGUwOTAsIDB4ZDgxNTMzYTcsIDB4OTg0YWYxMDQsIDB4ZGFmNzQxZWMsIDB4NTAwZTdmY2QsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4YjA0ZDQzZWYsIDB4NGQ1NGNjYWEsIDB4MDRkZmU0OTYsIDB4YjVlMzllZDEsIDB4ODgxYjRjNmEsIDB4MWZiOGMxMmMsIDB4NTE3ZjQ2NjUsIDB4ZWEwNDlkNWUsIDB4MzU1ZDAxOGMsIDB4NzQ3M2ZhODcsIDB4NDEyZWZiMGIsIDB4MWQ1YWIzNjcsIDB4ZDI1MjkyZGIsIDB4NTYzM2U5MTAsIDB4NDcxMzZkZDYsIDB4NjE4YzlhZDcsIDB4MGM3YTM3YTEsIDB4MTQ4ZTU5ZjgsIDB4M2M4OWViMTMsIDB4MjdlZWNlYTksIDB4YzkzNWI3NjEsIDB4ZTVlZGUxMWMsIDB4YjEzYzdhNDcsIDB4ZGY1OTljZDIsIDB4NzMzZjU1ZjIsIDB4Y2U3OTE4MTQsIDB4MzdiZjczYzcsIDB4Y2RlYTUzZjcsIDB4YWE1YjVmZmQsIDB4NmYxNGRmM2QsIDB4ZGI4Njc4NDQsIDB4ZjM4MWNhYWYsIDB4YzQzZWI5NjgsIDB4MzQyYzM4MjQsIDB4NDA1ZmMyYTMsIDB4YzM3MjE2MWQsIDB4MjUwY2JjZTIsIDB4NDk4YjI4M2MsIDB4OTU0MWZmMGQsIDB4MDE3MTM5YTgsIDB4YjNkZTA4MGMsIDB4ZTQ5Y2Q4YjQsIDB4YzE5MDY0NTYsIDB4ODQ2MTdiY2IsIDB4YjY3MGQ1MzIsIDB4NWM3NDQ4NmMsIDB4NTc0MmQwYjhdO1xuY29uc3QgVDggPSBbMHhmNGE3NTA1MSwgMHg0MTY1NTM3ZSwgMHgxN2E0YzMxYSwgMHgyNzVlOTYzYSwgMHhhYjZiY2IzYiwgMHg5ZDQ1ZjExZiwgMHhmYTU4YWJhYywgMHhlMzAzOTM0YiwgMHgzMGZhNTUyMCwgMHg3NjZkZjZhZCwgMHhjYzc2OTE4OCwgMHgwMjRjMjVmNSwgMHhlNWQ3ZmM0ZiwgMHgyYWNiZDdjNSwgMHgzNTQ0ODAyNiwgMHg2MmEzOGZiNSwgMHhiMTVhNDlkZSwgMHhiYTFiNjcyNSwgMHhlYTBlOTg0NSwgMHhmZWMwZTE1ZCwgMHgyZjc1MDJjMywgMHg0Y2YwMTI4MSwgMHg0Njk3YTM4ZCwgMHhkM2Y5YzY2YiwgMHg4ZjVmZTcwMywgMHg5MjljOTUxNSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHhiZTgzMmRkNCwgMHg3NDIxZDM1OCwgMHhlMDY5Mjk0OSwgMHhjOWM4NDQ4ZSwgMHhjMjg5NmE3NSwgMHg4ZTc5NzhmNCwgMHg1ODNlNmI5OSwgMHhiOTcxZGQyNywgMHhlMTRmYjZiZSwgMHg4OGFkMTdmMCwgMHgyMGFjNjZjOSwgMHhjZTNhYjQ3ZCwgMHhkZjRhMTg2MywgMHgxYTMxODJlNSwgMHg1MTMzNjA5NywgMHg1MzdmNDU2MiwgMHg2NDc3ZTBiMSwgMHg2YmFlODRiYiwgMHg4MWEwMWNmZSwgMHgwODJiOTRmOSwgMHg0ODY4NTg3MCwgMHg0NWZkMTk4ZiwgMHhkZTZjODc5NCwgMHg3YmY4Yjc1MiwgMHg3M2QzMjNhYiwgMHg0YjAyZTI3MiwgMHgxZjhmNTdlMywgMHg1NWFiMmE2NiwgMHhlYjI4MDdiMiwgMHhiNWMyMDMyZiwgMHhjNTdiOWE4NiwgMHgzNzA4YTVkMywgMHgyODg3ZjIzMCwgMHhiZmE1YjIyMywgMHgwMzZhYmEwMiwgMHgxNjgyNWNlZCwgMHhjZjFjMmI4YSwgMHg3OWI0OTJhNywgMHgwN2YyZjBmMywgMHg2OWUyYTE0ZSwgMHhkYWY0Y2Q2NSwgMHgwNWJlZDUwNiwgMHgzNDYyMWZkMSwgMHhhNmZlOGFjNCwgMHgyZTUzOWQzNCwgMHhmMzU1YTBhMiwgMHg4YWUxMzIwNSwgMHhmNmViNzVhNCwgMHg4M2VjMzkwYiwgMHg2MGVmYWE0MCwgMHg3MTlmMDY1ZSwgMHg2ZTEwNTFiZCwgMHgyMThhZjkzZSwgMHhkZDA2M2Q5NiwgMHgzZTA1YWVkZCwgMHhlNmJkNDY0ZCwgMHg1NDhkYjU5MSwgMHhjNDVkMDU3MSwgMHgwNmQ0NmYwNCwgMHg1MDE1ZmY2MCwgMHg5OGZiMjQxOSwgMHhiZGU5OTdkNiwgMHg0MDQzY2M4OSwgMHhkOTllNzc2NywgMHhlODQyYmRiMCwgMHg4OThiODgwNywgMHgxOTViMzhlNywgMHhjOGVlZGI3OSwgMHg3YzBhNDdhMSwgMHg0MjBmZTk3YywgMHg4NDFlYzlmOCwgMHgwMDAwMDAwMCwgMHg4MDg2ODMwOSwgMHgyYmVkNDgzMiwgMHgxMTcwYWMxZSwgMHg1YTcyNGU2YywgMHgwZWZmZmJmZCwgMHg4NTM4NTYwZiwgMHhhZWQ1MWUzZCwgMHgyZDM5MjczNiwgMHgwZmQ5NjQwYSwgMHg1Y2E2MjE2OCwgMHg1YjU0ZDE5YiwgMHgzNjJlM2EyNCwgMHgwYTY3YjEwYywgMHg1N2U3MGY5MywgMHhlZTk2ZDJiNCwgMHg5YjkxOWUxYiwgMHhjMGM1NGY4MCwgMHhkYzIwYTI2MSwgMHg3NzRiNjk1YSwgMHgxMjFhMTYxYywgMHg5M2JhMGFlMiwgMHhhMDJhZTVjMCwgMHgyMmUwNDMzYywgMHgxYjE3MWQxMiwgMHgwOTBkMGIwZSwgMHg4YmM3YWRmMiwgMHhiNmE4YjkyZCwgMHgxZWE5YzgxNCwgMHhmMTE5ODU1NywgMHg3NTA3NGNhZiwgMHg5OWRkYmJlZSwgMHg3ZjYwZmRhMywgMHgwMTI2OWZmNywgMHg3MmY1YmM1YywgMHg2NjNiYzU0NCwgMHhmYjdlMzQ1YiwgMHg0MzI5NzY4YiwgMHgyM2M2ZGNjYiwgMHhlZGZjNjhiNiwgMHhlNGYxNjNiOCwgMHgzMWRjY2FkNywgMHg2Mzg1MTA0MiwgMHg5NzIyNDAxMywgMHhjNjExMjA4NCwgMHg0YTI0N2Q4NSwgMHhiYjNkZjhkMiwgMHhmOTMyMTFhZSwgMHgyOWExNmRjNywgMHg5ZTJmNGIxZCwgMHhiMjMwZjNkYywgMHg4NjUyZWMwZCwgMHhjMWUzZDA3NywgMHhiMzE2NmMyYiwgMHg3MGI5OTlhOSwgMHg5NDQ4ZmExMSwgMHhlOTY0MjI0NywgMHhmYzhjYzRhOCwgMHhmMDNmMWFhMCwgMHg3ZDJjZDg1NiwgMHgzMzkwZWYyMiwgMHg0OTRlYzc4NywgMHgzOGQxYzFkOSwgMHhjYWEyZmU4YywgMHhkNDBiMzY5OCwgMHhmNTgxY2ZhNiwgMHg3YWRlMjhhNSwgMHhiNzhlMjZkYSwgMHhhZGJmYTQzZiwgMHgzYTlkZTQyYywgMHg3ODkyMGQ1MCwgMHg1ZmNjOWI2YSwgMHg3ZTQ2NjI1NCwgMHg4ZDEzYzJmNiwgMHhkOGI4ZTg5MCwgMHgzOWY3NWUyZSwgMHhjM2FmZjU4MiwgMHg1ZDgwYmU5ZiwgMHhkMDkzN2M2OSwgMHhkNTJkYTk2ZiwgMHgyNTEyYjNjZiwgMHhhYzk5M2JjOCwgMHgxODdkYTcxMCwgMHg5YzYzNmVlOCwgMHgzYmJiN2JkYiwgMHgyNjc4MDljZCwgMHg1OTE4ZjQ2ZSwgMHg5YWI3MDFlYywgMHg0ZjlhYTg4MywgMHg5NTZlNjVlNiwgMHhmZmU2N2VhYSwgMHhiY2NmMDgyMSwgMHgxNWU4ZTZlZiwgMHhlNzliZDliYSwgMHg2ZjM2Y2U0YSwgMHg5ZjA5ZDRlYSwgMHhiMDdjZDYyOSwgMHhhNGIyYWYzMSwgMHgzZjIzMzEyYSwgMHhhNTk0MzBjNiwgMHhhMjY2YzAzNSwgMHg0ZWJjMzc3NCwgMHg4MmNhYTZmYywgMHg5MGQwYjBlMCwgMHhhN2Q4MTUzMywgMHgwNDk4NGFmMSwgMHhlY2RhZjc0MSwgMHhjZDUwMGU3ZiwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHhlZmIwNGQ0MywgMHhhYTRkNTRjYywgMHg5NjA0ZGZlNCwgMHhkMWI1ZTM5ZSwgMHg2YTg4MWI0YywgMHgyYzFmYjhjMSwgMHg2NTUxN2Y0NiwgMHg1ZWVhMDQ5ZCwgMHg4YzM1NWQwMSwgMHg4Nzc0NzNmYSwgMHgwYjQxMmVmYiwgMHg2NzFkNWFiMywgMHhkYmQyNTI5MiwgMHgxMDU2MzNlOSwgMHhkNjQ3MTM2ZCwgMHhkNzYxOGM5YSwgMHhhMTBjN2EzNywgMHhmODE0OGU1OSwgMHgxMzNjODllYiwgMHhhOTI3ZWVjZSwgMHg2MWM5MzViNywgMHgxY2U1ZWRlMSwgMHg0N2IxM2M3YSwgMHhkMmRmNTk5YywgMHhmMjczM2Y1NSwgMHgxNGNlNzkxOCwgMHhjNzM3YmY3MywgMHhmN2NkZWE1MywgMHhmZGFhNWI1ZiwgMHgzZDZmMTRkZiwgMHg0NGRiODY3OCwgMHhhZmYzODFjYSwgMHg2OGM0M2ViOSwgMHgyNDM0MmMzOCwgMHhhMzQwNWZjMiwgMHgxZGMzNzIxNiwgMHhlMjI1MGNiYywgMHgzYzQ5OGIyOCwgMHgwZDk1NDFmZiwgMHhhODAxNzEzOSwgMHgwY2IzZGUwOCwgMHhiNGU0OWNkOCwgMHg1NmMxOTA2NCwgMHhjYjg0NjE3YiwgMHgzMmI2NzBkNSwgMHg2YzVjNzQ0OCwgMHhiODU3NDJkMF07XG4vLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb24ga2V5IGV4cGFuc2lvblxuY29uc3QgVTEgPSBbMHgwMDAwMDAwMCwgMHgwZTA5MGQwYiwgMHgxYzEyMWExNiwgMHgxMjFiMTcxZCwgMHgzODI0MzQyYywgMHgzNjJkMzkyNywgMHgyNDM2MmUzYSwgMHgyYTNmMjMzMSwgMHg3MDQ4Njg1OCwgMHg3ZTQxNjU1MywgMHg2YzVhNzI0ZSwgMHg2MjUzN2Y0NSwgMHg0ODZjNWM3NCwgMHg0NjY1NTE3ZiwgMHg1NDdlNDY2MiwgMHg1YTc3NGI2OSwgMHhlMDkwZDBiMCwgMHhlZTk5ZGRiYiwgMHhmYzgyY2FhNiwgMHhmMjhiYzdhZCwgMHhkOGI0ZTQ5YywgMHhkNmJkZTk5NywgMHhjNGE2ZmU4YSwgMHhjYWFmZjM4MSwgMHg5MGQ4YjhlOCwgMHg5ZWQxYjVlMywgMHg4Y2NhYTJmZSwgMHg4MmMzYWZmNSwgMHhhOGZjOGNjNCwgMHhhNmY1ODFjZiwgMHhiNGVlOTZkMiwgMHhiYWU3OWJkOSwgMHhkYjNiYmI3YiwgMHhkNTMyYjY3MCwgMHhjNzI5YTE2ZCwgMHhjOTIwYWM2NiwgMHhlMzFmOGY1NywgMHhlZDE2ODI1YywgMHhmZjBkOTU0MSwgMHhmMTA0OTg0YSwgMHhhYjczZDMyMywgMHhhNTdhZGUyOCwgMHhiNzYxYzkzNSwgMHhiOTY4YzQzZSwgMHg5MzU3ZTcwZiwgMHg5ZDVlZWEwNCwgMHg4ZjQ1ZmQxOSwgMHg4MTRjZjAxMiwgMHgzYmFiNmJjYiwgMHgzNWEyNjZjMCwgMHgyN2I5NzFkZCwgMHgyOWIwN2NkNiwgMHgwMzhmNWZlNywgMHgwZDg2NTJlYywgMHgxZjlkNDVmMSwgMHgxMTk0NDhmYSwgMHg0YmUzMDM5MywgMHg0NWVhMGU5OCwgMHg1N2YxMTk4NSwgMHg1OWY4MTQ4ZSwgMHg3M2M3MzdiZiwgMHg3ZGNlM2FiNCwgMHg2ZmQ1MmRhOSwgMHg2MWRjMjBhMiwgMHhhZDc2NmRmNiwgMHhhMzdmNjBmZCwgMHhiMTY0NzdlMCwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHg5YjViNTRkMSwgMHg4OTQwNDNjYywgMHg4NzQ5NGVjNywgMHhkZDNlMDVhZSwgMHhkMzM3MDhhNSwgMHhjMTJjMWZiOCwgMHhjZjI1MTJiMywgMHhlNTFhMzE4MiwgMHhlYjEzM2M4OSwgMHhmOTA4MmI5NCwgMHhmNzAxMjY5ZiwgMHg0ZGU2YmQ0NiwgMHg0M2VmYjA0ZCwgMHg1MWY0YTc1MCwgMHg1ZmZkYWE1YiwgMHg3NWMyODk2YSwgMHg3YmNiODQ2MSwgMHg2OWQwOTM3YywgMHg2N2Q5OWU3NywgMHgzZGFlZDUxZSwgMHgzM2E3ZDgxNSwgMHgyMWJjY2YwOCwgMHgyZmI1YzIwMywgMHgwNThhZTEzMiwgMHgwYjgzZWMzOSwgMHgxOTk4ZmIyNCwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg3ODQ0ZGI4NiwgMHg2YTVmY2M5YiwgMHg2NDU2YzE5MCwgMHg0ZTY5ZTJhMSwgMHg0MDYwZWZhYSwgMHg1MjdiZjhiNywgMHg1YzcyZjViYywgMHgwNjA1YmVkNSwgMHgwODBjYjNkZSwgMHgxYTE3YTRjMywgMHgxNDFlYTljOCwgMHgzZTIxOGFmOSwgMHgzMDI4ODdmMiwgMHgyMjMzOTBlZiwgMHgyYzNhOWRlNCwgMHg5NmRkMDYzZCwgMHg5OGQ0MGIzNiwgMHg4YWNmMWMyYiwgMHg4NGM2MTEyMCwgMHhhZWY5MzIxMSwgMHhhMGYwM2YxYSwgMHhiMmViMjgwNywgMHhiY2UyMjUwYywgMHhlNjk1NmU2NSwgMHhlODljNjM2ZSwgMHhmYTg3NzQ3MywgMHhmNDhlNzk3OCwgMHhkZWIxNWE0OSwgMHhkMGI4NTc0MiwgMHhjMmEzNDA1ZiwgMHhjY2FhNGQ1NCwgMHg0MWVjZGFmNywgMHg0ZmU1ZDdmYywgMHg1ZGZlYzBlMSwgMHg1M2Y3Y2RlYSwgMHg3OWM4ZWVkYiwgMHg3N2MxZTNkMCwgMHg2NWRhZjRjZCwgMHg2YmQzZjljNiwgMHgzMWE0YjJhZiwgMHgzZmFkYmZhNCwgMHgyZGI2YThiOSwgMHgyM2JmYTViMiwgMHgwOTgwODY4MywgMHgwNzg5OGI4OCwgMHgxNTkyOWM5NSwgMHgxYjliOTE5ZSwgMHhhMTdjMGE0NywgMHhhZjc1MDc0YywgMHhiZDZlMTA1MSwgMHhiMzY3MWQ1YSwgMHg5OTU4M2U2YiwgMHg5NzUxMzM2MCwgMHg4NTRhMjQ3ZCwgMHg4YjQzMjk3NiwgMHhkMTM0NjIxZiwgMHhkZjNkNmYxNCwgMHhjZDI2NzgwOSwgMHhjMzJmNzUwMiwgMHhlOTEwNTYzMywgMHhlNzE5NWIzOCwgMHhmNTAyNGMyNSwgMHhmYjBiNDEyZSwgMHg5YWQ3NjE4YywgMHg5NGRlNmM4NywgMHg4NmM1N2I5YSwgMHg4OGNjNzY5MSwgMHhhMmYzNTVhMCwgMHhhY2ZhNThhYiwgMHhiZWUxNGZiNiwgMHhiMGU4NDJiZCwgMHhlYTlmMDlkNCwgMHhlNDk2MDRkZiwgMHhmNjhkMTNjMiwgMHhmODg0MWVjOSwgMHhkMmJiM2RmOCwgMHhkY2IyMzBmMywgMHhjZWE5MjdlZSwgMHhjMGEwMmFlNSwgMHg3YTQ3YjEzYywgMHg3NDRlYmMzNywgMHg2NjU1YWIyYSwgMHg2ODVjYTYyMSwgMHg0MjYzODUxMCwgMHg0YzZhODgxYiwgMHg1ZTcxOWYwNiwgMHg1MDc4OTIwZCwgMHgwYTBmZDk2NCwgMHgwNDA2ZDQ2ZiwgMHgxNjFkYzM3MiwgMHgxODE0Y2U3OSwgMHgzMjJiZWQ0OCwgMHgzYzIyZTA0MywgMHgyZTM5Zjc1ZSwgMHgyMDMwZmE1NSwgMHhlYzlhYjcwMSwgMHhlMjkzYmEwYSwgMHhmMDg4YWQxNywgMHhmZTgxYTAxYywgMHhkNGJlODMyZCwgMHhkYWI3OGUyNiwgMHhjOGFjOTkzYiwgMHhjNmE1OTQzMCwgMHg5Y2QyZGY1OSwgMHg5MmRiZDI1MiwgMHg4MGMwYzU0ZiwgMHg4ZWM5Yzg0NCwgMHhhNGY2ZWI3NSwgMHhhYWZmZTY3ZSwgMHhiOGU0ZjE2MywgMHhiNmVkZmM2OCwgMHgwYzBhNjdiMSwgMHgwMjAzNmFiYSwgMHgxMDE4N2RhNywgMHgxZTExNzBhYywgMHgzNDJlNTM5ZCwgMHgzYTI3NWU5NiwgMHgyODNjNDk4YiwgMHgyNjM1NDQ4MCwgMHg3YzQyMGZlOSwgMHg3MjRiMDJlMiwgMHg2MDUwMTVmZiwgMHg2ZTU5MThmNCwgMHg0NDY2M2JjNSwgMHg0YTZmMzZjZSwgMHg1ODc0MjFkMywgMHg1NjdkMmNkOCwgMHgzN2ExMGM3YSwgMHgzOWE4MDE3MSwgMHgyYmIzMTY2YywgMHgyNWJhMWI2NywgMHgwZjg1Mzg1NiwgMHgwMThjMzU1ZCwgMHgxMzk3MjI0MCwgMHgxZDllMmY0YiwgMHg0N2U5NjQyMiwgMHg0OWUwNjkyOSwgMHg1YmZiN2UzNCwgMHg1NWYyNzMzZiwgMHg3ZmNkNTAwZSwgMHg3MWM0NWQwNSwgMHg2M2RmNGExOCwgMHg2ZGQ2NDcxMywgMHhkNzMxZGNjYSwgMHhkOTM4ZDFjMSwgMHhjYjIzYzZkYywgMHhjNTJhY2JkNywgMHhlZjE1ZThlNiwgMHhlMTFjZTVlZCwgMHhmMzA3ZjJmMCwgMHhmZDBlZmZmYiwgMHhhNzc5YjQ5MiwgMHhhOTcwYjk5OSwgMHhiYjZiYWU4NCwgMHhiNTYyYTM4ZiwgMHg5ZjVkODBiZSwgMHg5MTU0OGRiNSwgMHg4MzRmOWFhOCwgMHg4ZDQ2OTdhM107XG5jb25zdCBVMiA9IFsweDAwMDAwMDAwLCAweDBiMGUwOTBkLCAweDE2MWMxMjFhLCAweDFkMTIxYjE3LCAweDJjMzgyNDM0LCAweDI3MzYyZDM5LCAweDNhMjQzNjJlLCAweDMxMmEzZjIzLCAweDU4NzA0ODY4LCAweDUzN2U0MTY1LCAweDRlNmM1YTcyLCAweDQ1NjI1MzdmLCAweDc0NDg2YzVjLCAweDdmNDY2NTUxLCAweDYyNTQ3ZTQ2LCAweDY5NWE3NzRiLCAweGIwZTA5MGQwLCAweGJiZWU5OWRkLCAweGE2ZmM4MmNhLCAweGFkZjI4YmM3LCAweDljZDhiNGU0LCAweDk3ZDZiZGU5LCAweDhhYzRhNmZlLCAweDgxY2FhZmYzLCAweGU4OTBkOGI4LCAweGUzOWVkMWI1LCAweGZlOGNjYWEyLCAweGY1ODJjM2FmLCAweGM0YThmYzhjLCAweGNmYTZmNTgxLCAweGQyYjRlZTk2LCAweGQ5YmFlNzliLCAweDdiZGIzYmJiLCAweDcwZDUzMmI2LCAweDZkYzcyOWExLCAweDY2YzkyMGFjLCAweDU3ZTMxZjhmLCAweDVjZWQxNjgyLCAweDQxZmYwZDk1LCAweDRhZjEwNDk4LCAweDIzYWI3M2QzLCAweDI4YTU3YWRlLCAweDM1Yjc2MWM5LCAweDNlYjk2OGM0LCAweDBmOTM1N2U3LCAweDA0OWQ1ZWVhLCAweDE5OGY0NWZkLCAweDEyODE0Y2YwLCAweGNiM2JhYjZiLCAweGMwMzVhMjY2LCAweGRkMjdiOTcxLCAweGQ2MjliMDdjLCAweGU3MDM4ZjVmLCAweGVjMGQ4NjUyLCAweGYxMWY5ZDQ1LCAweGZhMTE5NDQ4LCAweDkzNGJlMzAzLCAweDk4NDVlYTBlLCAweDg1NTdmMTE5LCAweDhlNTlmODE0LCAweGJmNzNjNzM3LCAweGI0N2RjZTNhLCAweGE5NmZkNTJkLCAweGEyNjFkYzIwLCAweGY2YWQ3NjZkLCAweGZkYTM3ZjYwLCAweGUwYjE2NDc3LCAweGViYmY2ZDdhLCAweGRhOTU1MjU5LCAweGQxOWI1YjU0LCAweGNjODk0MDQzLCAweGM3ODc0OTRlLCAweGFlZGQzZTA1LCAweGE1ZDMzNzA4LCAweGI4YzEyYzFmLCAweGIzY2YyNTEyLCAweDgyZTUxYTMxLCAweDg5ZWIxMzNjLCAweDk0ZjkwODJiLCAweDlmZjcwMTI2LCAweDQ2NGRlNmJkLCAweDRkNDNlZmIwLCAweDUwNTFmNGE3LCAweDViNWZmZGFhLCAweDZhNzVjMjg5LCAweDYxN2JjYjg0LCAweDdjNjlkMDkzLCAweDc3NjdkOTllLCAweDFlM2RhZWQ1LCAweDE1MzNhN2Q4LCAweDA4MjFiY2NmLCAweDAzMmZiNWMyLCAweDMyMDU4YWUxLCAweDM5MGI4M2VjLCAweDI0MTk5OGZiLCAweDJmMTc5MWY2LCAweDhkNzY0ZGQ2LCAweDg2Nzg0NGRiLCAweDliNmE1ZmNjLCAweDkwNjQ1NmMxLCAweGExNGU2OWUyLCAweGFhNDA2MGVmLCAweGI3NTI3YmY4LCAweGJjNWM3MmY1LCAweGQ1MDYwNWJlLCAweGRlMDgwY2IzLCAweGMzMWExN2E0LCAweGM4MTQxZWE5LCAweGY5M2UyMThhLCAweGYyMzAyODg3LCAweGVmMjIzMzkwLCAweGU0MmMzYTlkLCAweDNkOTZkZDA2LCAweDM2OThkNDBiLCAweDJiOGFjZjFjLCAweDIwODRjNjExLCAweDExYWVmOTMyLCAweDFhYTBmMDNmLCAweDA3YjJlYjI4LCAweDBjYmNlMjI1LCAweDY1ZTY5NTZlLCAweDZlZTg5YzYzLCAweDczZmE4Nzc0LCAweDc4ZjQ4ZTc5LCAweDQ5ZGViMTVhLCAweDQyZDBiODU3LCAweDVmYzJhMzQwLCAweDU0Y2NhYTRkLCAweGY3NDFlY2RhLCAweGZjNGZlNWQ3LCAweGUxNWRmZWMwLCAweGVhNTNmN2NkLCAweGRiNzljOGVlLCAweGQwNzdjMWUzLCAweGNkNjVkYWY0LCAweGM2NmJkM2Y5LCAweGFmMzFhNGIyLCAweGE0M2ZhZGJmLCAweGI5MmRiNmE4LCAweGIyMjNiZmE1LCAweDgzMDk4MDg2LCAweDg4MDc4OThiLCAweDk1MTU5MjljLCAweDllMWI5YjkxLCAweDQ3YTE3YzBhLCAweDRjYWY3NTA3LCAweDUxYmQ2ZTEwLCAweDVhYjM2NzFkLCAweDZiOTk1ODNlLCAweDYwOTc1MTMzLCAweDdkODU0YTI0LCAweDc2OGI0MzI5LCAweDFmZDEzNDYyLCAweDE0ZGYzZDZmLCAweDA5Y2QyNjc4LCAweDAyYzMyZjc1LCAweDMzZTkxMDU2LCAweDM4ZTcxOTViLCAweDI1ZjUwMjRjLCAweDJlZmIwYjQxLCAweDhjOWFkNzYxLCAweDg3OTRkZTZjLCAweDlhODZjNTdiLCAweDkxODhjYzc2LCAweGEwYTJmMzU1LCAweGFiYWNmYTU4LCAweGI2YmVlMTRmLCAweGJkYjBlODQyLCAweGQ0ZWE5ZjA5LCAweGRmZTQ5NjA0LCAweGMyZjY4ZDEzLCAweGM5Zjg4NDFlLCAweGY4ZDJiYjNkLCAweGYzZGNiMjMwLCAweGVlY2VhOTI3LCAweGU1YzBhMDJhLCAweDNjN2E0N2IxLCAweDM3NzQ0ZWJjLCAweDJhNjY1NWFiLCAweDIxNjg1Y2E2LCAweDEwNDI2Mzg1LCAweDFiNGM2YTg4LCAweDA2NWU3MTlmLCAweDBkNTA3ODkyLCAweDY0MGEwZmQ5LCAweDZmMDQwNmQ0LCAweDcyMTYxZGMzLCAweDc5MTgxNGNlLCAweDQ4MzIyYmVkLCAweDQzM2MyMmUwLCAweDVlMmUzOWY3LCAweDU1MjAzMGZhLCAweDAxZWM5YWI3LCAweDBhZTI5M2JhLCAweDE3ZjA4OGFkLCAweDFjZmU4MWEwLCAweDJkZDRiZTgzLCAweDI2ZGFiNzhlLCAweDNiYzhhYzk5LCAweDMwYzZhNTk0LCAweDU5OWNkMmRmLCAweDUyOTJkYmQyLCAweDRmODBjMGM1LCAweDQ0OGVjOWM4LCAweDc1YTRmNmViLCAweDdlYWFmZmU2LCAweDYzYjhlNGYxLCAweDY4YjZlZGZjLCAweGIxMGMwYTY3LCAweGJhMDIwMzZhLCAweGE3MTAxODdkLCAweGFjMWUxMTcwLCAweDlkMzQyZTUzLCAweDk2M2EyNzVlLCAweDhiMjgzYzQ5LCAweDgwMjYzNTQ0LCAweGU5N2M0MjBmLCAweGUyNzI0YjAyLCAweGZmNjA1MDE1LCAweGY0NmU1OTE4LCAweGM1NDQ2NjNiLCAweGNlNGE2ZjM2LCAweGQzNTg3NDIxLCAweGQ4NTY3ZDJjLCAweDdhMzdhMTBjLCAweDcxMzlhODAxLCAweDZjMmJiMzE2LCAweDY3MjViYTFiLCAweDU2MGY4NTM4LCAweDVkMDE4YzM1LCAweDQwMTM5NzIyLCAweDRiMWQ5ZTJmLCAweDIyNDdlOTY0LCAweDI5NDllMDY5LCAweDM0NWJmYjdlLCAweDNmNTVmMjczLCAweDBlN2ZjZDUwLCAweDA1NzFjNDVkLCAweDE4NjNkZjRhLCAweDEzNmRkNjQ3LCAweGNhZDczMWRjLCAweGMxZDkzOGQxLCAweGRjY2IyM2M2LCAweGQ3YzUyYWNiLCAweGU2ZWYxNWU4LCAweGVkZTExY2U1LCAweGYwZjMwN2YyLCAweGZiZmQwZWZmLCAweDkyYTc3OWI0LCAweDk5YTk3MGI5LCAweDg0YmI2YmFlLCAweDhmYjU2MmEzLCAweGJlOWY1ZDgwLCAweGI1OTE1NDhkLCAweGE4ODM0ZjlhLCAweGEzOGQ0Njk3XTtcbmNvbnN0IFUzID0gWzB4MDAwMDAwMDAsIDB4MGQwYjBlMDksIDB4MWExNjFjMTIsIDB4MTcxZDEyMWIsIDB4MzQyYzM4MjQsIDB4MzkyNzM2MmQsIDB4MmUzYTI0MzYsIDB4MjMzMTJhM2YsIDB4Njg1ODcwNDgsIDB4NjU1MzdlNDEsIDB4NzI0ZTZjNWEsIDB4N2Y0NTYyNTMsIDB4NWM3NDQ4NmMsIDB4NTE3ZjQ2NjUsIDB4NDY2MjU0N2UsIDB4NGI2OTVhNzcsIDB4ZDBiMGUwOTAsIDB4ZGRiYmVlOTksIDB4Y2FhNmZjODIsIDB4YzdhZGYyOGIsIDB4ZTQ5Y2Q4YjQsIDB4ZTk5N2Q2YmQsIDB4ZmU4YWM0YTYsIDB4ZjM4MWNhYWYsIDB4YjhlODkwZDgsIDB4YjVlMzllZDEsIDB4YTJmZThjY2EsIDB4YWZmNTgyYzMsIDB4OGNjNGE4ZmMsIDB4ODFjZmE2ZjUsIDB4OTZkMmI0ZWUsIDB4OWJkOWJhZTcsIDB4YmI3YmRiM2IsIDB4YjY3MGQ1MzIsIDB4YTE2ZGM3MjksIDB4YWM2NmM5MjAsIDB4OGY1N2UzMWYsIDB4ODI1Y2VkMTYsIDB4OTU0MWZmMGQsIDB4OTg0YWYxMDQsIDB4ZDMyM2FiNzMsIDB4ZGUyOGE1N2EsIDB4YzkzNWI3NjEsIDB4YzQzZWI5NjgsIDB4ZTcwZjkzNTcsIDB4ZWEwNDlkNWUsIDB4ZmQxOThmNDUsIDB4ZjAxMjgxNGMsIDB4NmJjYjNiYWIsIDB4NjZjMDM1YTIsIDB4NzFkZDI3YjksIDB4N2NkNjI5YjAsIDB4NWZlNzAzOGYsIDB4NTJlYzBkODYsIDB4NDVmMTFmOWQsIDB4NDhmYTExOTQsIDB4MDM5MzRiZTMsIDB4MGU5ODQ1ZWEsIDB4MTk4NTU3ZjEsIDB4MTQ4ZTU5ZjgsIDB4MzdiZjczYzcsIDB4M2FiNDdkY2UsIDB4MmRhOTZmZDUsIDB4MjBhMjYxZGMsIDB4NmRmNmFkNzYsIDB4NjBmZGEzN2YsIDB4NzdlMGIxNjQsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4NTRkMTliNWIsIDB4NDNjYzg5NDAsIDB4NGVjNzg3NDksIDB4MDVhZWRkM2UsIDB4MDhhNWQzMzcsIDB4MWZiOGMxMmMsIDB4MTJiM2NmMjUsIDB4MzE4MmU1MWEsIDB4M2M4OWViMTMsIDB4MmI5NGY5MDgsIDB4MjY5ZmY3MDEsIDB4YmQ0NjRkZTYsIDB4YjA0ZDQzZWYsIDB4YTc1MDUxZjQsIDB4YWE1YjVmZmQsIDB4ODk2YTc1YzIsIDB4ODQ2MTdiY2IsIDB4OTM3YzY5ZDAsIDB4OWU3NzY3ZDksIDB4ZDUxZTNkYWUsIDB4ZDgxNTMzYTcsIDB4Y2YwODIxYmMsIDB4YzIwMzJmYjUsIDB4ZTEzMjA1OGEsIDB4ZWMzOTBiODMsIDB4ZmIyNDE5OTgsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4ZGI4Njc4NDQsIDB4Y2M5YjZhNWYsIDB4YzE5MDY0NTYsIDB4ZTJhMTRlNjksIDB4ZWZhYTQwNjAsIDB4ZjhiNzUyN2IsIDB4ZjViYzVjNzIsIDB4YmVkNTA2MDUsIDB4YjNkZTA4MGMsIDB4YTRjMzFhMTcsIDB4YTljODE0MWUsIDB4OGFmOTNlMjEsIDB4ODdmMjMwMjgsIDB4OTBlZjIyMzMsIDB4OWRlNDJjM2EsIDB4MDYzZDk2ZGQsIDB4MGIzNjk4ZDQsIDB4MWMyYjhhY2YsIDB4MTEyMDg0YzYsIDB4MzIxMWFlZjksIDB4M2YxYWEwZjAsIDB4MjgwN2IyZWIsIDB4MjUwY2JjZTIsIDB4NmU2NWU2OTUsIDB4NjM2ZWU4OWMsIDB4NzQ3M2ZhODcsIDB4Nzk3OGY0OGUsIDB4NWE0OWRlYjEsIDB4NTc0MmQwYjgsIDB4NDA1ZmMyYTMsIDB4NGQ1NGNjYWEsIDB4ZGFmNzQxZWMsIDB4ZDdmYzRmZTUsIDB4YzBlMTVkZmUsIDB4Y2RlYTUzZjcsIDB4ZWVkYjc5YzgsIDB4ZTNkMDc3YzEsIDB4ZjRjZDY1ZGEsIDB4ZjljNjZiZDMsIDB4YjJhZjMxYTQsIDB4YmZhNDNmYWQsIDB4YThiOTJkYjYsIDB4YTViMjIzYmYsIDB4ODY4MzA5ODAsIDB4OGI4ODA3ODksIDB4OWM5NTE1OTIsIDB4OTE5ZTFiOWIsIDB4MGE0N2ExN2MsIDB4MDc0Y2FmNzUsIDB4MTA1MWJkNmUsIDB4MWQ1YWIzNjcsIDB4M2U2Yjk5NTgsIDB4MzM2MDk3NTEsIDB4MjQ3ZDg1NGEsIDB4Mjk3NjhiNDMsIDB4NjIxZmQxMzQsIDB4NmYxNGRmM2QsIDB4NzgwOWNkMjYsIDB4NzUwMmMzMmYsIDB4NTYzM2U5MTAsIDB4NWIzOGU3MTksIDB4NGMyNWY1MDIsIDB4NDEyZWZiMGIsIDB4NjE4YzlhZDcsIDB4NmM4Nzk0ZGUsIDB4N2I5YTg2YzUsIDB4NzY5MTg4Y2MsIDB4NTVhMGEyZjMsIDB4NThhYmFjZmEsIDB4NGZiNmJlZTEsIDB4NDJiZGIwZTgsIDB4MDlkNGVhOWYsIDB4MDRkZmU0OTYsIDB4MTNjMmY2OGQsIDB4MWVjOWY4ODQsIDB4M2RmOGQyYmIsIDB4MzBmM2RjYjIsIDB4MjdlZWNlYTksIDB4MmFlNWMwYTAsIDB4YjEzYzdhNDcsIDB4YmMzNzc0NGUsIDB4YWIyYTY2NTUsIDB4YTYyMTY4NWMsIDB4ODUxMDQyNjMsIDB4ODgxYjRjNmEsIDB4OWYwNjVlNzEsIDB4OTIwZDUwNzgsIDB4ZDk2NDBhMGYsIDB4ZDQ2ZjA0MDYsIDB4YzM3MjE2MWQsIDB4Y2U3OTE4MTQsIDB4ZWQ0ODMyMmIsIDB4ZTA0MzNjMjIsIDB4Zjc1ZTJlMzksIDB4ZmE1NTIwMzAsIDB4YjcwMWVjOWEsIDB4YmEwYWUyOTMsIDB4YWQxN2YwODgsIDB4YTAxY2ZlODEsIDB4ODMyZGQ0YmUsIDB4OGUyNmRhYjcsIDB4OTkzYmM4YWMsIDB4OTQzMGM2YTUsIDB4ZGY1OTljZDIsIDB4ZDI1MjkyZGIsIDB4YzU0ZjgwYzAsIDB4Yzg0NDhlYzksIDB4ZWI3NWE0ZjYsIDB4ZTY3ZWFhZmYsIDB4ZjE2M2I4ZTQsIDB4ZmM2OGI2ZWQsIDB4NjdiMTBjMGEsIDB4NmFiYTAyMDMsIDB4N2RhNzEwMTgsIDB4NzBhYzFlMTEsIDB4NTM5ZDM0MmUsIDB4NWU5NjNhMjcsIDB4NDk4YjI4M2MsIDB4NDQ4MDI2MzUsIDB4MGZlOTdjNDIsIDB4MDJlMjcyNGIsIDB4MTVmZjYwNTAsIDB4MThmNDZlNTksIDB4M2JjNTQ0NjYsIDB4MzZjZTRhNmYsIDB4MjFkMzU4NzQsIDB4MmNkODU2N2QsIDB4MGM3YTM3YTEsIDB4MDE3MTM5YTgsIDB4MTY2YzJiYjMsIDB4MWI2NzI1YmEsIDB4Mzg1NjBmODUsIDB4MzU1ZDAxOGMsIDB4MjI0MDEzOTcsIDB4MmY0YjFkOWUsIDB4NjQyMjQ3ZTksIDB4NjkyOTQ5ZTAsIDB4N2UzNDViZmIsIDB4NzMzZjU1ZjIsIDB4NTAwZTdmY2QsIDB4NWQwNTcxYzQsIDB4NGExODYzZGYsIDB4NDcxMzZkZDYsIDB4ZGNjYWQ3MzEsIDB4ZDFjMWQ5MzgsIDB4YzZkY2NiMjMsIDB4Y2JkN2M1MmEsIDB4ZThlNmVmMTUsIDB4ZTVlZGUxMWMsIDB4ZjJmMGYzMDcsIDB4ZmZmYmZkMGUsIDB4YjQ5MmE3NzksIDB4Yjk5OWE5NzAsIDB4YWU4NGJiNmIsIDB4YTM4ZmI1NjIsIDB4ODBiZTlmNWQsIDB4OGRiNTkxNTQsIDB4OWFhODgzNGYsIDB4OTdhMzhkNDZdO1xuY29uc3QgVTQgPSBbMHgwMDAwMDAwMCwgMHgwOTBkMGIwZSwgMHgxMjFhMTYxYywgMHgxYjE3MWQxMiwgMHgyNDM0MmMzOCwgMHgyZDM5MjczNiwgMHgzNjJlM2EyNCwgMHgzZjIzMzEyYSwgMHg0ODY4NTg3MCwgMHg0MTY1NTM3ZSwgMHg1YTcyNGU2YywgMHg1MzdmNDU2MiwgMHg2YzVjNzQ0OCwgMHg2NTUxN2Y0NiwgMHg3ZTQ2NjI1NCwgMHg3NzRiNjk1YSwgMHg5MGQwYjBlMCwgMHg5OWRkYmJlZSwgMHg4MmNhYTZmYywgMHg4YmM3YWRmMiwgMHhiNGU0OWNkOCwgMHhiZGU5OTdkNiwgMHhhNmZlOGFjNCwgMHhhZmYzODFjYSwgMHhkOGI4ZTg5MCwgMHhkMWI1ZTM5ZSwgMHhjYWEyZmU4YywgMHhjM2FmZjU4MiwgMHhmYzhjYzRhOCwgMHhmNTgxY2ZhNiwgMHhlZTk2ZDJiNCwgMHhlNzliZDliYSwgMHgzYmJiN2JkYiwgMHgzMmI2NzBkNSwgMHgyOWExNmRjNywgMHgyMGFjNjZjOSwgMHgxZjhmNTdlMywgMHgxNjgyNWNlZCwgMHgwZDk1NDFmZiwgMHgwNDk4NGFmMSwgMHg3M2QzMjNhYiwgMHg3YWRlMjhhNSwgMHg2MWM5MzViNywgMHg2OGM0M2ViOSwgMHg1N2U3MGY5MywgMHg1ZWVhMDQ5ZCwgMHg0NWZkMTk4ZiwgMHg0Y2YwMTI4MSwgMHhhYjZiY2IzYiwgMHhhMjY2YzAzNSwgMHhiOTcxZGQyNywgMHhiMDdjZDYyOSwgMHg4ZjVmZTcwMywgMHg4NjUyZWMwZCwgMHg5ZDQ1ZjExZiwgMHg5NDQ4ZmExMSwgMHhlMzAzOTM0YiwgMHhlYTBlOTg0NSwgMHhmMTE5ODU1NywgMHhmODE0OGU1OSwgMHhjNzM3YmY3MywgMHhjZTNhYjQ3ZCwgMHhkNTJkYTk2ZiwgMHhkYzIwYTI2MSwgMHg3NjZkZjZhZCwgMHg3ZjYwZmRhMywgMHg2NDc3ZTBiMSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHg1YjU0ZDE5YiwgMHg0MDQzY2M4OSwgMHg0OTRlYzc4NywgMHgzZTA1YWVkZCwgMHgzNzA4YTVkMywgMHgyYzFmYjhjMSwgMHgyNTEyYjNjZiwgMHgxYTMxODJlNSwgMHgxMzNjODllYiwgMHgwODJiOTRmOSwgMHgwMTI2OWZmNywgMHhlNmJkNDY0ZCwgMHhlZmIwNGQ0MywgMHhmNGE3NTA1MSwgMHhmZGFhNWI1ZiwgMHhjMjg5NmE3NSwgMHhjYjg0NjE3YiwgMHhkMDkzN2M2OSwgMHhkOTllNzc2NywgMHhhZWQ1MWUzZCwgMHhhN2Q4MTUzMywgMHhiY2NmMDgyMSwgMHhiNWMyMDMyZiwgMHg4YWUxMzIwNSwgMHg4M2VjMzkwYiwgMHg5OGZiMjQxOSwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHg0NGRiODY3OCwgMHg1ZmNjOWI2YSwgMHg1NmMxOTA2NCwgMHg2OWUyYTE0ZSwgMHg2MGVmYWE0MCwgMHg3YmY4Yjc1MiwgMHg3MmY1YmM1YywgMHgwNWJlZDUwNiwgMHgwY2IzZGUwOCwgMHgxN2E0YzMxYSwgMHgxZWE5YzgxNCwgMHgyMThhZjkzZSwgMHgyODg3ZjIzMCwgMHgzMzkwZWYyMiwgMHgzYTlkZTQyYywgMHhkZDA2M2Q5NiwgMHhkNDBiMzY5OCwgMHhjZjFjMmI4YSwgMHhjNjExMjA4NCwgMHhmOTMyMTFhZSwgMHhmMDNmMWFhMCwgMHhlYjI4MDdiMiwgMHhlMjI1MGNiYywgMHg5NTZlNjVlNiwgMHg5YzYzNmVlOCwgMHg4Nzc0NzNmYSwgMHg4ZTc5NzhmNCwgMHhiMTVhNDlkZSwgMHhiODU3NDJkMCwgMHhhMzQwNWZjMiwgMHhhYTRkNTRjYywgMHhlY2RhZjc0MSwgMHhlNWQ3ZmM0ZiwgMHhmZWMwZTE1ZCwgMHhmN2NkZWE1MywgMHhjOGVlZGI3OSwgMHhjMWUzZDA3NywgMHhkYWY0Y2Q2NSwgMHhkM2Y5YzY2YiwgMHhhNGIyYWYzMSwgMHhhZGJmYTQzZiwgMHhiNmE4YjkyZCwgMHhiZmE1YjIyMywgMHg4MDg2ODMwOSwgMHg4OThiODgwNywgMHg5MjljOTUxNSwgMHg5YjkxOWUxYiwgMHg3YzBhNDdhMSwgMHg3NTA3NGNhZiwgMHg2ZTEwNTFiZCwgMHg2NzFkNWFiMywgMHg1ODNlNmI5OSwgMHg1MTMzNjA5NywgMHg0YTI0N2Q4NSwgMHg0MzI5NzY4YiwgMHgzNDYyMWZkMSwgMHgzZDZmMTRkZiwgMHgyNjc4MDljZCwgMHgyZjc1MDJjMywgMHgxMDU2MzNlOSwgMHgxOTViMzhlNywgMHgwMjRjMjVmNSwgMHgwYjQxMmVmYiwgMHhkNzYxOGM5YSwgMHhkZTZjODc5NCwgMHhjNTdiOWE4NiwgMHhjYzc2OTE4OCwgMHhmMzU1YTBhMiwgMHhmYTU4YWJhYywgMHhlMTRmYjZiZSwgMHhlODQyYmRiMCwgMHg5ZjA5ZDRlYSwgMHg5NjA0ZGZlNCwgMHg4ZDEzYzJmNiwgMHg4NDFlYzlmOCwgMHhiYjNkZjhkMiwgMHhiMjMwZjNkYywgMHhhOTI3ZWVjZSwgMHhhMDJhZTVjMCwgMHg0N2IxM2M3YSwgMHg0ZWJjMzc3NCwgMHg1NWFiMmE2NiwgMHg1Y2E2MjE2OCwgMHg2Mzg1MTA0MiwgMHg2YTg4MWI0YywgMHg3MTlmMDY1ZSwgMHg3ODkyMGQ1MCwgMHgwZmQ5NjQwYSwgMHgwNmQ0NmYwNCwgMHgxZGMzNzIxNiwgMHgxNGNlNzkxOCwgMHgyYmVkNDgzMiwgMHgyMmUwNDMzYywgMHgzOWY3NWUyZSwgMHgzMGZhNTUyMCwgMHg5YWI3MDFlYywgMHg5M2JhMGFlMiwgMHg4OGFkMTdmMCwgMHg4MWEwMWNmZSwgMHhiZTgzMmRkNCwgMHhiNzhlMjZkYSwgMHhhYzk5M2JjOCwgMHhhNTk0MzBjNiwgMHhkMmRmNTk5YywgMHhkYmQyNTI5MiwgMHhjMGM1NGY4MCwgMHhjOWM4NDQ4ZSwgMHhmNmViNzVhNCwgMHhmZmU2N2VhYSwgMHhlNGYxNjNiOCwgMHhlZGZjNjhiNiwgMHgwYTY3YjEwYywgMHgwMzZhYmEwMiwgMHgxODdkYTcxMCwgMHgxMTcwYWMxZSwgMHgyZTUzOWQzNCwgMHgyNzVlOTYzYSwgMHgzYzQ5OGIyOCwgMHgzNTQ0ODAyNiwgMHg0MjBmZTk3YywgMHg0YjAyZTI3MiwgMHg1MDE1ZmY2MCwgMHg1OTE4ZjQ2ZSwgMHg2NjNiYzU0NCwgMHg2ZjM2Y2U0YSwgMHg3NDIxZDM1OCwgMHg3ZDJjZDg1NiwgMHhhMTBjN2EzNywgMHhhODAxNzEzOSwgMHhiMzE2NmMyYiwgMHhiYTFiNjcyNSwgMHg4NTM4NTYwZiwgMHg4YzM1NWQwMSwgMHg5NzIyNDAxMywgMHg5ZTJmNGIxZCwgMHhlOTY0MjI0NywgMHhlMDY5Mjk0OSwgMHhmYjdlMzQ1YiwgMHhmMjczM2Y1NSwgMHhjZDUwMGU3ZiwgMHhjNDVkMDU3MSwgMHhkZjRhMTg2MywgMHhkNjQ3MTM2ZCwgMHgzMWRjY2FkNywgMHgzOGQxYzFkOSwgMHgyM2M2ZGNjYiwgMHgyYWNiZDdjNSwgMHgxNWU4ZTZlZiwgMHgxY2U1ZWRlMSwgMHgwN2YyZjBmMywgMHgwZWZmZmJmZCwgMHg3OWI0OTJhNywgMHg3MGI5OTlhOSwgMHg2YmFlODRiYiwgMHg2MmEzOGZiNSwgMHg1ZDgwYmU5ZiwgMHg1NDhkYjU5MSwgMHg0ZjlhYTg4MywgMHg0Njk3YTM4ZF07XG5mdW5jdGlvbiBjb252ZXJ0VG9JbnQzMihieXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goKGJ5dGVzW2ldIDw8IDI0KSB8IChieXRlc1tpICsgMV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAyXSA8PCA4KSB8IGJ5dGVzW2kgKyAzXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY2xhc3MgQUVTIHtcbiAgICBnZXQga2V5KCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX2tleSwgXCJmXCIpLnNsaWNlKCk7IH1cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgX0FFU19rZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Quc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Uuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBRVMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BRVNfa2V5LCBuZXcgVWludDhBcnJheShrZXkpLCBcImZcIik7XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XG4gICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgc2l6ZSAobXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5jcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZSwgW10sIFwiZlwiKTtcbiAgICAgICAgLy8gZGVjcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZCwgW10sIFwiZlwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcm91bmRzOyBpKyspIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3VuZEtleUNvdW50ID0gKHJvdW5kcyArIDEpICogNDtcbiAgICAgICAgY29uc3QgS0MgPSB0aGlzLmtleS5sZW5ndGggLyA0O1xuICAgICAgICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byBpbnRzXG4gICAgICAgIGNvbnN0IHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xuICAgICAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHJvdW5kIGtleSBhcnJheXNcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4ID0gaSA+PiAyO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtleSBleHBhbnNpb24gKGZpcHMtMTk3IHNlY3Rpb24gNS4yKVxuICAgICAgICBsZXQgcmNvbnBvaW50ZXIgPSAwO1xuICAgICAgICBsZXQgdCA9IEtDLCB0dDtcbiAgICAgICAgd2hpbGUgKHQgPCByb3VuZEtleUNvdW50KSB7XG4gICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XG4gICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG4gICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAoU1t0dCAmIDB4RkZdIDw8IDgpIF5cbiAgICAgICAgICAgICAgICBTWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgKHJjb25bcmNvbnBvaW50ZXJdIDw8IDI0KSk7XG4gICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xuICAgICAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiAoZm9yIG5vbi0yNTYgYml0KVxuICAgICAgICAgICAgaWYgKEtDICE9IDgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IChLQyAvIDIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0dCA9IHRrWyhLQyAvIDIpIC0gMV07XG4gICAgICAgICAgICAgICAgdGtbS0MgLyAyXSBePSAoU1t0dCAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgOCkgXlxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDI0KSAmIDB4RkZdIDw8IDI0KSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IChLQyAvIDIpICsgMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xuICAgICAgICAgICAgbGV0IGkgPSAwLCByLCBjO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBLQyAmJiB0IDwgcm91bmRLZXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XG4gICAgICAgICAgICAgICAgYyA9IHQgJSA0O1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpW3JdW2NdID0gdGtbaV07XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xuICAgICAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbnZlcnNlLWNpcGhlci1pZnkgdGhlIGRlY3J5cHRpb24gcm91bmQga2V5IChmaXBzLTE5NyBzZWN0aW9uIDUuMylcbiAgICAgICAgZm9yIChsZXQgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA0OyBjKyspIHtcbiAgICAgICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUyWyh0dCA+PiAxNikgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUzWyh0dCA+PiA4KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgVTRbdHQgJiAweEZGXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91bmRzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIikubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgYSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXG4gICAgICAgIGxldCB0ID0gY29udmVydFRvSW50MzIocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbMF1baV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgcm91bmQgdHJhbnNmb3Jtc1xuICAgICAgICBmb3IgKGxldCByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGFbaV0gPSAoVDFbKHRbaV0gPj4gMjQpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUM1sodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ0W3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gYS5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBsYXN0IHJvdW5kIGlzIHNwZWNpYWxcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBsZXQgdHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdHQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyb3VuZHNdW2ldO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpXSA9IChTWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAyXSA9IChTWyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF4gKHR0ID4+IDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTW3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGEgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIC8vIGNvbnZlcnQgcGxhaW50ZXh0IHRvIChpbnRzIF4ga2V5KVxuICAgICAgICBsZXQgdCA9IGNvbnZlcnRUb0ludDMyKGNpcGhlcnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKVswXVtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAobGV0IHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IChUNVsodFtpXSA+PiAyNCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ2Wyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ3Wyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgVDhbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGxldCB0dCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JvdW5kc11baV07XG4gICAgICAgICAgICByZXN1bHRbNCAqIGldID0gKFNpWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU2lbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF4gKHR0ID4+IDE2KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+IDgpICYgMHhmZl0gXiAodHQgPj4gOCkpICYgMHhmZjtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNpW3RbKGkgKyAxKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuX0FFU19rZXkgPSBuZXcgV2Vha01hcCgpLCBfQUVTX0tkID0gbmV3IFdlYWtNYXAoKSwgX0FFU19LZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/aes-js/lib.esm/aes.js\n"));

/***/ }),

/***/ "../common/node_modules/aes-js/lib.esm/index.js":
/*!******************************************************!*\
  !*** ../common/node_modules/aes-js/lib.esm/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AES: function() { return /* reexport safe */ _aes_js__WEBPACK_IMPORTED_MODULE_0__.AES; },\n/* harmony export */   CBC: function() { return /* reexport safe */ _mode_cbc_js__WEBPACK_IMPORTED_MODULE_2__.CBC; },\n/* harmony export */   CFB: function() { return /* reexport safe */ _mode_cfb_js__WEBPACK_IMPORTED_MODULE_3__.CFB; },\n/* harmony export */   CTR: function() { return /* reexport safe */ _mode_ctr_js__WEBPACK_IMPORTED_MODULE_4__.CTR; },\n/* harmony export */   ECB: function() { return /* reexport safe */ _mode_ecb_js__WEBPACK_IMPORTED_MODULE_5__.ECB; },\n/* harmony export */   ModeOfOperation: function() { return /* reexport safe */ _mode_js__WEBPACK_IMPORTED_MODULE_1__.ModeOfOperation; },\n/* harmony export */   OFB: function() { return /* reexport safe */ _mode_ofb_js__WEBPACK_IMPORTED_MODULE_6__.OFB; },\n/* harmony export */   pkcs7Pad: function() { return /* reexport safe */ _padding_js__WEBPACK_IMPORTED_MODULE_7__.pkcs7Pad; },\n/* harmony export */   pkcs7Strip: function() { return /* reexport safe */ _padding_js__WEBPACK_IMPORTED_MODULE_7__.pkcs7Strip; }\n/* harmony export */ });\n/* harmony import */ var _aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aes.js */ \"../common/node_modules/aes-js/lib.esm/aes.js\");\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mode.js */ \"../common/node_modules/aes-js/lib.esm/mode.js\");\n/* harmony import */ var _mode_cbc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mode-cbc.js */ \"../common/node_modules/aes-js/lib.esm/mode-cbc.js\");\n/* harmony import */ var _mode_cfb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mode-cfb.js */ \"../common/node_modules/aes-js/lib.esm/mode-cfb.js\");\n/* harmony import */ var _mode_ctr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mode-ctr.js */ \"../common/node_modules/aes-js/lib.esm/mode-ctr.js\");\n/* harmony import */ var _mode_ecb_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mode-ecb.js */ \"../common/node_modules/aes-js/lib.esm/mode-ecb.js\");\n/* harmony import */ var _mode_ofb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mode-ofb.js */ \"../common/node_modules/aes-js/lib.esm/mode-ofb.js\");\n/* harmony import */ var _padding_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./padding.js */ \"../common/node_modules/aes-js/lib.esm/padding.js\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNhO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnQjtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9pbmRleC5qcz85Y2Q4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEFFUyB9IGZyb20gXCIuL2Flcy5qc1wiO1xuZXhwb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xuZXhwb3J0IHsgQ0JDIH0gZnJvbSBcIi4vbW9kZS1jYmMuanNcIjtcbmV4cG9ydCB7IENGQiB9IGZyb20gXCIuL21vZGUtY2ZiLmpzXCI7XG5leHBvcnQgeyBDVFIgfSBmcm9tIFwiLi9tb2RlLWN0ci5qc1wiO1xuZXhwb3J0IHsgRUNCIH0gZnJvbSBcIi4vbW9kZS1lY2IuanNcIjtcbmV4cG9ydCB7IE9GQiB9IGZyb20gXCIuL21vZGUtb2ZiLmpzXCI7XG5leHBvcnQgeyBwa2NzN1BhZCwgcGtjczdTdHJpcCB9IGZyb20gXCIuL3BhZGRpbmcuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/aes-js/lib.esm/index.js\n"));

/***/ }),

/***/ "../common/node_modules/aes-js/lib.esm/mode-cbc.js":
/*!*********************************************************!*\
  !*** ../common/node_modules/aes-js/lib.esm/mode-cbc.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBC: function() { return /* binding */ CBC; }\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"../common/node_modules/aes-js/lib.esm/mode.js\");\n// Cipher Block Chaining\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CBC_iv, _CBC_lastBlock;\n\nclass CBC extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\n    constructor(key, iv) {\n        super(\"ECC\", key, CBC);\n        _CBC_iv.set(this, void 0);\n        _CBC_lastBlock.set(this, void 0);\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(iv), \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _CBC_lastBlock, this.iv, \"f\");\n    }\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, \"f\")); }\n    encrypt(plaintext) {\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const ciphertext = new Uint8Array(plaintext.length);\n        for (let i = 0; i < plaintext.length; i += 16) {\n            for (let j = 0; j < 16; j++) {\n                __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] ^= plaintext[i + j];\n            }\n            __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\")), \"f\");\n            ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\"), i);\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        const plaintext = new Uint8Array(ciphertext.length);\n        for (let i = 0; i < ciphertext.length; i += 16) {\n            const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));\n            for (let j = 0; j < 16; j++) {\n                plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j];\n                __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] = ciphertext[i + j];\n            }\n        }\n        return plaintext;\n    }\n}\n_CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap();\n//# sourceMappingURL=mode-cbc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWNiYy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNyQyxrQkFBa0IscURBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1jYmMuanM/ZWYzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDaXBoZXIgQmxvY2sgQ2hhaW5pbmdcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ0JDX2l2LCBfQ0JDX2xhc3RCbG9jaztcbmltcG9ydCB7IE1vZGVPZk9wZXJhdGlvbiB9IGZyb20gXCIuL21vZGUuanNcIjtcbmV4cG9ydCBjbGFzcyBDQkMgZXh0ZW5kcyBNb2RlT2ZPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgaXYpIHtcbiAgICAgICAgc3VwZXIoXCJFQ0NcIiwga2V5LCBDQkMpO1xuICAgICAgICBfQ0JDX2l2LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ0JDX2xhc3RCbG9jay5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgaWYgKGl2KSB7XG4gICAgICAgICAgICBpZiAoaXYubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBpdiBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19pdiwgbmV3IFVpbnQ4QXJyYXkoaXYpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQkNfaXYsIG5ldyBVaW50OEFycmF5KDE2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIHRoaXMuaXYsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGl2KCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2l2LCBcImZcIikpOyB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFpbnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIilbal0gXj0gcGxhaW50ZXh0W2kgKyBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgICAgICAgY2lwaGVydGV4dC5zZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmFlcy5kZWNyeXB0KGNpcGhlcnRleHQuc3ViYXJyYXkoaSwgaSArIDE2KSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAgICAgICBwbGFpbnRleHRbaSArIGpdID0gYmxvY2tbal0gXiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIilbal07XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpW2pdID0gY2lwaGVydGV4dFtpICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG59XG5fQ0JDX2l2ID0gbmV3IFdlYWtNYXAoKSwgX0NCQ19sYXN0QmxvY2sgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS1jYmMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/aes-js/lib.esm/mode-cbc.js\n"));

/***/ }),

/***/ "../common/node_modules/aes-js/lib.esm/mode-cfb.js":
/*!*********************************************************!*\
  !*** ../common/node_modules/aes-js/lib.esm/mode-cfb.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CFB: function() { return /* binding */ CFB; }\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"../common/node_modules/aes-js/lib.esm/mode.js\");\n// Cipher Feedback\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;\n\nclass CFB extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\n    constructor(key, iv, segmentSize = 8) {\n        super(\"CFB\", key, CFB);\n        _CFB_instances.add(this);\n        _CFB_iv.set(this, void 0);\n        _CFB_shiftRegister.set(this, void 0);\n        // This library currently only handles byte-aligned segmentSize\n        if (!Number.isInteger(segmentSize) || (segmentSize % 8)) {\n            throw new TypeError(\"invalid segmentSize\");\n        }\n        Object.defineProperties(this, {\n            segmentSize: { enumerable: true, value: segmentSize }\n        });\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(iv), \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _CFB_shiftRegister, this.iv, \"f\");\n    }\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, \"f\")); }\n    encrypt(plaintext) {\n        if (8 * plaintext.length % this.segmentSize) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of segmentSize bytes)\");\n        }\n        const segmentSize = this.segmentSize / 8;\n        const ciphertext = new Uint8Array(plaintext);\n        for (let i = 0; i < ciphertext.length; i += segmentSize) {\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n            for (let j = 0; j < segmentSize; j++) {\n                ciphertext[i + j] ^= xorSegment[j];\n            }\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (8 * ciphertext.length % this.segmentSize) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of segmentSize bytes)\");\n        }\n        const segmentSize = this.segmentSize / 8;\n        const plaintext = new Uint8Array(ciphertext);\n        for (let i = 0; i < plaintext.length; i += segmentSize) {\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n            for (let j = 0; j < segmentSize; j++) {\n                plaintext[i + j] ^= xorSegment[j];\n            }\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n        }\n        return plaintext;\n    }\n}\n_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {\n    const segmentSize = this.segmentSize / 8;\n    // Shift the register\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").subarray(segmentSize));\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(data.subarray(0, segmentSize), 16 - segmentSize);\n};\n//# sourceMappingURL=mode-cfb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWNmYi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNyQyxrQkFBa0IscURBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWNmYi5qcz84MTM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENpcGhlciBGZWVkYmFja1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9DRkJfaW5zdGFuY2VzLCBfQ0ZCX2l2LCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIF9DRkJfc2hpZnQ7XG5pbXBvcnQgeyBNb2RlT2ZPcGVyYXRpb24gfSBmcm9tIFwiLi9tb2RlLmpzXCI7XG5leHBvcnQgY2xhc3MgQ0ZCIGV4dGVuZHMgTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGl2LCBzZWdtZW50U2l6ZSA9IDgpIHtcbiAgICAgICAgc3VwZXIoXCJDRkJcIiwga2V5LCBDRkIpO1xuICAgICAgICBfQ0ZCX2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIF9DRkJfaXYuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9DRkJfc2hpZnRSZWdpc3Rlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgLy8gVGhpcyBsaWJyYXJ5IGN1cnJlbnRseSBvbmx5IGhhbmRsZXMgYnl0ZS1hbGlnbmVkIHNlZ21lbnRTaXplXG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWdtZW50U2l6ZSkgfHwgKHNlZ21lbnRTaXplICUgOCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHNlZ21lbnRTaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHNlZ21lbnRTaXplOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBzZWdtZW50U2l6ZSB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXYpIHtcbiAgICAgICAgICAgIGlmIChpdi5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGl2IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0ZCX2l2LCBuZXcgVWludDhBcnJheShpdiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NGQl9pdiwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIHRoaXMuaXYsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGl2KCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX2l2LCBcImZcIikpOyB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKDggKiBwbGFpbnRleHQubGVuZ3RoICUgdGhpcy5zZWdtZW50U2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2Ygc2VnbWVudFNpemUgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZ21lbnRTaXplID0gdGhpcy5zZWdtZW50U2l6ZSAvIDg7XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNpcGhlcnRleHQubGVuZ3RoOyBpICs9IHNlZ21lbnRTaXplKSB7XG4gICAgICAgICAgICBjb25zdCB4b3JTZWdtZW50ID0gdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VnbWVudFNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIGNpcGhlcnRleHRbaSArIGpdIF49IHhvclNlZ21lbnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfaW5zdGFuY2VzLCBcIm1cIiwgX0NGQl9zaGlmdCkuY2FsbCh0aGlzLCBjaXBoZXJ0ZXh0LnN1YmFycmF5KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmICg4ICogY2lwaGVydGV4dC5sZW5ndGggJSB0aGlzLnNlZ21lbnRTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2Ygc2VnbWVudFNpemUgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZ21lbnRTaXplID0gdGhpcy5zZWdtZW50U2l6ZSAvIDg7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gc2VnbWVudFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IHhvclNlZ21lbnQgPSB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9zaGlmdFJlZ2lzdGVyLCBcImZcIikpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWdtZW50U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0W2kgKyBqXSBePSB4b3JTZWdtZW50W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX2luc3RhbmNlcywgXCJtXCIsIF9DRkJfc2hpZnQpLmNhbGwodGhpcywgY2lwaGVydGV4dC5zdWJhcnJheShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG59XG5fQ0ZCX2l2ID0gbmV3IFdlYWtNYXAoKSwgX0NGQl9zaGlmdFJlZ2lzdGVyID0gbmV3IFdlYWtNYXAoKSwgX0NGQl9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfQ0ZCX3NoaWZ0ID0gZnVuY3Rpb24gX0NGQl9zaGlmdChkYXRhKSB7XG4gICAgY29uc3Qgc2VnbWVudFNpemUgPSB0aGlzLnNlZ21lbnRTaXplIC8gODtcbiAgICAvLyBTaGlmdCB0aGUgcmVnaXN0ZXJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpLnNldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgXCJmXCIpLnN1YmFycmF5KHNlZ21lbnRTaXplKSk7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKS5zZXQoZGF0YS5zdWJhcnJheSgwLCBzZWdtZW50U2l6ZSksIDE2IC0gc2VnbWVudFNpemUpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtY2ZiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/aes-js/lib.esm/mode-cfb.js\n"));

/***/ }),

/***/ "../common/node_modules/aes-js/lib.esm/mode-ctr.js":
/*!*********************************************************!*\
  !*** ../common/node_modules/aes-js/lib.esm/mode-ctr.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CTR: function() { return /* binding */ CTR; }\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"../common/node_modules/aes-js/lib.esm/mode.js\");\n// Counter Mode\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CTR_remaining, _CTR_remainingIndex, _CTR_counter;\n\nclass CTR extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\n    constructor(key, initialValue) {\n        super(\"CTR\", key, CTR);\n        // Remaining bytes for the one-time pad\n        _CTR_remaining.set(this, void 0);\n        _CTR_remainingIndex.set(this, void 0);\n        // The current counter\n        _CTR_counter.set(this, void 0);\n        __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), \"f\");\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").fill(0);\n        __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, \"f\"), \"f\"); // This will be discarded immediately\n        __classPrivateFieldSet(this, _CTR_remainingIndex, 16, \"f\");\n        if (initialValue == null) {\n            initialValue = 1;\n        }\n        if (typeof (initialValue) === \"number\") {\n            this.setCounterValue(initialValue);\n        }\n        else {\n            this.setCounterBytes(initialValue);\n        }\n    }\n    get counter() { return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, \"f\")); }\n    setCounterValue(value) {\n        if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {\n            throw new TypeError(\"invalid counter initial integer value\");\n        }\n        for (let index = 15; index >= 0; --index) {\n            __classPrivateFieldGet(this, _CTR_counter, \"f\")[index] = value % 256;\n            value = Math.floor(value / 256);\n        }\n    }\n    setCounterBytes(value) {\n        if (value.length !== 16) {\n            throw new TypeError(\"invalid counter initial Uint8Array value length\");\n        }\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").set(value);\n    }\n    increment() {\n        for (let i = 15; i >= 0; i--) {\n            if (__classPrivateFieldGet(this, _CTR_counter, \"f\")[i] === 255) {\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i] = 0;\n            }\n            else {\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i]++;\n                break;\n            }\n        }\n    }\n    encrypt(plaintext) {\n        var _a, _b;\n        const crypttext = new Uint8Array(plaintext);\n        for (let i = 0; i < crypttext.length; i++) {\n            if (__classPrivateFieldGet(this, _CTR_remainingIndex, \"f\") === 16) {\n                __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, \"f\")), \"f\");\n                __classPrivateFieldSet(this, _CTR_remainingIndex, 0, \"f\");\n                this.increment();\n            }\n            crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, \"f\")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, \"f\"), _a = _b++, _b), \"f\"), _a];\n        }\n        return crypttext;\n    }\n    decrypt(ciphertext) {\n        return this.encrypt(ciphertext);\n    }\n}\n_CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap();\n//# sourceMappingURL=mode-ctr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWN0ci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNyQyxrQkFBa0IscURBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1jdHIuanM/OWI5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3VudGVyIE1vZGVcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ1RSX3JlbWFpbmluZywgX0NUUl9yZW1haW5pbmdJbmRleCwgX0NUUl9jb3VudGVyO1xuaW1wb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xuZXhwb3J0IGNsYXNzIENUUiBleHRlbmRzIE1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgc3VwZXIoXCJDVFJcIiwga2V5LCBDVFIpO1xuICAgICAgICAvLyBSZW1haW5pbmcgYnl0ZXMgZm9yIHRoZSBvbmUtdGltZSBwYWRcbiAgICAgICAgX0NUUl9yZW1haW5pbmcuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9DVFJfcmVtYWluaW5nSW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IGNvdW50ZXJcbiAgICAgICAgX0NUUl9jb3VudGVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfY291bnRlciwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikuZmlsbCgwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSwgXCJmXCIpOyAvLyBUaGlzIHdpbGwgYmUgZGlzY2FyZGVkIGltbWVkaWF0ZWx5XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgMTYsIFwiZlwiKTtcbiAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGluaXRpYWxWYWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q291bnRlclZhbHVlKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldENvdW50ZXJCeXRlcyhpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb3VudGVyKCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSk7IH1cbiAgICBzZXRDb3VudGVyVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY291bnRlciBpbml0aWFsIGludGVnZXIgdmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxNTsgaW5kZXggPj0gMDsgLS1pbmRleCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpbmRleF0gPSB2YWx1ZSAlIDI1NjtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDI1Nik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q291bnRlckJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjb3VudGVyIGluaXRpYWwgVWludDhBcnJheSB2YWx1ZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKS5zZXQodmFsdWUpO1xuICAgIH1cbiAgICBpbmNyZW1lbnQoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2ldID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaV0rKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjcnlwdHRleHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNyeXB0dGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgXCJmXCIpID09PSAxNikge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmcsIHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSksIFwiZlwiKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIDAsIFwiZlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3J5cHR0ZXh0W2ldIF49IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmcsIFwiZlwiKVtfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIChfYiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgXCJmXCIpLCBfYSA9IF9iKyssIF9iKSwgXCJmXCIpLCBfYV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyeXB0dGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgfVxufVxuX0NUUl9yZW1haW5pbmcgPSBuZXcgV2Vha01hcCgpLCBfQ1RSX3JlbWFpbmluZ0luZGV4ID0gbmV3IFdlYWtNYXAoKSwgX0NUUl9jb3VudGVyID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtY3RyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/aes-js/lib.esm/mode-ctr.js\n"));

/***/ }),

/***/ "../common/node_modules/aes-js/lib.esm/mode-ecb.js":
/*!*********************************************************!*\
  !*** ../common/node_modules/aes-js/lib.esm/mode-ecb.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ECB: function() { return /* binding */ ECB; }\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"../common/node_modules/aes-js/lib.esm/mode.js\");\n// Electronic Code Book\n\nclass ECB extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\n    constructor(key) {\n        super(\"ECB\", key, ECB);\n    }\n    encrypt(plaintext) {\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const crypttext = new Uint8Array(plaintext.length);\n        for (let i = 0; i < plaintext.length; i += 16) {\n            crypttext.set(this.aes.encrypt(plaintext.subarray(i, i + 16)), i);\n        }\n        return crypttext;\n    }\n    decrypt(crypttext) {\n        if (crypttext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        const plaintext = new Uint8Array(crypttext.length);\n        for (let i = 0; i < crypttext.length; i += 16) {\n            plaintext.set(this.aes.decrypt(crypttext.subarray(i, i + 16)), i);\n        }\n        return plaintext;\n    }\n}\n//# sourceMappingURL=mode-ecb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWVjYi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzRDO0FBQ3JDLGtCQUFrQixxREFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLWVjYi5qcz9mMDlmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVsZWN0cm9uaWMgQ29kZSBCb29rXG5pbXBvcnQgeyBNb2RlT2ZPcGVyYXRpb24gfSBmcm9tIFwiLi9tb2RlLmpzXCI7XG5leHBvcnQgY2xhc3MgRUNCIGV4dGVuZHMgTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgc3VwZXIoXCJFQ0JcIiwga2V5LCBFQ0IpO1xuICAgIH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3J5cHR0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgY3J5cHR0ZXh0LnNldCh0aGlzLmFlcy5lbmNyeXB0KHBsYWludGV4dC5zdWJhcnJheShpLCBpICsgMTYpKSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyeXB0dGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjcnlwdHRleHQpIHtcbiAgICAgICAgaWYgKGNyeXB0dGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBuZXcgVWludDhBcnJheShjcnlwdHRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcnlwdHRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBwbGFpbnRleHQuc2V0KHRoaXMuYWVzLmRlY3J5cHQoY3J5cHR0ZXh0LnN1YmFycmF5KGksIGkgKyAxNikpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtZWNiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/aes-js/lib.esm/mode-ecb.js\n"));

/***/ }),

/***/ "../common/node_modules/aes-js/lib.esm/mode-ofb.js":
/*!*********************************************************!*\
  !*** ../common/node_modules/aes-js/lib.esm/mode-ofb.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OFB: function() { return /* binding */ OFB; }\n/* harmony export */ });\n/* harmony import */ var _mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode.js */ \"../common/node_modules/aes-js/lib.esm/mode.js\");\n// Output Feedback\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;\n\nclass OFB extends _mode_js__WEBPACK_IMPORTED_MODULE_0__.ModeOfOperation {\n    constructor(key, iv) {\n        super(\"OFB\", key, OFB);\n        _OFB_iv.set(this, void 0);\n        _OFB_lastPrecipher.set(this, void 0);\n        _OFB_lastPrecipherIndex.set(this, void 0);\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(iv), \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _OFB_lastPrecipher, this.iv, \"f\");\n        __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 16, \"f\");\n    }\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, \"f\")); }\n    encrypt(plaintext) {\n        var _a, _b;\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const ciphertext = new Uint8Array(plaintext);\n        for (let i = 0; i < ciphertext.length; i++) {\n            if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \"f\") === 16) {\n                __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, \"f\")), \"f\");\n                __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, \"f\");\n            }\n            ciphertext[i] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, \"f\")[__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \"f\"), _a = _b++, _b), \"f\"), _a];\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        return this.encrypt(ciphertext);\n    }\n}\n_OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap();\n//# sourceMappingURL=mode-ofb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLW9mYi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNyQyxrQkFBa0IscURBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS1vZmIuanM/MGZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPdXRwdXQgRmVlZGJhY2tcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfT0ZCX2l2LCBfT0ZCX2xhc3RQcmVjaXBoZXIsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4O1xuaW1wb3J0IHsgTW9kZU9mT3BlcmF0aW9uIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xuZXhwb3J0IGNsYXNzIE9GQiBleHRlbmRzIE1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBpdikge1xuICAgICAgICBzdXBlcihcIk9GQlwiLCBrZXksIE9GQik7XG4gICAgICAgIF9PRkJfaXYuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9PRkJfbGFzdFByZWNpcGhlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX09GQl9sYXN0UHJlY2lwaGVySW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmIChpdikge1xuICAgICAgICAgICAgaWYgKGl2Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaXYgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfaXYsIG5ldyBVaW50OEFycmF5KGl2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2l2LCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgdGhpcy5pdiwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCAxNiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgaXYoKSB7IHJldHVybiBuZXcgVWludDhBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfaXYsIFwiZlwiKSk7IH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIFwiZlwiKSA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgdGhpcy5hZXMuZW5jcnlwdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIDAsIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNpcGhlcnRleHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXIsIFwiZlwiKVtfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCAoX2IgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlckluZGV4LCBcImZcIiksIF9hID0gX2IrKywgX2IpLCBcImZcIiksIF9hXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgfVxufVxuX09GQl9pdiA9IG5ldyBXZWFrTWFwKCksIF9PRkJfbGFzdFByZWNpcGhlciA9IG5ldyBXZWFrTWFwKCksIF9PRkJfbGFzdFByZWNpcGhlckluZGV4ID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUtb2ZiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/aes-js/lib.esm/mode-ofb.js\n"));

/***/ }),

/***/ "../common/node_modules/aes-js/lib.esm/mode.js":
/*!*****************************************************!*\
  !*** ../common/node_modules/aes-js/lib.esm/mode.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModeOfOperation: function() { return /* binding */ ModeOfOperation; }\n/* harmony export */ });\n/* harmony import */ var _aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aes.js */ \"../common/node_modules/aes-js/lib.esm/aes.js\");\n\nclass ModeOfOperation {\n    constructor(name, key, cls) {\n        if (cls && !(this instanceof cls)) {\n            throw new Error(`${name} must be instantiated with \"new\"`);\n        }\n        Object.defineProperties(this, {\n            aes: { enumerable: true, value: new _aes_js__WEBPACK_IMPORTED_MODULE_0__.AES(key) },\n            name: { enumerable: true, value: name }\n        });\n    }\n}\n//# sourceMappingURL=mode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9tb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCO0FBQ3hCO0FBQ1A7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCLHdDQUFHLE9BQU87QUFDMUQsb0JBQW9CO0FBQ3BCLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vbW9kZS5qcz9mZmVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFFUyB9IGZyb20gXCIuL2Flcy5qc1wiO1xuZXhwb3J0IGNsYXNzIE1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwga2V5LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBjbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBcIm5ld1wiYCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYWVzOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBuZXcgQUVTKGtleSkgfSxcbiAgICAgICAgICAgIG5hbWU6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IG5hbWUgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/aes-js/lib.esm/mode.js\n"));

/***/ }),

/***/ "../common/node_modules/aes-js/lib.esm/padding.js":
/*!********************************************************!*\
  !*** ../common/node_modules/aes-js/lib.esm/padding.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pkcs7Pad: function() { return /* binding */ pkcs7Pad; },\n/* harmony export */   pkcs7Strip: function() { return /* binding */ pkcs7Strip; }\n/* harmony export */ });\nfunction pkcs7Pad(data) {\n    const padder = 16 - (data.length % 16);\n    const result = new Uint8Array(data.length + padder);\n    result.set(data);\n    for (let i = data.length; i < result.length; i++) {\n        result[i] = padder;\n    }\n    return result;\n}\nfunction pkcs7Strip(data) {\n    if (data.length < 16) {\n        throw new TypeError('PKCS#7 invalid length');\n    }\n    const padder = data[data.length - 1];\n    if (padder > 16) {\n        throw new TypeError('PKCS#7 padding byte out of range');\n    }\n    const length = data.length - padder;\n    for (let i = 0; i < padder; i++) {\n        if (data[length + i] !== padder) {\n            throw new TypeError('PKCS#7 invalid padding byte');\n        }\n    }\n    return new Uint8Array(data.subarray(0, length));\n}\n//# sourceMappingURL=padding.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmVzbS9wYWRkaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5lc20vcGFkZGluZy5qcz84ZGRjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBwa2NzN1BhZChkYXRhKSB7XG4gICAgY29uc3QgcGFkZGVyID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBwYWRkZXIpO1xuICAgIHJlc3VsdC5zZXQoZGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IHBhZGRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwa2NzN1N0cmlwKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAxNikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQS0NTIzcgaW52YWxpZCBsZW5ndGgnKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVyID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgIGlmIChwYWRkZXIgPiAxNikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQS0NTIzcgcGFkZGluZyBieXRlIG91dCBvZiByYW5nZScpO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCAtIHBhZGRlcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlcjsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2xlbmd0aCArIGldICE9PSBwYWRkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIHBhZGRpbmcgYnl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhLnN1YmFycmF5KDAsIGxlbmd0aCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkZGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/aes-js/lib.esm/padding.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/_version.js":
/*!*********************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/_version.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n/**\n *  The current version of Ethers.\n */\nconst version = \"6.14.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanM/ZWFkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBEbyBOT1QgbW9kaWZ5IHRoaXMgZmlsZTsgc2VlIC9zcmMudHMvX2FkbWluL3VwZGF0ZS12ZXJzaW9uLnRzICovXG4vKipcbiAqICBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIEV0aGVycy5cbiAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIjYuMTQuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/_version.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/abi-coder.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/abi-coder.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: function() { return /* binding */ AbiCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/address.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/address.js\");\n/* harmony import */ var _coders_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./coders/array.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/array.js\");\n/* harmony import */ var _coders_boolean_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/boolean.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/boolean.js\");\n/* harmony import */ var _coders_bytes_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/bytes.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/null.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/null.js\");\n/* harmony import */ var _coders_number_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/number.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/number.js\");\n/* harmony import */ var _coders_string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/string.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/string.js\");\n/* harmony import */ var _coders_tuple_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/tuple.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/tuple.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./fragments.js */ \"../common/node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nlet defaultMaxInflation = 1024;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n        data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        }\n        else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        }\n        else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\"string\"], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [reason]\n                };\n                message += `: ${JSON.stringify(reason)}`;\n            }\n            catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        }\n        else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\"uint256\"], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [code]\n                };\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\n                message += `: ${reason}`;\n            }\n            catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        }\n        else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: (tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.to) : null),\n        data: (tx.data || \"0x\")\n    };\n    if (tx.from) {\n        transaction.from = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.from);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(message, \"CALL_EXCEPTION\", {\n        action, data, reason, transaction, invocation, revert\n    });\n}\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */\nclass AbiCoder {\n    #getCoder(param) {\n        if (param.isArray()) {\n            return new _coders_array_js__WEBPACK_IMPORTED_MODULE_2__.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n        if (param.isTuple()) {\n            return new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_3__.TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);\n        }\n        switch (param.baseType) {\n            case \"address\":\n                return new _coders_address_js__WEBPACK_IMPORTED_MODULE_4__.AddressCoder(param.name);\n            case \"bool\":\n                return new _coders_boolean_js__WEBPACK_IMPORTED_MODULE_5__.BooleanCoder(param.name);\n            case \"string\":\n                return new _coders_string_js__WEBPACK_IMPORTED_MODULE_6__.StringCoder(param.name);\n            case \"bytes\":\n                return new _coders_bytes_js__WEBPACK_IMPORTED_MODULE_7__.BytesCoder(param.name);\n            case \"\":\n                return new _coders_null_js__WEBPACK_IMPORTED_MODULE_8__.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new _coders_number_js__WEBPACK_IMPORTED_MODULE_9__.NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_10__.FixedBytesCoder(size, param.name);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid type\", \"type\", param.type);\n    }\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */\n    getDefaultValue(types) {\n        const coders = types.map((type) => this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_11__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_3__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */\n    encode(types, values) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type) => this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_11__.ParamType.from(type)));\n        const coder = (new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_3__.TupleCoder(coders, \"_\"));\n        const writer = new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_12__.Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */\n    decode(types, data, loose) {\n        const coders = types.map((type) => this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_11__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_3__.TupleCoder(coders, \"_\");\n        return coder.decode(new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_12__.Reader(data, loose, defaultMaxInflation));\n    }\n    static _setDefaultMaxInflation(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"number\" && Number.isInteger(value), \"invalid defaultMaxInflation factor\", \"value\", value);\n        defaultMaxInflation = value;\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */\n    static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */\n    static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n}\n//# sourceMappingURL=abi-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvYWJpLWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0U7QUFDWjtBQUNUO0FBQ0o7QUFDSTtBQUNKO0FBQ1c7QUFDYjtBQUNJO0FBQ0E7QUFDRjtBQUNKO0FBQ007QUFDZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBUTtBQUM5QixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLGlCQUFpQix3REFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQ0FBb0MsR0FBRyxLQUFLO0FBQ3JGLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2REFBVTtBQUNyQztBQUNBLFdBQVcsMERBQVM7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1Qix3REFBVTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLHdEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBWTtBQUN2QztBQUNBLDJCQUEyQiw0REFBWTtBQUN2QztBQUNBLDJCQUEyQiwwREFBVztBQUN0QztBQUNBLDJCQUEyQix3REFBVTtBQUNyQztBQUNBLDJCQUEyQixzREFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQix1QkFBdUIsMERBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWM7QUFDMUIsdUJBQXVCLG9FQUFlO0FBQ3RDO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFEQUFTO0FBQ25FLDBCQUEwQix3REFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRUFBbUI7QUFDM0IsMERBQTBELHFEQUFTO0FBQ25FLDJCQUEyQix3REFBVTtBQUNyQywyQkFBMkIsOERBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxxREFBUztBQUNuRSwwQkFBMEIsd0RBQVU7QUFDcEMsZ0NBQWdDLDhEQUFNO0FBQ3RDO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2FiaS1jb2Rlci5qcz9lNTM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFdoZW4gc2VuZGluZyB2YWx1ZXMgdG8gb3IgcmVjZWl2aW5nIHZhbHVlcyBmcm9tIGEgW1tDb250cmFjdF1dLCB0aGVcbiAqICBkYXRhIGlzIGdlbmVyYWxseSBlbmNvZGVkIHVzaW5nIHRoZSBbQUJJIHN0YW5kYXJkXShsaW5rLXNvbGMtYWJpKS5cbiAqXG4gKiAgVGhlIEFiaUNvZGVyIHByb3ZpZGVzIGEgdXRpbGl0eSB0byBlbmNvZGUgdmFsdWVzIHRvIEFCSSBkYXRhIGFuZFxuICogIGRlY29kZSB2YWx1ZXMgZnJvbSBBQkkgZGF0YS5cbiAqXG4gKiAgTW9zdCBvZiB0aGUgdGltZSwgZGV2ZWxvcGVycyBzaG91bGQgZmF2b3VyIHRoZSBbW0NvbnRyYWN0XV0gY2xhc3MsXG4gKiAgd2hpY2ggZnVydGhlciBhYnN0cmFjdHMgYSBsb3Qgb2YgdGhlIGZpbmVyIGRldGFpbHMgb2YgQUJJIGRhdGEuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpBQkkgRW5jb2RpbmdcbiAqL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnRDb3VudCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBZGRyZXNzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWRkcmVzcy5qc1wiO1xuaW1wb3J0IHsgQXJyYXlDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hcnJheS5qc1wiO1xuaW1wb3J0IHsgQm9vbGVhbkNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2Jvb2xlYW4uanNcIjtcbmltcG9ydCB7IEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYnl0ZXMuanNcIjtcbmltcG9ydCB7IEZpeGVkQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9maXhlZC1ieXRlcy5qc1wiO1xuaW1wb3J0IHsgTnVsbENvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bGwuanNcIjtcbmltcG9ydCB7IE51bWJlckNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bWJlci5qc1wiO1xuaW1wb3J0IHsgU3RyaW5nQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvc3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBUdXBsZUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3R1cGxlLmpzXCI7XG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnksIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbFxuY29uc3QgUGFuaWNSZWFzb25zID0gbmV3IE1hcCgpO1xuUGFuaWNSZWFzb25zLnNldCgweDAwLCBcIkdFTkVSSUNfUEFOSUNcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDEsIFwiQVNTRVJUX0ZBTFNFXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDExLCBcIk9WRVJGTE9XXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDEyLCBcIkRJVklERV9CWV9aRVJPXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDIxLCBcIkVOVU1fUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjIsIFwiQkFEX1NUT1JBR0VfREFUQVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMSwgXCJTVEFDS19VTkRFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MzIsIFwiQVJSQVlfUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4NDEsIFwiT1VUX09GX01FTU9SWVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg1MSwgXCJVTklOSVRJQUxJWkVEX0ZVTkNUSU9OX0NBTExcIik7XG5jb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xuY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbmxldCBkZWZhdWx0Q29kZXIgPSBudWxsO1xubGV0IGRlZmF1bHRNYXhJbmZsYXRpb24gPSAxMDI0O1xuZnVuY3Rpb24gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgYWJpQ29kZXIpIHtcbiAgICBsZXQgbWVzc2FnZSA9IFwibWlzc2luZyByZXZlcnQgZGF0YVwiO1xuICAgIGxldCByZWFzb24gPSBudWxsO1xuICAgIGNvbnN0IGludm9jYXRpb24gPSBudWxsO1xuICAgIGxldCByZXZlcnQgPSBudWxsO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcImV4ZWN1dGlvbiByZXZlcnRlZFwiO1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAobm8gZGF0YSBwcmVzZW50OyBsaWtlbHkgcmVxdWlyZShmYWxzZSkgb2NjdXJyZWRcIjtcbiAgICAgICAgICAgIHJlYXNvbiA9IFwicmVxdWlyZShmYWxzZSlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggJSAzMiAhPT0gNCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgZGF0YSBsZW5ndGgpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHgwOGMzNzlhMFwiKSB7XG4gICAgICAgICAgICAvLyBFcnJvcihzdHJpbmcpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGFiaUNvZGVyLmRlY29kZShbXCJzdHJpbmdcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXTtcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlYXNvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtKU09OLnN0cmluZ2lmeShyZWFzb24pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBzdHJpbmcgZGF0YSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDRlNDg3YjcxXCIpIHtcbiAgICAgICAgICAgIC8vIFBhbmljKHVpbnQyNTYpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIoYWJpQ29kZXIuZGVjb2RlKFtcInVpbnQyNTZcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY29kZV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGBQYW5pYyBkdWUgdG8gJHtQYW5pY1JlYXNvbnMuZ2V0KGNvZGUpIHx8IFwiVU5LTk9XTlwifSgke2NvZGV9KWA7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke3JlYXNvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSBwYW5pYyBjb2RlKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIHRvOiAodHgudG8gPyBnZXRBZGRyZXNzKHR4LnRvKSA6IG51bGwpLFxuICAgICAgICBkYXRhOiAodHguZGF0YSB8fCBcIjB4XCIpXG4gICAgfTtcbiAgICBpZiAodHguZnJvbSkge1xuICAgICAgICB0cmFuc2FjdGlvbi5mcm9tID0gZ2V0QWRkcmVzcyh0eC5mcm9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VFcnJvcihtZXNzYWdlLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgYWN0aW9uLCBkYXRhLCByZWFzb24sIHRyYW5zYWN0aW9uLCBpbnZvY2F0aW9uLCByZXZlcnRcbiAgICB9KTtcbn1cbi8qKlxuICogIFRoZSAqKkFiaUNvZGVyKiogaXMgYSBsb3ctbGV2ZWwgY2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY29kaW5nIEphdmFTY3JpcHRcbiAqICB2YWx1ZXMgaW50byBiaW5hcnkgZGF0YSBhbmQgZGVjb2RpbmcgYmluYXJ5IGRhdGEgaW50byBKYXZhU2NyaXB0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFiaUNvZGVyIHtcbiAgICAjZ2V0Q29kZXIocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvZGVyKHRoaXMuI2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZUNvZGVyKHBhcmFtLmNvbXBvbmVudHMubWFwKChjKSA9PiB0aGlzLiNnZXRDb2RlcihjKSksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdWxsQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdT9pbnRbMC05XSpcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5dGVzWzAtOV0rXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHBhcmFtLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlIGdpdmVuICUldHlwZXMlJS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSBgYHVpbnRgYCBpcyBieSBkZWZhdWx0IGBgMGBgIGFuZCBgYGJvb2xgYFxuICAgICAqICBpcyBieSBkZWZhdWx0IGBgZmFsc2VgYC5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0VmFsdWUodHlwZXMpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGUgdGhlICUldmFsdWVzJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIEFCSSBkYXRhLlxuICAgICAqXG4gICAgICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAgICAgKi9cbiAgICBlbmNvZGUodHlwZXMsIHZhbHVlcykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlcy5sZW5ndGgsIHR5cGVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIpO1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gKG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgdGhlIEFCSSAlJWRhdGElJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlbG9vc2UlJSBkZWNvZGluZyBpcyBlbmFibGVkLCB0aGVuIHN0cmljdCBwYWRkaW5nIGlzXG4gICAgICogIG5vdCBlbmZvcmNlZC4gU29tZSBvbGRlciB2ZXJzaW9ucyBvZiBTb2xpZGl0eSBpbmNvcnJlY3RseVxuICAgICAqICBwYWRkZWQgZXZlbnQgZGF0YSBlbWl0dGVkIGZyb20gYGBleHRlcm5hbGBgIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBkZWNvZGUodHlwZXMsIGRhdGEsIGxvb3NlKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlY29kZShuZXcgUmVhZGVyKGRhdGEsIGxvb3NlLCBkZWZhdWx0TWF4SW5mbGF0aW9uKSk7XG4gICAgfVxuICAgIHN0YXRpYyBfc2V0RGVmYXVsdE1heEluZmxhdGlvbih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSwgXCJpbnZhbGlkIGRlZmF1bHRNYXhJbmZsYXRpb24gZmFjdG9yXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICBkZWZhdWx0TWF4SW5mbGF0aW9uID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzaGFyZWQgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgZGVmYXVsdCBbW0FiaUNvZGVyXV0uXG4gICAgICpcbiAgICAgKiAgT24gdGhlIGZpcnN0IGNhbGwsIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3RhdGljIGRlZmF1bHRBYmlDb2RlcigpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDb2RlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdENvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtY29tcGF0aWJsZSBbW0NhbGxFeGNlcHRpb25FcnJvcl1dIEVycm9yIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgcmVzdWx0ICUlZGF0YSUlIGZvciB0aGUgW1tDYWxsRXhjZXB0aW9uQWN0aW9uXV0gJSVhY3Rpb24lJSBhZ2FpbnN0XG4gICAgICogIHRoZSBUcmFuc2FjdGlvbiAlJXR4JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmktY29kZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/abi-coder.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/bytes32.js":
/*!************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/bytes32.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBytes32String: function() { return /* binding */ decodeBytes32String; },\n/* harmony export */   encodeBytes32String: function() { return /* binding */ encodeBytes32String; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/**\n *  About bytes32 strings...\n *\n *  @_docloc: api/utils:Bytes32 Strings\n */\n\n/**\n *  Encodes %%text%% as a Bytes32 string.\n */\nfunction encodeBytes32String(text) {\n    // Get the bytes\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(text);\n    // Check we have room for null-termination\n    if (bytes.length > 31) {\n        throw new Error(\"bytes32 string must be less than 32 bytes\");\n    }\n    // Zero-pad (implicitly null-terminates)\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadBytes)(bytes, 32);\n}\n/**\n *  Encodes the Bytes32-encoded %%bytes%% into a string.\n */\nfunction decodeBytes32String(_bytes) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_bytes, \"bytes\");\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) {\n        throw new Error(\"invalid bytes32 - not 32 bytes long\");\n    }\n    if (data[31] !== 0) {\n        throw new Error(\"invalid bytes32 string - no null terminator\");\n    }\n    // Find the null termination\n    let length = 31;\n    while (data[length - 1] === 0) {\n        length--;\n    }\n    // Determine the string value\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8String)(data.slice(0, length));\n}\n//# sourceMappingURL=bytes32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvYnl0ZXMzMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsNERBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQix5REFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQVk7QUFDdkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvYnl0ZXMzMi5qcz82YWFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEFib3V0IGJ5dGVzMzIgc3RyaW5ncy4uLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3V0aWxzOkJ5dGVzMzIgU3RyaW5nc1xuICovXG5pbXBvcnQgeyBnZXRCeXRlcywgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZywgemVyb1BhZEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBFbmNvZGVzICUldGV4dCUlIGFzIGEgQnl0ZXMzMiBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVCeXRlczMyU3RyaW5nKHRleHQpIHtcbiAgICAvLyBHZXQgdGhlIGJ5dGVzXG4gICAgY29uc3QgYnl0ZXMgPSB0b1V0ZjhCeXRlcyh0ZXh0KTtcbiAgICAvLyBDaGVjayB3ZSBoYXZlIHJvb20gZm9yIG51bGwtdGVybWluYXRpb25cbiAgICBpZiAoYnl0ZXMubGVuZ3RoID4gMzEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnl0ZXMzMiBzdHJpbmcgbXVzdCBiZSBsZXNzIHRoYW4gMzIgYnl0ZXNcIik7XG4gICAgfVxuICAgIC8vIFplcm8tcGFkIChpbXBsaWNpdGx5IG51bGwtdGVybWluYXRlcylcbiAgICByZXR1cm4gemVyb1BhZEJ5dGVzKGJ5dGVzLCAzMik7XG59XG4vKipcbiAqICBFbmNvZGVzIHRoZSBCeXRlczMyLWVuY29kZWQgJSVieXRlcyUlIGludG8gYSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCeXRlczMyU3RyaW5nKF9ieXRlcykge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfYnl0ZXMsIFwiYnl0ZXNcIik7XG4gICAgLy8gTXVzdCBiZSAzMiBieXRlcyB3aXRoIGEgbnVsbC10ZXJtaW5hdGlvblxuICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIC0gbm90IDMyIGJ5dGVzIGxvbmdcIik7XG4gICAgfVxuICAgIGlmIChkYXRhWzMxXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgc3RyaW5nIC0gbm8gbnVsbCB0ZXJtaW5hdG9yXCIpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBudWxsIHRlcm1pbmF0aW9uXG4gICAgbGV0IGxlbmd0aCA9IDMxO1xuICAgIHdoaWxlIChkYXRhW2xlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHN0cmluZyB2YWx1ZVxuICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoZGF0YS5zbGljZSgwLCBsZW5ndGgpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzMzIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/bytes32.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js":
/*!**************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: function() { return /* binding */ Coder; },\n/* harmony export */   Reader: function() { return /* binding */ Reader; },\n/* harmony export */   Result: function() { return /* binding */ Result; },\n/* harmony export */   WordSize: function() { return /* binding */ WordSize; },\n/* harmony export */   Writer: function() { return /* binding */ Writer; },\n/* harmony export */   checkResultErrors: function() { return /* binding */ checkResultErrors; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n/**\n * @_ignore:\n */\nconst WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n    return resultNames.get(result);\n}\nfunction setNames(result, names) {\n    resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\nfunction toObject(names, items, deep) {\n    if (names.indexOf(null) >= 0) {\n        return items.map((item, index) => {\n            if (item instanceof Result) {\n                return toObject(getNames(item), item, deep);\n            }\n            return item;\n        });\n    }\n    return names.reduce((accum, name, index) => {\n        let item = items.getValue(name);\n        if (!(name in accum)) {\n            if (deep && item instanceof Result) {\n                item = toObject(getNames(item), item, deep);\n            }\n            accum[name] = item;\n        }\n        return accum;\n    }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nclass Result extends Array {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    #names;\n    /**\n     *  @private\n     */\n    constructor(...args) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof (name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, (new Map()));\n        // Remove any key thats not unique\n        setNames(this, Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        })));\n        // Dummy operations to prevent TypeScript from complaining\n        this.#names = [];\n        if (this.#names == null) {\n            void (this.#names);\n        }\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        const proxy = new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function (...args) {\n                            return value.apply((this === receiver) ? target : this, args);\n                        };\n                    }\n                    else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target : this, [prop]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n        setNames(proxy, getNames(this));\n        return proxy;\n    }\n    /**\n     *  Returns the Result as a normal Array. If %%deep%%, any children\n     *  which are Result objects are also converted to a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray(deep) {\n        const result = [];\n        this.forEach((item, index) => {\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            if (deep && item instanceof Result) {\n                item = item.toArray(deep);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair. If\n     *  %%deep%%, any children which are Result objects are also\n     *  converted to an Object.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject(deep) {\n        const names = getNames(this);\n        return names.reduce((accum, name, index) => {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            return toObject(names, this, deep);\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */\n    slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const _names = getNames(this);\n        const result = [], names = [];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(_names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    filter(callback, thisArg) {\n        const _names = getNames(this);\n        const result = [], names = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(_names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    map(callback, thisArg) {\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name) {\n        const index = getNames(this).indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nfunction checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nfunction getValue(value) {\n    let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", { buffer: bytes, length: WordSize, offset: bytes.length });\n    if (bytes.length !== WordSize) {\n        bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([Padding.slice(bytes.length % WordSize), bytes]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */\nclass Coder {\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    name;\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    type;\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    localName;\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    dynamic;\n    constructor(name, type, localName, dynamic) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, message, this.localName, value);\n    }\n}\n/**\n *  @_ignore\n */\nclass Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor() {\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(this.#data);\n    }\n    get length() { return this.#dataLength; }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([bytes, Padding.slice(paddingOffset)]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n/**\n *  @_ignore\n */\nclass Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    allowLoose;\n    #data;\n    #offset;\n    #bytesRead;\n    #parent;\n    #maxInflation;\n    constructor(data, allowLoose, maxInflation) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { allowLoose: !!allowLoose });\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(data);\n        this.#bytesRead = 0;\n        this.#parent = null;\n        this.#maxInflation = (maxInflation != null) ? maxInflation : 1024;\n        this.#offset = 0;\n    }\n    get data() { return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(this.#data); }\n    get dataLength() { return this.#data.length; }\n    get consumed() { return this.#offset; }\n    get bytes() { return new Uint8Array(this.#data); }\n    #incrementBytesRead(count) {\n        if (this.#parent) {\n            return this.#parent.#incrementBytesRead(count);\n        }\n        this.#bytesRead += count;\n        // Check for excessive inflation (see: #4537)\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n            buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(this.#data), offset: this.#offset,\n            length: count, info: {\n                bytesRead: this.#bytesRead,\n                dataLength: this.dataLength\n            }\n        });\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            }\n            else {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n        reader.#parent = this;\n        return reader;\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#incrementBytesRead(length);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt)(this.readBytes(WordSize));\n    }\n    readIndex() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toNumber)(this.readBytes(WordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFFK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixLQUFLO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMERBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBTSxpQ0FBaUMsT0FBTztBQUMxRDtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBLG9DQUFvQyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0Esb0NBQW9DLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQVM7QUFDekIsSUFBSSx1REFBTSxzRUFBc0UsdURBQXVEO0FBQ3ZJO0FBQ0EsZ0JBQWdCLDZEQUFZLENBQUMsdURBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxnQ0FBZ0M7QUFDakU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQU07QUFDckI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZEQUFZO0FBQzNDO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esb0JBQW9CLDZEQUFZO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQVksQ0FBQyx1REFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUywwQkFBMEI7QUFDM0QscUJBQXFCLDZEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyx3REFBTztBQUMvQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLHNJQUFzSSxvQkFBb0I7QUFDeEssb0JBQW9CLDZEQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQU07QUFDdEIsNEJBQTRCLDZEQUFZO0FBQ3hDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUseURBQVE7QUFDdkI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanM/NjJjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBjb25jYXQsIGdldEJ5dGVzQ29weSwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b051bWJlciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudFxuLyosIGlzRXJyb3IqL1xuIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBfaWdub3JlOlxuICovXG5leHBvcnQgY29uc3QgV29yZFNpemUgPSAzMjtcbmNvbnN0IFBhZGRpbmcgPSBuZXcgVWludDhBcnJheShXb3JkU2l6ZSk7XG4vLyBQcm9wZXJ0aWVzIHVzZWQgdG8gaW1tZWRpYXRlIHBhc3MgdGhyb3VnaCB0byB0aGUgdW5kZXJseWluZyBvYmplY3Rcbi8vIC0gYHRoZW5gIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGFuIG9iamVjdCBpcyBhIFByb21pc2UgZm9yIGF3YWl0XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmNvbnN0IHJlc3VsdE5hbWVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldE5hbWVzKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHROYW1lcy5nZXQocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHNldE5hbWVzKHJlc3VsdCwgbmFtZXMpIHtcbiAgICByZXN1bHROYW1lcy5zZXQocmVzdWx0LCBuYW1lcyk7XG59XG5mdW5jdGlvbiB0aHJvd0Vycm9yKG5hbWUsIGVycm9yKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBFcnJvcihgZGVmZXJyZWQgZXJyb3IgZHVyaW5nIEFCSSBkZWNvZGluZyB0cmlnZ2VyZWQgYWNjZXNzaW5nICR7bmFtZX1gKTtcbiAgICB3cmFwcGVkLmVycm9yID0gZXJyb3I7XG4gICAgdGhyb3cgd3JhcHBlZDtcbn1cbmZ1bmN0aW9uIHRvT2JqZWN0KG5hbWVzLCBpdGVtcywgZGVlcCkge1xuICAgIGlmIChuYW1lcy5pbmRleE9mKG51bGwpID49IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvT2JqZWN0KGdldE5hbWVzKGl0ZW0pLCBpdGVtLCBkZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCBpdGVtID0gaXRlbXMuZ2V0VmFsdWUobmFtZSk7XG4gICAgICAgIGlmICghKG5hbWUgaW4gYWNjdW0pKSB7XG4gICAgICAgICAgICBpZiAoZGVlcCAmJiBpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRvT2JqZWN0KGdldE5hbWVzKGl0ZW0pLCBpdGVtLCBkZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY3VtW25hbWVdID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiAgQSBbW1Jlc3VsdF1dIGlzIGEgc3ViLWNsYXNzIG9mIEFycmF5LCB3aGljaCBhbGxvd3MgYWNjZXNzaW5nIGFueVxuICogIG9mIGl0cyB2YWx1ZXMgZWl0aGVyIHBvc2l0aW9uYWxseSBieSBpdHMgaW5kZXggb3IsIGlmIGtleXMgYXJlXG4gKiAgcHJvdmlkZWQgYnkgaXRzIG5hbWUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvYWJpXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXN1bHQgZXh0ZW5kcyBBcnJheSB7XG4gICAgLy8gTm8gbG9uZ2VyIHVzZWQ7IGJ1dCBjYW5ub3QgYmUgcmVtb3ZlZCBhcyBpdCB3aWxsIHJlbW92ZSB0aGVcbiAgICAvLyAjcHJpdmF0ZSBmaWVsZCBmcm9tIHRoZSAuZC50cyB3aGljaCBtYXkgYnJlYWsgYmFja3dhcmRzXG4gICAgLy8gY29tcGF0aWJpbGl0eVxuICAgICNuYW1lcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRvIHByb3Blcmx5IHN1Yi1jbGFzcyBBcnJheSBzbyB0aGUgb3RoZXIgYnVpbHQtaW5cbiAgICAgICAgLy8gZnVuY3Rpb25zIHdvcmssIHRoZSBjb25zdHJ1Y3RvciBoYXMgdG8gYmVoYXZlIGZhaXJseVxuICAgICAgICAvLyB3ZWxsLiBTbywgaW4gdGhlIGV2ZW50IHdlIGFyZSBjcmVhdGVkIHZpYSBmcm9tSXRlbXMoKVxuICAgICAgICAvLyB3ZSBidWlsZCB0aGUgcmVhZC1vbmx5IFJlc3VsdCBvYmplY3Qgd2Ugd2FudCwgYnV0IG9uXG4gICAgICAgIC8vIGFueSBvdGhlciBpbnB1dCwgd2UgdXNlIHRoZSBkZWZhdWx0IGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yKGd1YXJkOiBhbnksIGl0ZW1zOiBBcnJheTxhbnk+LCBrZXlzPzogQXJyYXk8bnVsbCB8IHN0cmluZz4pO1xuICAgICAgICBjb25zdCBndWFyZCA9IGFyZ3NbMF07XG4gICAgICAgIGxldCBpdGVtcyA9IGFyZ3NbMV07XG4gICAgICAgIGxldCBuYW1lcyA9IChhcmdzWzJdIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBsZXQgd3JhcCA9IHRydWU7XG4gICAgICAgIGlmIChndWFyZCAhPT0gX2d1YXJkKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGFyZ3M7XG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgd3JhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbid0IGp1c3QgcGFzcyBpbiAuLi5pdGVtcyBzaW5jZSBhbiBhcnJheSBvZiBsZW5ndGggMVxuICAgICAgICAvLyBpcyBhIHNwZWNpYWwgY2FzZSBpbiB0aGUgc3VwZXIuXG4gICAgICAgIHN1cGVyKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7IHRoaXNbaW5kZXhdID0gaXRlbTsgfSk7XG4gICAgICAgIC8vIEZpbmQgYWxsIHVuaXF1ZSBrZXlzXG4gICAgICAgIGNvbnN0IG5hbWVDb3VudHMgPSBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGFjY3VtLnNldChuYW1lLCAoYWNjdW0uZ2V0KG5hbWUpIHx8IDApICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIChuZXcgTWFwKCkpKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBrZXkgdGhhdHMgbm90IHVuaXF1ZVxuICAgICAgICBzZXROYW1lcyh0aGlzLCBPYmplY3QuZnJlZXplKGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpbmRleF07XG4gICAgICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmIG5hbWVDb3VudHMuZ2V0KG5hbWUpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgLy8gRHVtbXkgb3BlcmF0aW9ucyB0byBwcmV2ZW50IFR5cGVTY3JpcHQgZnJvbSBjb21wbGFpbmluZ1xuICAgICAgICB0aGlzLiNuYW1lcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy4jbmFtZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdm9pZCAodGhpcy4jbmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd3JhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgd3JhcHBlZCBSZXN1bHQgaXMgaW1tdXRhYmxlXG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIC8vIFByb3h5IGluZGljZXMgYW5kIG5hbWVzIHNvIHdlIGNhbiB0cmFwIGRlZmVycmVkIGVycm9yc1xuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kZXggYWNjZXNzb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TnVtYmVyKHByb3AsIFwiJWluZGV4XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJlc3VsdCByYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBmdW5jdGlvbnMgd29yayB3aXRoIHByaXZhdGUgdmFyaWFibGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5I25vX3ByaXZhdGVfcHJvcGVydHlfZm9yd2FyZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIG5hbWUgYWNjZXNzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0VmFsdWUuYXBwbHkoKHRoaXMgPT09IHJlY2VpdmVyKSA/IHRhcmdldCA6IHRoaXMsIFtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0TmFtZXMocHJveHksIGdldE5hbWVzKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgUmVzdWx0IGFzIGEgbm9ybWFsIEFycmF5LiBJZiAlJWRlZXAlJSwgYW55IGNoaWxkcmVuXG4gICAgICogIHdoaWNoIGFyZSBSZXN1bHQgb2JqZWN0cyBhcmUgYWxzbyBjb252ZXJ0ZWQgdG8gYSBub3JtYWwgQXJyYXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZXJlIGFyZSBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWRcbiAgICAgKiAgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvQXJyYXkoZGVlcCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVlcCAmJiBpdGVtIGluc3RhbmNlb2YgUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0udG9BcnJheShkZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFJlc3VsdCBhcyBhbiBPYmplY3Qgd2l0aCBlYWNoIG5hbWUtdmFsdWUgcGFpci4gSWZcbiAgICAgKiAgJSVkZWVwJSUsIGFueSBjaGlsZHJlbiB3aGljaCBhcmUgUmVzdWx0IG9iamVjdHMgYXJlIGFsc29cbiAgICAgKiAgY29udmVydGVkIHRvIGFuIE9iamVjdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgaWYgYW55IHZhbHVlIGlzIHVubmFtZWQsIG9yIGlmIHRoZXJlIGFyZVxuICAgICAqICBhbnkgb3V0c3RhbmRpbmcgZGVmZXJyZWQgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvT2JqZWN0KGRlZXApIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBnZXROYW1lcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQobmFtZSAhPSBudWxsLCBgdmFsdWUgYXQgaW5kZXggJHtpbmRleH0gdW5uYW1lZGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwidG9PYmplY3QoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b09iamVjdChuYW1lcywgdGhpcywgZGVlcCk7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfbmFtZXMgPSBnZXROYW1lcyh0aGlzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW10sIG5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzW2ldKTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2goX25hbWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBmaWx0ZXIoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgX25hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aX1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgbmFtZXMucHVzaChfbmFtZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgcmVzdWx0LCBuYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIG1hcChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdmFsdWUgZm9yICUlbmFtZSUlLlxuICAgICAqXG4gICAgICogIFNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgYSBrZXkgd2hvc2UgbmFtZSBjb25mbGljdHMgd2l0aFxuICAgICAqICBhIG1ldGhvZCBvbiBhIFtbUmVzdWx0XV0gb3IgaXRzIHN1cGVyY2xhc3MgQXJyYXksIG9yIGFueVxuICAgICAqICBKYXZhU2NyaXB0IGtleXdvcmQsIHRoaXMgZW5zdXJlcyBhbGwgbmFtZWQgdmFsdWVzIGFyZSBzdGlsbFxuICAgICAqICBhY2Nlc3NpYmxlIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0VmFsdWUobmFtZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldE5hbWVzKHRoaXMpLmluZGV4T2YobmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgdmFsdWUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tSZXN1bHRdXSBmb3IgJSVpdGVtcyUlIHdpdGggZWFjaCBlbnRyeVxuICAgICAqICBhbHNvIGFjY2Vzc2libGUgYnkgaXRzIGNvcnJlc3BvbmRpbmcgbmFtZSBpbiAlJWtleXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUl0ZW1zKGl0ZW1zLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KF9ndWFyZCwgaXRlbXMsIGtleXMpO1xuICAgIH1cbn1cbi8qKlxuICogIFJldHVybnMgYWxsIGVycm9ycyBmb3VuZCBpbiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIFNpbmNlIGNlcnRhaW4gZXJyb3JzIGVuY291bnRlcmVkIHdoZW4gY3JlYXRpbmcgYSBbW1Jlc3VsdF1dIGRvXG4gKiAgbm90IGltcGFjdCB0aGUgYWJpbGl0eSB0byBjb250aW51ZSBwYXJzaW5nIGRhdGEsIHRoZXkgYXJlXG4gKiAgZGVmZXJyZWQgdW50aWwgdGhleSBhcmUgYWN0dWFsbHkgYWNjZXNzZWQuIEhlbmNlIGEgZmF1bHR5IHN0cmluZ1xuICogIGluIGFuIEV2ZW50IHRoYXQgaXMgbmV2ZXIgdXNlZCBkb2VzIG5vdCBpbXBhY3QgdGhlIHByb2dyYW0gZmxvdy5cbiAqXG4gKiAgSG93ZXZlciwgc29tZXRpbWVzIGl0IG1heSBiZSB1c2VmdWwgdG8gYWNjZXNzLCBpZGVudGlmeSBvclxuICogIHZhbGlkYXRlIGNvcnJlY3RuZXNzIG9mIGEgW1tSZXN1bHRdXS5cbiAqXG4gKiAgQF9kb2Nsb2MgYXBpL2FiaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBieXRlcyA9IHRvQmVBcnJheSh2YWx1ZSk7XG4gICAgYXNzZXJ0KGJ5dGVzLmxlbmd0aCA8PSBXb3JkU2l6ZSwgXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwgeyBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IFdvcmRTaXplLCBvZmZzZXQ6IGJ5dGVzLmxlbmd0aCB9KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBXb3JkU2l6ZSkge1xuICAgICAgICBieXRlcyA9IGdldEJ5dGVzQ29weShjb25jYXQoW1BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgV29yZFNpemUpLCBieXRlc10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVyIHtcbiAgICAvLyBUaGUgY29kZXIgbmFtZTpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUsIGFycmF5LCBldGMuXG4gICAgbmFtZTtcbiAgICAvLyBUaGUgZnVsbHkgZXhwYW5kZWQgdHlwZSwgaW5jbHVkaW5nIGNvbXBvc2l0ZSB0eXBlczpcbiAgICAvLyAgIC0gYWRkcmVzcywgdWludDI1NiwgdHVwbGUoYWRkcmVzcyxieXRlcyksIHVpbnQyNTZbM11bNF1bXSwgIGV0Yy5cbiAgICB0eXBlO1xuICAgIC8vIFRoZSBsb2NhbE5hbWUgYm91bmQgaW4gdGhlIHNpZ25hdHVyZSwgaW4gdGhpcyBleGFtcGxlIGl0IGlzIFwiYmF6XCI6XG4gICAgLy8gICAtIHR1cGxlKGFkZHJlc3MgZm9vLCB1aW50IGJhcikgYmF6XG4gICAgbG9jYWxOYW1lO1xuICAgIC8vIFdoZXRoZXIgdGhpcyB0eXBlIGlzIGR5bmFtaWM6XG4gICAgLy8gIC0gRHluYW1pYzogYnl0ZXMsIHN0cmluZywgYWRkcmVzc1tdLCB0dXBsZShib29sZWFuW10pLCBldGMuXG4gICAgLy8gIC0gTm90IER5bmFtaWM6IGFkZHJlc3MsIHVpbnQyNTYsIGJvb2xlYW5bM10sIHR1cGxlKGFkZHJlc3MsIHVpbnQ4KVxuICAgIGR5bmFtaWM7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIiwgdHlwZTogXCJzdHJpbmdcIiwgbG9jYWxOYW1lOiBcInN0cmluZ1wiLCBkeW5hbWljOiBcImJvb2xlYW5cIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIG1lc3NhZ2UsIHRoaXMubG9jYWxOYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFdyaXRlciB7XG4gICAgLy8gQW4gYXJyYXkgb2YgV29yZFNpemUgbGVuZ3RoZWQgb2JqZWN0cyB0byBjb25jYXRlbmF0aW9uXG4gICAgI2RhdGE7XG4gICAgI2RhdGFMZW5ndGg7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KHRoaXMuI2RhdGEpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YUxlbmd0aDsgfVxuICAgICN3cml0ZURhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgYXBwZW5kV3JpdGVyKHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGdldEJ5dGVzQ29weSh3cml0ZXIuZGF0YSkpO1xuICAgIH1cbiAgICAvLyBBcnJheWlzaCBpdGVtOyBwYWQgb24gdGhlIHJpZ2h0IHRvICpuZWFyZXN0KiBXb3JkU2l6ZVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ09mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplO1xuICAgICAgICBpZiAocGFkZGluZ09mZnNldCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtieXRlcywgUGFkZGluZy5zbGljZShwYWRkaW5nT2Zmc2V0KV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jd3JpdGVEYXRhKGJ5dGVzKTtcbiAgICB9XG4gICAgLy8gTnVtZXJpYyBpdGVtOyBwYWQgb24gdGhlIGxlZnQgKnRvKiBXb3JkU2l6ZVxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBJbnNlcnRzIGEgbnVtZXJpYyBwbGFjZS1ob2xkZXIsIHJldHVybmluZyBhIGNhbGxiYWNrIHRoYXQgY2FuXG4gICAgLy8gYmUgdXNlZCB0byBhc2p1c3QgdGhlIHZhbHVlIGxhdGVyXG4gICAgd3JpdGVVcGRhdGFibGVWYWx1ZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy4jZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuI2RhdGEucHVzaChQYWRkaW5nKTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCArPSBXb3JkU2l6ZTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZGF0YVtvZmZzZXRdID0gZ2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkZXIge1xuICAgIC8vIEFsbG93cyBpbmNvbXBsZXRlIHVucGFkZGVkIGRhdGEgdG8gYmUgcmVhZDsgb3RoZXJ3aXNlIGFuIGVycm9yXG4gICAgLy8gaXMgcmFpc2VkIGlmIGF0dGVtcHRpbmcgdG8gb3ZlcnJ1biB0aGUgYnVmZmVyLiBUaGlzIGlzIHJlcXVpcmVkXG4gICAgLy8gdG8gZGVhbCB3aXRoIGFuIG9sZCBTb2xpZGl0eSBidWcsIGluIHdoaWNoIGV2ZW50IGRhdGEgZm9yXG4gICAgLy8gZXh0ZXJuYWwgKG5vdCBwdWJsaWMgdGhvZ3VoKSB3YXMgdGlnaHRseSBwYWNrZWQuXG4gICAgYWxsb3dMb29zZTtcbiAgICAjZGF0YTtcbiAgICAjb2Zmc2V0O1xuICAgICNieXRlc1JlYWQ7XG4gICAgI3BhcmVudDtcbiAgICAjbWF4SW5mbGF0aW9uO1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGFsbG93TG9vc2UsIG1heEluZmxhdGlvbikge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWxsb3dMb29zZTogISFhbGxvd0xvb3NlIH0pO1xuICAgICAgICB0aGlzLiNkYXRhID0gZ2V0Qnl0ZXNDb3B5KGRhdGEpO1xuICAgICAgICB0aGlzLiNieXRlc1JlYWQgPSAwO1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhJbmZsYXRpb24gPSAobWF4SW5mbGF0aW9uICE9IG51bGwpID8gbWF4SW5mbGF0aW9uIDogMTAyNDtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiBoZXhsaWZ5KHRoaXMuI2RhdGEpOyB9XG4gICAgZ2V0IGRhdGFMZW5ndGgoKSB7IHJldHVybiB0aGlzLiNkYXRhLmxlbmd0aDsgfVxuICAgIGdldCBjb25zdW1lZCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxuICAgIGdldCBieXRlcygpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2RhdGEpOyB9XG4gICAgI2luY3JlbWVudEJ5dGVzUmVhZChjb3VudCkge1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcGFyZW50LiNpbmNyZW1lbnRCeXRlc1JlYWQoY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2J5dGVzUmVhZCArPSBjb3VudDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGV4Y2Vzc2l2ZSBpbmZsYXRpb24gKHNlZTogIzQ1MzcpXG4gICAgICAgIGFzc2VydCh0aGlzLiNtYXhJbmZsYXRpb24gPCAxIHx8IHRoaXMuI2J5dGVzUmVhZCA8PSB0aGlzLiNtYXhJbmZsYXRpb24gKiB0aGlzLmRhdGFMZW5ndGgsIGBjb21wcmVzc2VkIEFCSSBkYXRhIGV4Y2VlZHMgaW5mbGF0aW9uIHJhdGlvIG9mICR7dGhpcy4jbWF4SW5mbGF0aW9ufSAoIHNlZTogaHR0cHM6L1xcL2dpdGh1Yi5jb20vZXRoZXJzLWlvL2V0aGVycy5qcy9pc3N1ZXMvNDUzNyApYCwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGdldEJ5dGVzQ29weSh0aGlzLiNkYXRhKSwgb2Zmc2V0OiB0aGlzLiNvZmZzZXQsXG4gICAgICAgICAgICBsZW5ndGg6IGNvdW50LCBpbmZvOiB7XG4gICAgICAgICAgICAgICAgYnl0ZXNSZWFkOiB0aGlzLiNieXRlc1JlYWQsXG4gICAgICAgICAgICAgICAgZGF0YUxlbmd0aDogdGhpcy5kYXRhTGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjcGVla0J5dGVzKG9mZnNldCwgbGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYWxpZ25lZExlbmd0aCA9IE1hdGguY2VpbChsZW5ndGggLyBXb3JkU2l6ZSkgKiBXb3JkU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLiNkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dMb29zZSAmJiBsb29zZSAmJiB0aGlzLiNvZmZzZXQgKyBsZW5ndGggPD0gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbGlnbmVkTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImRhdGEgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBnZXRCeXRlc0NvcHkodGhpcy4jZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy4jZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNkYXRhLnNsaWNlKHRoaXMuI29mZnNldCwgdGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCk7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIHN1Yi1yZWFkZXIgd2l0aCB0aGUgc2FtZSB1bmRlcmx5aW5nIGRhdGEsIGJ1dCBvZmZzZXRcbiAgICBzdWJSZWFkZXIob2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWFkZXIodGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQgKyBvZmZzZXQpLCB0aGlzLmFsbG93TG9vc2UsIHRoaXMuI21heEluZmxhdGlvbik7XG4gICAgICAgIHJlYWRlci4jcGFyZW50ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcbiAgICB9XG4gICAgLy8gUmVhZCBieXRlc1xuICAgIHJlYWRCeXRlcyhsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IHRoaXMuI3BlZWtCeXRlcygwLCBsZW5ndGgsICEhbG9vc2UpO1xuICAgICAgICB0aGlzLiNpbmNyZW1lbnRCeXRlc1JlYWQobGVuZ3RoKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGUgbGVuZ3RoLi5lbmQgYnl0ZXMgYXJlIGFsbCAwP1xuICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gUmVhZCBhIG51bWVyaWMgdmFsdWVzXG4gICAgcmVhZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdG9CaWdJbnQodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcbiAgICB9XG4gICAgcmVhZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodGhpcy5yZWFkQnl0ZXMoV29yZFNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/address.js":
/*!*******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/address.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: function() { return /* binding */ AddressCoder; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/maths.js */ \"../common/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"../common/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n\n/**\n *  @_ignore\n */\nclass AddressCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"string\");\n        try {\n            value = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n        }\n        catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.toBeHex)(reader.readValue(), 20));\n    }\n}\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBb0Q7QUFDTDtBQUNYO0FBQ1E7QUFDNUM7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLHFEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFLO0FBQ3pCO0FBQ0Esb0JBQW9CLDZEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2REFBVSxDQUFDLHdEQUFPO0FBQ2pDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FkZHJlc3MuanM/MThlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uLy4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHRvQmVIZXggfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQWRkcmVzc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModG9CZUhleChyZWFkZXIucmVhZFZhbHVlKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/address.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/anonymous.js":
/*!*********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/anonymous.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: function() { return /* binding */ AnonymousCoder; }\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */\nclass AnonymousCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    coder;\n    constructor(coder) {\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n}\n//# sourceMappingURL=anonymous.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fub255bW91cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLHFEQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYW5vbnltb3VzLmpzPzY5ZTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQ2xvbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIGV4aXN0aW5nIENvZGVyLCBidXQgd2l0aG91dCBhIGxvY2FsTmFtZVxuICpcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXI7XG4gICAgY29uc3RydWN0b3IoY29kZXIpIHtcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgXCJfXCIsIGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbm9ueW1vdXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/anonymous.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/array.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/array.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: function() { return /* binding */ ArrayCoder; },\n/* harmony export */   pack: function() { return /* binding */ pack; },\n/* harmony export */   unpack: function() { return /* binding */ unpack; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"../common/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anonymous.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/anonymous.js\");\n\n\n\n\n/**\n *  @_ignore\n */\nfunction pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    }\n    else if (values && typeof (values) === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n            unique[name] = true;\n            return values[name];\n        });\n    }\n    else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let dynamicWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n/**\n *  @_ignore\n */\nfunction unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder) => {\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Result.fromItems(values, keys);\n}\n/**\n *  @_ignore\n */\nclass ArrayCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Coder {\n    coder;\n    length;\n    constructor(coder, length, localName) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { coder, length });\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        let coders = [];\n        for (let i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", { buffer: reader.bytes, offset: count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize, length: reader.dataLength });\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) {\n            coders.push(new _anonymous_js__WEBPACK_IMPORTED_MODULE_3__.AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n}\n//# sourceMappingURL=array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FycmF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEc7QUFDMUU7QUFDa0M7QUFDdEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBTSxzRkFBc0YsNEJBQTRCLE9BQU8saUJBQWlCO0FBQzVKLFlBQVksdURBQU0saUdBQWlHLDRCQUE0QixPQUFPLGlCQUFpQjtBQUN2SztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0EsSUFBSSwrREFBYztBQUNsQiwyQkFBMkIsc0RBQU07QUFDakMsNEJBQTRCLHNEQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLHNEQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUJBQXlCLHFEQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9FQUFtQjtBQUMzQjtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUFNLFNBQVMsd0RBQVEsdUVBQXVFLHNDQUFzQyx3REFBUSw2QkFBNkI7QUFDckw7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLDRCQUE0Qix5REFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYXJyYXkuanM/YzRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRBcmd1bWVudENvdW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIsIFJlc3VsdCwgV29yZFNpemUsIFdyaXRlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBbm9ueW1vdXNDb2RlciB9IGZyb20gXCIuL2Fub255bW91cy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuICAgIGxldCBhcnJheVZhbHVlcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHt9O1xuICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgYXNzZXJ0KG5hbWUsIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIGFzc2VydCghdW5pcXVlW25hbWVdLCBcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBkdXBsaWNhdGUgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIHVuaXF1ZVtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb2RlcnMubGVuZ3RoID09PSBhcnJheVZhbHVlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCB1cGRhdGVGdW5jcyA9IFtdO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuYyA9IHN0YXRpY1dyaXRlci53cml0ZVVwZGF0YWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB1cGRhdGVGdW5jcy5wdXNoKChiYXNlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG4gICAgdXBkYXRlRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKHN0YXRpY1dyaXRlci5sZW5ndGgpOyB9KTtcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xuICAgIGxlbmd0aCArPSB3cml0ZXIuYXBwZW5kV3JpdGVyKGR5bmFtaWNXcml0ZXIpO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrKHJlYWRlciwgY29kZXJzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBrZXlzID0gW107XG4gICAgLy8gQSByZWFkZXIgYW5jaG9yZWQgdG8gdGhpcyBiYXNlXG4gICAgbGV0IGJhc2VSZWFkZXIgPSByZWFkZXIuc3ViUmVhZGVyKDApO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRSZWFkZXIgPSBiYXNlUmVhZGVyLnN1YlJlYWRlcihvZmZzZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQlVGRkVSX09WRVJSVU5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlc3RpZ2F0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIGtleXMucHVzaChjb2Rlci5sb2NhbE5hbWUgfHwgbnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVyO1xuICAgIGxlbmd0aDtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb2RlciwgbGVuZ3RoIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIC8vIFZlcmlmaWVzIHRoZSBjaGlsZCBjb2RlciBpcyB2YWxpZCAoZXZlbiBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYyBvciAwLWxlbmd0aClcbiAgICAgICAgY29uc3QgZGVmYXVsdENoaWxkID0gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVmYXVsdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYXJyYXlcIik7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxuICAgICAgICAgICAgLy8gc3RyYXkgcmFuZG9tIGRhdGEgaXMgbm90IGJlaW5nIHJlYWQgYXMgYSBsZW5ndGguIEVhY2hcbiAgICAgICAgICAgIC8vIHNsb3QgcmVxdWlyZXMgYXQgbGVhc3QgMzIgYnl0ZXMgZm9yIHRoZWlyIHZhbHVlIChvciAzMlxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXG4gICAgICAgICAgICAvLyB0aWdodGVyIGJvdW5kLCBidXQgd2UgYXJlIGVycm9yaW5nIG9uIHRoZSBzaWRlIG9mIHNhZmV0eS5cbiAgICAgICAgICAgIGFzc2VydChjb3VudCAqIFdvcmRTaXplIDw9IHJlYWRlci5kYXRhTGVuZ3RoLCBcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiByZWFkZXIuYnl0ZXMsIG9mZnNldDogY291bnQgKiBXb3JkU2l6ZSwgbGVuZ3RoOiByZWFkZXIuZGF0YUxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IEFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5wYWNrKHJlYWRlciwgY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/array.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/boolean.js":
/*!*******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/boolean.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: function() { return /* binding */ BooleanCoder; }\n/* harmony export */ });\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"../common/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */\nclass BooleanCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n}\n//# sourceMappingURL=boolean.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Jvb2xlYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9DO0FBQ1E7QUFDNUM7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLHFEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYm9vbGVhbi5qcz9hNWM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQm9vbGVhbkNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJvb2xcIiwgXCJib29sXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcImJvb2xcIik7XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gISFyZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/boolean.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/bytes.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/bytes.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: function() { return /* binding */ BytesCoder; },\n/* harmony export */   DynamicBytesCoder: function() { return /* binding */ DynamicBytesCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */\nclass DynamicBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(type, localName) {\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\n/**\n *  @_ignore\n */\nclass BytesCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader));\n    }\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkQ7QUFDakI7QUFDNUM7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLHFEQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZEQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTztBQUN0QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ieXRlcy5qcz80OTliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEJ5dGVzQ29weSwgaGV4bGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIER5bmFtaWNCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcih0eXBlLCB0eXBlLCBsb2NhbE5hbWUsIHRydWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRJbmRleCgpLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQnl0ZXNDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJieXRlc1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/bytes.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js":
/*!***********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: function() { return /* binding */ FixedBytesCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"../common/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n/**\n *  @_ignore\n */\nclass FixedBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    size;\n    constructor(size, localName) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { size }, { size: \"number\" });\n    }\n    defaultValue() {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(reader.readBytes(this.size));\n    }\n}\n//# sourceMappingURL=fixed-bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2ZpeGVkLWJ5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0U7QUFDM0M7QUFDUTtBQUM1QztBQUNBO0FBQ0E7QUFDTyw4QkFBOEIscURBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLE1BQU0sSUFBSSxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBWSxDQUFDLDRDQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQU87QUFDdEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvZml4ZWQtYnl0ZXMuanM/M2VjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRml4ZWRCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIHNpemU7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUgfSwgeyBzaXplOiBcIm51bWJlclwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAoXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikuc3Vic3RyaW5nKDAsIDIgKyB0aGlzLnNpemUgKiAyKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gZ2V0Qnl0ZXNDb3B5KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlYWRlci5yZWFkQnl0ZXModGhpcy5zaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWQtYnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/null.js":
/*!****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/null.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: function() { return /* binding */ NullCoder; }\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */\nclass NullCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName) {\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n}\n//# sourceMappingURL=null.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IscURBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVsbC5qcz9iZDJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmNvbnN0IEVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkoW10pO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIE51bGxDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJudWxsXCIsIFwiXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIm5vdCBudWxsXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoRW1wdHkpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5yZWFkQnl0ZXMoMCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/null.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/number.js":
/*!******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/number.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: function() { return /* binding */ NumberCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"../common/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */\nclass NumberCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    size;\n    signed;\n    constructor(size, signed, localName) {\n        const name = ((signed ? \"int\" : \"uint\") + (size * 8));\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { size, signed }, { size: \"number\", signed: \"boolean\" });\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(BN_MAX_UINT256, _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize * 8);\n        if (this.signed) {\n            let bounds = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(maxUintValue, (this.size * 8) - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toTwos)(value, 8 * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize);\n        }\n        else if (value < BN_0 || value > (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, this.size * 8);\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJGO0FBQ3ZEO0FBQ2tCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQixxREFBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxjQUFjLElBQUksbUNBQW1DO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVMsQ0FBQyw0Q0FBSztBQUNuQztBQUNBLDJCQUEyQixxREFBSSxpQkFBaUIsd0RBQVE7QUFDeEQ7QUFDQSx5QkFBeUIscURBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVEQUFNLFlBQVksd0RBQVE7QUFDOUM7QUFDQSx5Q0FBeUMscURBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBSTtBQUN4QjtBQUNBLG9CQUFvQix5REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVtYmVyLmpzP2EyZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZnJvbVR3b3MsIGdldEJpZ0ludCwgbWFzaywgdG9Ud29zIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIsIFdvcmRTaXplIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fTUFYX1VJTlQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgTnVtYmVyQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgc2l6ZTtcbiAgICBzaWduZWQ7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgc2lnbmVkLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9ICgoc2lnbmVkID8gXCJpbnRcIiA6IFwidWludFwiKSArIChzaXplICogOCkpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUsIHNpZ25lZCB9LCB7IHNpemU6IFwibnVtYmVyXCIsIHNpZ25lZDogXCJib29sZWFuXCIgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xuICAgICAgICBsZXQgbWF4VWludFZhbHVlID0gbWFzayhCTl9NQVhfVUlOVDI1NiwgV29yZFNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICBsZXQgYm91bmRzID0gbWFzayhtYXhVaW50VmFsdWUsICh0aGlzLnNpemUgKiA4KSAtIDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gYm91bmRzIHx8IHZhbHVlIDwgLShib3VuZHMgKyBCTl8xKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHRvVHdvcyh2YWx1ZSwgOCAqIFdvcmRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IEJOXzAgfHwgdmFsdWUgPiBtYXNrKG1heFVpbnRWYWx1ZSwgdGhpcy5zaXplICogOCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICBsZXQgdmFsdWUgPSBtYXNrKHJlYWRlci5yZWFkVmFsdWUoKSwgdGhpcy5zaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmcm9tVHdvcyh2YWx1ZSwgdGhpcy5zaXplICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/number.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/string.js":
/*!******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/string.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: function() { return /* binding */ StringCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utf8.js */ \"../common/node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"../common/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n\n\n\n/**\n *  @_ignore\n */\nclass StringCoder extends _bytes_js__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    constructor(localName) {\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n}\n//# sourceMappingURL=string.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdFO0FBQzVCO0FBQ1c7QUFDL0M7QUFDQTtBQUNBO0FBQ08sMEJBQTBCLHdEQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyREFBVyxDQUFDLDRDQUFLO0FBQ3JEO0FBQ0E7QUFDQSxlQUFlLDREQUFZO0FBQzNCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3N0cmluZy5qcz9jNTFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRmOC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IER5bmFtaWNCeXRlc0NvZGVyIH0gZnJvbSBcIi4vYnl0ZXMuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJpbmdcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmNvZGUod3JpdGVyLCB0b1V0ZjhCeXRlcyhUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/string.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/coders/tuple.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/coders/tuple.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: function() { return /* binding */ TupleCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/properties.js */ \"../common/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"../common/node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/array.js\");\n\n\n\n\n/**\n *  @_ignore\n */\nclass TupleCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    coders;\n    constructor(coders, localName) {\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n        super(\"tuple\", type, localName, dynamic);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { coders: Object.freeze(coders.slice()) });\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"tuple\");\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.unpack)(reader, this.coders);\n    }\n}\n//# sourceMappingURL=tuple.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3R1cGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZEO0FBQ3pCO0FBQ1E7QUFDRjtBQUMxQztBQUNBO0FBQ0E7QUFDTyx5QkFBeUIscURBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLHNFQUFnQixTQUFTLHVDQUF1QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUFLO0FBQzNCLGVBQWUsK0NBQUk7QUFDbkI7QUFDQTtBQUNBLGVBQWUsaURBQU07QUFDckI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvdHVwbGUuanM/ZmVhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBwYWNrLCB1bnBhY2sgfSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFR1cGxlQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXJzO1xuICAgIGNvbnN0cnVjdG9yKGNvZGVycywgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBkeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzLnB1c2goY29kZXIudHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eXBlID0gKFwidHVwbGUoXCIgKyB0eXBlcy5qb2luKFwiLFwiKSArIFwiKVwiKTtcbiAgICAgICAgc3VwZXIoXCJ0dXBsZVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgY29kZXJzOiBPYmplY3QuZnJlZXplKGNvZGVycy5zbGljZSgpKSB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGNvZGVyLmRlZmF1bHRWYWx1ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xuICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IHRoaXMuY29kZXJzLnJlZHVjZSgoYWNjdW0sIGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY3VtW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvLyBBZGQgbmFtZWQgdmFsdWVzXG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAoIW5hbWUgfHwgdW5pcXVlTmFtZXNbbmFtZV0gIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwidHVwbGVcIik7XG4gICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgdGhpcy5jb2RlcnMsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdW5wYWNrKHJlYWRlciwgdGhpcy5jb2RlcnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR1cGxlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/coders/tuple.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/fragments.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/fragments.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: function() { return /* binding */ ConstructorFragment; },\n/* harmony export */   ErrorFragment: function() { return /* binding */ ErrorFragment; },\n/* harmony export */   EventFragment: function() { return /* binding */ EventFragment; },\n/* harmony export */   FallbackFragment: function() { return /* binding */ FallbackFragment; },\n/* harmony export */   Fragment: function() { return /* binding */ Fragment; },\n/* harmony export */   FunctionFragment: function() { return /* binding */ FunctionFragment; },\n/* harmony export */   NamedFragment: function() { return /* binding */ NamedFragment; },\n/* harmony export */   ParamType: function() { return /* binding */ ParamType; },\n/* harmony export */   StructFragment: function() { return /* binding */ StructFragment; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hash/index.js */ \"../common/node_modules/ethers/lib.esm/hash/index.js\");\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\n\n\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k) => result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable override\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view override\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\", \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\", \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\", \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() { return this.#offset; }\n    get length() { return this.#tokens.length - this.#offset; }\n    constructor(tokens) {\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() { return new TokenString(this.#tokens); }\n    reset() { this.#offset = 0; }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t) => {\n            return Object.freeze(Object.assign({}, t, {\n                match: (t.match - from),\n                linkBack: (t.linkBack - from),\n                linkNext: (t.linkNext - from),\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            const top = this.peek();\n            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while (this.#offset < top.match - 1) {\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return (top != null && allowed.has(top)) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return (top.type === type) ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message) => {\n        const token = (offset < text.length) ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while (offset < text.length) {\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \"\", text: \"\", offset, value: -1 };\n        tokens.push(token);\n        let type = (SimpleTokens[cur[0]] || \"\");\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            }\n            else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                (tokens[token.match]).match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\n            }\n            else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            }\n            else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            }\n            else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    (tokens[tokens.length - 1]).value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                (tokens[tokens.length - 1]).text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for (const key in allowed.keys()) {\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while (true) {\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || (allowed && !allowed.has(keyword))) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    }\n    else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nclass ParamType {\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    name;\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    type;\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    baseType;\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    indexed;\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    components;\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    arrayLength;\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    arrayChildren;\n    /**\n     *  @private\n     */\n    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        }\n        else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        }\n        else if (components != null) {\n            throw new Error(\"\");\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\n        }\n        else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */\n    isArray() {\n        return (this.baseType === \"array\");\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */\n    isTuple() {\n        return (this.baseType === \"tuple\");\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */\n    isIndexable() {\n        return (this.indexed != null);\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */\n    walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v) => (_this.arrayChildren.walk(v, process)));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i) => (_this.components[i].walk(v, process)));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index) => {\n                childType.#walkAsync(promises, value, process, (value) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            }\n            else {\n                if (value == null || typeof (value) !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param) => {\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index) => {\n                components[index].#walkAsync(promises, value, process, (value) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push((async function () { setValue(await result); })());\n        }\n        else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS names by walking and resolving each\n     *  ``\"address\"`` type.\n     */\n    async walkAsync(value, process) {\n        const promises = [];\n        const result = [value];\n        this.#walkAsync(promises, value, process, (value) => {\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */\n    static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t) => ParamType.from(t));\n                type = `tuple(${comps.map((c) => c.format()).join(\",\")})`;\n            }\n            else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while (obj.length && obj.peekType(\"BRACKET\")) {\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = (obj.peekType(\"ID\") ? obj.pop().text : \"\");\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!name || (typeof (name) === \"string\" && name.match(regexId)), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */\n    static isParamType(value) {\n        return (value && value[internal] === ParamTypeInternal);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nclass Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    type;\n    /**\n     *  The inputs for the fragment.\n     */\n    inputs;\n    /**\n     *  @private\n     */\n    constructor(guard, type, inputs) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { type, inputs });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */\n    static from(obj) {\n        if (typeof (obj) === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            }\n            catch (e) { }\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch (type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n        }\n        else if (typeof (obj) === \"object\") {\n            // JSON ABI\n            switch (obj.type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */\n    static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */\n    static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */\n    static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */\n    static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */\n    static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nclass NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    name;\n    /**\n     *  @private\n     */\n    constructor(guard, type, name, inputs) {\n        super(guard, type, inputs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (name) === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name });\n    }\n}\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p) => p.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nclass ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n    /**\n     *  The Custom Error selector.\n     */\n    get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_1__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === ErrorFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents an Event.\n */\nclass EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    anonymous;\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs, anonymous) {\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, { value: EventFragmentInternal });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { anonymous });\n    }\n    /**\n     *  The Event topic hash.\n     */\n    get topicHash() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_1__.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */\n    static getTopicHash(name, params) {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === EventFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a constructor.\n */\nclass ConstructorFragment extends Fragment {\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    payable;\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    gas;\n    /**\n     *  @private\n     */\n    constructor(guard, type, inputs, payable, gas) {\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { payable, gas });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */\n    format(format) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", { operation: \"format(sighash)\" });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: (this.payable ? \"payable\" : \"undefined\"),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas : undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n        const result = [`constructor${joinParams(format, this.inputs)}`];\n        if (this.payable) {\n            result.push(\"payable\");\n        }\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\"constructor\"]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === ConstructorFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a method.\n */\nclass FallbackFragment extends Fragment {\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    payable;\n    constructor(guard, inputs, payable) {\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { payable });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */\n    format(format) {\n        const type = ((this.inputs.length === 0) ? \"receive\" : \"fallback\");\n        if (format === \"json\") {\n            const stateMutability = (this.payable ? \"payable\" : \"nonpayable\");\n            return JSON.stringify({ type, stateMutability });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\"fallback\", \"receive\"]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\"payable\"]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n            else {\n                inputs = [ParamType.from(\"bytes\")];\n            }\n            const mutability = consumeMutability(obj);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [ParamType.from(\"bytes\")];\n            const payable = (obj.stateMutability === \"payable\");\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === FallbackFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a method.\n */\nclass FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    constant;\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    outputs;\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    stateMutability;\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    payable;\n    /**\n     *  The recommended gas limit to send when calling this function.\n     */\n    gas;\n    /**\n     *  @private\n     */\n    constructor(guard, name, stateMutability, inputs, outputs, gas) {\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });\n        outputs = Object.freeze(outputs.slice());\n        const constant = (stateMutability === \"view\" || stateMutability === \"pure\");\n        const payable = (stateMutability === \"payable\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { constant, gas, outputs, payable, stateMutability });\n    }\n    /**\n     *  The Function selector.\n     */\n    get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_1__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas : undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */\n    static getSelector(name, params) {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof (obj.constant) === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            }\n            else if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === FunctionFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a structure.\n */\nclass StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */\n    format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (typeof (obj) === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            }\n            catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === StructFragmentInternal);\n    }\n}\n//# sourceMappingURL=fragments.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvZnJhZ21lbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrSDtBQUM1RTtBQUN0QztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sTUFBTSxVQUFVLEVBQUUseUJBQXlCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwrQkFBK0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvZnJhZ21lbnRzLmpzPzI3NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBmcmFnbWVudCBpcyBhIHNpbmdsZSBpdGVtIGZyb20gYW4gQUJJLCB3aGljaCBtYXkgcmVwcmVzZW50IGFueSBvZjpcbiAqXG4gKiAgLSBbRnVuY3Rpb25zXShGdW5jdGlvbkZyYWdtZW50KVxuICogIC0gW0V2ZW50c10oRXZlbnRGcmFnbWVudClcbiAqICAtIFtDb25zdHJ1Y3RvcnNdKENvbnN0cnVjdG9yRnJhZ21lbnQpXG4gKiAgLSBDdXN0b20gW0Vycm9yc10oRXJyb3JGcmFnbWVudClcbiAqICAtIFtGYWxsYmFjayBvciBSZWNlaXZlXShGYWxsYmFja0ZyYWdtZW50KSBmdW5jdGlvbnNcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkZyYWdtZW50cyAgW2Fib3V0LWZyYWdtZW50c11cbiAqL1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGFzc2VydCwgYXNzZXJ0UHJpdmF0ZSwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbjtcbi8vIFsgXCJhXCIsIFwiYlwiIF0gPT4geyBcImFcIjogMSwgXCJiXCI6IDEgfVxuZnVuY3Rpb24gc2V0aWZ5KGl0ZW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgIGl0ZW1zLmZvckVhY2goKGspID0+IHJlc3VsdC5hZGQoaykpO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG59XG5jb25zdCBfa3dWaXNpYkRlcGxveSA9IFwiZXh0ZXJuYWwgcHVibGljIHBheWFibGUgb3ZlcnJpZGVcIjtcbmNvbnN0IEt3VmlzaWJEZXBsb3kgPSBzZXRpZnkoX2t3VmlzaWJEZXBsb3kuc3BsaXQoXCIgXCIpKTtcbi8vIFZpc2liaWxpdHkgS2V5d29yZHNcbmNvbnN0IF9rd1Zpc2liID0gXCJjb25zdGFudCBleHRlcm5hbCBpbnRlcm5hbCBwYXlhYmxlIHByaXZhdGUgcHVibGljIHB1cmUgdmlldyBvdmVycmlkZVwiO1xuY29uc3QgS3dWaXNpYiA9IHNldGlmeShfa3dWaXNpYi5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3VHlwZXMgPSBcImNvbnN0cnVjdG9yIGVycm9yIGV2ZW50IGZhbGxiYWNrIGZ1bmN0aW9uIHJlY2VpdmUgc3RydWN0XCI7XG5jb25zdCBLd1R5cGVzID0gc2V0aWZ5KF9rd1R5cGVzLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dNb2RpZmllcnMgPSBcImNhbGxkYXRhIG1lbW9yeSBzdG9yYWdlIHBheWFibGUgaW5kZXhlZFwiO1xuY29uc3QgS3dNb2RpZmllcnMgPSBzZXRpZnkoX2t3TW9kaWZpZXJzLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dPdGhlciA9IFwidHVwbGUgcmV0dXJuc1wiO1xuLy8gQWxsIEtleXdvcmRzXG5jb25zdCBfa2V5d29yZHMgPSBbX2t3VHlwZXMsIF9rd01vZGlmaWVycywgX2t3T3RoZXIsIF9rd1Zpc2liXS5qb2luKFwiIFwiKTtcbmNvbnN0IEtleXdvcmRzID0gc2V0aWZ5KF9rZXl3b3Jkcy5zcGxpdChcIiBcIikpO1xuLy8gU2luZ2xlIGNoYXJhY3RlciB0b2tlbnNcbmNvbnN0IFNpbXBsZVRva2VucyA9IHtcbiAgICBcIihcIjogXCJPUEVOX1BBUkVOXCIsIFwiKVwiOiBcIkNMT1NFX1BBUkVOXCIsXG4gICAgXCJbXCI6IFwiT1BFTl9CUkFDS0VUXCIsIFwiXVwiOiBcIkNMT1NFX0JSQUNLRVRcIixcbiAgICBcIixcIjogXCJDT01NQVwiLCBcIkBcIjogXCJBVFwiXG59O1xuLy8gUGFyc2VyIHJlZ2V4ZXMgdG8gY29uc3VtZSB0aGUgbmV4dCB0b2tlblxuY29uc3QgcmVnZXhXaGl0ZXNwYWNlUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oXFxcXHMqKVwiKTtcbmNvbnN0IHJlZ2V4TnVtYmVyUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oWzAtOV0rKVwiKTtcbmNvbnN0IHJlZ2V4SWRQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopXCIpO1xuLy8gUGFyc2VyIHJlZ2V4cyB0byBjaGVjayB2YWxpZGl0eVxuY29uc3QgcmVnZXhJZCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKikkXCIpO1xuY29uc3QgcmVnZXhUeXBlID0gbmV3IFJlZ0V4cChcIl4oYWRkcmVzc3xib29sfGJ5dGVzKFswLTldKil8c3RyaW5nfHU/aW50KFswLTldKikpJFwiKTtcbmNsYXNzIFRva2VuU3RyaW5nIHtcbiAgICAjb2Zmc2V0O1xuICAgICN0b2tlbnM7XG4gICAgZ2V0IG9mZnNldCgpIHsgcmV0dXJuIHRoaXMuI29mZnNldDsgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiN0b2tlbnMubGVuZ3RoIC0gdGhpcy4jb2Zmc2V0OyB9XG4gICAgY29uc3RydWN0b3IodG9rZW5zKSB7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuI3Rva2VucyA9IHRva2Vucy5zbGljZSgpO1xuICAgIH1cbiAgICBjbG9uZSgpIHsgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMpOyB9XG4gICAgcmVzZXQoKSB7IHRoaXMuI29mZnNldCA9IDA7IH1cbiAgICAjc3ViVG9rZW5TdHJpbmcoZnJvbSA9IDAsIHRvID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRoaXMuI3Rva2Vucy5zbGljZShmcm9tLCB0bykubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKHt9LCB0LCB7XG4gICAgICAgICAgICAgICAgbWF0Y2g6ICh0Lm1hdGNoIC0gZnJvbSksXG4gICAgICAgICAgICAgICAgbGlua0JhY2s6ICh0LmxpbmtCYWNrIC0gZnJvbSksXG4gICAgICAgICAgICAgICAgbGlua05leHQ6ICh0LmxpbmtOZXh0IC0gZnJvbSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4sIGlmIGl0IGlzIGEga2V5d29yZCBpbiBhbGxvd2VkOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcEtleXdvcmQoYWxsb3dlZCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIktFWVdPUkRcIiB8fCAhYWxsb3dlZC5oYXModG9wLnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGtleXdvcmQgJHt0b3AudGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiBpZiBpdCBpcyBgdHlwZWA7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wVHlwZSh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfTsgZ290ICR7dG9wLnR5cGV9ICR7SlNPTi5zdHJpbmdpZnkodG9wLnRleHQpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgYSBcIihcIiBUT0tFTlMgXCIpXCJcbiAgICBwb3BQYXJlbigpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBzdGFydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCB0b3AubWF0Y2ggKyAxKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gdG9wLm1hdGNoICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgaXRlbXMgd2l0aGluIFwiKFwiIElURU0xIFwiLFwiIElURU0yIFwiLFwiIC4uLiBcIilcIlxuICAgIHBvcFBhcmFtcygpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBzdGFydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuI29mZnNldCA8IHRvcC5tYXRjaCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLnBlZWsoKS5saW5rTmV4dDtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuI3N1YlRva2VuU3RyaW5nKHRoaXMuI29mZnNldCArIDEsIGxpbmspKTtcbiAgICAgICAgICAgIHRoaXMuI29mZnNldCA9IGxpbms7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gdG9wLm1hdGNoICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdG9wIFRva2VuLCB0aHJvd2luZyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuI29mZnNldCA+PSB0aGlzLiN0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXQtb2YtYm91bmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN0b2tlbnNbdGhpcy4jb2Zmc2V0XTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB2YWx1ZSwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGBhbGxvd2VkYFxuICAgIHBlZWtLZXl3b3JkKGFsbG93ZWQpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIHJldHVybiAodG9wICE9IG51bGwgJiYgYWxsb3dlZC5oYXModG9wKSkgPyB0b3AgOiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiBpZiBpdCBpcyBgdHlwZWBcbiAgICBwZWVrVHlwZSh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHJldHVybiAodG9wLnR5cGUgPT09IHR5cGUpID8gdG9wLnRleHQgOiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBuZXh0IHRva2VuOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHRoaXMuI29mZnNldCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiNvZmZzZXQ7IGkgPCB0aGlzLiN0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy4jdG9rZW5zW2ldO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goYCR7dG9rZW4udHlwZX06JHt0b2tlbi50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPFRva2VuU3RyaW5nICR7dG9rZW5zLmpvaW4oXCIgXCIpfT5gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxleCh0ZXh0KSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgY29uc3QgdGhyb3dFcnJvciA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gKG9mZnNldCA8IHRleHQubGVuZ3RoKSA/IEpTT04uc3RyaW5naWZ5KHRleHRbb2Zmc2V0XSkgOiBcIiRFT0lcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHRva2VuICR7dG9rZW59IGF0ICR7b2Zmc2V0fTogJHttZXNzYWdlfWApO1xuICAgIH07XG4gICAgbGV0IGJyYWNrZXRzID0gW107XG4gICAgbGV0IGNvbW1hcyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAvLyBTdHJpcCBvZmYgYW55IGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgICBsZXQgY3VyID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgbGV0IG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4V2hpdGVzcGFjZVByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW4gPSB7IGRlcHRoOiBicmFja2V0cy5sZW5ndGgsIGxpbmtCYWNrOiAtMSwgbGlua05leHQ6IC0xLCBtYXRjaDogLTEsIHR5cGU6IFwiXCIsIHRleHQ6IFwiXCIsIG9mZnNldCwgdmFsdWU6IC0xIH07XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgbGV0IHR5cGUgPSAoU2ltcGxlVG9rZW5zW2N1clswXV0gfHwgXCJcIik7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBjdXJbMF07XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbW1hcy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJDTE9TRV9QQVJFTlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwibm8gbWF0Y2hpbmcgb3BlbiBicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaCA9IGJyYWNrZXRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubWF0Y2hdKS5tYXRjaCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHRva2VuLmRlcHRoLS07XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIkNPTU1BXCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5saW5rQmFjayA9IGNvbW1hcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLmxpbmtCYWNrXSkubGlua05leHQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIk9QRU5fQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiQlJBQ0tFVFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDTE9TRV9CUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIENMT1NFX0JSQUNLRVRcbiAgICAgICAgICAgICAgICBsZXQgc3VmZml4ID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAwICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSA9PT0gXCJOVU1CRVJcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSB2YWx1ZSArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pLnZhbHVlID0gZ2V0TnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSBcIkJSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG9wZW5pbmcgYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pLnRleHQgKz0gc3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhJZFByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRva2VuLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKEtleXdvcmRzLmhhcyh0b2tlbi50ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIktFWVdPUkRcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50ZXh0Lm1hdGNoKHJlZ2V4VHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJUWVBFXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJJRFwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhOdW1iZXJQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIk5VTUJFUlwiO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRva2VuLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHRva2VuICR7SlNPTi5zdHJpbmdpZnkoY3VyWzBdKX0gYXQgcG9zaXRpb24gJHtvZmZzZXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodG9rZW5zLm1hcCgodCkgPT4gT2JqZWN0LmZyZWV6ZSh0KSkpO1xufVxuLy8gQ2hlY2sgb25seSBvbmUgb2YgYGFsbG93ZWRgIGlzIGluIGBzZXRgXG5mdW5jdGlvbiBhbGxvd1NpbmdsZShzZXQsIGFsbG93ZWQpIHtcbiAgICBsZXQgaW5jbHVkZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhbGxvd2VkLmtleXMoKSkge1xuICAgICAgICBpZiAoc2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBpbmNsdWRlZC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluY2x1ZGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb25mbGljdGluZyB0eXBlczogJHtpbmNsdWRlZC5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxufVxuLy8gRnVuY3Rpb25zIHRvIHByb2Nlc3MgYSBTb2xpZGl0eSBTaWduYXR1cmUgVG9rZW5TdHJpbmcgZnJvbSBsZWZ0LXRvLXJpZ2h0IGZvci4uLlxuLy8gLi4udGhlIG5hbWUgd2l0aCBhbiBvcHRpb25hbCB0eXBlLCByZXR1cm5pbmcgdGhlIG5hbWVcbmZ1bmN0aW9uIGNvbnN1bWVOYW1lKHR5cGUsIHRva2Vucykge1xuICAgIGlmICh0b2tlbnMucGVla0tleXdvcmQoS3dUeXBlcykpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICBpZiAoa2V5d29yZCAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke3R5cGV9LCBnb3QgJHtrZXl3b3JkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnMucG9wVHlwZShcIklEXCIpO1xufVxuLy8gLi4uYWxsIGtleXdvcmRzIG1hdGNoaW5nIGFsbG93ZWQsIHJldHVybmluZyB0aGUga2V5d29yZHNcbmZ1bmN0aW9uIGNvbnN1bWVLZXl3b3Jkcyh0b2tlbnMsIGFsbG93ZWQpIHtcbiAgICBjb25zdCBrZXl3b3JkcyA9IG5ldyBTZXQoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBrZXl3b3JkID0gdG9rZW5zLnBlZWtUeXBlKFwiS0VZV09SRFwiKTtcbiAgICAgICAgaWYgKGtleXdvcmQgPT0gbnVsbCB8fCAoYWxsb3dlZCAmJiAhYWxsb3dlZC5oYXMoa2V5d29yZCkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIGlmIChrZXl3b3Jkcy5oYXMoa2V5d29yZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIGtleXdvcmRzOiAke0pTT04uc3RyaW5naWZ5KGtleXdvcmQpfWApO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRzLmFkZChrZXl3b3JkKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoa2V5d29yZHMpO1xufVxuLy8gLi4uYWxsIHZpc2liaWxpdHkga2V5d29yZHMsIHJldHVybmluZyB0aGUgY29hbGVzY2VkIG11dGFiaWxpdHlcbmZ1bmN0aW9uIGNvbnN1bWVNdXRhYmlsaXR5KHRva2Vucykge1xuICAgIGxldCBtb2RpZmllcnMgPSBjb25zdW1lS2V5d29yZHModG9rZW5zLCBLd1Zpc2liKTtcbiAgICAvLyBEZXRlY3QgY29uZmxpY3RpbmcgbW9kaWZpZXJzXG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJjb25zdGFudCBwYXlhYmxlIG5vbnBheWFibGVcIi5zcGxpdChcIiBcIikpKTtcbiAgICBhbGxvd1NpbmdsZShtb2RpZmllcnMsIHNldGlmeShcInB1cmUgdmlldyBwYXlhYmxlIG5vbnBheWFibGVcIi5zcGxpdChcIiBcIikpKTtcbiAgICAvLyBQcm9jZXNzIG11dGFiaWxpdHkgc3RhdGVzXG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJ2aWV3XCIpKSB7XG4gICAgICAgIHJldHVybiBcInZpZXdcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJwdXJlXCIpKSB7XG4gICAgICAgIHJldHVybiBcInB1cmVcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJwYXlhYmxlXCIpKSB7XG4gICAgICAgIHJldHVybiBcInBheWFibGVcIjtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJub25wYXlhYmxlXCIpKSB7XG4gICAgICAgIHJldHVybiBcIm5vbnBheWFibGVcIjtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBsZWdhY3kgYGNvbnN0YW50YCBsYXN0XG4gICAgaWYgKG1vZGlmaWVycy5oYXMoXCJjb25zdGFudFwiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIHJldHVybiBcIm5vbnBheWFibGVcIjtcbn1cbi8vIC4uLmEgcGFyYW1ldGVyIGxpc3QsIHJldHVybmluZyB0aGUgUGFyYW1UeXBlIGxpc3RcbmZ1bmN0aW9uIGNvbnN1bWVQYXJhbXModG9rZW5zLCBhbGxvd0luZGV4ZWQpIHtcbiAgICByZXR1cm4gdG9rZW5zLnBvcFBhcmFtcygpLm1hcCgodCkgPT4gUGFyYW1UeXBlLmZyb20odCwgYWxsb3dJbmRleGVkKSk7XG59XG4vLyAuLi5hIGdhcyBsaW1pdCwgcmV0dXJuaW5nIGEgQmlnTnVtYmVyIG9yIG51bGwgaWYgbm9uZVxuZnVuY3Rpb24gY29uc3VtZUdhcyh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtUeXBlKFwiQVRcIikpIHtcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAodG9rZW5zLnBlZWtUeXBlKFwiTlVNQkVSXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHRva2Vucy5wb3AoKS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGdhc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb25zdW1lRW9pKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbnMgYXQgb2Zmc2V0ICR7dG9rZW5zLm9mZnNldH06ICR7dG9rZW5zLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxufVxuY29uc3QgcmVnZXhBcnJheVR5cGUgPSBuZXcgUmVnRXhwKC9eKC4qKVxcWyhbMC05XSopXFxdJC8pO1xuZnVuY3Rpb24gdmVyaWZ5QmFzaWNUeXBlKHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhUeXBlKTtcbiAgICBhc3NlcnRBcmd1bWVudChtYXRjaCwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIGlmICh0eXBlID09PSBcInVpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJ1aW50MjU2XCI7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgIHJldHVybiBcImludDI1NlwiO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgLy8gYnl0ZXNYWFxuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXRjaFszXSkge1xuICAgICAgICAvLyBpbnRYWCBvciB1aW50WFhcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDI1NiAmJiAoc2l6ZSAlIDgpID09PSAwLCBcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xufVxuLy8gTWFrZSB0aGUgRnJhZ21lbnQgY29uc3RydWN0b3JzIGVmZmVjdGl2ZWx5IHByaXZhdGVcbmNvbnN0IF9ndWFyZCA9IHt9O1xuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc19pbnRlcm5hbFwiKTtcbmNvbnN0IFBhcmFtVHlwZUludGVybmFsID0gXCJfUGFyYW1UeXBlSW50ZXJuYWxcIjtcbmNvbnN0IEVycm9yRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0Vycm9ySW50ZXJuYWxcIjtcbmNvbnN0IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCA9IFwiX0V2ZW50SW50ZXJuYWxcIjtcbmNvbnN0IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0NvbnN0cnVjdG9ySW50ZXJuYWxcIjtcbmNvbnN0IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0ZhbGxiYWNrSW50ZXJuYWxcIjtcbmNvbnN0IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCA9IFwiX0Z1bmN0aW9uSW50ZXJuYWxcIjtcbmNvbnN0IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwgPSBcIl9TdHJ1Y3RJbnRlcm5hbFwiO1xuLyoqXG4gKiAgRWFjaCBpbnB1dCBhbmQgb3V0cHV0IG9mIGEgW1tGcmFnbWVudF1dIGlzIGFuIEFycmF5IG9mICoqUGFyYW1UeXBlKiouXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJhbVR5cGUge1xuICAgIC8qKlxuICAgICAqICBUaGUgbG9jYWwgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIChvciBgYFwiXCJgYCBpZiB1bmJvdW5kKVxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxseSBxdWFsaWZpZWQgdHlwZSAoZS5nLiBgYFwiYWRkcmVzc1wiYGAsIGBgXCJ0dXBsZShhZGRyZXNzKVwiYGAsXG4gICAgICogIGBgXCJ1aW50MjU2WzNdW11cImBgKVxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBiYXNlIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGVcImBgLCBgYFwiYXJyYXlcImBgKVxuICAgICAqL1xuICAgIGJhc2VUeXBlO1xuICAgIC8qKlxuICAgICAqICBUcnVlIGlmIHRoZSBwYXJhbWV0ZXJzIGlzIGluZGV4ZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1pbmRleGFibGUgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBpbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29tcG9uZW50cyBmb3IgdGhlIHR1cGxlLlxuICAgICAqXG4gICAgICogIEZvciBub24tdHVwbGUgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBjb21wb25lbnRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJyYXkgbGVuZ3RoLCBvciBgYC0xYGAgZm9yIGR5bmFtaWMtbGVuZ3RoZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUxlbmd0aDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUgb2YgZWFjaCBjaGlsZCBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1hcnJheSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFycmF5Q2hpbGRyZW47XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wb25lbnRzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbikge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiUGFyYW1UeXBlXCIpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IFBhcmFtVHlwZUludGVybmFsIH0pO1xuICAgICAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgICAgICAgY29tcG9uZW50cyA9IE9iamVjdC5mcmVlemUoY29tcG9uZW50cy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgaWYgKGFycmF5TGVuZ3RoID09IG51bGwgfHwgYXJyYXlDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFycmF5TGVuZ3RoICE9IG51bGwgfHwgYXJyYXlDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLFxuICAgICAqXG4gICAgICogIGBgc2lnaGFzaFwiID0+IFwiKHVpbnQyNTYsYWRkcmVzcylcImBgXG4gICAgICpcbiAgICAgKiAgYGBcIm1pbmltYWxcIiA9PiBcInR1cGxlKHVpbnQyNTYsYWRkcmVzcykgaW5kZXhlZFwiYGBcbiAgICAgKlxuICAgICAqICBgYFwiZnVsbFwiID0+IFwidHVwbGUodWludDI1NiBmb28sIGFkZHJlc3MgYmFyKSBpbmRleGVkIGJhelwiYGBcbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWUgfHwgXCJcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UodGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudHlwZSArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogKCh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKSxcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5pbmRleGVkKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXhlZCA9IHRoaXMuaW5kZXhlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLm1hcCgoYykgPT4gSlNPTi5wYXJzZShjLmZvcm1hdChmb3JtYXQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGBbJHsodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKX1dYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIihcIiArIHRoaXMuY29tcG9uZW50cy5tYXAoKGNvbXApID0+IGNvbXAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gXCJmdWxsXCIpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGluZGV4ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiZnVsbFwiICYmIHRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGFuIEFycmF5IHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2FycmF5Q2hpbGRyZW5dXVxuICAgICAqICBhbmQgW1thcnJheUxlbmd0aF1dIGFyZSBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0FycmF5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmFzZVR5cGUgPT09IFwiYXJyYXlcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYSBUdXBsZSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1tjb21wb25lbnRzXV1cbiAgICAgKiAgaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNUdXBsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGFuIEluZGV4YWJsZSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1tpbmRleGVkXV1cbiAgICAgKiAgaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNJbmRleGFibGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbmRleGVkICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2Fsa3MgdGhlICoqUGFyYW1UeXBlKiogd2l0aCAlJXZhbHVlJSUsIGNhbGxpbmcgJSVwcm9jZXNzJSVcbiAgICAgKiAgb24gZWFjaCB0eXBlLCBkZXN0cnVjdGluZyB0aGUgJSV2YWx1ZSUlIHJlY3Vyc2l2ZWx5LlxuICAgICAqL1xuICAgIHdhbGsodmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiAoX3RoaXMuYXJyYXlDaGlsZHJlbi53YWxrKHYsIHByb2Nlc3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IHRoaXMuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpKSA9PiAoX3RoaXMuY29tcG9uZW50c1tpXS53YWxrKHYsIHByb2Nlc3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgICN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCBzZXRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXlMZW5ndGggIT09IC0xICYmIHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IHRoaXMuYXJyYXlDaGlsZHJlbjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGRUeXBlLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cztcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG9iamVjdCBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiAodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBvbmVudHMubWFwKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2Ugb2JqZWN0IHZhbHVlIHdpdGggdW5uYW1lZCBjb21wb25lbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtLm5hbWUgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGNvbXBvbmVudCAke3BhcmFtLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW3BhcmFtLm5hbWVdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IHRoaXMuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpbmRleF0uI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzcyh0aGlzLnR5cGUsIHZhbHVlKTtcbiAgICAgICAgaWYgKHJlc3VsdC50aGVuKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHNldFZhbHVlKGF3YWl0IHJlc3VsdCk7IH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2Fsa3MgdGhlICoqUGFyYW1UeXBlKiogd2l0aCAlJXZhbHVlJSUsIGFzeW5jaHJvbm91c2x5IGNhbGxpbmdcbiAgICAgKiAgJSVwcm9jZXNzJSUgb24gZWFjaCB0eXBlLCBkZXN0cnVjdGluZyB0aGUgJSV2YWx1ZSUlIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZXMgYnkgd2Fsa2luZyBhbmQgcmVzb2x2aW5nIGVhY2hcbiAgICAgKiAgYGBcImFkZHJlc3NcImBgIHR5cGUuXG4gICAgICovXG4gICAgYXN5bmMgd2Fsa0FzeW5jKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFt2YWx1ZV07XG4gICAgICAgIHRoaXMuI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipQYXJhbVR5cGUqKiBmb3IgJSVvYmolJS5cbiAgICAgKlxuICAgICAqICBJZiAlJWFsbG93SW5kZXhlZCUlIHRoZW4gdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgaXMgcGVybWl0dGVkLFxuICAgICAqICBvdGhlcndpc2UgdGhlIGBgaW5kZXhlZGBgIGtleXdvcmQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmosIGFsbG93SW5kZXhlZCkge1xuICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb20obGV4KG9iaiksIGFsbG93SW5kZXhlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHBhcmFtIHR5cGVcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBcIlwiLCBiYXNlVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJ0dXBsZVwiXSkpLmhhcyhcInR1cGxlXCIpIHx8IG9iai5wZWVrVHlwZShcIk9QRU5fUEFSRU5cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBUdXBsZVxuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gXCJ0dXBsZVwiO1xuICAgICAgICAgICAgICAgIGNvbXBzID0gb2JqLnBvcFBhcmFtcygpLm1hcCgodCkgPT4gUGFyYW1UeXBlLmZyb20odCkpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBgdHVwbGUoJHtjb21wcy5tYXAoKGMpID0+IGMuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsXG4gICAgICAgICAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoucG9wVHlwZShcIlRZUEVcIikpO1xuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBBcnJheVxuICAgICAgICAgICAgbGV0IGFycmF5Q2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGFycmF5TGVuZ3RoID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChvYmoubGVuZ3RoICYmIG9iai5wZWVrVHlwZShcIkJSQUNLRVRcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBicmFja2V0ID0gb2JqLnBvcCgpOyAvL2FycmF5c1tpXTtcbiAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIFwiXCIsIHR5cGUsIGJhc2VUeXBlLCBudWxsLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoID0gYnJhY2tldC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0eXBlICs9IGJyYWNrZXQudGV4dDtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5kZXhlZCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkcyA9IGNvbnN1bWVLZXl3b3JkcyhvYmosIEt3TW9kaWZpZXJzKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3Jkcy5oYXMoXCJpbmRleGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAob2JqLnBlZWtUeXBlKFwiSURcIikgPyBvYmoucG9wKCkudGV4dCA6IFwiXCIpO1xuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZWZ0b3ZlciB0b2tlbnNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIW5hbWUgfHwgKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIgJiYgbmFtZS5tYXRjaChyZWdleElkKSksIFwiaW52YWxpZCBuYW1lXCIsIFwib2JqLm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGxldCBpbmRleGVkID0gb2JqLmluZGV4ZWQ7XG4gICAgICAgIGlmIChpbmRleGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFsbG93SW5kZXhlZCwgXCJwYXJhbWV0ZXIgY2Fubm90IGJlIGluZGV4ZWRcIiwgXCJvYmouaW5kZXhlZFwiLCBvYmouaW5kZXhlZCk7XG4gICAgICAgICAgICBpbmRleGVkID0gISFpbmRleGVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gb2JqLnR5cGU7XG4gICAgICAgIGxldCBhcnJheU1hdGNoID0gdHlwZS5tYXRjaChyZWdleEFycmF5VHlwZSk7XG4gICAgICAgIGlmIChhcnJheU1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheUxlbmd0aCA9IHBhcnNlSW50KGFycmF5TWF0Y2hbMl0gfHwgXCItMVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5Q2hpbGRyZW4gPSBQYXJhbVR5cGUuZnJvbSh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXJyYXlNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBvYmouY29tcG9uZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJhcnJheVwiLCBpbmRleGVkLCBudWxsLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwidHVwbGVcIiB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJ0dXBsZShcIiAvKiBmaXg6ICkgKi8pIHx8IHR5cGUuc3RhcnRzV2l0aChcIihcIiAvKiBmaXg6ICkgKi8pKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wcyA9IChvYmouY29tcG9uZW50cyAhPSBudWxsKSA/IG9iai5jb21wb25lbnRzLm1hcCgoYykgPT4gUGFyYW1UeXBlLmZyb20oYykpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgXCJ0dXBsZVwiLCBpbmRleGVkLCBjb21wcywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAvLyBAVE9ETzogdXNlIGxleGVyIHRvIHZhbGlkYXRlIGFuZCBub3JtYWxpemUgdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHR1cGxlO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnR5cGUpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUgfHwgXCJcIiwgdHlwZSwgdHlwZSwgaW5kZXhlZCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgKipQYXJhbVR5cGUqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNQYXJhbVR5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IFBhcmFtVHlwZUludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiBhYnN0cmFjdCBjbGFzcyB0byByZXByZXNlbnQgQW4gaW5kaXZpZHVhbCBmcmFnbWVudCBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGlucHV0cyBmb3IgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGlucHV0cztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzKSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJGcmFnbWVudFwiKTtcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyB0eXBlLCBpbnB1dHMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRnJhZ21lbnQqKiBmb3IgJSVvYmolJSwgd2ljaCBjYW4gYmUgYW55IHN1cHBvcnRlZFxuICAgICAqICBBQkkgZnJnYW1lbnQgdHlwZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gVHJ5IHBhcnNpbmcgSlNPTi4uLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBGcmFnbWVudC5mcm9tKEpTT04ucGFyc2Uob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAvLyAuLi5vdGhlcndpc2UsIHVzZSB0aGUgaHVtYW4tcmVhZGFibGUgbGV4ZXJcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIEh1bWFuLXJlYWRhYmxlIEFCSSAoYWxyZWFkeSBsZXhlZClcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucGVla0tleXdvcmQoS3dUeXBlcyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmopID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBKU09OIEFCSVxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOiByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjogcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYHVuc3VwcG9ydGVkIHR5cGU6ICR7b2JqLnR5cGV9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJGcmFnbWVudC5mcm9tXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGZyZ2FtZW50IG9iamVjdFwiLCBcIm9ialwiLCBvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbQ29uc3RydWN0b3JGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0NvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBbW0Vycm9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFcnJvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFdmVudEZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXZlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tGdW5jdGlvbkZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgW1tTdHJ1Y3RGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1N0cnVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnRcbiAqICB3aGljaCBoYXMgYSBuYW1lIGZyb20gYSBwYXJzZSBBQkkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOYW1lZEZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCB0eXBlLCBpbnB1dHMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCksIFwiaW52YWxpZCBpZGVudGlmaWVyXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgaW5wdXRzID0gT2JqZWN0LmZyZWV6ZShpbnB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGpvaW5QYXJhbXMoZm9ybWF0LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gXCIoXCIgKyBwYXJhbXMubWFwKChwKSA9PiBwLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgLy9DdXN0b20gRXJyb3IvLy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yRnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImVycm9yXCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXJyb3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEN1c3RvbSBFcnJvciBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnJhZ21lbnQgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJlcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFcnJvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFcnJvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZXJyb3JcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXG4gICAgICogICoqRXJyb3JGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBFcnJvckZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhbiBFdmVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50RnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGlzIGV2ZW50IGlzIGFub255bW91cy5cbiAgICAgKi9cbiAgICBhbm9ueW1vdXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImV2ZW50XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXZlbnRGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYW5vbnltb3VzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEV2ZW50IHRvcGljIGhhc2guXG4gICAgICovXG4gICAgZ2V0IHRvcGljSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIGlkKHRoaXMuZm9ybWF0KFwic2lnaGFzaFwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXZlbnQgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgICAgICAgICAgICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImV2ZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubmFtZSArIGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cykpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiAmJiB0aGlzLmFub255bW91cykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJhbm9ueW1vdXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgdG9waWMgaGFzaCBmb3IgYW4gZXZlbnQgd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VG9waWNIYXNoKG5hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHApKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG5hbWUsIHBhcmFtcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkV2ZW50RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEV2ZW50RnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGV2ZW50IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImV2ZW50XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBhbm9ueW1vdXMgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJhbm9ueW1vdXNcIl0pKS5oYXMoXCJhbm9ueW1vdXNcIik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCwgdHJ1ZSkpIDogW10sICEhb2JqLmFub255bW91cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXG4gICAgICogICoqRXZlbnRGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBFdmVudEZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnQgY2xhc3MgQ29uc3RydWN0b3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGUgY29uc3RydWN0b3IgY2FuIHJlY2VpdmUgYW4gZW5kb3dtZW50LlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgZm9yIGRlcGxveW1lbnQgb3IgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2FzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBpbnB1dHMsIHBheWFibGUsIGdhcykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwYXlhYmxlLCBnYXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29uc3RydWN0b3IgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGFzc2VydChmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXQgIT09IFwic2lnaGFzaFwiLCBcImNhbm5vdCBmb3JtYXQgYSBjb25zdHJ1Y3RvciBmb3Igc2lnaGFzaFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmb3JtYXQoc2lnaGFzaClcIiB9KTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKHRoaXMucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJ1bmRlZmluZWRcIiksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtgY29uc3RydWN0b3Ike2pvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLmlucHV0cyl9YF07XG4gICAgICAgIGlmICh0aGlzLnBheWFibGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwicGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYEAke3RoaXMuZ2FzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipDb25zdHJ1Y3RvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChDb25zdHJ1Y3RvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBjb25zdHVjdG9yIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJjb25zdHJ1Y3RvclwiXSkpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3QgcGF5YWJsZSA9ICEhY29uc3VtZUtleXdvcmRzKG9iaiwgS3dWaXNpYkRlcGxveSkuaGFzKFwicGF5YWJsZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGdhcyA9IGNvbnN1bWVHYXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfZ3VhcmQsIFwiY29uc3RydWN0b3JcIiwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfZ3VhcmQsIFwiY29uc3RydWN0b3JcIiwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAhIW9iai5wYXlhYmxlLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkNvbnN0cnVjdG9yRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWxsYmFja0ZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gY2FuIGJlIHNlbnQgdmFsdWUgZHVyaW5nIGludm9jYXRpb24uXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgaW5wdXRzLCBwYXlhYmxlKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImZhbGxiYWNrXCIsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRmFsbGJhY2tGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGF5YWJsZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmYWxsYmFjayBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9ICgodGhpcy5pbnB1dHMubGVuZ3RoID09PSAwKSA/IFwicmVjZWl2ZVwiIDogXCJmYWxsYmFja1wiKTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTXV0YWJpbGl0eSA9ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IHR5cGUsIHN0YXRlTXV0YWJpbGl0eSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dHlwZX0oKSR7dGhpcy5wYXlhYmxlID8gXCIgcGF5YWJsZVwiIDogXCJcIn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkZhbGxiYWNrRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEZhbGxiYWNrRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yT2JqID0gb2JqLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCB0b3BJc1ZhbGlkID0gb2JqLnBlZWtLZXl3b3JkKHNldGlmeShbXCJmYWxsYmFja1wiLCBcInJlY2VpdmVcIl0pKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHRvcElzVmFsaWQsIFwidHlwZSBtdXN0IGJlIGZhbGxiYWNrIG9yIHJlY2VpdmVcIiwgXCJvYmpcIiwgZXJyb3JPYmopO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9iai5wb3BLZXl3b3JkKHNldGlmeShbXCJmYWxsYmFja1wiLCBcInJlY2VpdmVcIl0pKTtcbiAgICAgICAgICAgIC8vIHJlY2VpdmUoKVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicmVjZWl2ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlucHV0cy5sZW5ndGggPT09IDAsIGByZWNlaXZlIGNhbm5vdCBoYXZlIGFyZ3VtZW50c2AsIFwib2JqLmlucHV0c1wiLCBpbnB1dHMpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJwYXlhYmxlXCJdKSk7XG4gICAgICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIFtdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKCkgW3BheWFibGVdXG4gICAgICAgICAgICAvLyBmYWxsYmFjayhieXRlcykgW3BheWFibGVdIHJldHVybnMgKGJ5dGVzKVxuICAgICAgICAgICAgbGV0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5wdXRzLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgaW5wdXRzXCIsIFwib2JqLmlucHV0c1wiLCBpbnB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSBbUGFyYW1UeXBlLmZyb20oXCJieXRlc1wiKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtdXRhYmlsaXR5ID0gY29uc3VtZU11dGFiaWxpdHkob2JqKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG11dGFiaWxpdHkgPT09IFwibm9ucGF5YWJsZVwiIHx8IG11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiLCBcImZhbGxiYWNrIGNhbm5vdCBiZSBjb25zdGFudHNcIiwgXCJvYmouc3RhdGVNdXRhYmlsaXR5XCIsIG11dGFiaWxpdHkpO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJyZXR1cm5zXCJdKSkuaGFzKFwicmV0dXJuc1wiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQob3V0cHV0cy5sZW5ndGggPT09IDEgJiYgb3V0cHV0c1swXS50eXBlID09PSBcImJ5dGVzXCIsIFwiaW52YWxpZCBmYWxsYmFjayBvdXRwdXRzXCIsIFwib2JqLm91dHB1dHNcIiwgb3V0cHV0cy5tYXAoKGkpID0+IGkuZm9ybWF0KFwibWluaW1hbFwiKSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIGlucHV0cywgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIFtdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiZmFsbGJhY2tcIikge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgY29uc3QgcGF5YWJsZSA9IChvYmouc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIHBheWFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZmFsbGJhY2sgZGVzY3JpcHRpb25cIiwgXCJvYmpcIiwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZhbGxiYWNrRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRmFsbGJhY2tGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBpcyBjb25zdGFudCAoZS5nLiBgYHB1cmVgYCBvciBgYHZpZXdgYCBmdW5jdGlvbnMpLlxuICAgICAqL1xuICAgIGNvbnN0YW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcmV0dXJuZWQgdHlwZXMgZm9yIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG91dHB1dHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBzdGF0ZSBtdXRhYmlsaXR5IChlLmcuIGBgcGF5YWJsZWBgLCBgYG5vbnBheWFibGVgYCwgYGB2aWV3YGBcbiAgICAgKiAgb3IgYGBwdXJlYGApXG4gICAgICovXG4gICAgc3RhdGVNdXRhYmlsaXR5O1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gY2FuIGJlIHNlbnQgdmFsdWUgZHVyaW5nIGludm9jYXRpb24uXG4gICAgICovXG4gICAgcGF5YWJsZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY29tbWVuZGVkIGdhcyBsaW1pdCB0byBzZW5kIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGdhcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBpbnB1dHMsIG91dHB1dHMsIGdhcykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmdW5jdGlvblwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgb3V0cHV0cyA9IE9iamVjdC5mcmVlemUob3V0cHV0cy5zbGljZSgpKTtcbiAgICAgICAgY29uc3QgY29uc3RhbnQgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBzdGF0ZU11dGFiaWxpdHkgPT09IFwicHVyZVwiKTtcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IChzdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvbnN0YW50LCBnYXMsIG91dHB1dHMsIHBheWFibGUsIHN0YXRlTXV0YWJpbGl0eSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBGdW5jdGlvbiBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdGFudDogdGhpcy5jb25zdGFudCxcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMubWFwKChvKSA9PiBKU09OLnBhcnNlKG8uZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnN0YXRlTXV0YWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRzICYmIHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChcInJldHVybnNcIik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goam9pblBhcmFtcyhmb3JtYXQsIHRoaXMub3V0cHV0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChgQCR7dGhpcy5nYXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzZWxlY3RvciBmb3IgYSBmdW5jdGlvbiB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3RvcihuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBcInZpZXdcIiwgcGFyYW1zLCBbXSwgbnVsbCk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5zZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGdW5jdGlvbkZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmdW5jdGlvbiBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJmdW5jdGlvblwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICBsZXQgb3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJyZXR1cm5zXCJdKSkuaGFzKFwicmV0dXJuc1wiKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBtdXRhYmlsaXR5LCBpbnB1dHMsIG91dHB1dHMsIGdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlTXV0YWJpbGl0eSA9IG9iai5zdGF0ZU11dGFiaWxpdHk7XG4gICAgICAgIC8vIFVzZSBsZWdhY3kgU29saWRpdHkgQUJJIGxvZ2ljIGlmIHN0YXRlTXV0YWJpbGl0eSBpcyBtaXNzaW5nXG4gICAgICAgIGlmIChzdGF0ZU11dGFiaWxpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJwYXlhYmxlXCI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChvYmouY29uc3RhbnQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuICAgICAgICAgICAgICAgIGlmICghb2JqLmNvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9iai5wYXlhYmxlKSA9PT0gXCJib29sZWFuXCIgJiYgIW9iai5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IHZlcmlmeVN0YXRlIGZvciBzdGF0ZU11dGFiaWxpdHkgKGUuZy4gdGhyb3cgaWZcbiAgICAgICAgLy8gICAgICAgIHBheWFibGU6IGZhbHNlIGJ1dCBzdGF0ZU11dGFiaWxpdHkgaXMgXCJub25wYXlhYmxlXCIpXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBzdGF0ZU11dGFiaWxpdHksIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgb2JqLm91dHB1dHMgPyBvYmoub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqRnVuY3Rpb25GcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cnVjdEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJzdHJ1Y3RcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBTdHJ1Y3RGcmFnbWVudEludGVybmFsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHN0cnVjdCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqU3RydWN0RnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHN0cnVjdCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJzdHJ1Y3RcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RydWN0RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0RnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgb2JqLmlucHV0cyA/IG9iai5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IGZpeCB0aGlzIHJldHVybiB0eXBlXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKlN0cnVjdEZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IFN0cnVjdEZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyYWdtZW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/fragments.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/index.js":
/*!**********************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: function() { return /* reexport safe */ _abi_coder_js__WEBPACK_IMPORTED_MODULE_0__.AbiCoder; },\n/* harmony export */   ConstructorFragment: function() { return /* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ConstructorFragment; },\n/* harmony export */   ErrorDescription: function() { return /* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.ErrorDescription; },\n/* harmony export */   ErrorFragment: function() { return /* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment; },\n/* harmony export */   EventFragment: function() { return /* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.EventFragment; },\n/* harmony export */   FallbackFragment: function() { return /* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.FallbackFragment; },\n/* harmony export */   Fragment: function() { return /* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.Fragment; },\n/* harmony export */   FunctionFragment: function() { return /* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.FunctionFragment; },\n/* harmony export */   Indexed: function() { return /* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.Indexed; },\n/* harmony export */   Interface: function() { return /* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.Interface; },\n/* harmony export */   LogDescription: function() { return /* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.LogDescription; },\n/* harmony export */   NamedFragment: function() { return /* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.NamedFragment; },\n/* harmony export */   ParamType: function() { return /* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ParamType; },\n/* harmony export */   Result: function() { return /* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.Result; },\n/* harmony export */   StructFragment: function() { return /* reexport safe */ _fragments_js__WEBPACK_IMPORTED_MODULE_2__.StructFragment; },\n/* harmony export */   TransactionDescription: function() { return /* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.TransactionDescription; },\n/* harmony export */   Typed: function() { return /* reexport safe */ _typed_js__WEBPACK_IMPORTED_MODULE_4__.Typed; },\n/* harmony export */   checkResultErrors: function() { return /* reexport safe */ _interface_js__WEBPACK_IMPORTED_MODULE_3__.checkResultErrors; },\n/* harmony export */   decodeBytes32String: function() { return /* reexport safe */ _bytes32_js__WEBPACK_IMPORTED_MODULE_1__.decodeBytes32String; },\n/* harmony export */   encodeBytes32String: function() { return /* reexport safe */ _bytes32_js__WEBPACK_IMPORTED_MODULE_1__.encodeBytes32String; }\n/* harmony export */ });\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abi-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _bytes32_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytes32.js */ \"../common/node_modules/ethers/lib.esm/abi/bytes32.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragments.js */ \"../common/node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interface.js */ \"../common/node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typed.js */ \"../common/node_modules/ethers/lib.esm/abi/typed.js\");\n/**\n *  The Application Binary Interface (ABI) describes how method input\n *  parameters should be encoded, their results decoded, and how to\n *  decode events and errors.\n *\n *  See [About ABIs](docs-abi) for more details how they are used.\n *\n *  @_section api/abi:Application Binary Interface  [about-abi]\n *  @_navTitle: ABI\n */\n//////\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMEM7QUFDOEI7QUFDb0c7QUFDbkM7QUFDdEc7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2luZGV4LmpzPzQyZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIEFwcGxpY2F0aW9uIEJpbmFyeSBJbnRlcmZhY2UgKEFCSSkgZGVzY3JpYmVzIGhvdyBtZXRob2QgaW5wdXRcbiAqICBwYXJhbWV0ZXJzIHNob3VsZCBiZSBlbmNvZGVkLCB0aGVpciByZXN1bHRzIGRlY29kZWQsIGFuZCBob3cgdG9cbiAqICBkZWNvZGUgZXZlbnRzIGFuZCBlcnJvcnMuXG4gKlxuICogIFNlZSBbQWJvdXQgQUJJc10oZG9jcy1hYmkpIGZvciBtb3JlIGRldGFpbHMgaG93IHRoZXkgYXJlIHVzZWQuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvYWJpOkFwcGxpY2F0aW9uIEJpbmFyeSBJbnRlcmZhY2UgIFthYm91dC1hYmldXG4gKiAgQF9uYXZUaXRsZTogQUJJXG4gKi9cbi8vLy8vL1xuZXhwb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXIuanNcIjtcbmV4cG9ydCB7IGRlY29kZUJ5dGVzMzJTdHJpbmcsIGVuY29kZUJ5dGVzMzJTdHJpbmcgfSBmcm9tIFwiLi9ieXRlczMyLmpzXCI7XG5leHBvcnQgeyBDb25zdHJ1Y3RvckZyYWdtZW50LCBFcnJvckZyYWdtZW50LCBFdmVudEZyYWdtZW50LCBGYWxsYmFja0ZyYWdtZW50LCBGcmFnbWVudCwgRnVuY3Rpb25GcmFnbWVudCwgTmFtZWRGcmFnbWVudCwgUGFyYW1UeXBlLCBTdHJ1Y3RGcmFnbWVudCwgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBJbmRleGVkLCBJbnRlcmZhY2UsIEVycm9yRGVzY3JpcHRpb24sIExvZ0Rlc2NyaXB0aW9uLCBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uLCBSZXN1bHQgfSBmcm9tIFwiLi9pbnRlcmZhY2UuanNcIjtcbmV4cG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4vdHlwZWQuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/interface.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/interface.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: function() { return /* binding */ ErrorDescription; },\n/* harmony export */   Indexed: function() { return /* binding */ Indexed; },\n/* harmony export */   Interface: function() { return /* binding */ Interface; },\n/* harmony export */   LogDescription: function() { return /* binding */ LogDescription; },\n/* harmony export */   Result: function() { return /* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result; },\n/* harmony export */   TransactionDescription: function() { return /* binding */ TransactionDescription; },\n/* harmony export */   checkResultErrors: function() { return /* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.checkResultErrors; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../hash/index.js */ \"../common/node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abi-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"../common/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragments.js */ \"../common/node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typed.js */ \"../common/node_modules/ethers/lib.esm/abi/typed.js\");\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\n\n\n\n\n\n\n\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nclass LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    fragment;\n    /**\n     *  The name of the Event.\n     */\n    name;\n    /**\n     *  The full Event signature.\n     */\n    signature;\n    /**\n     *  The topic hash for the Event.\n     */\n    topic;\n    /**\n     *  The arguments passed into the Event with ``emit``.\n     */\n    args;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, topic, args) {\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment, name, signature, topic, args\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nclass TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    fragment;\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    name;\n    /**\n     *  The arguments passed to the Function from the transaction ``data``.\n     */\n    args;\n    /**\n     *  The full Function signature from the transaction ``data``.\n     */\n    signature;\n    /**\n     *  The selector for the Function from the transaction ``data``.\n     */\n    selector;\n    /**\n     *  The ``value`` (in wei) from the transaction.\n     */\n    value;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, selector, args, value) {\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment, name, args, signature, selector, value\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nclass ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    fragment;\n    /**\n     *  The name of the Error.\n     */\n    name;\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    args;\n    /**\n     *  The full Error signature.\n     */\n    signature;\n    /**\n     *  The selector for the Error.\n     */\n    selector;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, selector, args) {\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment, name, args, signature, selector\n        });\n    }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nclass Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    hash;\n    /**\n     *  @_ignore:\n     */\n    _isIndexed;\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */\n    static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */\n    constructor(hash) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { hash, _isIndexed: true });\n    }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\",\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\"string\"],\n        reason: (message) => {\n            return `reverted with reason string ${JSON.stringify(message)}`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\"uint256\"],\n        reason: (code) => {\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n        }\n    }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nclass Interface {\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    fragments;\n    /**\n     *  The Contract constructor.\n     */\n    deploy;\n    /**\n     *  The Fallback method, if any.\n     */\n    fallback;\n    /**\n     *  If receiving ether is supported.\n     */\n    receive;\n    #errors;\n    #events;\n    #functions;\n    //    #structs: Map<string, StructFragment>;\n    #abiCoder;\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */\n    constructor(fragments) {\n        let abi = [];\n        if (typeof (fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        }\n        else {\n            abi = fragments;\n        }\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi) {\n            try {\n                frags.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(a));\n            }\n            catch (error) {\n                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        this.#abiCoder = this.getAbiCoder();\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index) => {\n            let bucket;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { deploy: fragment });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    }\n                    else {\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                deploy: _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { fallback, receive });\n    }\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */\n    format(minimal) {\n        const format = (minimal ? \"minimal\" : \"full\");\n        const abi = this.fragments.map((f) => f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n    formatJson() {\n        const abi = this.fragments.map((f) => f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j) => JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n    getAbiCoder() {\n        return _abi_coder_js__WEBPACK_IMPORTED_MODULE_3__.AbiCoder.defaultAbiCoder();\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key, values, forceUnique) {\n        // Selector\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()) {\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#functions) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                const lastValue = (values.length > 0) ? values[values.length - 1] : null;\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (_typed_js__WEBPACK_IMPORTED_MODULE_4__.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_4__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") {\n                                continue;\n                            }\n                            matching.splice(i, 1);\n                            break;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof (lastArg) !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.FunctionFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    getFunctionName(key) {\n        const fragment = this.#getFunction(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */\n    hasFunction(key) {\n        return !!this.#getFunction(key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n    getFunction(key, values) {\n        return this.#getFunction(key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n    forEachFunction(callback) {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#functions.get(name)), i);\n        }\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key, values, forceUnique) {\n        // EventTopic\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()) {\n                if (eventTopic === fragment.topicHash) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#events) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_4__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.EventFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    getEventName(key) {\n        const fragment = this.#getEvent(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */\n    hasEvent(key) {\n        return !!this.#getEvent(key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n    getEvent(key, values) {\n        return this.#getEvent(key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n    forEachEvent(callback) {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#events.get(name)), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n    getError(key, values) {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of this.#errors.values()) {\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#errors) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            }\n            else if (matching.length > 1) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = this.#errors.get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n    forEachError(callback) {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#errors.get(name)), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n    _decodeParams(params, data) {\n        return this.#abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this.#abiCoder.encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n    encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeErrorResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeErrorResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n    decodeFunctionData(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n    encodeFunctionData(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeFunctionResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(data);\n        if ((bytes.length % 32) === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            }\n            catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, message, \"BAD_DATA\", {\n            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(bytes),\n            info: { method: fragment.name, signature: fragment.format() }\n        });\n    }\n    makeError(_data, tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n        const error = _abi_coder_js__WEBPACK_IMPORTED_MODULE_3__.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name, signature: ef.format(), args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${error.reason}`;\n                }\n                catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`;\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeFunctionResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", { count: values.length, expectedCount: fragment.inputs.length });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value) => {\n            if (param.type === \"string\") {\n                return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_5__.id)(value);\n            }\n            else if (param.type === \"bytes\") {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof (value) === \"boolean\") {\n                value = (value ? \"0x01\" : \"0x00\");\n            }\n            else if (param.type.match(/^u?int/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(value); // @TODO: Should this toTwos??\n            }\n            else if (param.type.match(/^bytes/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.zeroPadBytes)(value, 32);\n            }\n            else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode([\"address\"], [value]);\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(value), 32);\n        };\n        values.forEach((value, index) => {\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            }\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            }\n            else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            }\n            else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_5__.id)(value));\n                }\n                else if (param.type === \"bytes\") {\n                    topics.push((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.keccak256)(value));\n                }\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                }\n                else {\n                    topics.push(this.#abiCoder.encode([param.type], [value]));\n                }\n            }\n            else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this.#abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.ParamType.from({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                }\n                else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            }\n            else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(topics)) : null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index) => {\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                }\n                else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                }\n                else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    }\n                    catch (error) {\n                        value = error;\n                    }\n                }\n            }\n            else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                }\n                catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n    parseTransaction(tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(tx.data, \"tx.data\");\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)((tx.value != null) ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */\n    parseError(data) {\n        const hexData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data);\n        const fragment = this.getError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n    static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof (value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // An Interface; possibly from another v6 instance\n        if (typeof (value.formatJson) === \"function\") {\n            return new Interface(value.formatJson());\n        }\n        // A legacy Interface; from an older version\n        if (typeof (value.format) === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n}\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQztBQUNUO0FBQ3dKO0FBQ3BKO0FBQzZCO0FBQ21EO0FBQ3ZGO0FBQ0U7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQjtBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcz84MmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSBJbnRlcmZhY2UgY2xhc3MgaXMgYSBsb3ctbGV2ZWwgY2xhc3MgdGhhdCBhY2NlcHRzIGFuXG4gKiAgQUJJIGFuZCBwcm92aWRlcyBhbGwgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbmFsaXR5IHRvIGVuY29kZVxuICogIGFuZCBkZWNvZGUgcGFyYW1hdGVycyB0byBhbmQgcmVzdWx0cyBmcm9tIG1ldGhvZHMsIGV2ZW50c1xuICogIGFuZCBlcnJvcnMuXG4gKlxuICogIEl0IGFsc28gcHJvdmlkZXMgc2V2ZXJhbCBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGF1dG9tYXRpY2FsbHlcbiAqICBzZWFyY2ggYW5kIGZpbmQgbWF0Y2hpbmcgdHJhbnNhY3Rpb25zIGFuZCBldmVudHMgdG8gcGFyc2UgdGhlbS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmk6SW50ZXJmYWNlcyAgW2ludGVyZmFjZXNdXG4gKi9cbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnksIHplcm9QYWRCeXRlcywgemVyb1BhZFZhbHVlLCBpc0hleFN0cmluZywgZGVmaW5lUHJvcGVydGllcywgYXNzZXJ0QXJndW1lbnQsIHRvQmVIZXgsIGFzc2VydCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXIuanNcIjtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IENvbnN0cnVjdG9yRnJhZ21lbnQsIEVycm9yRnJhZ21lbnQsIEV2ZW50RnJhZ21lbnQsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4vdHlwZWQuanNcIjtcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfTtcbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlTG9nXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhIExvZyB0byBpdHMgZXZlbnRcbiAqICBmb3IgcGFyc2luZywgYSAqKkxvZ0Rlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dEZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhlIGBgdG9waWMwYGAuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFdmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgdG9waWMgaGFzaCBmb3IgdGhlIEV2ZW50LlxuICAgICAqL1xuICAgIHRvcGljO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBFdmVudCB3aXRoIGBgZW1pdGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCB0b3BpYywgYXJncykge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIHNpZ25hdHVyZSwgdG9waWMsIGFyZ3NcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VUcmFuc2FjdGlvbl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2hcbiAqICBhIHRyYW5zYWN0aW9uIGRhdGEgdG8gaXRzIGZ1bmN0aW9uIGZvciBwYXJzaW5nLFxuICogIGEgKipUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEZ1bmN0aW9uIHNpZ25hdHVyZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YWx1ZWBgIChpbiB3ZWkpIGZyb20gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHZhbHVlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvciwgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VFcnJvcl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYW5cbiAqICBlcnJvciBmb3IgYSBjYWxsIHJlc3VsdCBmb3IgcGFyc2luZywgYW4gKipFcnJvckRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXJyb3IuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEVycm9yIHdpdGggYGByZXZlcnRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFcnJvciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvclxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKkluZGV4ZWQqKiBpcyB1c2VkIGFzIGEgdmFsdWUgd2hlbiBhIHZhbHVlIHRoYXQgZG9lcyBub3RcbiAqICBmaXQgd2l0aGluIGEgdG9waWMgKGkuZS4gbm90IGEgZml4ZWQtbGVuZ3RoLCAzMi1ieXRlIHR5cGUpLiBJdFxuICogIGlzIHRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSwgYW5kIHVzZWQgZm9yIHR5cGVzIHN1Y2ggYXNcbiAqICBhcnJheXMsIHR1cGxlcywgYnl0ZXMgYW5kIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaXNJbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUldmFsdWUlJSBpcyBhbiAqKkluZGV4ZWQqKi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCBmb3IgcHJvcGVydHkgYWNjZXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFzaCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgaGFzaCwgX2lzSW5kZXhlZDogdHJ1ZSB9KTtcbiAgICB9XG59XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjEzL2NvbnRyb2wtc3RydWN0dXJlcy5odG1sP2hpZ2hsaWdodD1wYW5pYyNwYW5pYy12aWEtYXNzZXJ0LWFuZC1lcnJvci12aWEtcmVxdWlyZVxuY29uc3QgUGFuaWNSZWFzb25zID0ge1xuICAgIFwiMFwiOiBcImdlbmVyaWMgcGFuaWNcIixcbiAgICBcIjFcIjogXCJhc3NlcnQoZmFsc2UpXCIsXG4gICAgXCIxN1wiOiBcImFyaXRobWV0aWMgb3ZlcmZsb3dcIixcbiAgICBcIjE4XCI6IFwiZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIixcbiAgICBcIjMzXCI6IFwiZW51bSBvdmVyZmxvd1wiLFxuICAgIFwiMzRcIjogXCJpbnZhbGlkIGVuY29kZWQgc3RvcmFnZSBieXRlIGFycmF5IGFjY2Vzc2VkXCIsXG4gICAgXCI0OVwiOiBcIm91dC1vZi1ib3VuZHMgYXJyYXkgYWNjZXNzOyBwb3BwaW5nIG9uIGFuIGVtcHR5IGFycmF5XCIsXG4gICAgXCI1MFwiOiBcIm91dC1vZi1ib3VuZHMgYWNjZXNzIG9mIGFuIGFycmF5IG9yIGJ5dGVzTlwiLFxuICAgIFwiNjVcIjogXCJvdXQgb2YgbWVtb3J5XCIsXG4gICAgXCI4MVwiOiBcInVuaW5pdGlhbGl6ZWQgZnVuY3Rpb25cIixcbn07XG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xuICAgIFwiMHgwOGMzNzlhMFwiOiB7XG4gICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgaW5wdXRzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgIHJlYXNvbjogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCByZWFzb24gc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSl9YDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIweDRlNDg3YjcxXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgaW5wdXRzOiBbXCJ1aW50MjU2XCJdLFxuICAgICAgICByZWFzb246IChjb2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVhc29uID0gXCJ1bmtub3duIHBhbmljIGNvZGVcIjtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDAgJiYgY29kZSA8PSAweGZmICYmIFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcGFuaWMgY29kZSAweCR7Y29kZS50b1N0cmluZygxNil9ICgke3JlYXNvbn0pYDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqICBBbiBJbnRlcmZhY2UgYWJzdHJhY3RzIG1hbnkgb2YgdGhlIGxvdy1sZXZlbCBkZXRhaWxzIGZvclxuICogIGVuY29kaW5nIGFuZCBkZWNvZGluZyB0aGUgZGF0YSBvbiB0aGUgYmxvY2tjaGFpbi5cbiAqXG4gKiAgQW4gQUJJIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBlbmNvZGUgZGF0YSB0byBzZW5kIHRvXG4gKiAgYSBDb250cmFjdCwgaG93IHRvIGRlY29kZSB0aGUgcmVzdWx0cyBhbmQgZXZlbnRzIGFuZCBob3cgdG9cbiAqICBpbnRlcnByZXQgcmV2ZXJ0IGVycm9ycy5cbiAqXG4gKiAgVGhlIEFCSSBjYW4gYmUgc3BlY2lmaWVkIGJ5IFthbnkgc3VwcG9ydGVkIGZvcm1hdF0oSW50ZXJmYWNlQWJpKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgQ29udHJhY3QgQUJJIG1lbWJlcnMgKGkuZS4gbWV0aG9kcywgZXZlbnRzLCBlcnJvcnMsIGV0YykuXG4gICAgICovXG4gICAgZnJhZ21lbnRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZGVwbG95O1xuICAgIC8qKlxuICAgICAqICBUaGUgRmFsbGJhY2sgbWV0aG9kLCBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIElmIHJlY2VpdmluZyBldGhlciBpcyBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgcmVjZWl2ZTtcbiAgICAjZXJyb3JzO1xuICAgICNldmVudHM7XG4gICAgI2Z1bmN0aW9ucztcbiAgICAvLyAgICAjc3RydWN0czogTWFwPHN0cmluZywgU3RydWN0RnJhZ21lbnQ+O1xuICAgICNhYmlDb2RlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEludGVyZmFjZSBmb3IgdGhlICUlZnJhZ21lbnRzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBhYmkgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Z1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vICAgICAgICB0aGlzLiNzdHJ1Y3RzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBmcmFncyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGEgb2YgYWJpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZyYWdzLnB1c2goRnJhZ21lbnQuZnJvbShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1dhcm5pbmddIEludmFsaWQgRnJhZ21lbnQgJHtKU09OLnN0cmluZ2lmeShhKX06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudHM6IE9iamVjdC5mcmVlemUoZnJhZ3MpXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZmFsbGJhY2sgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNhYmlDb2RlciA9IHRoaXMuZ2V0QWJpQ29kZXIoKTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1Y2tldDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGRlcGxveTogZnJhZ21lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZhbGxiYWNrIHx8IGZyYWdtZW50LnBheWFibGUgIT09IGZhbGxiYWNrLnBheWFibGUsIFwiY29uZmxpY3RpbmcgZmFsbGJhY2sgZnJhZ21lbnRzXCIsIGBmcmFnbWVudHNbJHtpbmRleH1dYCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSBmYWxsYmFjay5wYXlhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2V2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHdvIGlkZW50aWNhbCBlbnRyaWVzOyBpZ25vcmUgaXRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC5oYXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Y2tldC5zZXQoc2lnbmF0dXJlLCBmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcbiAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZGVwbG95OiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oXCJjb25zdHJ1Y3RvcigpXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmFsbGJhY2ssIHJlY2VpdmUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRpcmUgSHVtYW4tUmVhZGFibGUgQUJJLCBhcyBhbiBhcnJheSBvZlxuICAgICAqICBzaWduYXR1cmVzLCBvcHRpb25hbGx5IGFzICUlbWluaW1hbCUlIHN0cmluZ3MsIHdoaWNoXG4gICAgICogIHJlbW92ZXMgcGFyYW1ldGVyIG5hbWVzIGFuZCB1bm5lY2Vlc2FyeSBzcGFjZXMuXG4gICAgICovXG4gICAgZm9ybWF0KG1pbmltYWwpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gKG1pbmltYWwgPyBcIm1pbmltYWxcIiA6IFwiZnVsbFwiKTtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChmb3JtYXQpKTtcbiAgICAgICAgcmV0dXJuIGFiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgSlNPTi1lbmNvZGVkIEFCSS4gVGhpcyBpcyB0aGUgZm9ybWF0IFNvbGlkaXlcbiAgICAgKiAgcmV0dXJucy5cbiAgICAgKi9cbiAgICBmb3JtYXRKc29uKCkge1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEFCSSBjb2RlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbmNvZGUgYW5kIGRlY29kZSBiaW5hcnlcbiAgICAgKiAgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRBYmlDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRGdW5jdGlvbihrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gU2VsZWN0b3JcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Z1bmN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Z1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSAodmFsdWVzLmxlbmd0aCA+IDApID8gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZChsYXN0VmFsdWUpICYmIGxhc3RWYWx1ZS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguIFRoZSBhcmdzXG4gICAgICAgICAgICAgICAgLy8gbWF5IGNvbnRhaW4gYW4gb3ZlcnJpZGVzLCBzbyB0aGUgbWF0Y2ggbWF5IGhhdmUgbiBvciBuIC0gMSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHZhbHVlTGVuZ3RoICYmICghYWxsb3dPcHRpb25zIHx8IGlucHV0cyAhPT0gdmFsdWVMZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgcGFzdCB0aGUgaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNpbmdsZSBtYXRjaGluZyBzaWduYXR1cmUgd2l0aCBhbiBvdmVycmlkZXMsIGJ1dCB0aGVcbiAgICAgICAgICAgIC8vIGxhc3QgdmFsdWUgaXMgc29tZXRoaW5nIHRoYXQgY2Fubm90IHBvc3NpYmx5IGJlIGFuIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDEgJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggIT09IG1hdGNoaW5nWzBdLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEFyZyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobGFzdEFyZykgfHwgdHlwZW9mIChsYXN0QXJnKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBmdW5jdGlvbiBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVuY3Rpb25zLmdldChGdW5jdGlvbkZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGZ1bmN0aW9uIG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uIHNlbGVjdG9yLFxuICAgICAqICBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbk5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGEgZnVuY3Rpb24gc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3JcbiAgICAgKiAgZnVuY3Rpb24gc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYSBmdW5jdGlvbiBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb25cbiAgICAgKiAgc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBmdW5jdGlvbnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGZ1bmN0aW9uIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGZ1bmN0aW9ucywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hGdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZnVuY3Rpb25zLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNmdW5jdGlvbnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEV2ZW50KGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBFdmVudFRvcGljXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2V2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRvcGljID09PSBmcmFnbWVudC50b3BpY0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGV2ZW50IGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNldmVudHMuZ2V0KEV2ZW50RnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZXZlbnQgbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RXZlbnROYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBldmVudFwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhbiBldmVudCB0b3BpYyBoYXNoLCBldmVudCBuYW1lIG9yXG4gICAgICogIGV2ZW50IHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGFuIGV2ZW50IG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tFdmVudEZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNFdmVudChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXZlbnRGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXZlbnRzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBldmVudCBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEV2ZW50KGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBldmVudHMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2V2ZW50cy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXZlbnRzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXJyb3JGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYW4gZXJyb3JcbiAgICAgKiAgc2VsZWN0b3IsIGVycm9yIG5hbWUgb3IgZXJyb3Igc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBlcnJvcnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGVycm9yIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFcnJvcihrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChCdWlsdGluRXJyb3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXJyb3JzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXJyb3IgZGVzY3JpcHRpb24gKGkuZS4gJHttYXRjaFN0cn0pYCwgXCJuYW1lXCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAga2V5ID0gRXJyb3JGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3Ioc3RyaW5nKVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNlcnJvcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGVycm9ycywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFcnJvcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXJyb3JzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNlcnJvcnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSA0LWJ5dGUgc2VsZWN0b3IgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgLypcbmdldFNlbGVjdG9yKGZyYWdtZW50OiBFcnJvckZyYWdtZW50IHwgRnVuY3Rpb25GcmFnbWVudCk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlczogQXJyYXk8RnJhZ21lbnQ+ID0gWyBdO1xuXG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KSk7IH0gY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RXJyb3IoPHN0cmluZz5mcmFnbWVudCkpOyB9IGNhdGNoIChfKSB7IH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGZyYWdtZW50XCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbWJpZ3VvdXMgZnJhZ21lbnQgbWF0Y2hlcyBmdW5jdGlvbiBhbmQgZXJyb3JcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgPSBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbn1cbiAgICAqL1xuICAgIC8vIEdldCB0aGUgMzItYnl0ZSB0b3BpYyBoYXNoIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICAvKlxuICAgIGdldEV2ZW50VG9waWMoZnJhZ21lbnQ6IEV2ZW50RnJhZ21lbnQpOiBzdHJpbmcge1xuICAgICAgICAvL2lmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTsgfVxuICAgICAgICByZXR1cm4gaWQoZnJhZ21lbnQuZm9ybWF0KCkpO1xuICAgIH1cbiAgICAqL1xuICAgIF9kZWNvZGVQYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gICAgX2VuY29kZVBhcmFtcyhwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgYSBgYHR4LmRhdGFgYCBvYmplY3QgZm9yIGRlcGxveWluZyB0aGUgQ29udHJhY3Qgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgY29uc3RydWN0b3IgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGVycm9yIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgdHJhbnNhY3Rpb24gcmV2ZXJ0IGRhdGEgZm9yIGEgY2FsbCByZXN1bHQgdGhhdFxuICAgICAqICByZXZlcnRlZCBmcm9tIHRoZSB0aGUgQ29udHJhY3Qgd2l0aCB0aGUgc2VwY2lmaWVkICUlZXJyb3IlJVxuICAgICAqICAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGggdGhlICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSAlJWRhdGElJSBmcm9tIGEgdHJhbnNhY3Rpb24gYGB0eC5kYXRhYGAgZm9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZVRyYW5zYWN0aW9uXV0gbWV0aG9kXG4gICAgICogIGluc3RlYWQsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgYGB0eC5kYXRhYGAgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBjYWxscyB0aGUgZnVuY3Rpb25cbiAgICAgKiAgc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJpbnZhbGlkIGxlbmd0aCBmb3IgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XG4gICAgICAgIGlmICgoYnl0ZXMubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiY291bGQgbm90IGRlY29kZSByZXN1bHQgZGF0YVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgcmV0dXJuZWQgZGF0YSB3aXRoIG5vIGVycm9yLCBidXQgdGhlIGRhdGEgaXMganVua1xuICAgICAgICBhc3NlcnQoZmFsc2UsIG1lc3NhZ2UsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgdmFsdWU6IGhleGxpZnkoYnl0ZXMpLFxuICAgICAgICAgICAgaW5mbzogeyBtZXRob2Q6IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUVycm9yKF9kYXRhLCB0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihcImNhbGxcIiwgdHgsIGRhdGEpO1xuICAgICAgICAvLyBOb3QgYSBidWlsdC1pbiBlcnJvcjsgdHJ5IGZpbmRpbmcgYSBjdXN0b20gZXJyb3JcbiAgICAgICAgY29uc3QgY3VzdG9tUHJlZml4ID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWQgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKGN1c3RvbVByZWZpeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaGV4bGlmeShkYXRhLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgIGNvbnN0IGVmID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWYpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGVmLmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVmLm5hbWUsIHNpZ25hdHVyZTogZWYuZm9ybWF0KCksIGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVhc29uID0gZXJyb3IucmV2ZXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQ6ICR7ZXJyb3IucmVhc29ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkIChjb3VsdCBub3QgZGVjb2RlIGN1c3RvbSBlcnJvcilgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGludm9jYXRpb24sIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBlcnJvci5pbnZvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyc2VkLm5hbWUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBwYXJzZWQuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZC5hcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHJlc3VsdCBkYXRhIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpIHdpdGggJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHNwZWx1bmsoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55PiwgcHJvY2Vzc2Z1bmM6ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55Pik6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8Pj4gPSBbIF07XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gZnVuY3Rpb24odHlwZTogUGFyYW1UeXBlLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kKHR5cGUuY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCBkZXNjZW5kID0gZnVuY3Rpb24gKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbWlzbWF0Y2hcIik7IH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PGFueT4gPSBbIF07XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA8PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBgdG9vIG1hbnkgYXJndW1lbnRzIGZvciAke2ZyYWdtZW50LmZvcm1hdCgpfWAsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7IGNvdW50OiB2YWx1ZXMubGVuZ3RoLCBleHBlY3RlZENvdW50OiBmcmFnbWVudC5pbnB1dHMubGVuZ3RoIH0pO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IFVzZSB0aGUgY29kZXJzIGZvciB0aGlzOyB0byBwcm9wZXJseSBzdXBwb3J0IHR1cGxlcywgZXRjLlxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiICYmIHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9CZUhleCh2YWx1ZSk7IC8vIEBUT0RPOiBTaG91bGQgdGhpcyB0b1R3b3M/P1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXmJ5dGVzLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHplcm9QYWRCeXRlcyh2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWRWYWx1ZShoZXhsaWZ5KHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGZyYWdtZW50LmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA9PSBudWxsLCBcImNhbm5vdCBmaWx0ZXIgbm9uLWluZGV4ZWQgcGFyYW1ldGVyczsgbXVzdCBiZSBudWxsXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZXMubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChpZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy4jYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpICYmIHRvcGljc1swXS50b0xvd2VyQ2FzZSgpID09PSBldmVudFRvcGljLCBcImZyYWdtZW50L3RvcGljIG1pc21hdGNoXCIsIFwidG9waWNzWzBdXCIsIHRvcGljc1swXSk7XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBub25JbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbSh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuI2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCBjb25jYXQodG9waWNzKSkgOiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHROb25JbmRleGVkID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xuICAgICAgICAvL2NvbnN0IHJlc3VsdDogKEFycmF5PGFueT4gJiB7IFsga2V5OiBzdHJpbmcgXTogYW55IH0pID0gWyBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEluZGV4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMucHVzaChwYXJhbS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHRyYW5zYWN0aW9uLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZnVuY3Rpb24gZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gY2Fubm90IGJlIGZvdW5kLCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyh0eC5kYXRhLCBcInR4LmRhdGFcIik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KCh0eC52YWx1ZSAhPSBudWxsKSA/IHR4LnZhbHVlIDogMCwgXCJ0eC52YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgcGFyc2VDYWxsUmVzdWx0KGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZWNlaXB0IGxvZywgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXZlbnQgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGV2ZW50IGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGV2ZW50IGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlTG9nKGxvZykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC50b3BpY0hhc2gsIHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZXZlcnQgZGF0YSwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXJyb3IgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGVycm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGVycm9yIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xuICAgICAgICBjb25zdCBoZXhEYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGRhdGFTbGljZShoZXhEYXRhLCAwLCA0KSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoaGV4RGF0YSwgNCkpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tJbnRlcmZhY2VdXSBmcm9tIHRoZSBBQkkgJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJXZhbHVlJSUgbWF5IGJlIHByb3ZpZGVkIGFzIGFuIGV4aXN0aW5nIFtbSW50ZXJmYWNlXV0gb2JqZWN0LFxuICAgICAqICBhIEpTT04tZW5jb2RlZCBBQkkgb3IgYW55IEh1bWFuLVJlYWRhYmxlIEFCSSBmb3JtYXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhbiBJbnRlcmZhY2UsIHdoaWNoIGlzIGltbXV0YWJsZVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcmZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKU09OXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFuIEludGVyZmFjZTsgcG9zc2libHkgZnJvbSBhbm90aGVyIHY2IGluc3RhbmNlXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlLmZvcm1hdEpzb24pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdEpzb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBsZWdhY3kgSW50ZXJmYWNlOyBmcm9tIGFuIG9sZGVyIHZlcnNpb25cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUuZm9ybWF0KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZS5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiBmcmFnbWVudHNcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/interface.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/abi/typed.js":
/*!**********************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/abi/typed.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Typed: function() { return /* binding */ Typed; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */\n\nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, { signed, width });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${(size) ? size : \"\"}`, value, { size });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */\nclass Typed {\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    type;\n    /**\n     *  The actual value.\n     */\n    value;\n    #options;\n    /**\n     *  @_ignore:\n     */\n    _typedSymbol;\n    /**\n     *  @_ignore:\n     */\n    constructor(gaurd, type, value, options) {\n        if (options == null) {\n            options = null;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(_gaurd, gaurd, \"Typed\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { _typedSymbol, type, value });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */\n    format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        }\n        else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        }\n        else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v) => v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */\n    defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */\n    minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */\n    maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */\n    isBigInt() {\n        return !!(this.type.match(/^u?int[0-9]+$/));\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */\n    isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */\n    isString() {\n        return (this.type === \"string\");\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */\n    get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */\n    get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return (this.value).length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */\n    static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static uint8(v) { return n(v, 8); }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */\n    static uint16(v) { return n(v, 16); }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */\n    static uint24(v) { return n(v, 24); }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */\n    static uint32(v) { return n(v, 32); }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */\n    static uint40(v) { return n(v, 40); }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */\n    static uint48(v) { return n(v, 48); }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */\n    static uint56(v) { return n(v, 56); }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */\n    static uint64(v) { return n(v, 64); }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */\n    static uint72(v) { return n(v, 72); }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */\n    static uint80(v) { return n(v, 80); }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */\n    static uint88(v) { return n(v, 88); }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */\n    static uint96(v) { return n(v, 96); }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */\n    static uint104(v) { return n(v, 104); }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */\n    static uint112(v) { return n(v, 112); }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */\n    static uint120(v) { return n(v, 120); }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */\n    static uint128(v) { return n(v, 128); }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */\n    static uint136(v) { return n(v, 136); }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */\n    static uint144(v) { return n(v, 144); }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */\n    static uint152(v) { return n(v, 152); }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */\n    static uint160(v) { return n(v, 160); }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */\n    static uint168(v) { return n(v, 168); }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */\n    static uint176(v) { return n(v, 176); }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */\n    static uint184(v) { return n(v, 184); }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */\n    static uint192(v) { return n(v, 192); }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */\n    static uint200(v) { return n(v, 200); }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */\n    static uint208(v) { return n(v, 208); }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */\n    static uint216(v) { return n(v, 216); }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */\n    static uint224(v) { return n(v, 224); }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */\n    static uint232(v) { return n(v, 232); }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */\n    static uint240(v) { return n(v, 240); }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */\n    static uint248(v) { return n(v, 248); }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint256(v) { return n(v, 256); }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint(v) { return n(v, 256); }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */\n    static int8(v) { return n(v, -8); }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */\n    static int16(v) { return n(v, -16); }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */\n    static int24(v) { return n(v, -24); }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */\n    static int32(v) { return n(v, -32); }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */\n    static int40(v) { return n(v, -40); }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */\n    static int48(v) { return n(v, -48); }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */\n    static int56(v) { return n(v, -56); }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */\n    static int64(v) { return n(v, -64); }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */\n    static int72(v) { return n(v, -72); }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */\n    static int80(v) { return n(v, -80); }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */\n    static int88(v) { return n(v, -88); }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */\n    static int96(v) { return n(v, -96); }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */\n    static int104(v) { return n(v, -104); }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */\n    static int112(v) { return n(v, -112); }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */\n    static int120(v) { return n(v, -120); }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */\n    static int128(v) { return n(v, -128); }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */\n    static int136(v) { return n(v, -136); }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */\n    static int144(v) { return n(v, -144); }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */\n    static int152(v) { return n(v, -152); }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */\n    static int160(v) { return n(v, -160); }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */\n    static int168(v) { return n(v, -168); }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */\n    static int176(v) { return n(v, -176); }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */\n    static int184(v) { return n(v, -184); }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */\n    static int192(v) { return n(v, -192); }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */\n    static int200(v) { return n(v, -200); }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */\n    static int208(v) { return n(v, -208); }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */\n    static int216(v) { return n(v, -216); }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */\n    static int224(v) { return n(v, -224); }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */\n    static int232(v) { return n(v, -232); }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */\n    static int240(v) { return n(v, -240); }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */\n    static int248(v) { return n(v, -248); }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int256(v) { return n(v, -256); }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int(v) { return n(v, -256); }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */\n    static bytes1(v) { return b(v, 1); }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */\n    static bytes2(v) { return b(v, 2); }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */\n    static bytes3(v) { return b(v, 3); }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */\n    static bytes4(v) { return b(v, 4); }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */\n    static bytes5(v) { return b(v, 5); }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */\n    static bytes6(v) { return b(v, 6); }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */\n    static bytes7(v) { return b(v, 7); }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */\n    static bytes8(v) { return b(v, 8); }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */\n    static bytes9(v) { return b(v, 9); }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */\n    static bytes10(v) { return b(v, 10); }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */\n    static bytes11(v) { return b(v, 11); }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */\n    static bytes12(v) { return b(v, 12); }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */\n    static bytes13(v) { return b(v, 13); }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */\n    static bytes14(v) { return b(v, 14); }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */\n    static bytes15(v) { return b(v, 15); }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */\n    static bytes16(v) { return b(v, 16); }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */\n    static bytes17(v) { return b(v, 17); }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */\n    static bytes18(v) { return b(v, 18); }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */\n    static bytes19(v) { return b(v, 19); }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */\n    static bytes20(v) { return b(v, 20); }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */\n    static bytes21(v) { return b(v, 21); }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */\n    static bytes22(v) { return b(v, 22); }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */\n    static bytes23(v) { return b(v, 23); }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */\n    static bytes24(v) { return b(v, 24); }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */\n    static bytes25(v) { return b(v, 25); }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */\n    static bytes26(v) { return b(v, 26); }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */\n    static bytes27(v) { return b(v, 27); }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */\n    static bytes28(v) { return b(v, 28); }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */\n    static bytes29(v) { return b(v, 29); }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */\n    static bytes30(v) { return b(v, 30); }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */\n    static bytes31(v) { return b(v, 31); }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */\n    static bytes32(v) { return b(v, 32); }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */\n    static address(v) { return new Typed(_gaurd, \"address\", v); }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */\n    static bool(v) { return new Typed(_gaurd, \"bool\", !!v); }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */\n    static bytes(v) { return new Typed(_gaurd, \"bytes\", v); }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */\n    static string(v) { return new Typed(_gaurd, \"string\", v); }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */\n    static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */\n    static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */\n    static isTyped(value) {\n        return (value\n            && typeof (value) === \"object\"\n            && \"_typedSymbol\" in value\n            && value._typedSymbol === _typedSymbol);\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */\n    static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=typed.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvdHlwZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCLEtBQUssTUFBTSxZQUFZLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQixZQUFZLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQWE7QUFDckIsUUFBUSxpRUFBZ0IsU0FBUywyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRDQUE0QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxLQUFLLFFBQVEsV0FBVztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvdHlwZWQuanM/MDBhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIFR5cGVkIG9iamVjdCBhbGxvd3MgYSB2YWx1ZSB0byBoYXZlIGl0cyB0eXBlIGV4cGxpY2l0bHlcbiAqICBzcGVjaWZpZWQuXG4gKlxuICogIEZvciBleGFtcGxlLCBpbiBTb2xpZGl0eSwgdGhlIHZhbHVlIGBgNDVgYCBjb3VsZCByZXByZXNlbnQgYVxuICogIGBgdWludDhgYCBvciBhIGBgdWludDI1NmBgLiBUaGUgdmFsdWUgYGAweDEyMzRgYCBjb3VsZCByZXByZXNlbnRcbiAqICBhIGBgYnl0ZXMyYGAgb3IgYGBieXRlc2BgLlxuICpcbiAqICBTaW5jZSBKYXZhU2NyaXB0IGhhcyBubyBtZWFuaW5nZnVsIHdheSB0byBleHBsaWNpdGx5IGluZm9ybSBhbnlcbiAqICBBUElzIHdoaWNoIHdoYXQgdGhlIHR5cGUgaXMsIHRoaXMgYWxsb3dzIHRyYW5zcGFyZW50IGludGVyb3BlcmF0aW9uXG4gKiAgd2l0aCBTb2xkaXR5LlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9hYmk6VHlwZWQgVmFsdWVzXG4gKi9cbmltcG9ydCB7IGFzc2VydFByaXZhdGUsIGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IF9nYXVyZCA9IHt9O1xuZnVuY3Rpb24gbih2YWx1ZSwgd2lkdGgpIHtcbiAgICBsZXQgc2lnbmVkID0gZmFsc2U7XG4gICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICBzaWduZWQgPSB0cnVlO1xuICAgICAgICB3aWR0aCAqPSAtMTtcbiAgICB9XG4gICAgLy8gQFRPRE86IENoZWNrIHJhbmdlIGlzIHZhbGlkIGZvciB2YWx1ZVxuICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBgJHtzaWduZWQgPyBcIlwiIDogXCJ1XCJ9aW50JHt3aWR0aH1gLCB2YWx1ZSwgeyBzaWduZWQsIHdpZHRoIH0pO1xufVxuZnVuY3Rpb24gYih2YWx1ZSwgc2l6ZSkge1xuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYGJ5dGVzJHsoc2l6ZSkgPyBzaXplIDogXCJcIn1gLCB2YWx1ZSwgeyBzaXplIH0pO1xufVxuY29uc3QgX3R5cGVkU3ltYm9sID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfdHlwZWRcIik7XG4vKipcbiAqICBUaGUgKipUeXBlZCoqIGNsYXNzIHRvIHdyYXAgdmFsdWVzIHByb3ZpZGluZyBleHBsaWNpdCB0eXBlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSwgYXMgYSBTb2xpZGl0eS1jb21wYXRpYmxlIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3R5cGVkU3ltYm9sO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXVyZCwgdHlwZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShfZ2F1cmQsIGdhdXJkLCBcIlR5cGVkXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgX3R5cGVkU3ltYm9sLCB0eXBlLCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIENoZWNrIHRoZSB2YWx1ZSBpcyB2YWxpZFxuICAgICAgICB0aGlzLmZvcm1hdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRm9ybWF0IHRoZSB0eXBlIGFzIGEgSHVtYW4tUmVhZGFibGUgdHlwZS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJkeW5hbWljQXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYHR1cGxlKCR7dGhpcy52YWx1ZS5tYXAoKHYpID0+IHYuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSB0aGlzIHR5cGUuXG4gICAgICovXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtaW5pbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxuICAgICAqL1xuICAgIG1pblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxuICAgICAqL1xuICAgIG1heFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZEJpZ0ludF1dLlxuICAgICAqL1xuICAgIGlzQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy50eXBlLm1hdGNoKC9edT9pbnRbMC05XSskLykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkRGF0YV1dLlxuICAgICAqL1xuICAgIGlzRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zdGFydHNXaXRoKFwiYnl0ZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRTdHJpbmddXS5cbiAgICAgKi9cbiAgICBpc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IFwic3RyaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHVwbGUgbmFtZSwgaWYgdGhpcyBpcyBhIHR1cGxlLiBUaHJvd3Mgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldCB0dXBsZU5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGEgdHVwbGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGlzIHR5cGUgYXMgYW4gYXJyYXlcbiAgICAvLyAtIGBudWxsYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyB1bmZvcmNlZCwgaXQgY291bGQgYmUgZHluYW1pY1xuICAgIC8vIC0gYC0xYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyBkeW5hbWljXG4gICAgLy8gLSBhbnkgb3RoZXIgdmFsdWUgaW5kaWNhdGVzIGl0IGlzIGEgc3RhdGljIGFycmF5IGFuZCBpcyBpdHMgbGVuZ3RoXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdHlwZSBvciBgYC0xYGAgaWYgaXQgaXMgZHluYW1pYy5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIHR5cGUgaXMgbm90IGFuIGFycmF5LlxuICAgICAqL1xuICAgIGdldCBhcnJheUxlbmd0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlR5cGVkKiogb2YgJSV0eXBlJSUgd2l0aCB0aGUgJSV2YWx1ZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCB0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OCh2KSB7IHJldHVybiBuKHYsIDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTYodikgeyByZXR1cm4gbih2LCAxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNCh2KSB7IHJldHVybiBuKHYsIDI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDMyKHYpIHsgcmV0dXJuIG4odiwgMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDAodikgeyByZXR1cm4gbih2LCA0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ0OCh2KSB7IHJldHVybiBuKHYsIDQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDU2KHYpIHsgcmV0dXJuIG4odiwgNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ2NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NjQodikgeyByZXR1cm4gbih2LCA2NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDcyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ3Mih2KSB7IHJldHVybiBuKHYsIDcyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgwKHYpIHsgcmV0dXJuIG4odiwgODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50ODgodikgeyByZXR1cm4gbih2LCA4OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDk2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ5Nih2KSB7IHJldHVybiBuKHYsIDk2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMDQodikgeyByZXR1cm4gbih2LCAxMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDExMih2KSB7IHJldHVybiBuKHYsIDExMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTIwKHYpIHsgcmV0dXJuIG4odiwgMTIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMjgodikgeyByZXR1cm4gbih2LCAxMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEzNih2KSB7IHJldHVybiBuKHYsIDEzNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE0NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgMTQ0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTUyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNTIodikgeyByZXR1cm4gbih2LCAxNTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2MCh2KSB7IHJldHVybiBuKHYsIDE2MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTY4KHYpIHsgcmV0dXJuIG4odiwgMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTc2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNzYodikgeyByZXR1cm4gbih2LCAxNzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE4NCh2KSB7IHJldHVybiBuKHYsIDE4NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE5MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTkyKHYpIHsgcmV0dXJuIG4odiwgMTkyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDAodikgeyByZXR1cm4gbih2LCAyMDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIwOCh2KSB7IHJldHVybiBuKHYsIDIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjE2KHYpIHsgcmV0dXJuIG4odiwgMjE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMjQodikgeyByZXR1cm4gbih2LCAyMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIzMih2KSB7IHJldHVybiBuKHYsIDIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQwKHYpIHsgcmV0dXJuIG4odiwgMjQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNDgodikgeyByZXR1cm4gbih2LCAyNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI1Nih2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50KHYpIHsgcmV0dXJuIG4odiwgMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDgodikgeyByZXR1cm4gbih2LCAtOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTYodikgeyByZXR1cm4gbih2LCAtMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0KHYpIHsgcmV0dXJuIG4odiwgLTI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQzMih2KSB7IHJldHVybiBuKHYsIC0zMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NDAodikgeyByZXR1cm4gbih2LCAtNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQ4KHYpIHsgcmV0dXJuIG4odiwgLTQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ1Nih2KSB7IHJldHVybiBuKHYsIC01Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NjQodikgeyByZXR1cm4gbih2LCAtNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDcyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDcyKHYpIHsgcmV0dXJuIG4odiwgLTcyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4MCh2KSB7IHJldHVybiBuKHYsIC04MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODgodikgeyByZXR1cm4gbih2LCAtODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDk2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDk2KHYpIHsgcmV0dXJuIG4odiwgLTk2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTA0KHYpIHsgcmV0dXJuIG4odiwgLTEwNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDExMih2KSB7IHJldHVybiBuKHYsIC0xMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMjAodikgeyByZXR1cm4gbih2LCAtMTIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTI4KHYpIHsgcmV0dXJuIG4odiwgLTEyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEzNih2KSB7IHJldHVybiBuKHYsIC0xMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE0NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNDQodikgeyByZXR1cm4gbih2LCAtMTQ0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNTIodikgeyByZXR1cm4gbih2LCAtMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTYwKHYpIHsgcmV0dXJuIG4odiwgLTE2MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTY4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2OCh2KSB7IHJldHVybiBuKHYsIC0xNjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNzYodikgeyByZXR1cm4gbih2LCAtMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTg0KHYpIHsgcmV0dXJuIG4odiwgLTE4NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTkyKHYpIHsgcmV0dXJuIG4odiwgLTE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIwMCh2KSB7IHJldHVybiBuKHYsIC0yMDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDgodikgeyByZXR1cm4gbih2LCAtMjA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjE2KHYpIHsgcmV0dXJuIG4odiwgLTIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIyNCh2KSB7IHJldHVybiBuKHYsIC0yMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMzIodikgeyByZXR1cm4gbih2LCAtMjMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQwKHYpIHsgcmV0dXJuIG4odiwgLTI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0OCh2KSB7IHJldHVybiBuKHYsIC0yNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNTYodikgeyByZXR1cm4gbih2LCAtMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMSh2KSB7IHJldHVybiBiKHYsIDEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIodikgeyByZXR1cm4gYih2LCAyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzKHYpIHsgcmV0dXJuIGIodiwgMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNCh2KSB7IHJldHVybiBiKHYsIDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczUodikgeyByZXR1cm4gYih2LCA1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM2KHYpIHsgcmV0dXJuIGIodiwgNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNyh2KSB7IHJldHVybiBiKHYsIDcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczgodikgeyByZXR1cm4gYih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM5KHYpIHsgcmV0dXJuIGIodiwgOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEwKHYpIHsgcmV0dXJuIGIodiwgMTApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMSh2KSB7IHJldHVybiBiKHYsIDExKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTIodikgeyByZXR1cm4gYih2LCAxMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEzKHYpIHsgcmV0dXJuIGIodiwgMTMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNCh2KSB7IHJldHVybiBiKHYsIDE0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTUodikgeyByZXR1cm4gYih2LCAxNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE2KHYpIHsgcmV0dXJuIGIodiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNyh2KSB7IHJldHVybiBiKHYsIDE3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTgodikgeyByZXR1cm4gYih2LCAxOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE5KHYpIHsgcmV0dXJuIGIodiwgMTkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMCh2KSB7IHJldHVybiBiKHYsIDIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjEodikgeyByZXR1cm4gYih2LCAyMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIyKHYpIHsgcmV0dXJuIGIodiwgMjIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMyh2KSB7IHJldHVybiBiKHYsIDIzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjQodikgeyByZXR1cm4gYih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI1KHYpIHsgcmV0dXJuIGIodiwgMjUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNih2KSB7IHJldHVybiBiKHYsIDI2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjcodikgeyByZXR1cm4gYih2LCAyNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI4KHYpIHsgcmV0dXJuIGIodiwgMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOSh2KSB7IHJldHVybiBiKHYsIDI5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzAodikgeyByZXR1cm4gYih2LCAzMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMxKHYpIHsgcmV0dXJuIGIodiwgMzEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMih2KSB7IHJldHVybiBiKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBhZGRyZXNzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGFkZHJlc3ModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhZGRyZXNzXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJvb2xgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYm9vbCh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJvb2xcIiwgISF2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlcyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJ5dGVzXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHN0cmluZ2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmcodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJzdHJpbmdcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYXJyYXlgYCB0eXBlIGZvciAlJXYlJSwgYWxsb3dpbmcgJSVkeW5hbWljJSUgbGVuZ3RoLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheSh2LCBkeW5hbWljKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImFycmF5XCIsIHYsIGR5bmFtaWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdHVwbGVgYCB0eXBlIGZvciAlJXYlJSwgd2l0aCB0aGUgb3B0aW9uYWwgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIHR1cGxlKHYsIG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwidHVwbGVcIiwgdiwgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBvdmVycmlkZXModikge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJvdmVycmlkZXNcIiwgT2JqZWN0LmFzc2lnbih7fSwgdikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIG9ubHkgaWYgJSV2YWx1ZSUlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1R5cGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWVcbiAgICAgICAgICAgICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAmJiBcIl90eXBlZFN5bWJvbFwiIGluIHZhbHVlXG4gICAgICAgICAgICAmJiB2YWx1ZS5fdHlwZWRTeW1ib2wgPT09IF90eXBlZFN5bWJvbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0aGUgdmFsdWUgaXMgYSBbW1R5cGVkXV0gaW5zdGFuY2UsIHZhbGlkYXRlcyB0aGUgdW5kZXJseWluZyB2YWx1ZVxuICAgICAqICBhbmQgcmV0dXJucyBpdCwgb3RoZXJ3aXNlIHJldHVybnMgdmFsdWUgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIGZ1bmN0aW9ucyB0aGF0IHdpdGggdG8gYWNjZXB0IGVpdGhlciBhIFtbVHlwZWRdXVxuICAgICAqICBvYmplY3Qgb3IgdmFsdWVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGU6IGV4cGVjZXRkICR7dHlwZX0sIGdvdCAke3ZhbHVlLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/abi/typed.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/address/address.js":
/*!****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/address/address.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: function() { return /* binding */ getAddress; },\n/* harmony export */   getIcapAddress: function() { return /* binding */ getIcapAddress; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = (function () {\n    ;\n    const result = {};\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nfunction getAddress(address) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (address) === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nfunction getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQztBQUNjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxtQkFBbUIseURBQVEsQ0FBQywyREFBUztBQUNyQyxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx1QkFBdUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksK0RBQWM7QUFDbEIseUNBQXlDLEdBQUc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxZQUFZLE1BQU07QUFDcEQ7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzP2FjY2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMzYgPSBCaWdJbnQoMzYpO1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvLyAgICBpZiAoIWlzSGV4U3RyaW5nKGFkZHJlc3MsIDIwKSkge1xuICAgIC8vICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAvLyAgICB9XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjaGFycyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO1xuICAgIGNvbnN0IGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICBleHBhbmRlZFtpXSA9IGNoYXJzW2ldLmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGdldEJ5dGVzKGtlY2NhazI1NihleHBhbmRlZCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XG59XG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlclxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxuY29uc3QgaWJhbkxvb2t1cCA9IHt9O1xuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcoaSldID0gU3RyaW5nKGkpO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNjsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgaSldID0gU3RyaW5nKDEwICsgaSk7XG59XG4vLyBIb3cgbWFueSBkZWNpbWFsIGRpZ2l0cyBjYW4gd2UgcHJvY2Vzcz8gKGZvciA2NC1iaXQgZmxvYXQsIHRoaXMgaXMgMTUpXG4vLyBpLmUuIE1hdGguZmxvb3IoTWF0aC5sb2cxMChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xuY29uc3Qgc2FmZURpZ2l0cyA9IDE1O1xuZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZyg0KSArIGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICsgXCIwMFwiO1xuICAgIGxldCBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKChjKSA9PiB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xuICAgIC8vIEphdmFzY3JpcHQgY2FuIGhhbmRsZSBpbnRlZ2VycyBzYWZlbHkgdXAgdG8gMTUgKGRlY2ltYWwpIGRpZ2l0c1xuICAgIHdoaWxlIChleHBhbmRlZC5sZW5ndGggPj0gc2FmZURpZ2l0cykge1xuICAgICAgICBsZXQgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XG4gICAgICAgIGV4cGFuZGVkID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgZXhwYW5kZWQuc3Vic3RyaW5nKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcbiAgICB3aGlsZSAoY2hlY2tzdW0ubGVuZ3RoIDwgMikge1xuICAgICAgICBjaGVja3N1bSA9IFwiMFwiICsgY2hlY2tzdW07XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bTtcbn1cbjtcbmNvbnN0IEJhc2UzNiA9IChmdW5jdGlvbiAoKSB7XG4gICAgO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzY7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiW2ldO1xuICAgICAgICByZXN1bHRba2V5XSA9IEJpZ0ludChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5mdW5jdGlvbiBmcm9tQmFzZTM2KHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICogQk5fMzYgKyBCYXNlMzZbdmFsdWVbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIG5vcm1hbGl6ZWQgYW5kIGNoZWNrc3VtZWQgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUuXG4gKiAgVGhpcyBhY2NlcHRzIG5vbi1jaGVja3N1bSBhZGRyZXNzZXMsIGNoZWNrc3VtIGFkZHJlc3NlcyBhbmRcbiAqICBbW2dldEljYXBBZGRyZXNzXV0gZm9ybWF0cy5cbiAqXG4gKiAgVGhlIGNoZWNrc3VtIGluIEV0aGVyZXVtIHVzZXMgdGhlIGNhcGl0YWxpemF0aW9uICh1cHBlci1jYXNlXG4gKiAgdnMgbG93ZXItY2FzZSkgb2YgdGhlIGNoYXJhY3RlcnMgd2l0aGluIGFuIGFkZHJlc3MgdG8gZW5jb2RlXG4gKiAgaXRzIGNoZWNrc3VtLCB3aGljaCBvZmZlcnMsIG9uIGF2ZXJhZ2UsIGEgY2hlY2tzdW0gb2YgMTUtYml0cy5cbiAqXG4gKiAgSWYgJSVhZGRyZXNzJSUgY29udGFpbnMgYm90aCB1cHBlci1jYXNlIGFuZCBsb3dlci1jYXNlLCBpdCBpc1xuICogIGFzc3VtZWQgdG8gYWxyZWFkeSBiZSBhIGNoZWNrc3VtIGFkZHJlc3MgYW5kIGl0cyBjaGVja3N1bSBpc1xuICogIHZhbGlkYXRlZCwgYW5kIGlmIHRoZSBhZGRyZXNzIGZhaWxzIGl0cyBleHBlY3RlZCBjaGVja3N1bSBhblxuICogIGVycm9yIGlzIHRocm93bi5cbiAqXG4gKiAgSWYgeW91IHdpc2ggdGhlIGNoZWNrc3VtIG9mICUlYWRkcmVzcyUlIHRvIGJlIGlnbm9yZSwgaXQgc2hvdWxkXG4gKiAgYmUgY29udmVydGVkIHRvIGxvd2VyLWNhc2UgKGkuZS4gYGAudG9Mb3dlcmNhc2UoKWBgKSBiZWZvcmVcbiAqICBiZWluZyBwYXNzZWQgaW4uIFRoaXMgc2hvdWxkIGJlIGEgdmVyeSByYXJlIHNpdHVhdGlvbiB0aG91Z2gsXG4gKiAgdGhhdCB5b3Ugd2lzaCB0byBieXBhc3MgdGhlIHNhZmVnYXVyZHMgaW4gcGxhY2UgdG8gcHJvdGVjdFxuICogIGFnYWluc3QgYW4gYWRkcmVzcyB0aGF0IGhhcyBiZWVuIGluY29ycmVjdGx5IGNvcGllZCBmcm9tIGFub3RoZXJcbiAqICBzb3VyY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gQWRkcyB0aGUgY2hlY2tzdW0gKHZpYSB1cHBlci1jYXNpbmcgc3BlY2lmaWMgbGV0dGVycylcbiAqICAgIGdldEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBDb252ZXJ0cyBJQ0FQIGFkZHJlc3MgYW5kIGFkZHMgY2hlY2tzdW1cbiAqICAgIGdldEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgYW4gYWRkcmVzcyBjb250YWlucyBtaXhlZCBjYXNlLFxuICogICAgLy8gYnV0IHRoZSBjaGVja3N1bSBmYWlsc1xuICogICAgZ2V0QWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGFkZHJlc3MpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xuICAgICAgICAvLyBNaXNzaW5nIHRoZSAweCBwcmVmaXhcbiAgICAgICAgaWYgKCFhZGRyZXNzLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAvLyBJdCBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBhc3NlcnRBcmd1bWVudCghYWRkcmVzcy5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSB8fCByZXN1bHQgPT09IGFkZHJlc3MsIFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBNYXliZSBJQ0FQPyAod2Ugb25seSBzdXBwb3J0IGRpcmVjdCBtb2RlKVxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzLnN1YnN0cmluZygyLCA0KSA9PT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpLCBcImJhZCBpY2FwIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZyb21CYXNlMzYoYWRkcmVzcy5zdWJzdHJpbmcoNCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA0MCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xufVxuLyoqXG4gKiAgVGhlIFtJQ0FQIEFkZHJlc3MgZm9ybWF0XShsaW5rLWljYXApIGZvcm1hdCBpcyBhbiBlYXJseSBjaGVja3N1bVxuICogIGZvcm1hdCB3aGljaCBhdHRlbXB0cyB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIGJhbmtpbmdcbiAqICBpbmR1c3RyeSBbSUJBTiBmb3JtYXRdKGxpbmstd2lraS1pYmFuKSBmb3IgYmFuayBhY2NvdW50cy5cbiAqXG4gKiAgSXQgaXMgbm8gbG9uZ2VyIGNvbW1vbiBvciBhIHJlY29tbWVuZGVkIGZvcm1hdC5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpO1xuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgSUNBUCBjaGVja3N1bSBpcyB3cm9uZ1xuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszN1wiKTtcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWNhcEFkZHJlc3MoYWRkcmVzcykge1xuICAgIC8vbGV0IGJhc2UzNiA9IF9iYXNlMTZUbzM2KGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldCBiYXNlMzYgPSBCaWdJbnQoZ2V0QWRkcmVzcyhhZGRyZXNzKSkudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCk7XG4gICAgd2hpbGUgKGJhc2UzNi5sZW5ndGggPCAzMCkge1xuICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcbiAgICB9XG4gICAgcmV0dXJuIFwiWEVcIiArIGliYW5DaGVja3N1bShcIlhFMDBcIiArIGJhc2UzNikgKyBiYXNlMzY7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/address/address.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/address/checks.js":
/*!***************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/address/checks.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddress: function() { return /* binding */ isAddress; },\n/* harmony export */   isAddressable: function() { return /* binding */ isAddressable; },\n/* harmony export */   resolveAddress: function() { return /* binding */ resolveAddress; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"../common/node_modules/ethers/lib.esm/address/address.js\");\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nfunction isAddressable(value) {\n    return (value && typeof (value.getAddress) === \"function\");\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nfunction isAddress(value) {\n    try {\n        (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof (target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nfunction resolveAddress(target, resolver) {\n    if (typeof (target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(target);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\n        return checkAddress(target, resolver.resolveName(target));\n    }\n    else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    }\n    else if (target && typeof (target.then) === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n}\n//# sourceMappingURL=checks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NoZWNrcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUNqQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSx1REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSwyRUFBMkUsZUFBZTtBQUN4RyxRQUFRLCtEQUFjLG9DQUFvQztBQUMxRDtBQUNBLFdBQVcsdURBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QyxtQkFBbUIsdURBQVU7QUFDN0I7QUFDQSxRQUFRLHVEQUFNLG9GQUFvRiwwQkFBMEI7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NoZWNrcy5qcz84Y2NhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZVxuICogIFtbQWRkcmVzc2FibGVdXSBpbnRlcmZhY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gV2FsbGV0cyBhbmQgQWJzdHJhY3RTaWduZXIgc3ViLWNsYXNzZXNcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnRyYWN0c1xuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgWyBdLCBwcm92aWRlcilcbiAqICAgIGlzQWRkcmVzc2FibGUoY29udHJhY3QpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3NhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVmFsaWQgSUNBUCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gTm90IGFuIGFkZHJlc3MgKGFuIEVOUyBuYW1lIHJlcXVpcmVzIGEgcHJvdmlkZWQgYW5kIGFuXG4gKiAgICAvLyBhc3luY2hyb25vdXMgQVBJIHRvIGFjY2VzcylcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja0FkZHJlc3ModGFyZ2V0LCBwcm9taXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHRhcmdldCkgIT09IFwic3RyaW5nXCIsIFwidW5jb25maWd1cmVkIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7IHZhbHVlOiB0YXJnZXQgfSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MocmVzdWx0KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGFuIGFkZHJlc3MgZm9yIHRoZSAlJXRhcmdldCUlLCB3aGljaCBtYXkgYmUgYW55XG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxuICogIHJlc29sdmVzIHRvIGFuIGFkZHJlc3MuXG4gKlxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcbiAqICBjb25maWd1cmVkIGEgW1tVbmNvbmZpZ3VyZWROYW1lRXJyb3JdXSBpcyB0aHJvd24uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgYWRkciA9IFwiMHg2QjE3NTQ3NEU4OTA5NEM0NERhOThiOTU0RWVkZUFDNDk1MjcxZDBGXCJcbiAqXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzIHByb21pc2VzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoUHJvbWlzZS5yZXNvbHZlKGFkZHIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyLCBbIF0pXG4gKiAgICByZXNvbHZlQWRkcmVzcyhjb250cmFjdCwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVW5jb25maWd1cmVkIEVOUyBuYW1lcyByZWplY3RcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXG4gKiAgICAvLyAobm90aWNlIHRoZSBwcm92aWRlciB3YXMgb21pdHRlZClcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3ModGFyZ2V0LCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaCgvXjB4WzAtOWEtZl17NDB9JC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocmVzb2x2ZXIgIT0gbnVsbCwgXCJFTlMgcmVzb2x1dGlvbiByZXF1aXJlcyBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIgfSk7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBZGRyZXNzYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQuZ2V0QWRkcmVzcygpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiAodGFyZ2V0LnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGFkZHJlc3NhYmxlIHZhbHVlXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/address/checks.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/address/contract-address.js":
/*!*************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/address/contract-address.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCreate2Address: function() { return /* binding */ getCreate2Address; },\n/* harmony export */   getCreateAddress: function() { return /* binding */ getCreateAddress; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"../common/node_modules/ethers/lib.esm/address/address.js\");\n\n\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */\nfunction getCreateAddress(tx) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.from);\n    const nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(tx.nonce, \"tx.nonce\");\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    }\n    else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    }\n    else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.encodeRlp)([from, nonceHex])), 12));\n}\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */\nfunction getCreate2Address(_from, _salt, _initCodeHash) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(_from);\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\n    const initCodeHash = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_initCodeHash, \"initCodeHash\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\"0xff\", from, salt, initCodeHash])), 12));\n}\n//# sourceMappingURL=contract-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NvbnRyYWN0LWFkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0M7QUFDdUQ7QUFDNUQ7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ087QUFDUCxpQkFBaUIsdURBQVU7QUFDM0Isa0JBQWtCLDBEQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBVSxDQUFDLDBEQUFTLENBQUMsMkRBQVMsQ0FBQywwREFBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQix1REFBVTtBQUMzQixpQkFBaUIseURBQVE7QUFDekIseUJBQXlCLHlEQUFRO0FBQ2pDLElBQUksK0RBQWM7QUFDbEIsSUFBSSwrREFBYztBQUNsQixXQUFXLHVEQUFVLENBQUMsMERBQVMsQ0FBQywyREFBUyxDQUFDLHVEQUFNO0FBQ2hEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jb250cmFjdC1hZGRyZXNzLmpzPzgyMGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhU2xpY2UsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGVuY29kZVJscCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFYGAgZm9yICUldHglJS5cbiAqXG4gKiAgVGhpcyBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGFuIEVPQSB3aGVuIHNlbmRpbmcgYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIChpLmUuXG4gKiAgd2hlbiB0aGUgYGB0b2BgIGFkZHJlc3MgaXMgYGBudWxsYGApLlxuICpcbiAqICBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcbiAqICBkZXBsb3llZCB0byBieSBhIGNvbnRyYWN0LCBieSB1c2luZyB0aGUgY29udHJhY3QncyBhZGRyZXNzIGFzIHRoZVxuICogIGBgdG9gYCBhbmQgdGhlIGNvbnRyYWN0J3Mgbm9uY2UuXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBmcm9tID0gXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIjtcbiAqICAgIG5vbmNlID0gNTtcbiAqXG4gKiAgICBnZXRDcmVhdGVBZGRyZXNzKHsgZnJvbSwgbm9uY2UgfSk7XG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGVBZGRyZXNzKHR4KSB7XG4gICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3ModHguZnJvbSk7XG4gICAgY29uc3Qgbm9uY2UgPSBnZXRCaWdJbnQodHgubm9uY2UsIFwidHgubm9uY2VcIik7XG4gICAgbGV0IG5vbmNlSGV4ID0gbm9uY2UudG9TdHJpbmcoMTYpO1xuICAgIGlmIChub25jZUhleCA9PT0gXCIwXCIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vbmNlSGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4MFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIiArIG5vbmNlSGV4O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZVJscChbZnJvbSwgbm9uY2VIZXhdKSksIDEyKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURTJgYCBvcGVyYXRpb25cbiAqICB3aXRoIHRoZSBnaXZlbiAlJWZyb20lJSwgJSVzYWx0JSUgYW5kICUlaW5pdENvZGVIYXNoJSUuXG4gKlxuICogIFRvIGNvbXB1dGUgdGhlICUlaW5pdENvZGVIYXNoJSUgZnJvbSBhIGNvbnRyYWN0J3MgaW5pdCBjb2RlLCB1c2VcbiAqICB0aGUgW1trZWNjYWsyNTZdXSBmdW5jdGlvbi5cbiAqXG4gKiAgRm9yIGEgcXVpY2sgb3ZlcnZpZXcgYW5kIGV4YW1wbGUgb2YgYGBDUkVBVEUyYGAsIHNlZSBbW2xpbmstcmljbW9vLXdpc3BzXV0uXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3RcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiXG4gKlxuICogICAgLy8gVGhlIHNhbHRcbiAqICAgIHNhbHQgPSBpZChcIkhlbGxvV29ybGRcIilcbiAqXG4gKiAgICAvLyBUaGUgaGFzaCBvZiB0aGUgaW5pdENvZGVcbiAqICAgIGluaXRDb2RlID0gXCIweDYzOTQxOThkZjE2MDAwNTI2MTAzZmY2MDIwNjAwNDYwMWMzMzVhZmE2MDQwNTE2MDYwZjNcIjtcbiAqICAgIGluaXRDb2RlSGFzaCA9IGtlY2NhazI1Nihpbml0Q29kZSlcbiAqXG4gKiAgICBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhfZnJvbSwgX3NhbHQsIF9pbml0Q29kZUhhc2gpIHtcbiAgICBjb25zdCBmcm9tID0gZ2V0QWRkcmVzcyhfZnJvbSk7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgY29uc3QgaW5pdENvZGVIYXNoID0gZ2V0Qnl0ZXMoX2luaXRDb2RlSGFzaCwgXCJpbml0Q29kZUhhc2hcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQoc2FsdC5sZW5ndGggPT09IDMyLCBcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgX3NhbHQpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluaXRDb2RlSGFzaC5sZW5ndGggPT09IDMyLCBcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIF9pbml0Q29kZUhhc2gpO1xuICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIiwgZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/address/contract-address.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/address/index.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/address/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: function() { return /* reexport safe */ _address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress; },\n/* harmony export */   getCreate2Address: function() { return /* reexport safe */ _contract_address_js__WEBPACK_IMPORTED_MODULE_1__.getCreate2Address; },\n/* harmony export */   getCreateAddress: function() { return /* reexport safe */ _contract_address_js__WEBPACK_IMPORTED_MODULE_1__.getCreateAddress; },\n/* harmony export */   getIcapAddress: function() { return /* reexport safe */ _address_js__WEBPACK_IMPORTED_MODULE_0__.getIcapAddress; },\n/* harmony export */   isAddress: function() { return /* reexport safe */ _checks_js__WEBPACK_IMPORTED_MODULE_2__.isAddress; },\n/* harmony export */   isAddressable: function() { return /* reexport safe */ _checks_js__WEBPACK_IMPORTED_MODULE_2__.isAddressable; },\n/* harmony export */   resolveAddress: function() { return /* reexport safe */ _checks_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress; }\n/* harmony export */ });\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"../common/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _contract_address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contract-address.js */ \"../common/node_modules/ethers/lib.esm/address/contract-address.js\");\n/* harmony import */ var _checks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./checks.js */ \"../common/node_modules/ethers/lib.esm/address/checks.js\");\n/**\n *  Addresses are a fundamental part of interacting with Ethereum. They\n *  represent the global identity of Externally Owned Accounts (accounts\n *  backed by a private key) and contracts.\n *\n *  The Ethereum Naming Service (ENS) provides an interconnected ecosystem\n *  of contracts, standards and libraries which enable looking up an\n *  address for an ENS name.\n *\n *  These functions help convert between various formats, validate\n *  addresses and safely resolve ENS names.\n *\n *  @_section: api/address:Addresses  [about-addresses]\n */\nnull;\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMEQ7QUFDa0I7QUFDTDtBQUN2RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2luZGV4LmpzP2JhZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQWRkcmVzc2VzIGFyZSBhIGZ1bmRhbWVudGFsIHBhcnQgb2YgaW50ZXJhY3Rpbmcgd2l0aCBFdGhlcmV1bS4gVGhleVxuICogIHJlcHJlc2VudCB0aGUgZ2xvYmFsIGlkZW50aXR5IG9mIEV4dGVybmFsbHkgT3duZWQgQWNjb3VudHMgKGFjY291bnRzXG4gKiAgYmFja2VkIGJ5IGEgcHJpdmF0ZSBrZXkpIGFuZCBjb250cmFjdHMuXG4gKlxuICogIFRoZSBFdGhlcmV1bSBOYW1pbmcgU2VydmljZSAoRU5TKSBwcm92aWRlcyBhbiBpbnRlcmNvbm5lY3RlZCBlY29zeXN0ZW1cbiAqICBvZiBjb250cmFjdHMsIHN0YW5kYXJkcyBhbmQgbGlicmFyaWVzIHdoaWNoIGVuYWJsZSBsb29raW5nIHVwIGFuXG4gKiAgYWRkcmVzcyBmb3IgYW4gRU5TIG5hbWUuXG4gKlxuICogIFRoZXNlIGZ1bmN0aW9ucyBoZWxwIGNvbnZlcnQgYmV0d2VlbiB2YXJpb3VzIGZvcm1hdHMsIHZhbGlkYXRlXG4gKiAgYWRkcmVzc2VzIGFuZCBzYWZlbHkgcmVzb2x2ZSBFTlMgbmFtZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL2FkZHJlc3M6QWRkcmVzc2VzICBbYWJvdXQtYWRkcmVzc2VzXVxuICovXG5udWxsO1xuZXhwb3J0IHsgZ2V0QWRkcmVzcywgZ2V0SWNhcEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG5leHBvcnQgeyBnZXRDcmVhdGVBZGRyZXNzLCBnZXRDcmVhdGUyQWRkcmVzcyB9IGZyb20gXCIuL2NvbnRyYWN0LWFkZHJlc3MuanNcIjtcbmV4cG9ydCB7IGlzQWRkcmVzc2FibGUsIGlzQWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi9jaGVja3MuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/address/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/constants/addresses.js":
/*!********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/constants/addresses.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroAddress: function() { return /* binding */ ZeroAddress; }\n/* harmony export */ });\n/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */\nconst ZeroAddress = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvYWRkcmVzc2VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvYWRkcmVzc2VzLmpzP2UwOWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gYWRkcmVzcy5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzc2VzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/constants/addresses.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/constants/hashes.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/constants/hashes.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroHash: function() { return /* binding */ ZeroHash; }\n/* harmony export */ });\n/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */\nconst ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaGFzaGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaGFzaGVzLmpzPzVmZjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gaGFzaC5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0hhc2ggPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/constants/hashes.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/constants/index.js":
/*!****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/constants/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EtherSymbol: function() { return /* reexport safe */ _strings_js__WEBPACK_IMPORTED_MODULE_3__.EtherSymbol; },\n/* harmony export */   MaxInt256: function() { return /* reexport safe */ _numbers_js__WEBPACK_IMPORTED_MODULE_2__.MaxInt256; },\n/* harmony export */   MaxUint256: function() { return /* reexport safe */ _numbers_js__WEBPACK_IMPORTED_MODULE_2__.MaxUint256; },\n/* harmony export */   MessagePrefix: function() { return /* reexport safe */ _strings_js__WEBPACK_IMPORTED_MODULE_3__.MessagePrefix; },\n/* harmony export */   MinInt256: function() { return /* reexport safe */ _numbers_js__WEBPACK_IMPORTED_MODULE_2__.MinInt256; },\n/* harmony export */   N: function() { return /* reexport safe */ _numbers_js__WEBPACK_IMPORTED_MODULE_2__.N; },\n/* harmony export */   WeiPerEther: function() { return /* reexport safe */ _numbers_js__WEBPACK_IMPORTED_MODULE_2__.WeiPerEther; },\n/* harmony export */   ZeroAddress: function() { return /* reexport safe */ _addresses_js__WEBPACK_IMPORTED_MODULE_0__.ZeroAddress; },\n/* harmony export */   ZeroHash: function() { return /* reexport safe */ _hashes_js__WEBPACK_IMPORTED_MODULE_1__.ZeroHash; }\n/* harmony export */ });\n/* harmony import */ var _addresses_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addresses.js */ \"../common/node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _hashes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hashes.js */ \"../common/node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var _numbers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./numbers.js */ \"../common/node_modules/ethers/lib.esm/constants/numbers.js\");\n/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strings.js */ \"../common/node_modules/ethers/lib.esm/constants/strings.js\");\n/**\n *  Some common constants useful for Ethereum.\n *\n *  @_section: api/constants: Constants  [about-constants]\n */\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkM7QUFDTjtBQUN5QztBQUN0QjtBQUMxRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaW5kZXguanM/MDg0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIGNvbW1vbiBjb25zdGFudHMgdXNlZnVsIGZvciBFdGhlcmV1bS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvY29uc3RhbnRzOiBDb25zdGFudHMgIFthYm91dC1jb25zdGFudHNdXG4gKi9cbmV4cG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzc2VzLmpzXCI7XG5leHBvcnQgeyBaZXJvSGFzaCB9IGZyb20gXCIuL2hhc2hlcy5qc1wiO1xuZXhwb3J0IHsgTiwgV2VpUGVyRXRoZXIsIE1heFVpbnQyNTYsIE1pbkludDI1NiwgTWF4SW50MjU2IH0gZnJvbSBcIi4vbnVtYmVycy5qc1wiO1xuZXhwb3J0IHsgRXRoZXJTeW1ib2wsIE1lc3NhZ2VQcmVmaXggfSBmcm9tIFwiLi9zdHJpbmdzLmpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/constants/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/constants/numbers.js":
/*!******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/constants/numbers.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MaxInt256: function() { return /* binding */ MaxInt256; },\n/* harmony export */   MaxUint256: function() { return /* binding */ MaxUint256; },\n/* harmony export */   MinInt256: function() { return /* binding */ MinInt256; },\n/* harmony export */   N: function() { return /* binding */ N; },\n/* harmony export */   WeiPerEther: function() { return /* binding */ WeiPerEther; }\n/* harmony export */ });\n/**\n *  A constant for the order N for the secp256k1 curve.\n *\n *  (**i.e.** ``0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n``)\n */\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n/**\n *  A constant for the number of wei in a single ether.\n *\n *  (**i.e.** ``1000000000000000000n``)\n */\nconst WeiPerEther = BigInt(\"1000000000000000000\");\n/**\n *  A constant for the maximum value for a ``uint256``.\n *\n *  (**i.e.** ``0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)\n */\nconst MaxUint256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  A constant for the minimum value for an ``int256``.\n *\n *  (**i.e.** ``-8000000000000000000000000000000000000000000000000000000000000000n``)\n */\nconst MinInt256 = BigInt(\"0x8000000000000000000000000000000000000000000000000000000000000000\") * BigInt(-1);\n/**\n *  A constant for the maximum value for an ``int256``.\n *\n *  (**i.e.** ``0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)\n */\nconst MaxInt256 = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n//# sourceMappingURL=numbers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvbnVtYmVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9udW1iZXJzLmpzPzVmOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIG9yZGVyIE4gZm9yIHRoZSBzZWNwMjU2azEgY3VydmUuXG4gKlxuICogICgqKmkuZS4qKiBgYDB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MW5gYClcbiAqL1xuZXhwb3J0IGNvbnN0IE4gPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgbnVtYmVyIG9mIHdlaSBpbiBhIHNpbmdsZSBldGhlci5cbiAqXG4gKiAgKCoqaS5lLioqIGBgMTAwMDAwMDAwMDAwMDAwMDAwMG5gYClcbiAqL1xuZXhwb3J0IGNvbnN0IFdlaVBlckV0aGVyID0gQmlnSW50KFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKTtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBtYXhpbXVtIHZhbHVlIGZvciBhIGBgdWludDI1NmBgLlxuICpcbiAqICAoKippLmUuKiogYGAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZuYGApXG4gKi9cbmV4cG9ydCBjb25zdCBNYXhVaW50MjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIG1pbmltdW0gdmFsdWUgZm9yIGFuIGBgaW50MjU2YGAuXG4gKlxuICogICgqKmkuZS4qKiBgYC04MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwbmBgKVxuICovXG5leHBvcnQgY29uc3QgTWluSW50MjU2ID0gQmlnSW50KFwiMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpICogQmlnSW50KC0xKTtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBtYXhpbXVtIHZhbHVlIGZvciBhbiBgYGludDI1NmBgLlxuICpcbiAqICAoKippLmUuKiogYGAweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZuYGApXG4gKi9cbmV4cG9ydCBjb25zdCBNYXhJbnQyNTYgPSBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/constants/numbers.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/constants/strings.js":
/*!******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/constants/strings.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EtherSymbol: function() { return /* binding */ EtherSymbol; },\n/* harmony export */   MessagePrefix: function() { return /* binding */ MessagePrefix; }\n/* harmony export */ });\n// NFKC (composed)             // (decomposed)\n/**\n *  A constant for the ether symbol (normalized using NFKC).\n *\n *  (**i.e.** ``\"\\\\u039e\"``)\n */\nconst EtherSymbol = \"\\u039e\"; // \"\\uD835\\uDF63\";\n/**\n *  A constant for the [[link-eip-191]] personal message prefix.\n *\n *  (**i.e.** ``\"\\\\x19Ethereum Signed Message:\\\\n\"``)\n */\nconst MessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvc3RyaW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDhCQUE4QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvc3RyaW5ncy5qcz9mY2U1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5GS0MgKGNvbXBvc2VkKSAgICAgICAgICAgICAvLyAoZGVjb21wb3NlZClcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBldGhlciBzeW1ib2wgKG5vcm1hbGl6ZWQgdXNpbmcgTkZLQykuXG4gKlxuICogICgqKmkuZS4qKiBgYFwiXFxcXHUwMzllXCJgYClcbiAqL1xuZXhwb3J0IGNvbnN0IEV0aGVyU3ltYm9sID0gXCJcXHUwMzllXCI7IC8vIFwiXFx1RDgzNVxcdURGNjNcIjtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBbW2xpbmstZWlwLTE5MV1dIHBlcnNvbmFsIG1lc3NhZ2UgcHJlZml4LlxuICpcbiAqICAoKippLmUuKiogYGBcIlxcXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXFxcblwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBNZXNzYWdlUHJlZml4ID0gXCJcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/constants/strings.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/contract/contract.js":
/*!******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/contract/contract.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: function() { return /* binding */ BaseContract; },\n/* harmony export */   Contract: function() { return /* binding */ Contract; },\n/* harmony export */   copyOverrides: function() { return /* binding */ copyOverrides; },\n/* harmony export */   resolveArgs: function() { return /* binding */ resolveArgs; }\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abi/index.js */ \"../common/node_modules/ethers/lib.esm/abi/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../providers/provider.js */ \"../common/node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrappers.js */ \"../common/node_modules/ethers/lib.esm/contract/wrappers.js\");\n\n\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return (value && typeof (value.call) === \"function\");\n}\nfunction canEstimate(value) {\n    return (value && typeof (value.estimateGas) === \"function\");\n}\nfunction canResolve(value) {\n    return (value && typeof (value.resolveName) === \"function\");\n}\nfunction canSend(value) {\n    return (value && typeof (value.sendTransaction) === \"function\");\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nclass PreparedTopicFilter {\n    #filter;\n    fragment;\n    constructor(contract, fragment, args) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = (async function () {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v) => (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(v, resolver)));\n                        }\n                        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value[feature]) === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof (value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nasync function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(arg, \"overrides\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (_overrides) === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0,_providers_provider_js__WEBPACK_IMPORTED_MODULE_3__.copyRequest)(_overrides);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\n/**\n *  @_ignore:\n */\nasync function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function (overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = (await copyOverrides(overrides, [\"data\"]));\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)((tx.value || BN_0), \"overrides.value\") === BN_0);\n        const noData = ((tx.data || \"0x\") === \"0x\");\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function (overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        }\n        catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function (overrides) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides) => {\n        return await send(overrides);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function (...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function (...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function (...args) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function (...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        }\n        catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    };\n    const method = function (...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return (value && typeof (value) === \"object\" && (\"getTopicFilter\" in value) &&\n        (typeof (value.getTopicFilter) === \"function\") && value.fragment);\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function (name) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    }\n    else if (event === \"*\") {\n        topics = [null];\n    }\n    else if (typeof (event) === \"string\") {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [event];\n        }\n        else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [fragment.topicHash];\n        }\n    }\n    else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    }\n    else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [fragment.topicHash];\n    }\n    else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t) => {\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return { fragment, tag, topics };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", { operation });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = (addr ? addr : contract);\n        const filter = { address, topics };\n        const listener = (log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener) => {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            }\n            else {\n                emit(contract, event, [], (listener) => {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = () => {\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async () => {\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = { tag, listeners: [], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        }\n        catch (error) { }\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return (count > 0);\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    }\n    catch (error) { }\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\"then\"];\nclass BaseContract {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    target;\n    /**\n     *  The contract Interface.\n     */\n    interface;\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    runner;\n    /**\n     *  All the Events available on this contract.\n     */\n    filters;\n    /**\n     *  @_ignore:\n     */\n    [internal];\n    /**\n     *  The fallback or receive function if any.\n     */\n    fallback;\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */\n    constructor(target, abi, runner, _deployTx) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (target) === \"string\" || (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Interface.from(abi);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { target, runner, interface: iface });\n        Object.defineProperty(this, internal, { value: {} });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof (target) === \"string\") {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            }\n            else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) {\n                        throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        }\n        else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (typeof (prop) === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                }\n                catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { filters });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)) : null)\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                }\n                catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop) => {\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */\n    connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n    attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */\n    async getAddress() { return await getInternal(this).addrPromise; }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */\n    async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n    async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                }\n                catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n    deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getFunction(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getEvent(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */\n    async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n    async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr : (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            if (foundFragment) {\n                try {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.EventLog(log, this.interface, foundFragment);\n                }\n                catch (error) {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_4__.UndecodedEventLog(log, error);\n                }\n            }\n            return new _providers_provider_js__WEBPACK_IMPORTED_MODULE_3__.Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n    async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n    async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n    async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n    async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n    async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n    async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n    async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */\n    async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n    static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    ;\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nclass Contract extends _ContractBase() {\n}\n//# sourceMappingURL=contract.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC9jb250cmFjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBbUQ7QUFDaUI7QUFDcEU7QUFDQTtBQUM0RDtBQUNpRztBQUNqQjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsaUVBQWM7QUFDOUU7QUFDQSwrQkFBK0IsaUVBQWM7QUFDN0M7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSx1QkFBdUIsZ0RBQUs7QUFDNUIsSUFBSSwrREFBYztBQUNsQjtBQUNBLHNCQUFzQixtRUFBVztBQUNqQyxJQUFJLCtEQUFjO0FBQ2xCLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFLO0FBQ3pCO0FBQ0EsdUJBQXVCLGlFQUFjO0FBQ3JDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC9jb250cmFjdC5qcz8xNjQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEludGVyZmFjZSwgVHlwZWQgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpc0FkZHJlc3NhYmxlLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG4vLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXG5pbXBvcnQgeyBjb3B5UmVxdWVzdCwgTG9nIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBpc0NhbGxFeGNlcHRpb24sIGlzSGV4U3RyaW5nLCByZXNvbHZlUHJvcGVydGllcywgaXNFcnJvciwgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdEV2ZW50UGF5bG9hZCwgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkLCBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UsIEV2ZW50TG9nLCBVbmRlY29kZWRFdmVudExvZyB9IGZyb20gXCIuL3dyYXBwZXJzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuZnVuY3Rpb24gY2FuQ2FsbCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5jYWxsKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhbkVzdGltYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmVzdGltYXRlR2FzKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhblJlc29sdmUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucmVzb2x2ZU5hbWUpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuU2VuZCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5zZW5kVHJhbnNhY3Rpb24pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2FuUmVzb2x2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm92aWRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgUHJlcGFyZWRUb3BpY0ZpbHRlciB7XG4gICAgI2ZpbHRlcjtcbiAgICBmcmFnbWVudDtcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZyYWdtZW50IH0pO1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChmcmFnbWVudC5pbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoKHYpID0+IHJlc29sdmVBZGRyZXNzKHYsIHJlc29sdmVyKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKHZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGaWx0ZXJUb3BpY3MoZnJhZ21lbnQsIHJlc29sdmVkQXJncyk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGdldFRvcGljRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmlsdGVyO1xuICAgIH1cbn1cbi8vIEEgPSBBcmd1bWVudHMgcGFzc2VkIGluIGFzIGEgdHVwbGVcbi8vIFIgPSBUaGUgcmVzdWx0IHR5cGUgb2YgdGhlIGNhbGwgKGkuZS4gaWYgb25seSBvbmUgcmV0dXJuIHR5cGUsXG4vLyAgICAgdGhlIHF1YWxpZmllZCB0eXBlLCBvdGhlcndpc2UgUmVzdWx0KVxuLy8gRCA9IFRoZSB0eXBlIHRoZSBkZWZhdWx0IGNhbGwgd2lsbCByZXR1cm4gKGkuZS4gUiBmb3Igdmlldy9wdXJlLFxuLy8gICAgIFRyYW5zYWN0aW9uUmVzcG9uc2Ugb3RoZXJ3aXNlKVxuLy9leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0TWV0aG9kPEEgZXh0ZW5kcyBBcnJheTxhbnk+ID0gQXJyYXk8YW55PiwgUiA9IGFueSwgRCBleHRlbmRzIFIgfCBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2U+IHtcbmZ1bmN0aW9uIGdldFJ1bm5lcih2YWx1ZSwgZmVhdHVyZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZVtmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5wcm92aWRlciAmJiB0eXBlb2YgKHZhbHVlLnByb3ZpZGVyW2ZlYXR1cmVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm92aWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRQcm92aWRlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucHJvdmlkZXIgfHwgbnVsbDtcbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29weU92ZXJyaWRlcyhhcmcsIGFsbG93ZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG92ZXJyaWRlcyBwYXNzZWQgaW4gYXJlIGEgdmFsaWQgb3ZlcnJpZGVzIG9iamVjdFxuICAgIGNvbnN0IF9vdmVycmlkZXMgPSBUeXBlZC5kZXJlZmVyZW5jZShhcmcsIFwib3ZlcnJpZGVzXCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoX292ZXJyaWRlcykgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBvdmVycmlkZXMgcGFyYW1ldGVyXCIsIFwib3ZlcnJpZGVzXCIsIGFyZyk7XG4gICAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjb3B5ICh3ZSdsbCBkZWVwLWlmeSBhbnl0aGluZyBuZWVkZWQgZHVyaW5nIG5vcm1hbGl6aW5nKVxuICAgIGNvbnN0IG92ZXJyaWRlcyA9IGNvcHlSZXF1ZXN0KF9vdmVycmlkZXMpO1xuICAgIGFzc2VydEFyZ3VtZW50KG92ZXJyaWRlcy50byA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwidG9cIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgdG9cIiwgXCJvdmVycmlkZXMudG9cIiwgb3ZlcnJpZGVzLnRvKTtcbiAgICBhc3NlcnRBcmd1bWVudChvdmVycmlkZXMuZGF0YSA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwiZGF0YVwiKSA+PSAwLCBcImNhbm5vdCBvdmVycmlkZSBkYXRhXCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgb3ZlcnJpZGVzLmRhdGEpO1xuICAgIC8vIFJlc29sdmUgYW55IGZyb21cbiAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBvdmVycmlkZXMuZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJyaWRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUFyZ3MoX3J1bm5lciwgaW5wdXRzLCBhcmdzKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihfcnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3ModmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRmFsbGJhY2soY29udHJhY3QpIHtcbiAgICBjb25zdCBwb3B1bGF0ZVRyYW5zYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgdHggPSAoYXdhaXQgY29weU92ZXJyaWRlcyhvdmVycmlkZXMsIFtcImRhdGFcIl0pKTtcbiAgICAgICAgdHgudG8gPSBhd2FpdCBjb250cmFjdC5nZXRBZGRyZXNzKCk7XG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHguZnJvbSwgZ2V0UmVzb2x2ZXIoY29udHJhY3QucnVubmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWZhY2UgPSBjb250cmFjdC5pbnRlcmZhY2U7XG4gICAgICAgIGNvbnN0IG5vVmFsdWUgPSAoZ2V0QmlnSW50KCh0eC52YWx1ZSB8fCBCTl8wKSwgXCJvdmVycmlkZXMudmFsdWVcIikgPT09IEJOXzApO1xuICAgICAgICBjb25zdCBub0RhdGEgPSAoKHR4LmRhdGEgfHwgXCIweFwiKSA9PT0gXCIweFwiKTtcbiAgICAgICAgaWYgKGlmYWNlLmZhbGxiYWNrICYmICFpZmFjZS5mYWxsYmFjay5wYXlhYmxlICYmIGlmYWNlLnJlY2VpdmUgJiYgIW5vRGF0YSAmJiAhbm9WYWx1ZSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlIG9yIHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXNcIiwgb3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChpZmFjZS5mYWxsYmFjayB8fCBub0RhdGEsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlLW9ubHkgY29udHJhY3RcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCB0eC5kYXRhKTtcbiAgICAgICAgLy8gT25seSBhbGxvdyBwYXlhYmxlIGNvbnRyYWN0cyB0byBzZXQgbm9uLXplcm8gdmFsdWVcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IGlmYWNlLnJlY2VpdmUgfHwgKGlmYWNlLmZhbGxiYWNrICYmIGlmYWNlLmZhbGxiYWNrLnBheWFibGUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXlhYmxlIHx8IG5vVmFsdWUsIFwiY2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXMudmFsdWVcIiwgdHgudmFsdWUpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IGZhbGxiYWNrIGNvbnRyYWN0cyB0byBzZXQgbm9uLWVtcHR5IGRhdGFcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkNhbGwocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImNhbGxcIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmNhbGwodHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICBhc3NlcnQoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAob3ZlcnJpZGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kKG92ZXJyaWRlcyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbFxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRNZXRob2QoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5LCBhcmdzKTtcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IGF3YWl0IGNvcHlPdmVycmlkZXMoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKG92ZXJyaWRlcy5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsIGVycm9yOiBmcmFnbWVudCBpbnB1dHMgZG9lc24ndCBtYXRjaCBhcmd1bWVudHM7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IHJlc29sdmVBcmdzKGNvbnRyYWN0LnJ1bm5lciwgZnJhZ21lbnQuaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcywgYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdG86IGNvbnRyYWN0LmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgIGRhdGE6IGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHJlc29sdmVkQXJncylcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0YXRpY0NhbGxSZXN1bHQoLi4uYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBzZW5kID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gY29udHJhY3QucnVubmVyO1xuICAgICAgICBhc3NlcnQoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJ1bm5lci5zZW5kVHJhbnNhY3Rpb24oYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGxSZXN1bHQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgIGFzc2VydChjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250cmFjdC5pbnRlcmZhY2UubWFrZUVycm9yKGVycm9yLmRhdGEsIHR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZnJhZ21lbnQuY29uc3RhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBzdGF0aWNDYWxsKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kKC4uLmFyZ3MpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uTmFtZShrZXkpLFxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXG4gICAgICAgIGdldEZyYWdtZW50LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbCwgc3RhdGljQ2FsbFJlc3VsdCxcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXkpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRFdmVudChjb250cmFjdCwga2V5KSB7XG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChrZXksIGFyZ3MpO1xuICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICBpbmZvOiB7IGtleSwgYXJncyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByZXBhcmVkVG9waWNGaWx0ZXIoY29udHJhY3QsIGdldEZyYWdtZW50KC4uLmFyZ3MpLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudE5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudFxuICAgIH0pO1xuICAgIC8vIE9ubHkgd29ya3Mgb24gbm9uLWFtYmlndW91cyBrZXlzIChyZWZpbmVkIGZyYWdtZW50IGlzIGFsd2F5cyBub24tYW1iaWd1b3VzKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSk7XG4gICAgICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsga2V5IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbi8vIFRoZSBjb21iaW5hdGlvbiBvZiBUeXBlU2NyeXBlLCBQcml2YXRlIEZpZWxkcyBhbmQgUHJveGllcyBtYWtlc1xuLy8gdGhlIHdvcmxkIGdvIGJvb207IHNvIHdlIGhpZGUgdmFyaWFibGVzIHdpdGggc29tZSB0cmlja2VyeSBrZWVwaW5nXG4vLyBhIHN5bWJvbCBhdHRhY2hlZCB0byBlYWNoIEJhc2VDb250cmFjdCB3aGljaCBpdHMgc3ViLWNsYXNzIChldmVuXG4vLyB2aWEgYSBQcm94eSkgY2FuIHJlYWNoIGFuZCB1c2UgdG8gbG9vayB1cCBpdHMgaW50ZXJuYWwgdmFsdWVzLlxuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc0ludGVybmFsX2NvbnRyYWN0XCIpO1xuY29uc3QgaW50ZXJuYWxWYWx1ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0SW50ZXJuYWwoY29udHJhY3QsIHZhbHVlcykge1xuICAgIGludGVybmFsVmFsdWVzLnNldChjb250cmFjdFtpbnRlcm5hbF0sIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbChjb250cmFjdCkge1xuICAgIHJldHVybiBpbnRlcm5hbFZhbHVlcy5nZXQoY29udHJhY3RbaW50ZXJuYWxdKTtcbn1cbmZ1bmN0aW9uIGlzRGVmZXJyZWQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIChcImdldFRvcGljRmlsdGVyXCIgaW4gdmFsdWUpICYmXG4gICAgICAgICh0eXBlb2YgKHZhbHVlLmdldFRvcGljRmlsdGVyKSA9PT0gXCJmdW5jdGlvblwiKSAmJiB2YWx1ZS5mcmFnbWVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGxldCB0b3BpY3M7XG4gICAgbGV0IGZyYWdtZW50ID0gbnVsbDtcbiAgICAvLyBDb252ZXJ0IG5hbWVkIGV2ZW50cyB0byB0b3BpY0hhc2ggYW5kIGdldCB0aGUgZnJhZ21lbnQgZm9yXG4gICAgLy8gZXZlbnRzIHdoaWNoIG5lZWQgZGVjb25zdHJ1Y3RpbmcuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IHRvcGljSGFzaGlmeSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZSwgMzIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChuYW1lKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXJyYXkgb2YgVG9waWNzIGFuZCBOYW1lczsgZS5nLiBgWyBcIjB4MTIzNC4uLjg5YWJcIiwgXCJUcmFuc2ZlcihhZGRyZXNzKVwiIF1gXG4gICAgICAgIHRvcGljcyA9IGV2ZW50Lm1hcCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5tYXAodG9waWNIYXNoaWZ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3BpY0hhc2hpZnkoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgdG9waWNzID0gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGV2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZXZlbnQsIDMyKSkge1xuICAgICAgICAgICAgLy8gVG9waWMgSGFzaFxuICAgICAgICAgICAgdG9waWNzID0gW2V2ZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5hbWUgb3IgU2lnbmF0dXJlOyBlLmcuIGBcIlRyYW5zZmVyXCIsIGBcIlRyYW5zZmVyKGFkZHJlc3MpXCJgXG4gICAgICAgICAgICBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChldmVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWZlcnJlZChldmVudCkpIHtcbiAgICAgICAgLy8gRGVmZXJyZWQgVG9waWMgRmlsdGVyOyBlLmcuIGBjb250cmFjdC5maWx0ZXIuVHJhbnNmZXIoZnJvbSlgXG4gICAgICAgIHRvcGljcyA9IGF3YWl0IGV2ZW50LmdldFRvcGljRmlsdGVyKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwiZnJhZ21lbnRcIiBpbiBldmVudCkge1xuICAgICAgICAvLyBDb250cmFjdEV2ZW50OyBlLmcuIGBjb250cmFjdC5maWx0ZXIuVHJhbnNmZXJgXG4gICAgICAgIGZyYWdtZW50ID0gZXZlbnQuZnJhZ21lbnQ7XG4gICAgICAgIHRvcGljcyA9IFtmcmFnbWVudC50b3BpY0hhc2hdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBldmVudCBuYW1lXCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdG9waWNzIGFuZCBzb3J0IFRvcGljU2V0c1xuICAgIHRvcGljcyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShuZXcgU2V0KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKS52YWx1ZXMoKSk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgY29uc3QgdGFnID0gdG9waWNzLm1hcCgodCkgPT4ge1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pLmpvaW4oXCImXCIpO1xuICAgIHJldHVybiB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaGFzU3ViKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwoY29udHJhY3QpO1xuICAgIHJldHVybiBzdWJzLmdldCgoYXdhaXQgZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpKS50YWcpIHx8IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWIoY29udHJhY3QsIG9wZXJhdGlvbiwgZXZlbnQpIHtcbiAgICAvLyBNYWtlIHN1cmUgb3VyIHJ1bm5lciBjYW4gYWN0dWFsbHkgc3Vic2NyaWJlIHRvIGV2ZW50c1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc3Vic2NyaWJpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgdGFnLCB0b3BpY3MgfSA9IGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KTtcbiAgICBjb25zdCB7IGFkZHIsIHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcbiAgICBsZXQgc3ViID0gc3Vicy5nZXQodGFnKTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogY29udHJhY3QpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcyB9O1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGZyYWdtZW50IGlzIG51bGwsIHdlIGRvIG5vdCBkZWNvbnN0cnVjdCB0aGUgYXJncyB0byBlbWl0XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mb3VuZEZyYWdtZW50ID0gZm91bmRGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gZnJhZ21lbnQgPyBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSA6IFtdO1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdEV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBfZm91bmRGcmFnbWVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBbXSwgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkKGNvbnRyYWN0LCBsaXN0ZW5lciwgZXZlbnQsIGxvZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdGFydGluZyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydGluZy5wdXNoKHByb3ZpZGVyLm9uKGZpbHRlciwgbGlzdGVuZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydGluZy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydGVkID0gc3RhcnRpbmc7XG4gICAgICAgICAgICBzdGFydGluZyA9IFtdO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc3RhcnRlZCk7XG4gICAgICAgICAgICBwcm92aWRlci5vZmYoZmlsdGVyLCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICAgIHN1YiA9IHsgdGFnLCBsaXN0ZW5lcnM6IFtdLCBzdGFydCwgc3RvcCB9O1xuICAgICAgICBzdWJzLnNldCh0YWcsIHN1Yik7XG4gICAgfVxuICAgIHJldHVybiBzdWI7XG59XG4vLyBXZSB1c2UgdGhpcyB0byBlbnN1cmUgb25lIGVtaXQgcmVzb2x2ZXMgYmVmb3JlIGZpcmluZyB0aGUgbmV4dCB0b1xuLy8gZW5zdXJlIGNvcnJlY3Qgb3JkZXJpbmcgKG5vdGUgdGhpcyBjYW5ub3QgdGhyb3cgYW5kIGp1c3QgYWRkcyB0aGVcbi8vIG5vdGljZSB0byB0aGUgZXZlbnQgcXVldSB1c2luZyBzZXRUaW1lb3V0KS5cbmxldCBsYXN0RW1pdCA9IFByb21pc2UucmVzb2x2ZSgpO1xuYXN5bmMgZnVuY3Rpb24gX2VtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xuICAgIGF3YWl0IGxhc3RFbWl0O1xuICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yihjb250cmFjdCwgZXZlbnQpO1xuICAgIGlmICghc3ViKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICBzdWIubGlzdGVuZXJzID0gc3ViLmxpc3RlbmVycy5maWx0ZXIoKHsgbGlzdGVuZXIsIG9uY2UgfSkgPT4ge1xuICAgICAgICBjb25zdCBwYXNzQXJncyA9IEFycmF5LmZyb20oYXJncyk7XG4gICAgICAgIGlmIChwYXlsb2FkRnVuYykge1xuICAgICAgICAgICAgcGFzc0FyZ3MucHVzaChwYXlsb2FkRnVuYyhvbmNlID8gbnVsbCA6IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoY29udHJhY3QsIC4uLnBhc3NBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gIW9uY2U7XG4gICAgfSk7XG4gICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgIGdldEludGVybmFsKGNvbnRyYWN0KS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIChjb3VudCA+IDApO1xufVxuYXN5bmMgZnVuY3Rpb24gZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbGFzdEVtaXQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpO1xuICAgIGxhc3RFbWl0ID0gcmVzdWx0UHJvbWlzZTtcbiAgICByZXR1cm4gYXdhaXQgcmVzdWx0UHJvbWlzZTtcbn1cbmNvbnN0IHBhc3NQcm9wZXJ0aWVzID0gW1widGhlblwiXTtcbmV4cG9ydCBjbGFzcyBCYXNlQ29udHJhY3Qge1xuICAgIC8qKlxuICAgICAqICBUaGUgdGFyZ2V0IHRvIGNvbm5lY3QgdG8uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gYmUgYW4gYWRkcmVzcywgRU5TIG5hbWUgb3IgYW55IFtbQWRkcmVzc2FibGVdXSwgc3VjaCBhc1xuICAgICAqICBhbm90aGVyIGNvbnRyYWN0LiBUbyBnZXQgdGhlIHJlc292bGVkIGFkZHJlc3MsIHVzZSB0aGUgYGBnZXRBZGRyZXNzYGBcbiAgICAgKiAgbWV0aG9kLlxuICAgICAqL1xuICAgIHRhcmdldDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcnVubmVyLiBUaGlzIGlzIGdlbmVyYWxseSBhIFtbUHJvdmlkZXJdXSBvciBhXG4gICAgICogIFtbU2lnbmVyXV0sIHdoaWNoIGRpY3RhdGVzIHdoYXQgb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBhICoqQ29udHJhY3QqKiBjb25uZWN0ZWQgdG8gYSBbW1Byb3ZpZGVyXV0gbWF5XG4gICAgICogIG9ubHkgZXhlY3V0ZSByZWFkLW9ubHkgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBydW5uZXI7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgRXZlbnRzIGF2YWlsYWJsZSBvbiB0aGlzIGNvbnRyYWN0LlxuICAgICAqL1xuICAgIGZpbHRlcnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIFtpbnRlcm5hbF07XG4gICAgLyoqXG4gICAgICogIFRoZSBmYWxsYmFjayBvciByZWNlaXZlIGZ1bmN0aW9uIGlmIGFueS5cbiAgICAgKi9cbiAgICBmYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBjb250cmFjdCBjb25uZWN0ZWQgdG8gJSV0YXJnZXQlJSB3aXRoIHRoZSAlJWFiaSUlIGFuZFxuICAgICAqICBvcHRpb25hbGx5IGNvbm5lY3RlZCB0byBhICUlcnVubmVyJSUgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGJlaGFsZlxuICAgICAqICBvZi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGFiaSwgcnVubmVyLCBfZGVwbG95VHgpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiIHx8IGlzQWRkcmVzc2FibGUodGFyZ2V0KSwgXCJpbnZhbGlkIHZhbHVlIGZvciBDb250cmFjdCB0YXJnZXRcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gSW50ZXJmYWNlLmZyb20oYWJpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHRhcmdldCwgcnVubmVyLCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IHt9IH0pO1xuICAgICAgICBsZXQgYWRkclByb21pc2U7XG4gICAgICAgIGxldCBhZGRyID0gbnVsbDtcbiAgICAgICAgbGV0IGRlcGxveVR4ID0gbnVsbDtcbiAgICAgICAgaWYgKF9kZXBsb3lUeCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihydW5uZXIpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICAgICAgZGVwbG95VHggPSBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgX2RlcGxveVR4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGFyZ2V0IGFzIHRoZSBhZGRyZXNzXG4gICAgICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgYWRkciA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBnZXRSdW5uZXIocnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuUmVzb2x2ZShyZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgbmFtZSByZXNvbHV0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHJlc29sdmVyLnJlc29sdmVOYW1lKHRhcmdldCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3IoXCJhbiBFTlMgbmFtZSB1c2VkIGZvciBhIGNvbnRyYWN0IHRhcmdldCBtdXN0IGJlIGNvcnJlY3RseSBjb25maWd1cmVkXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLmFkZHIgPSBhZGRyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZHJQcm9taXNlID0gdGFyZ2V0LmdldEFkZHJlc3MoKS50aGVuKChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvdXIgcHJpdmF0ZSB2YWx1ZXNcbiAgICAgICAgc2V0SW50ZXJuYWwodGhpcywgeyBhZGRyUHJvbWlzZSwgYWRkciwgZGVwbG95VHgsIHN1YnMgfSk7XG4gICAgICAgIC8vIEFkZCB0aGUgZXZlbnQgZmlsdGVyc1xuICAgICAgICBjb25zdCBmaWx0ZXJzID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV2ZW50KHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApIHx8IHRoaXMuaW50ZXJmYWNlLmhhc0V2ZW50KFN0cmluZyhwcm9wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmlsdGVycyB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmYWxsYmFjazogKChpZmFjZS5yZWNlaXZlIHx8IGlmYWNlLmZhbGxiYWNrKSA/IChidWlsZFdyYXBwZWRGYWxsYmFjayh0aGlzKSkgOiBudWxsKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV0dXJuIGEgUHJveHkgdGhhdCB3aWxsIHJlc3BvbmQgdG8gZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gdGFyZ2V0IHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVuZGVmaW5lZCBwcm9wZXJ0aWVzIHNob3VsZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRGdW5jdGlvbihwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gdGFyZ2V0IHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5pbnRlcmZhY2UuaGFzRnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgdGFyZ2V0IGFuZCBBQkksIGJ1dFxuICAgICAqICBhIGRpZmZlcmVudCAlJXJ1bm5lciUlLlxuICAgICAqL1xuICAgIGNvbm5lY3QocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRoaXMudGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgcnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIEFCSSBhbmQgcnVubmVyLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSV0YXJnZXQlJS5cbiAgICAgKi9cbiAgICBhdHRhY2godGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHRoaXMucnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcmVzb2x2ZWQgYWRkcmVzcyBvZiB0aGlzIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiBhd2FpdCBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyUHJvbWlzZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRlcGxveWVkIGJ5dGVjb2RlIG9yIG51bGwgaWYgbm8gYnl0ZWNvZGUgaXMgZm91bmQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95ZWRDb2RlKCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcInJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IC5wcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJnZXREZXBsb3llZENvZGVcIiB9KTtcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHByb3ZpZGVyLmdldENvZGUoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhpcyBDb250cmFjdCBvbmNlIHRoZSBieXRlY29kZSBoYXMgYmVlbiBkZXBsb3llZCwgb3JcbiAgICAgKiAgcmVzb2x2ZSBpbW1lZGlhdGVseSBpZiBhbHJlYWR5IGRlcGxveWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JEZXBsb3ltZW50KCkge1xuICAgICAgICAvLyBXZSBoYXZlIHRoZSBkZXBsb3llbWVudCB0cmFuc2FjdGlvbjsganVzdCB1c2UgdGhhdCAodGhyb3dzIGlmIGRlcGxveWVtZW50IGZhaWxzKVxuICAgICAgICBjb25zdCBkZXBsb3lUeCA9IHRoaXMuZGVwbG95bWVudFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmIChkZXBsb3lUeCkge1xuICAgICAgICAgICAgYXdhaXQgZGVwbG95VHgud2FpdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNvZGVcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjYW4gc3Vic2NyaWJlIHRvIGEgcHJvdmlkZXIgZXZlbnRcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciAhPSBudWxsLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IC5wcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJ3YWl0Rm9yRGVwbG95bWVudFwiIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tDb2RlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgY2hlY2tDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoZWNrQ29kZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgdHJhbnNhY3Rpb24gdXNlZCB0byBkZXBsb3kgdGhpcyBjb250cmFjdC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGlmIHRoaXMgaW5zdGFuY2Ugd2FzIHJldHVybmVkIGZyb20gYVxuICAgICAqICBbW0NvbnRyYWN0RmFjdG9yeV1dLlxuICAgICAqL1xuICAgIGRlcGxveW1lbnRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsKHRoaXMpLmRlcGxveVR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBuYW1lLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgY29udHJhY3RcbiAgICAgKiAgbWV0aG9kIG5hbWUgY29uZmxpY3RzIHdpdGggYSBKYXZhU2NyaXB0IG5hbWUgc3VjaCBhcyBgYHByb3RvdHlwZWBgIG9yXG4gICAgICogIHdoZW4gdXNpbmcgYSBDb250cmFjdCBwcm9ncmFtYXRpY2FsbHkuXG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jID0gYnVpbGRXcmFwcGVkTWV0aG9kKHRoaXMsIGtleSk7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBldmVudCBmb3IgYSBnaXZlbiBuYW1lLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgY29udHJhY3RcbiAgICAgKiAgZXZlbnQgbmFtZSBjb25mbGljdHMgd2l0aCBhIEphdmFTY3JpcHQgbmFtZSBzdWNoIGFzIGBgcHJvdG90eXBlYGAgb3JcbiAgICAgKiAgd2hlbiB1c2luZyBhIENvbnRyYWN0IHByb2dyYW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBnZXRFdmVudChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZFdyYXBwZWRFdmVudCh0aGlzLCBrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlUcmFuc2FjdGlvbihoYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKlxuICAgIC8vIEBUT0RPOiB0aGlzIGlzIGEgbm9uLWJhY2t3YXJkcyBjb21wYXRpYmxlIGNoYW5nZSwgYnV0IHdpbGwgYmUgYWRkZWRcbiAgICAvLyAgICAgICAgaW4gdjcgYW5kIGluIGEgcG90ZW50aWFsIFNtYXJ0Q29udHJhY3QgY2xhc3MgaW4gYW4gdXBjb21pbmdcbiAgICAvLyAgICAgICAgdjYgcmVsZWFzZVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoOiBzdHJpbmcpOiBQcm9taXNlPG51bGwgfCBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdD4ge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIixcbiAgICAgICAgICAgIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInF1ZXJ5VHJhbnNhY3Rpb25cIiB9KTtcblxuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbiAgICAqL1xuICAgIC8qKlxuICAgICAqICBQcm92aWRlIGhpc3RvcmljIGFjY2VzcyB0byBldmVudCBkYXRhIGZvciAlJWV2ZW50JSUgaW4gdGhlIHJhbmdlXG4gICAgICogICUlZnJvbUJsb2NrJSUgKGRlZmF1bHQ6IGBgMGBgKSB0byAlJXRvQmxvY2slJSAoZGVmYXVsdDogYGBcImxhdGVzdFwiYGApXG4gICAgICogIGluY2x1c2l2ZS5cbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeUZpbHRlcihldmVudCwgZnJvbUJsb2NrLCB0b0Jsb2NrKSB7XG4gICAgICAgIGlmIChmcm9tQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgZnJvbUJsb2NrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9CbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0b0Jsb2NrID0gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFkZHIsIGFkZHJQcm9taXNlIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IChhd2FpdCBhZGRyUHJvbWlzZSkpO1xuICAgICAgICBjb25zdCB7IGZyYWdtZW50LCB0b3BpY3MgfSA9IGF3YWl0IGdldFN1YkluZm8odGhpcywgZXZlbnQpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcywgZnJvbUJsb2NrLCB0b0Jsb2NrIH07XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeUZpbHRlclwiIH0pO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKSkubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50TG9nKGxvZywgdGhpcy5pbnRlcmZhY2UsIGZvdW5kRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmRlY29kZWRFdmVudExvZyhsb2csIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLlxuICAgICAqL1xuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvblwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJSwgYnV0IHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgKiAgYWZ0ZXIgaXQgaXMgZmlyZWQgb25jZS5cbiAgICAgKi9cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvbmNlXCIsIGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVtaXQgYW4gJSVldmVudCUlIGNhbGxpbmcgYWxsIGxpc3RlbmVycyB3aXRoICUlYXJncyUlLlxuICAgICAqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIGFueSBsaXN0ZW5lcnMgd2VyZSBjYWxsZWQuXG4gICAgICovXG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW1pdCh0aGlzLCBldmVudCwgYXJncywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvZiAlJWV2ZW50JSUgb3IgdGhlIHRvdGFsIG51bWJlclxuICAgICAqICBvZiBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byAlJWV2ZW50JSUgb3IgYWxsIGxpc3RlbmVyc1xuICAgICAqICBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgdGhlICUlbGlzdGVuZXIlJSBmcm9tIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmVcbiAgICAgKiAgYWxsIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGlmXG4gICAgICogIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YWcsIHN0b3AgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHN1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29uXS5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsaWFzIGZvciBbb2ZmXS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQ2xhc3MgZm9yIHRoZSAlJWFiaSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZENsYXNzKGFiaSkge1xuICAgICAgICBjbGFzcyBDdXN0b21Db250cmFjdCBleHRlbmRzIEJhc2VDb250cmFjdCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBydW5uZXIgPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoYWRkcmVzcywgYWJpLCBydW5uZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDdXN0b21Db250cmFjdDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQmFzZUNvbnRyYWN0IHdpdGggYSBzcGVjaWZpZWQgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHRhcmdldCwgYWJpLCBydW5uZXIpIHtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IHRoaXModGFyZ2V0LCBhYmksIHJ1bm5lcik7XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfQ29udHJhY3RCYXNlKCkge1xuICAgIHJldHVybiBCYXNlQ29udHJhY3Q7XG59XG4vKipcbiAqICBBIFtbQmFzZUNvbnRyYWN0XV0gd2l0aCBubyB0eXBlIGd1YXJkcyBvbiBpdHMgbWV0aG9kcyBvciBldmVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdCBleHRlbmRzIF9Db250cmFjdEJhc2UoKSB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cmFjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/contract/contract.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/contract/factory.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/contract/factory.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractFactory: function() { return /* binding */ ContractFactory; }\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abi/index.js */ \"../common/node_modules/ethers/lib.esm/abi/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _contract_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contract.js */ \"../common/node_modules/ethers/lib.esm/contract/contract.js\");\n\n\n\n\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\n/**\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\n */\nclass ContractFactory {\n    /**\n     *  The Contract Interface.\n     */\n    interface;\n    /**\n     *  The Contract deployment bytecode. Often called the initcode.\n     */\n    bytecode;\n    /**\n     *  The ContractRunner to deploy the Contract as.\n     */\n    runner;\n    /**\n     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\n     *  optionally connected to %%runner%%.\n     *\n     *  The %%bytecode%% may be the ``bytecode`` property within the\n     *  standard Solidity JSON output.\n     */\n    constructor(abi, bytecode, runner) {\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_0__.Interface.from(abi);\n        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n        if (bytecode instanceof Uint8Array) {\n            bytecode = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(bytecode));\n        }\n        else {\n            if (typeof (bytecode) === \"object\") {\n                bytecode = bytecode.object;\n            }\n            if (!bytecode.startsWith(\"0x\")) {\n                bytecode = \"0x\" + bytecode;\n            }\n            bytecode = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(bytecode));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            bytecode, interface: iface, runner: (runner || null)\n        });\n    }\n    attach(target) {\n        return new _contract_js__WEBPACK_IMPORTED_MODULE_2__.BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Resolves to the transaction to deploy the contract, passing %%args%%\n     *  into the constructor.\n     */\n    async getDeployTransaction(...args) {\n        let overrides = {};\n        const fragment = this.interface.deploy;\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await (0,_contract_js__WEBPACK_IMPORTED_MODULE_2__.copyOverrides)(args.pop());\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"incorrect number of arguments to constructor\");\n        }\n        const resolvedArgs = await (0,_contract_js__WEBPACK_IMPORTED_MODULE_2__.resolveArgs)(this.runner, fragment.inputs, args);\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);\n        return Object.assign({}, overrides, { data });\n    }\n    /**\n     *  Resolves to the Contract deployed by passing %%args%% into the\n     *  constructor.\n     *\n     *  This will resolve to the Contract before it has been deployed to the\n     *  network, so the [[BaseContract-waitForDeployment]] should be used before\n     *  sending any transactions to it.\n     */\n    async deploy(...args) {\n        const tx = await this.getDeployTransaction(...args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.runner && typeof (this.runner.sendTransaction) === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const sentTx = await this.runner.sendTransaction(tx);\n        const address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getCreateAddress)(sentTx);\n        return new _contract_js__WEBPACK_IMPORTED_MODULE_2__.BaseContract(address, this.interface, this.runner, sentTx);\n    }\n    /**\n     *  Return a new **ContractFactory** with the same ABI and bytecode,\n     *  but connected to %%runner%%.\n     */\n    connect(runner) {\n        return new ContractFactory(this.interface, this.bytecode, runner);\n    }\n    /**\n     *  Create a new **ContractFactory** from the standard Solidity JSON output.\n     */\n    static fromSolidity(output, runner) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(output != null, \"bad compiler output\", \"output\", output);\n        if (typeof (output) === \"string\") {\n            output = JSON.parse(output);\n        }\n        const abi = output.abi;\n        let bytecode = \"\";\n        if (output.bytecode) {\n            bytecode = output.bytecode;\n        }\n        else if (output.evm && output.evm.bytecode) {\n            bytecode = output.evm.bytecode;\n        }\n        return new this(abi, bytecode, runner);\n    }\n}\n//# sourceMappingURL=factory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC9mYWN0b3J5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQ1c7QUFDaUQ7QUFDL0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBUztBQUMvQjtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFPLENBQUMseURBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBTyxDQUFDLHlEQUFRO0FBQ3ZDO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQixzREFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQVc7QUFDOUMscUJBQXFCLHVEQUFNO0FBQzNCLCtCQUErQixlQUFlLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixtRUFBZ0I7QUFDeEMsbUJBQW1CLHNEQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L2ZhY3RvcnkuanM/Y2E1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlcmZhY2UgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRDcmVhdGVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGVmaW5lUHJvcGVydGllcywgZ2V0Qnl0ZXMsIGhleGxpZnksIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEJhc2VDb250cmFjdCwgY29weU92ZXJyaWRlcywgcmVzb2x2ZUFyZ3MgfSBmcm9tIFwiLi9jb250cmFjdC5qc1wiO1xuLy8gQSA9IEFyZ3VtZW50cyB0byB0aGUgY29uc3RydWN0b3Jcbi8vIEkgPSBJbnRlcmZhY2Ugb2YgZGVwbG95ZWQgY29udHJhY3RzXG4vKipcbiAqICBBICoqQ29udHJhY3RGYWN0b3J5KiogaXMgdXNlZCB0byBkZXBsb3kgYSBDb250cmFjdCB0byB0aGUgYmxvY2tjaGFpbi5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0RmFjdG9yeSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgZGVwbG95bWVudCBieXRlY29kZS4gT2Z0ZW4gY2FsbGVkIHRoZSBpbml0Y29kZS5cbiAgICAgKi9cbiAgICBieXRlY29kZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0UnVubmVyIHRvIGRlcGxveSB0aGUgQ29udHJhY3QgYXMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipDb250cmFjdEZhY3RvcnkqKiB3aXRoICUlYWJpJSUgYW5kICUlYnl0ZWNvZGUlJSxcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gJSVydW5uZXIlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVieXRlY29kZSUlIG1heSBiZSB0aGUgYGBieXRlY29kZWBgIHByb3BlcnR5IHdpdGhpbiB0aGVcbiAgICAgKiAgc3RhbmRhcmQgU29saWRpdHkgSlNPTiBvdXRwdXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWJpLCBieXRlY29kZSwgcnVubmVyKSB7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gSW50ZXJmYWNlLmZyb20oYWJpKTtcbiAgICAgICAgLy8gRGVyZWZlcmVuY2UgU29saWRpdHkgYnl0ZWNvZGUgb2JqZWN0cyBhbmQgYWxsb3cgYSBtaXNzaW5nIGAweGAtcHJlZml4XG4gICAgICAgIGlmIChieXRlY29kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gaGV4bGlmeShnZXRCeXRlcyhieXRlY29kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoYnl0ZWNvZGUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgYnl0ZWNvZGUgPSBieXRlY29kZS5vYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJ5dGVjb2RlLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgICAgIGJ5dGVjb2RlID0gXCIweFwiICsgYnl0ZWNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieXRlY29kZSA9IGhleGxpZnkoZ2V0Qnl0ZXMoYnl0ZWNvZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlLCBpbnRlcmZhY2U6IGlmYWNlLCBydW5uZXI6IChydW5uZXIgfHwgbnVsbClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF0dGFjaCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgdGhpcy5ydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRvIGRlcGxveSB0aGUgY29udHJhY3QsIHBhc3NpbmcgJSVhcmdzJSVcbiAgICAgKiAgaW50byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95VHJhbnNhY3Rpb24oLi4uYXJncykge1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZGVwbG95O1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdmVycmlkZXMgPSBhd2FpdCBjb3B5T3ZlcnJpZGVzKGFyZ3MucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gY29uc3RydWN0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgcmVzb2x2ZUFyZ3ModGhpcy5ydW5uZXIsIGZyYWdtZW50LmlucHV0cywgYXJncyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjb25jYXQoW3RoaXMuYnl0ZWNvZGUsIHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShyZXNvbHZlZEFyZ3MpXSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBDb250cmFjdCBkZXBsb3llZCBieSBwYXNzaW5nICUlYXJncyUlIGludG8gdGhlXG4gICAgICogIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCByZXNvbHZlIHRvIHRoZSBDb250cmFjdCBiZWZvcmUgaXQgaGFzIGJlZW4gZGVwbG95ZWQgdG8gdGhlXG4gICAgICogIG5ldHdvcmssIHNvIHRoZSBbW0Jhc2VDb250cmFjdC13YWl0Rm9yRGVwbG95bWVudF1dIHNob3VsZCBiZSB1c2VkIGJlZm9yZVxuICAgICAqICBzZW5kaW5nIGFueSB0cmFuc2FjdGlvbnMgdG8gaXQuXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgICBhc3NlcnQodGhpcy5ydW5uZXIgJiYgdHlwZW9mICh0aGlzLnJ1bm5lci5zZW5kVHJhbnNhY3Rpb24pID09PSBcImZ1bmN0aW9uXCIsIFwiZmFjdG9yeSBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNlbnRUeCA9IGF3YWl0IHRoaXMucnVubmVyLnNlbmRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRDcmVhdGVBZGRyZXNzKHNlbnRUeCk7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KGFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lciwgc2VudFR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyAqKkNvbnRyYWN0RmFjdG9yeSoqIHdpdGggdGhlIHNhbWUgQUJJIGFuZCBieXRlY29kZSxcbiAgICAgKiAgYnV0IGNvbm5lY3RlZCB0byAlJXJ1bm5lciUlLlxuICAgICAqL1xuICAgIGNvbm5lY3QocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RGYWN0b3J5KHRoaXMuaW50ZXJmYWNlLCB0aGlzLmJ5dGVjb2RlLCBydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQ29udHJhY3RGYWN0b3J5KiogZnJvbSB0aGUgc3RhbmRhcmQgU29saWRpdHkgSlNPTiBvdXRwdXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Tb2xpZGl0eShvdXRwdXQsIHJ1bm5lcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChvdXRwdXQgIT0gbnVsbCwgXCJiYWQgY29tcGlsZXIgb3V0cHV0XCIsIFwib3V0cHV0XCIsIG91dHB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgKG91dHB1dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYmkgPSBvdXRwdXQuYWJpO1xuICAgICAgICBsZXQgYnl0ZWNvZGUgPSBcIlwiO1xuICAgICAgICBpZiAob3V0cHV0LmJ5dGVjb2RlKSB7XG4gICAgICAgICAgICBieXRlY29kZSA9IG91dHB1dC5ieXRlY29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdXRwdXQuZXZtICYmIG91dHB1dC5ldm0uYnl0ZWNvZGUpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gb3V0cHV0LmV2bS5ieXRlY29kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoYWJpLCBieXRlY29kZSwgcnVubmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWN0b3J5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/contract/factory.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/contract/index.js":
/*!***************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/contract/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: function() { return /* reexport safe */ _contract_js__WEBPACK_IMPORTED_MODULE_0__.BaseContract; },\n/* harmony export */   Contract: function() { return /* reexport safe */ _contract_js__WEBPACK_IMPORTED_MODULE_0__.Contract; },\n/* harmony export */   ContractEventPayload: function() { return /* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.ContractEventPayload; },\n/* harmony export */   ContractFactory: function() { return /* reexport safe */ _factory_js__WEBPACK_IMPORTED_MODULE_1__.ContractFactory; },\n/* harmony export */   ContractTransactionReceipt: function() { return /* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.ContractTransactionReceipt; },\n/* harmony export */   ContractTransactionResponse: function() { return /* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.ContractTransactionResponse; },\n/* harmony export */   ContractUnknownEventPayload: function() { return /* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.ContractUnknownEventPayload; },\n/* harmony export */   EventLog: function() { return /* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.EventLog; },\n/* harmony export */   UndecodedEventLog: function() { return /* reexport safe */ _wrappers_js__WEBPACK_IMPORTED_MODULE_2__.UndecodedEventLog; }\n/* harmony export */ });\n/* harmony import */ var _contract_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contract.js */ \"../common/node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./factory.js */ \"../common/node_modules/ethers/lib.esm/contract/factory.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrappers.js */ \"../common/node_modules/ethers/lib.esm/contract/wrappers.js\");\n/**\n *  A **Contract** object is a meta-class (a class whose definition is\n *  defined at runtime), which communicates with a deployed smart contract\n *  on the blockchain and provides a simple JavaScript interface to call\n *  methods, send transaction, query historic logs and listen for its events.\n *\n *  @_section: api/contract:Contracts  [about-contracts]\n */\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQ1I7QUFDeUg7QUFDeEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvaW5kZXguanM/NWRmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBICoqQ29udHJhY3QqKiBvYmplY3QgaXMgYSBtZXRhLWNsYXNzIChhIGNsYXNzIHdob3NlIGRlZmluaXRpb24gaXNcbiAqICBkZWZpbmVkIGF0IHJ1bnRpbWUpLCB3aGljaCBjb21tdW5pY2F0ZXMgd2l0aCBhIGRlcGxveWVkIHNtYXJ0IGNvbnRyYWN0XG4gKiAgb24gdGhlIGJsb2NrY2hhaW4gYW5kIHByb3ZpZGVzIGEgc2ltcGxlIEphdmFTY3JpcHQgaW50ZXJmYWNlIHRvIGNhbGxcbiAqICBtZXRob2RzLCBzZW5kIHRyYW5zYWN0aW9uLCBxdWVyeSBoaXN0b3JpYyBsb2dzIGFuZCBsaXN0ZW4gZm9yIGl0cyBldmVudHMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL2NvbnRyYWN0OkNvbnRyYWN0cyAgW2Fib3V0LWNvbnRyYWN0c11cbiAqL1xuZXhwb3J0IHsgQmFzZUNvbnRyYWN0LCBDb250cmFjdCB9IGZyb20gXCIuL2NvbnRyYWN0LmpzXCI7XG5leHBvcnQgeyBDb250cmFjdEZhY3RvcnkgfSBmcm9tIFwiLi9mYWN0b3J5LmpzXCI7XG5leHBvcnQgeyBDb250cmFjdEV2ZW50UGF5bG9hZCwgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkLCBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlLCBFdmVudExvZywgVW5kZWNvZGVkRXZlbnRMb2cgfSBmcm9tIFwiLi93cmFwcGVycy5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/contract/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/contract/wrappers.js":
/*!******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/contract/wrappers.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractEventPayload: function() { return /* binding */ ContractEventPayload; },\n/* harmony export */   ContractTransactionReceipt: function() { return /* binding */ ContractTransactionReceipt; },\n/* harmony export */   ContractTransactionResponse: function() { return /* binding */ ContractTransactionResponse; },\n/* harmony export */   ContractUnknownEventPayload: function() { return /* binding */ ContractUnknownEventPayload; },\n/* harmony export */   EventLog: function() { return /* binding */ EventLog; },\n/* harmony export */   UndecodedEventLog: function() { return /* binding */ UndecodedEventLog; }\n/* harmony export */ });\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/provider.js */ \"../common/node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nclass EventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     *  The Contract Interface.\n     */\n    interface;\n    /**\n     *  The matching event.\n     */\n    fragment;\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    args;\n    /**\n     * @_ignore:\n     */\n    constructor(log, iface, fragment) {\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { args, fragment, interface: iface });\n    }\n    /**\n     *  The name of the event.\n     */\n    get eventName() { return this.fragment.name; }\n    /**\n     *  The signature of the event.\n     */\n    get eventSignature() { return this.fragment.format(); }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nclass UndecodedEventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     *  The error encounted when trying to decode the log.\n     */\n    error;\n    /**\n     * @_ignore:\n     */\n    constructor(log, error) {\n        super(log, log.provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { error });\n    }\n}\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */\nclass ContractTransactionReceipt extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */\n    get logs() {\n        return super.logs.map((log) => {\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                }\n                catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */\nclass ContractTransactionResponse extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(confirms, timeout) {\n        const receipt = await super.wait(confirms, timeout);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */\nclass ContractUnknownEventPayload extends _utils_index_js__WEBPACK_IMPORTED_MODULE_1__.EventPayload {\n    /**\n     *  The log with no matching events.\n     */\n    log;\n    /**\n     *  @_event:\n     */\n    constructor(contract, listener, filter, log) {\n        super(contract, listener, filter);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { log });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */\n    async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */\n    async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */\n    async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */\nclass ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */\n    constructor(contract, listener, filter, fragment, _log) {\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { args, fragment });\n    }\n    /**\n     *  The event name.\n     */\n    get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */\n    get eventSignature() {\n        return this.fragment.format();\n    }\n}\n//# sourceMappingURL=wrappers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC93cmFwcGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDd0Y7QUFDckI7QUFDbkU7QUFDQTtBQUNBO0FBQ08sdUJBQXVCLHVEQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyx1REFBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUNBQXlDLHNFQUFrQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLHVFQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLHlEQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC93cmFwcGVycy5qcz9kODA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCBmcm9tIHByb3ZpZGVyLnRzIGluc3RlYWQgb2YgaW5kZXgudHMgdG8gcHJldmVudCBjaXJjdWxhciBkZXBcbi8vIGZyb20gRXRoZXJzY2FuUHJvdmlkZXJcbmltcG9ydCB7IExvZywgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgRXZlbnRQYXlsb2FkIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRMb2cgZXh0ZW5kcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGludGVyZmFjZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGV2ZW50LlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFyc2VkIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGV2ZW50IGJ5IGBgZW1pdGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBpZmFjZSwgZnJhZ21lbnQpIHtcbiAgICAgICAgc3VwZXIobG9nLCBsb2cucHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBhcmdzID0gaWZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50LCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBldmVudE5hbWUoKSB7IHJldHVybiB0aGlzLmZyYWdtZW50Lm5hbWU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTsgfVxufVxuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuZXhwb3J0IGNsYXNzIFVuZGVjb2RlZEV2ZW50TG9nIGV4dGVuZHMgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGVycm9yIGVuY291bnRlZCB3aGVuIHRyeWluZyB0byBkZWNvZGUgdGhlIGxvZy5cbiAgICAgKi9cbiAgICBlcnJvcjtcbiAgICAvKipcbiAgICAgKiBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIGVycm9yKSB7XG4gICAgICAgIHN1cGVyKGxvZywgbG9nLnByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGVycm9yIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCoqIGluY2x1ZGVzIHRoZSBwYXJzZWQgbG9ncyBmcm9tIGFcbiAqICBbW1RyYW5zYWN0aW9uUmVjZWlwdF1dLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQgZXh0ZW5kcyBUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgICNpZmFjZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWZhY2UsIHByb3ZpZGVyLCB0eCkge1xuICAgICAgICBzdXBlcih0eCwgcHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNpZmFjZSA9IGlmYWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcnNlZCBsb2dzIGZvciBhbnkgW1tMb2ddXSB3aGljaCBoYXMgYSBtYXRjaGluZyBldmVudCBpbiB0aGVcbiAgICAgKiAgQ29udHJhY3QgQUJJLlxuICAgICAqL1xuICAgIGdldCBsb2dzKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBsb2cudG9waWNzLmxlbmd0aCA/IHRoaXMuI2lmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRMb2cobG9nLCB0aGlzLiNpZmFjZSwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmRlY29kZWRFdmVudExvZyhsb2csIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKiogd2lsbCByZXR1cm4gYVxuICogIFtbQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHRdXSB3aGVuIHdhaXRlZCBvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSBleHRlbmRzIFRyYW5zYWN0aW9uUmVzcG9uc2Uge1xuICAgICNpZmFjZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWZhY2UsIHByb3ZpZGVyLCB0eCkge1xuICAgICAgICBzdXBlcih0eCwgcHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNpZmFjZSA9IGlmYWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgb25jZSB0aGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFuZCBoYXNcbiAgICAgKiAgJSVjb25maXJtcyUlIGJsb2NrcyBpbmNsdWRpbmcgaXQgKGRlZmF1bHQ6IGBgMWBgKSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUldGltZW91dCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIHJlc29sdmUgdG8gYGBudWxsYGAgb25seSBpZiAlJWNvbmZpcm1zJSUgaXMgYGAwYGBcbiAgICAgKiAgYW5kIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQsIG90aGVyd2lzZSB0aGlzIHdpbGxcbiAgICAgKiAgd2FpdCB1bnRpbCBlbm91Z2ggY29uZmlybWF0aW9ucyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KGNvbmZpcm1zLCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBzdXBlci53YWl0KGNvbmZpcm1zLCB0aW1lb3V0KTtcbiAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLiNpZmFjZSwgdGhpcy5wcm92aWRlciwgcmVjZWlwdCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBkb2VzIG5vdCBtYXRjaCBhbnkgZXZlbnRzIGluIHRoZSBBQkkuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQgZXh0ZW5kcyBFdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgbG9nIHdpdGggbm8gbWF0Y2hpbmcgZXZlbnRzLlxuICAgICAqL1xuICAgIGxvZztcbiAgICAvKipcbiAgICAgKiAgQF9ldmVudDpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbG9nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGxvZyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBibG9jayB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldEJsb2NrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gdGhlIGV2ZW50IG9jY3VyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQgdGhlIGV2ZW50IG9jY3VyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0RXZlbnRQYXlsb2FkKiogaXMgaW5jbHVkZWQgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGlzIGtub3duLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RFdmVudFBheWxvYWQgZXh0ZW5kcyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgZnJhZ21lbnQsIF9sb2cpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIG5ldyBFdmVudExvZyhfbG9nLCBjb250cmFjdC5pbnRlcmZhY2UsIGZyYWdtZW50KSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIHRoaXMubG9nLmRhdGEsIHRoaXMubG9nLnRvcGljcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcmdzLCBmcmFnbWVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBuYW1lLlxuICAgICAqL1xuICAgIGdldCBldmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGdldCBldmVudFNpZ25hdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JhcHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/contract/wrappers.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/crypto-browser.js":
/*!**********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/crypto-browser.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHash: function() { return /* binding */ createHash; },\n/* harmony export */   createHmac: function() { return /* binding */ createHmac; },\n/* harmony export */   pbkdf2Sync: function() { return /* binding */ pbkdf2Sync; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/hmac */ \"../../node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"../../node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"../../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"../../node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* Browser Crypto Shims */\n\n\n\n\n\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n}\n;\nconst anyGlobal = getGlobal();\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nfunction createHash(algo) {\n    switch (algo) {\n        case \"sha256\": return _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256.create();\n        case \"sha512\": return _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512.create();\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}\nfunction createHmac(_algo, key) {\n    const algo = ({ sha256: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256, sha512: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512 }[_algo]);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n    return _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_3__.hmac.create(algo, key);\n}\nfunction pbkdf2Sync(password, salt, iterations, keylen, _algo) {\n    const algo = ({ sha256: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256, sha512: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512 }[_algo]);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(algo, password, salt, { c: iterations, dkLen: keylen });\n}\nfunction randomBytes(length) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"randomBytes\"\n    });\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return result;\n}\n//# sourceMappingURL=crypto-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vY3J5cHRvLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDSTtBQUNBO0FBQ0E7QUFDYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsOEJBQThCLHdEQUFNO0FBQ3BDLDhCQUE4Qix3REFBTTtBQUNwQztBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDTztBQUNQLG9CQUFvQixNQUFNLGtFQUFRLDREQUFFO0FBQ3BDLElBQUksK0RBQWM7QUFDbEIsV0FBVyxvREFBSTtBQUNmO0FBQ087QUFDUCxvQkFBb0IsTUFBTSxrRUFBUSw0REFBRTtBQUNwQyxJQUFJLCtEQUFjO0FBQ2xCLFdBQVcsNERBQU0seUJBQXlCLDhCQUE4QjtBQUN4RTtBQUNPO0FBQ1AsSUFBSSx1REFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vY3J5cHRvLWJyb3dzZXIuanM/NGFhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBCcm93c2VyIENyeXB0byBTaGltcyAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2htYWNcIjtcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3Bia2RmMlwiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBzaGE1MTIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGE1MTJcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG47XG5jb25zdCBhbnlHbG9iYWwgPSBnZXRHbG9iYWwoKTtcbmNvbnN0IGNyeXB0byA9IGFueUdsb2JhbC5jcnlwdG8gfHwgYW55R2xvYmFsLm1zQ3J5cHRvO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2goYWxnbykge1xuICAgIHN3aXRjaCAoYWxnbykge1xuICAgICAgICBjYXNlIFwic2hhMjU2XCI6IHJldHVybiBzaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGNhc2UgXCJzaGE1MTJcIjogcmV0dXJuIHNoYTUxMi5jcmVhdGUoKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBoYXNoaW5nIGFsZ29yaXRobSBuYW1lXCIsIFwiYWxnb3JpdGhtXCIsIGFsZ28pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWMoX2FsZ28sIGtleSkge1xuICAgIGNvbnN0IGFsZ28gPSAoeyBzaGEyNTYsIHNoYTUxMiB9W19hbGdvXSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoYWxnbyAhPSBudWxsLCBcImludmFsaWQgaG1hYyBhbGdvcml0aG1cIiwgXCJhbGdvcml0aG1cIiwgX2FsZ28pO1xuICAgIHJldHVybiBobWFjLmNyZWF0ZShhbGdvLCBrZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgX2FsZ28pIHtcbiAgICBjb25zdCBhbGdvID0gKHsgc2hhMjU2LCBzaGE1MTIgfVtfYWxnb10pO1xuICAgIGFzc2VydEFyZ3VtZW50KGFsZ28gIT0gbnVsbCwgXCJpbnZhbGlkIHBia2RmMiBhbGdvcml0aG1cIiwgXCJhbGdvcml0aG1cIiwgX2FsZ28pO1xuICAgIHJldHVybiBwYmtkZjIoYWxnbywgcGFzc3dvcmQsIHNhbHQsIHsgYzogaXRlcmF0aW9ucywgZGtMZW46IGtleWxlbiB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgpIHtcbiAgICBhc3NlcnQoY3J5cHRvICE9IG51bGwsIFwicGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCBzZWN1cmUgcmFuZG9tIG51bWJlcnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwicmFuZG9tQnl0ZXNcIlxuICAgIH0pO1xuICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIobGVuZ3RoKSAmJiBsZW5ndGggPiAwICYmIGxlbmd0aCA8PSAxMDI0LCBcImludmFsaWQgbGVuZ3RoXCIsIFwibGVuZ3RoXCIsIGxlbmd0aCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/crypto-browser.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/hmac.js":
/*!************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/hmac.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeHmac: function() { return /* binding */ computeHmac; }\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"../common/node_modules/ethers/lib.esm/crypto/crypto-browser.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/**\n *  An **HMAC** enables verification that a given key was used\n *  to authenticate a payload.\n *\n *  See: [[link-wiki-hmac]]\n *\n *  @_subsection: api/crypto:HMAC  [about-hmac]\n */\n\n\nlet locked = false;\nconst _computeHmac = function (algorithm, key, data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHmac)(algorithm, key).update(data).digest();\n};\nlet __computeHmac = _computeHmac;\n/**\n *  Return the HMAC for %%data%% using the %%key%% key with the underlying\n *  %%algo%% used for compression.\n *\n *  @example:\n *    key = id(\"some-secret\")\n *\n *    // Compute the HMAC\n *    computeHmac(\"sha256\", key, \"0x1337\")\n *    //_result:\n *\n *    // To compute the HMAC of UTF-8 data, the data must be\n *    // converted to UTF-8 bytes\n *    computeHmac(\"sha256\", key, toUtf8Bytes(\"Hello World\"))\n *    //_result:\n *\n */\nfunction computeHmac(algorithm, _key, _data) {\n    const key = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_key, \"key\");\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__computeHmac(algorithm, key, data));\n}\ncomputeHmac._ = _computeHmac;\ncomputeHmac.lock = function () { locked = true; };\ncomputeHmac.register = function (func) {\n    if (locked) {\n        throw new Error(\"computeHmac is locked\");\n    }\n    __computeHmac = func;\n};\nObject.freeze(computeHmac);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ2E7QUFDdEQ7QUFDQTtBQUNBLFdBQVcsc0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdCQUFnQix5REFBUTtBQUN4QixpQkFBaUIseURBQVE7QUFDekIsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2htYWMuanM/OTQ4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBbiAqKkhNQUMqKiBlbmFibGVzIHZlcmlmaWNhdGlvbiB0aGF0IGEgZ2l2ZW4ga2V5IHdhcyB1c2VkXG4gKiAgdG8gYXV0aGVudGljYXRlIGEgcGF5bG9hZC5cbiAqXG4gKiAgU2VlOiBbW2xpbmstd2lraS1obWFjXV1cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOkhNQUMgIFthYm91dC1obWFjXVxuICovXG5pbXBvcnQgeyBjcmVhdGVIbWFjIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX2NvbXB1dGVIbWFjID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhtYWMoYWxnb3JpdGhtLCBrZXkpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5sZXQgX19jb21wdXRlSG1hYyA9IF9jb21wdXRlSG1hYztcbi8qKlxuICogIFJldHVybiB0aGUgSE1BQyBmb3IgJSVkYXRhJSUgdXNpbmcgdGhlICUla2V5JSUga2V5IHdpdGggdGhlIHVuZGVybHlpbmdcbiAqICAlJWFsZ28lJSB1c2VkIGZvciBjb21wcmVzc2lvbi5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBrZXkgPSBpZChcInNvbWUtc2VjcmV0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgSE1BQ1xuICogICAgY29tcHV0ZUhtYWMoXCJzaGEyNTZcIiwga2V5LCBcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRvIGNvbXB1dGUgdGhlIEhNQUMgb2YgVVRGLTggZGF0YSwgdGhlIGRhdGEgbXVzdCBiZVxuICogICAgLy8gY29udmVydGVkIHRvIFVURi04IGJ5dGVzXG4gKiAgICBjb21wdXRlSG1hYyhcInNoYTI1NlwiLCBrZXksIHRvVXRmOEJ5dGVzKFwiSGVsbG8gV29ybGRcIikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBfa2V5LCBfZGF0YSkge1xuICAgIGNvbnN0IGtleSA9IGdldEJ5dGVzKF9rZXksIFwia2V5XCIpO1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpKTtcbn1cbmNvbXB1dGVIbWFjLl8gPSBfY29tcHV0ZUhtYWM7XG5jb21wdXRlSG1hYy5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xuY29tcHV0ZUhtYWMucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29tcHV0ZUhtYWMgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX2NvbXB1dGVIbWFjID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKGNvbXB1dGVIbWFjKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/hmac.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/index.js":
/*!*************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: function() { return /* reexport safe */ _signature_js__WEBPACK_IMPORTED_MODULE_8__.Signature; },\n/* harmony export */   SigningKey: function() { return /* reexport safe */ _signing_key_js__WEBPACK_IMPORTED_MODULE_7__.SigningKey; },\n/* harmony export */   computeHmac: function() { return /* reexport safe */ _hmac_js__WEBPACK_IMPORTED_MODULE_0__.computeHmac; },\n/* harmony export */   keccak256: function() { return /* reexport safe */ _keccak_js__WEBPACK_IMPORTED_MODULE_2__.keccak256; },\n/* harmony export */   lock: function() { return /* binding */ lock; },\n/* harmony export */   pbkdf2: function() { return /* reexport safe */ _pbkdf2_js__WEBPACK_IMPORTED_MODULE_5__.pbkdf2; },\n/* harmony export */   randomBytes: function() { return /* reexport safe */ _random_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes; },\n/* harmony export */   ripemd160: function() { return /* reexport safe */ _ripemd160_js__WEBPACK_IMPORTED_MODULE_3__.ripemd160; },\n/* harmony export */   scrypt: function() { return /* reexport safe */ _scrypt_js__WEBPACK_IMPORTED_MODULE_6__.scrypt; },\n/* harmony export */   scryptSync: function() { return /* reexport safe */ _scrypt_js__WEBPACK_IMPORTED_MODULE_6__.scryptSync; },\n/* harmony export */   sha256: function() { return /* reexport safe */ _sha2_js__WEBPACK_IMPORTED_MODULE_4__.sha256; },\n/* harmony export */   sha512: function() { return /* reexport safe */ _sha2_js__WEBPACK_IMPORTED_MODULE_4__.sha512; }\n/* harmony export */ });\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hmac.js */ \"../common/node_modules/ethers/lib.esm/crypto/hmac.js\");\n/* harmony import */ var _keccak_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keccak.js */ \"../common/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _ripemd160_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ripemd160.js */ \"../common/node_modules/ethers/lib.esm/crypto/ripemd160.js\");\n/* harmony import */ var _pbkdf2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pbkdf2.js */ \"../common/node_modules/ethers/lib.esm/crypto/pbkdf2.js\");\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./random.js */ \"../common/node_modules/ethers/lib.esm/crypto/random.js\");\n/* harmony import */ var _scrypt_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scrypt.js */ \"../common/node_modules/ethers/lib.esm/crypto/scrypt.js\");\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sha2.js */ \"../common/node_modules/ethers/lib.esm/crypto/sha2.js\");\n/* harmony import */ var _signing_key_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./signing-key.js */ \"../common/node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _signature_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./signature.js */ \"../common/node_modules/ethers/lib.esm/crypto/signature.js\");\n/**\n *  A fundamental building block of Ethereum is the underlying\n *  cryptographic primitives.\n *\n *  @_section: api/crypto:Cryptographic Functions   [about-crypto]\n */\nnull;\n// We import all these so we can export lock()\n\n\n\n\n\n\n\n\n\n\n/**\n *  Once called, prevents any future change to the underlying cryptographic\n *  primitives using the ``.register`` feature for hooks.\n */\nfunction lock() {\n    _hmac_js__WEBPACK_IMPORTED_MODULE_0__.computeHmac.lock();\n    _keccak_js__WEBPACK_IMPORTED_MODULE_2__.keccak256.lock();\n    _pbkdf2_js__WEBPACK_IMPORTED_MODULE_5__.pbkdf2.lock();\n    _random_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes.lock();\n    _ripemd160_js__WEBPACK_IMPORTED_MODULE_3__.ripemd160.lock();\n    _scrypt_js__WEBPACK_IMPORTED_MODULE_6__.scrypt.lock();\n    _scrypt_js__WEBPACK_IMPORTED_MODULE_6__.scryptSync.lock();\n    _sha2_js__WEBPACK_IMPORTED_MODULE_4__.sha256.lock();\n    _sha2_js__WEBPACK_IMPORTED_MODULE_4__.sha512.lock();\n    _random_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes.lock();\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3QztBQUNBO0FBQ0c7QUFDTjtBQUNLO0FBQ087QUFDTjtBQUMyRDtBQUN4RDtBQUNIO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlEQUFXO0FBQ2YsSUFBSSxpREFBUztBQUNiLElBQUksOENBQU07QUFDVixJQUFJLG1EQUFXO0FBQ2YsSUFBSSxvREFBUztBQUNiLElBQUksOENBQU07QUFDVixJQUFJLGtEQUFVO0FBQ2QsSUFBSSw0Q0FBTTtBQUNWLElBQUksNENBQU07QUFDVixJQUFJLG1EQUFXO0FBQ2Y7QUFDZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2luZGV4LmpzP2Y5NzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9jayBvZiBFdGhlcmV1bSBpcyB0aGUgdW5kZXJseWluZ1xuICogIGNyeXB0b2dyYXBoaWMgcHJpbWl0aXZlcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvY3J5cHRvOkNyeXB0b2dyYXBoaWMgRnVuY3Rpb25zICAgW2Fib3V0LWNyeXB0b11cbiAqL1xubnVsbDtcbi8vIFdlIGltcG9ydCBhbGwgdGhlc2Ugc28gd2UgY2FuIGV4cG9ydCBsb2NrKClcbmltcG9ydCB7IGNvbXB1dGVIbWFjIH0gZnJvbSBcIi4vaG1hYy5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4va2VjY2FrLmpzXCI7XG5pbXBvcnQgeyByaXBlbWQxNjAgfSBmcm9tIFwiLi9yaXBlbWQxNjAuanNcIjtcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCIuL3Bia2RmMi5qc1wiO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tIFwiLi9yYW5kb20uanNcIjtcbmltcG9ydCB7IHNjcnlwdCwgc2NyeXB0U3luYyB9IGZyb20gXCIuL3NjcnlwdC5qc1wiO1xuaW1wb3J0IHsgc2hhMjU2LCBzaGE1MTIgfSBmcm9tIFwiLi9zaGEyLmpzXCI7XG5leHBvcnQgeyBjb21wdXRlSG1hYywgcmFuZG9tQnl0ZXMsIGtlY2NhazI1NiwgcmlwZW1kMTYwLCBzaGEyNTYsIHNoYTUxMiwgcGJrZGYyLCBzY3J5cHQsIHNjcnlwdFN5bmMgfTtcbmV4cG9ydCB7IFNpZ25pbmdLZXkgfSBmcm9tIFwiLi9zaWduaW5nLWtleS5qc1wiO1xuZXhwb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLmpzXCI7XG4vKipcbiAqICBPbmNlIGNhbGxlZCwgcHJldmVudHMgYW55IGZ1dHVyZSBjaGFuZ2UgdG8gdGhlIHVuZGVybHlpbmcgY3J5cHRvZ3JhcGhpY1xuICogIHByaW1pdGl2ZXMgdXNpbmcgdGhlIGBgLnJlZ2lzdGVyYGAgZmVhdHVyZSBmb3IgaG9va3MuXG4gKi9cbmZ1bmN0aW9uIGxvY2soKSB7XG4gICAgY29tcHV0ZUhtYWMubG9jaygpO1xuICAgIGtlY2NhazI1Ni5sb2NrKCk7XG4gICAgcGJrZGYyLmxvY2soKTtcbiAgICByYW5kb21CeXRlcy5sb2NrKCk7XG4gICAgcmlwZW1kMTYwLmxvY2soKTtcbiAgICBzY3J5cHQubG9jaygpO1xuICAgIHNjcnlwdFN5bmMubG9jaygpO1xuICAgIHNoYTI1Ni5sb2NrKCk7XG4gICAgc2hhNTEyLmxvY2soKTtcbiAgICByYW5kb21CeXRlcy5sb2NrKCk7XG59XG5leHBvcnQgeyBsb2NrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/keccak.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/keccak.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: function() { return /* binding */ keccak256; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"../../node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */\n\n\nlet locked = false;\nconst _keccak256 = function (data) {\n    return (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */\nfunction keccak256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function () { locked = true; };\nkeccak256.register = function (func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256);\n//# sourceMappingURL=keccak.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8va2VjY2FrLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDTTtBQUN0RDtBQUNBO0FBQ0EsV0FBVyw4REFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQix5REFBUTtBQUN6QixXQUFXLHdEQUFPO0FBQ2xCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8va2VjY2FrLmpzP2VjYjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQ3J5cHRvZ3JhcGhpYyBoYXNoaW5nIGZ1bmN0aW9uc1xuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnMgW2Fib3V0LWNyeXB0by1oYXNoaW5nXVxuICovXG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhM1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9rZWNjYWsyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBrZWNjYWtfMjU2KGRhdGEpO1xufTtcbmxldCBfX2tlY2NhazI1NiA9IF9rZWNjYWsyNTY7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIEtFQ0NBSzI1NiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBUaGUgJSVkYXRhJSUgKiptdXN0KiogYmUgYSBkYXRhIHJlcHJlc2VudGF0aW9uLCB0byBjb21wdXRlIHRoZVxuICogIGhhc2ggb2YgVVRGLTggZGF0YSB1c2UgdGhlIFtbaWRdXSBmdW5jdGlvbi5cbiAqXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICogIEBleGFtcGxlOlxuICogICAga2VjY2FrMjU2KFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFN0cmluZ3MgYXJlIGFzc3VtZWQgdG8gYmUgRGF0YUhleFN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGxcbiAqICAgIC8vIHRocm93LiBUbyBoYXNoIFVURi04IGRhdGEsIHNlZSB0aGUgbm90ZSBhYm92ZS5cbiAqICAgIGtlY2NhazI1NihcIkhlbGxvIFdvcmxkXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fa2VjY2FrMjU2KGRhdGEpKTtcbn1cbmtlY2NhazI1Ni5fID0gX2tlY2NhazI1NjtcbmtlY2NhazI1Ni5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xua2VjY2FrMjU2LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZWNjYWsyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX2tlY2NhazI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShrZWNjYWsyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2VjY2FrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/keccak.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/pbkdf2.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/pbkdf2.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: function() { return /* binding */ pbkdf2; }\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"../common/node_modules/ethers/lib.esm/crypto/crypto-browser.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/**\n *  A **Password-Based Key-Derivation Function** is designed to create\n *  a sequence of bytes suitible as a **key** from a human-rememberable\n *  password.\n *\n *  @_subsection: api/crypto:Passwords  [about-pbkdf]\n */\n\n\nlet locked = false;\nconst _pbkdf2 = function (password, salt, iterations, keylen, algo) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.pbkdf2Sync)(password, salt, iterations, keylen, algo);\n};\nlet __pbkdf2 = _pbkdf2;\n/**\n *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\n *  the %%salt%% and using %%iterations%% of %%algo%%.\n *\n *  This PBKDF is outdated and should not be used in new projects, but is\n *  required to decrypt older files.\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the PBKDF2\n *    pbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\n *    //_result:\n */\nfunction pbkdf2(_password, _salt, iterations, keylen, algo) {\n    const password = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_password, \"password\");\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__pbkdf2(password, salt, iterations, keylen, algo));\n}\npbkdf2._ = _pbkdf2;\npbkdf2.lock = function () { locked = true; };\npbkdf2.register = function (func) {\n    if (locked) {\n        throw new Error(\"pbkdf2 is locked\");\n    }\n    __pbkdf2 = func;\n};\nObject.freeze(pbkdf2);\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vcGJrZGYyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ2E7QUFDdEQ7QUFDQTtBQUNBLFdBQVcsc0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFCQUFxQix5REFBUTtBQUM3QixpQkFBaUIseURBQVE7QUFDekIsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3Bia2RmMi5qcz8yMWJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEEgKipQYXNzd29yZC1CYXNlZCBLZXktRGVyaXZhdGlvbiBGdW5jdGlvbioqIGlzIGRlc2lnbmVkIHRvIGNyZWF0ZVxuICogIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3VpdGlibGUgYXMgYSAqKmtleSoqIGZyb20gYSBodW1hbi1yZW1lbWJlcmFibGVcbiAqICBwYXNzd29yZC5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOlBhc3N3b3JkcyAgW2Fib3V0LXBia2RmXVxuICovXG5pbXBvcnQgeyBwYmtkZjJTeW5jIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX3Bia2RmMiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBhbGdvKSB7XG4gICAgcmV0dXJuIHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbyk7XG59O1xubGV0IF9fcGJrZGYyID0gX3Bia2RmMjtcbi8qKlxuICogIFJldHVybiB0aGUgW1tsaW5rLXBia2RmMl1dIGZvciAlJWtleWxlbiUlIGJ5dGVzIGZvciAlJXBhc3N3b3JkJSUgdXNpbmdcbiAqICB0aGUgJSVzYWx0JSUgYW5kIHVzaW5nICUlaXRlcmF0aW9ucyUlIG9mICUlYWxnbyUlLlxuICpcbiAqICBUaGlzIFBCS0RGIGlzIG91dGRhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzLCBidXQgaXNcbiAqICByZXF1aXJlZCB0byBkZWNyeXB0IG9sZGVyIGZpbGVzLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBwYXNzd29yZCBtdXN0IGJlIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIGl0IGlzIGdlbmVyYWxseVxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxuICogICAgcGFzc3dvcmQgPSBcImhlbGxvXCJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXG4gKlxuICogICAgc2FsdCA9IGlkKFwic29tZS1zYWx0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgUEJLREYyXG4gKiAgICBwYmtkZjIocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgMTYsIFwic2hhMjU2XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYmtkZjIoX3Bhc3N3b3JkLCBfc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBhbGdvKSB7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBnZXRCeXRlcyhfcGFzc3dvcmQsIFwicGFzc3dvcmRcIik7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgcmV0dXJuIGhleGxpZnkoX19wYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykpO1xufVxucGJrZGYyLl8gPSBfcGJrZGYyO1xucGJrZGYyLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5wYmtkZjIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGJrZGYyIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19wYmtkZjIgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUocGJrZGYyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/pbkdf2.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/random.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/random.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; }\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"../common/node_modules/ethers/lib.esm/crypto/crypto-browser.js\");\n/**\n *  A **Cryptographically Secure Random Value** is one that has been\n *  generated with additional care take to prevent side-channels\n *  from allowing others to detect it and prevent others from through\n *  coincidence generate the same values.\n *\n *  @_subsection: api/crypto:Random Values  [about-crypto-random]\n */\n\nlet locked = false;\nconst _randomBytes = function (length) {\n    return new Uint8Array((0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(length));\n};\nlet __randomBytes = _randomBytes;\n/**\n *  Return %%length%% bytes of cryptographically secure random data.\n *\n *  @example:\n *    randomBytes(8)\n *    //_result:\n */\nfunction randomBytes(length) {\n    return __randomBytes(length);\n}\nrandomBytes._ = _randomBytes;\nrandomBytes.lock = function () { locked = true; };\nrandomBytes.register = function (func) {\n    if (locked) {\n        throw new Error(\"randomBytes is locked\");\n    }\n    __randomBytes = func;\n};\nObject.freeze(randomBytes);\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vcmFuZG9tLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRDtBQUMzRDtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3JhbmRvbS5qcz9iNDI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEEgKipDcnlwdG9ncmFwaGljYWxseSBTZWN1cmUgUmFuZG9tIFZhbHVlKiogaXMgb25lIHRoYXQgaGFzIGJlZW5cbiAqICBnZW5lcmF0ZWQgd2l0aCBhZGRpdGlvbmFsIGNhcmUgdGFrZSB0byBwcmV2ZW50IHNpZGUtY2hhbm5lbHNcbiAqICBmcm9tIGFsbG93aW5nIG90aGVycyB0byBkZXRlY3QgaXQgYW5kIHByZXZlbnQgb3RoZXJzIGZyb20gdGhyb3VnaFxuICogIGNvaW5jaWRlbmNlIGdlbmVyYXRlIHRoZSBzYW1lIHZhbHVlcy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOlJhbmRvbSBWYWx1ZXMgIFthYm91dC1jcnlwdG8tcmFuZG9tXVxuICovXG5pbXBvcnQgeyByYW5kb21CeXRlcyBhcyBjcnlwdG9fcmFuZG9tIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfcmFuZG9tQnl0ZXMgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0b19yYW5kb20obGVuZ3RoKSk7XG59O1xubGV0IF9fcmFuZG9tQnl0ZXMgPSBfcmFuZG9tQnl0ZXM7XG4vKipcbiAqICBSZXR1cm4gJSVsZW5ndGglJSBieXRlcyBvZiBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcmFuZG9tIGRhdGEuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgcmFuZG9tQnl0ZXMoOClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGxlbmd0aCkge1xuICAgIHJldHVybiBfX3JhbmRvbUJ5dGVzKGxlbmd0aCk7XG59XG5yYW5kb21CeXRlcy5fID0gX3JhbmRvbUJ5dGVzO1xucmFuZG9tQnl0ZXMubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbnJhbmRvbUJ5dGVzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhbmRvbUJ5dGVzIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19yYW5kb21CeXRlcyA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShyYW5kb21CeXRlcyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/random.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/ripemd160.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/ripemd160.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ripemd160: function() { return /* binding */ ripemd160; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"../../node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\nlet locked = false;\nconst _ripemd160 = function (data) {\n    return (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_0__.ripemd160)(data);\n};\nlet __ripemd160 = _ripemd160;\n/**\n *  Compute the cryptographic RIPEMD-160 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    ripemd160(\"0x\")\n *    //_result:\n *\n *    ripemd160(\"0x1337\")\n *    //_result:\n *\n *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */\nfunction ripemd160(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__ripemd160(data));\n}\nripemd160._ = _ripemd160;\nripemd160.lock = function () { locked = true; };\nripemd160.register = function (func) {\n    if (locked) {\n        throw new TypeError(\"ripemd160 is locked\");\n    }\n    __ripemd160 = func;\n};\nObject.freeze(ripemd160);\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vcmlwZW1kMTYwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RTtBQUNqQjtBQUN0RDtBQUNBO0FBQ0EsV0FBVyxrRUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHlEQUFRO0FBQ3pCLFdBQVcsd0RBQU87QUFDbEI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9yaXBlbWQxNjAuanM/YTBiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByaXBlbWQxNjAgYXMgbm9ibGVfcmlwZW1kMTYwIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvcmlwZW1kMTYwXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX3JpcGVtZDE2MCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5vYmxlX3JpcGVtZDE2MChkYXRhKTtcbn07XG5sZXQgX19yaXBlbWQxNjAgPSBfcmlwZW1kMTYwO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBSSVBFTUQtMTYwIGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJpcGVtZDE2MChcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgcmlwZW1kMTYwKFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgcmlwZW1kMTYwKG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByaXBlbWQxNjAoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX3JpcGVtZDE2MChkYXRhKSk7XG59XG5yaXBlbWQxNjAuXyA9IF9yaXBlbWQxNjA7XG5yaXBlbWQxNjAubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbnJpcGVtZDE2MC5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmlwZW1kMTYwIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19yaXBlbWQxNjAgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUocmlwZW1kMTYwKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpcGVtZDE2MC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/ripemd160.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/scrypt.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/scrypt.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scrypt: function() { return /* binding */ scrypt; },\n/* harmony export */   scryptSync: function() { return /* binding */ scryptSync; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/scrypt */ \"../../node_modules/@noble/hashes/esm/scrypt.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\nlet lockedSync = false, lockedAsync = false;\nconst _scryptAsync = async function (passwd, salt, N, r, p, dkLen, onProgress) {\n    return await (0,_noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_0__.scryptAsync)(passwd, salt, { N, r, p, dkLen, onProgress });\n};\nconst _scryptSync = function (passwd, salt, N, r, p, dkLen) {\n    return (0,_noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_0__.scrypt)(passwd, salt, { N, r, p, dkLen });\n};\nlet __scryptAsync = _scryptAsync;\nlet __scryptSync = _scryptSync;\n/**\n *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of\n *  derivation to increase the resource cost to brute-force a password\n *  for a given key.\n *\n *  This means this algorithm is intentionally slow, and can be tuned to\n *  become slower. As computation and memory speed improve over time,\n *  increasing the difficulty maintains the cost of an attacker.\n *\n *  For example, if a target time of 5 seconds is used, a legitimate user\n *  which knows their password requires only 5 seconds to unlock their\n *  account. A 6 character password has 68 billion possibilities, which\n *  would require an attacker to invest over 10,000 years of CPU time. This\n *  is of course a crude example (as password generally aren't random),\n *  but demonstrates to value of imposing large costs to decryption.\n *\n *  For this reason, if building a UI which involved decrypting or\n *  encrypting datsa using scrypt, it is recommended to use a\n *  [[ProgressCallback]] (as event short periods can seem lik an eternity\n *  if the UI freezes). Including the phrase //\"decrypting\"// in the UI\n *  can also help, assuring the user their waiting is for a good reason.\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nasync function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {\n    const passwd = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_passwd, \"passwd\");\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));\n}\nscrypt._ = _scryptAsync;\nscrypt.lock = function () { lockedAsync = true; };\nscrypt.register = function (func) {\n    if (lockedAsync) {\n        throw new Error(\"scrypt is locked\");\n    }\n    __scryptAsync = func;\n};\nObject.freeze(scrypt);\n/**\n *  Provides a synchronous variant of [[scrypt]].\n *\n *  This will completely lock up and freeze the UI in a browser and will\n *  prevent any event loop from progressing. For this reason, it is\n *  preferred to use the [async variant](scrypt).\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nfunction scryptSync(_passwd, _salt, N, r, p, dkLen) {\n    const passwd = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_passwd, \"passwd\");\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_salt, \"salt\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__scryptSync(passwd, salt, N, r, p, dkLen));\n}\nscryptSync._ = _scryptSync;\nscryptSync.lock = function () { lockedSync = true; };\nscryptSync.register = function (func) {\n    if (lockedSync) {\n        throw new Error(\"scryptSync is locked\");\n    }\n    __scryptSync = func;\n};\nObject.freeze(scryptSync);\n//# sourceMappingURL=scrypt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2NyeXB0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0Y7QUFDN0I7QUFDM0Q7QUFDQTtBQUNBLGlCQUFpQixpRUFBVyxpQkFBaUIsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDREQUFVLGlCQUFpQixnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1CQUFtQix5REFBUTtBQUMzQixpQkFBaUIseURBQVE7QUFDekIsV0FBVyx3REFBQztBQUNaO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUJBQW1CLHlEQUFRO0FBQzNCLGlCQUFpQix5REFBUTtBQUN6QixXQUFXLHdEQUFDO0FBQ1o7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zY3J5cHQuanM/OGZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzY3J5cHQgYXMgX25vYmxlU3luYywgc2NyeXB0QXN5bmMgYXMgX25vYmxlQXN5bmMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zY3J5cHRcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IGFzIEggfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmxldCBsb2NrZWRTeW5jID0gZmFsc2UsIGxvY2tlZEFzeW5jID0gZmFsc2U7XG5jb25zdCBfc2NyeXB0QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAocGFzc3dkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgb25Qcm9ncmVzcykge1xuICAgIHJldHVybiBhd2FpdCBfbm9ibGVBc3luYyhwYXNzd2QsIHNhbHQsIHsgTiwgciwgcCwgZGtMZW4sIG9uUHJvZ3Jlc3MgfSk7XG59O1xuY29uc3QgX3NjcnlwdFN5bmMgPSBmdW5jdGlvbiAocGFzc3dkLCBzYWx0LCBOLCByLCBwLCBka0xlbikge1xuICAgIHJldHVybiBfbm9ibGVTeW5jKHBhc3N3ZCwgc2FsdCwgeyBOLCByLCBwLCBka0xlbiB9KTtcbn07XG5sZXQgX19zY3J5cHRBc3luYyA9IF9zY3J5cHRBc3luYztcbmxldCBfX3NjcnlwdFN5bmMgPSBfc2NyeXB0U3luYztcbi8qKlxuICogIFRoZSBbW2xpbmstd2lraS1zY3J5cHRdXSB1c2VzIGEgbWVtb3J5IGFuZCBjcHUgaGFyZCBtZXRob2Qgb2ZcbiAqICBkZXJpdmF0aW9uIHRvIGluY3JlYXNlIHRoZSByZXNvdXJjZSBjb3N0IHRvIGJydXRlLWZvcmNlIGEgcGFzc3dvcmRcbiAqICBmb3IgYSBnaXZlbiBrZXkuXG4gKlxuICogIFRoaXMgbWVhbnMgdGhpcyBhbGdvcml0aG0gaXMgaW50ZW50aW9uYWxseSBzbG93LCBhbmQgY2FuIGJlIHR1bmVkIHRvXG4gKiAgYmVjb21lIHNsb3dlci4gQXMgY29tcHV0YXRpb24gYW5kIG1lbW9yeSBzcGVlZCBpbXByb3ZlIG92ZXIgdGltZSxcbiAqICBpbmNyZWFzaW5nIHRoZSBkaWZmaWN1bHR5IG1haW50YWlucyB0aGUgY29zdCBvZiBhbiBhdHRhY2tlci5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGlmIGEgdGFyZ2V0IHRpbWUgb2YgNSBzZWNvbmRzIGlzIHVzZWQsIGEgbGVnaXRpbWF0ZSB1c2VyXG4gKiAgd2hpY2gga25vd3MgdGhlaXIgcGFzc3dvcmQgcmVxdWlyZXMgb25seSA1IHNlY29uZHMgdG8gdW5sb2NrIHRoZWlyXG4gKiAgYWNjb3VudC4gQSA2IGNoYXJhY3RlciBwYXNzd29yZCBoYXMgNjggYmlsbGlvbiBwb3NzaWJpbGl0aWVzLCB3aGljaFxuICogIHdvdWxkIHJlcXVpcmUgYW4gYXR0YWNrZXIgdG8gaW52ZXN0IG92ZXIgMTAsMDAwIHllYXJzIG9mIENQVSB0aW1lLiBUaGlzXG4gKiAgaXMgb2YgY291cnNlIGEgY3J1ZGUgZXhhbXBsZSAoYXMgcGFzc3dvcmQgZ2VuZXJhbGx5IGFyZW4ndCByYW5kb20pLFxuICogIGJ1dCBkZW1vbnN0cmF0ZXMgdG8gdmFsdWUgb2YgaW1wb3NpbmcgbGFyZ2UgY29zdHMgdG8gZGVjcnlwdGlvbi5cbiAqXG4gKiAgRm9yIHRoaXMgcmVhc29uLCBpZiBidWlsZGluZyBhIFVJIHdoaWNoIGludm9sdmVkIGRlY3J5cHRpbmcgb3JcbiAqICBlbmNyeXB0aW5nIGRhdHNhIHVzaW5nIHNjcnlwdCwgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGFcbiAqICBbW1Byb2dyZXNzQ2FsbGJhY2tdXSAoYXMgZXZlbnQgc2hvcnQgcGVyaW9kcyBjYW4gc2VlbSBsaWsgYW4gZXRlcm5pdHlcbiAqICBpZiB0aGUgVUkgZnJlZXplcykuIEluY2x1ZGluZyB0aGUgcGhyYXNlIC8vXCJkZWNyeXB0aW5nXCIvLyBpbiB0aGUgVUlcbiAqICBjYW4gYWxzbyBoZWxwLCBhc3N1cmluZyB0aGUgdXNlciB0aGVpciB3YWl0aW5nIGlzIGZvciBhIGdvb2QgcmVhc29uLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpQYXNzd29yZHNcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBUaGUgcGFzc3dvcmQgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMsIGFuZCBpdCBpcyBnZW5lcmFsbHlcbiAqICAgIC8vIGJlc3QgcHJhY3RpY2VzIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGhhcyBiZWVuIG5vcm1hbGl6ZWQuIE1hbnlcbiAqICAgIC8vIGZvcm1hdHMgZXhwbGljaXRseSBpbmRpY2F0ZSB0aGUgbm9ybWFsaXphdGlvbiBmb3JtIHRvIHVzZS5cbiAqICAgIHBhc3N3b3JkID0gXCJoZWxsb1wiXG4gKiAgICBwYXNzd29yZEJ5dGVzID0gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFwiTkZLQ1wiKVxuICpcbiAqICAgIHNhbHQgPSBpZChcInNvbWUtc2FsdFwiKVxuICpcbiAqICAgIC8vIENvbXB1dGUgdGhlIHNjcnlwdFxuICogICAgc2NyeXB0KHBhc3N3b3JkQnl0ZXMsIHNhbHQsIDEwMjQsIDgsIDEsIDE2KVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2NyeXB0KF9wYXNzd2QsIF9zYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3MpIHtcbiAgICBjb25zdCBwYXNzd2QgPSBnZXRCeXRlcyhfcGFzc3dkLCBcInBhc3N3ZFwiKTtcbiAgICBjb25zdCBzYWx0ID0gZ2V0Qnl0ZXMoX3NhbHQsIFwic2FsdFwiKTtcbiAgICByZXR1cm4gSChhd2FpdCBfX3NjcnlwdEFzeW5jKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIHByb2dyZXNzKSk7XG59XG5zY3J5cHQuXyA9IF9zY3J5cHRBc3luYztcbnNjcnlwdC5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWRBc3luYyA9IHRydWU7IH07XG5zY3J5cHQucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWRBc3luYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY3J5cHQgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NjcnlwdEFzeW5jID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNjcnlwdCk7XG4vKipcbiAqICBQcm92aWRlcyBhIHN5bmNocm9ub3VzIHZhcmlhbnQgb2YgW1tzY3J5cHRdXS5cbiAqXG4gKiAgVGhpcyB3aWxsIGNvbXBsZXRlbHkgbG9jayB1cCBhbmQgZnJlZXplIHRoZSBVSSBpbiBhIGJyb3dzZXIgYW5kIHdpbGxcbiAqICBwcmV2ZW50IGFueSBldmVudCBsb29wIGZyb20gcHJvZ3Jlc3NpbmcuIEZvciB0aGlzIHJlYXNvbiwgaXQgaXNcbiAqICBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbYXN5bmMgdmFyaWFudF0oc2NyeXB0KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86UGFzc3dvcmRzXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVGhlIHBhc3N3b3JkIG11c3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLCBhbmQgaXQgaXMgZ2VuZXJhbGx5XG4gKiAgICAvLyBiZXN0IHByYWN0aWNlcyB0byBlbnN1cmUgdGhlIHN0cmluZyBoYXMgYmVlbiBub3JtYWxpemVkLiBNYW55XG4gKiAgICAvLyBmb3JtYXRzIGV4cGxpY2l0bHkgaW5kaWNhdGUgdGhlIG5vcm1hbGl6YXRpb24gZm9ybSB0byB1c2UuXG4gKiAgICBwYXNzd29yZCA9IFwiaGVsbG9cIlxuICogICAgcGFzc3dvcmRCeXRlcyA9IHRvVXRmOEJ5dGVzKHBhc3N3b3JkLCBcIk5GS0NcIilcbiAqXG4gKiAgICBzYWx0ID0gaWQoXCJzb21lLXNhbHRcIilcbiAqXG4gKiAgICAvLyBDb21wdXRlIHRoZSBzY3J5cHRcbiAqICAgIHNjcnlwdFN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgOCwgMSwgMTYpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY3J5cHRTeW5jKF9wYXNzd2QsIF9zYWx0LCBOLCByLCBwLCBka0xlbikge1xuICAgIGNvbnN0IHBhc3N3ZCA9IGdldEJ5dGVzKF9wYXNzd2QsIFwicGFzc3dkXCIpO1xuICAgIGNvbnN0IHNhbHQgPSBnZXRCeXRlcyhfc2FsdCwgXCJzYWx0XCIpO1xuICAgIHJldHVybiBIKF9fc2NyeXB0U3luYyhwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKSk7XG59XG5zY3J5cHRTeW5jLl8gPSBfc2NyeXB0U3luYztcbnNjcnlwdFN5bmMubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkU3luYyA9IHRydWU7IH07XG5zY3J5cHRTeW5jLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkU3luYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY3J5cHRTeW5jIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zY3J5cHRTeW5jID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNjcnlwdFN5bmMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyeXB0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/scrypt.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/sha2.js":
/*!************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/sha2.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: function() { return /* binding */ sha256; },\n/* harmony export */   sha512: function() { return /* binding */ sha512; }\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"../common/node_modules/ethers/lib.esm/crypto/crypto-browser.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\nconst _sha256 = function (data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha256\").update(data).digest();\n};\nconst _sha512 = function (data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha512\").update(data).digest();\n};\nlet __sha256 = _sha256;\nlet __sha512 = _sha512;\nlet locked256 = false, locked512 = false;\n/**\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha256(\"0x\")\n *    //_result:\n *\n *    sha256(\"0x1337\")\n *    //_result:\n *\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */\nfunction sha256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha256(data));\n}\nsha256._ = _sha256;\nsha256.lock = function () { locked256 = true; };\nsha256.register = function (func) {\n    if (locked256) {\n        throw new Error(\"sha256 is locked\");\n    }\n    __sha256 = func;\n};\nObject.freeze(sha256);\n/**\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha512(\"0x\")\n *    //_result:\n *\n *    sha512(\"0x1337\")\n *    //_result:\n *\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n */\nfunction sha512(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha512(data));\n}\nsha512._ = _sha512;\nsha512.lock = function () { locked512 = true; };\nsha512.register = function (func) {\n    if (locked512) {\n        throw new Error(\"sha512 is locked\");\n    }\n    __sha512 = func;\n};\nObject.freeze(sha256);\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlDO0FBQ2E7QUFDdEQ7QUFDQSxXQUFXLHNEQUFVO0FBQ3JCO0FBQ0E7QUFDQSxXQUFXLHNEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHlEQUFRO0FBQ3pCLFdBQVcsd0RBQU87QUFDbEI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIseURBQVE7QUFDekIsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NoYTIuanM/MjM5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSBcIi4vY3J5cHRvLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgX3NoYTI1NiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufTtcbmNvbnN0IF9zaGE1MTIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKFwic2hhNTEyXCIpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn07XG5sZXQgX19zaGEyNTYgPSBfc2hhMjU2O1xubGV0IF9fc2hhNTEyID0gX3NoYTUxMjtcbmxldCBsb2NrZWQyNTYgPSBmYWxzZSwgbG9ja2VkNTEyID0gZmFsc2U7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFNIQTItMjU2IGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHNoYTI1NihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhMjU2KFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGEyNTYoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX3NoYTI1NihkYXRhKSk7XG59XG5zaGEyNTYuXyA9IF9zaGEyNTY7XG5zaGEyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkMjU2ID0gdHJ1ZTsgfTtcbnNoYTI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZDI1Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGEyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NoYTI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBTSEEyLTUxMiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9uc1xuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBzaGE1MTIoXCIweFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTUxMihcIjB4MTMzN1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHNoYTUxMihuZXcgVWludDhBcnJheShbIDB4MTMsIDB4MzcgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGE1MTIoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX3NoYTUxMihkYXRhKSk7XG59XG5zaGE1MTIuXyA9IF9zaGE1MTI7XG5zaGE1MTIubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkNTEyID0gdHJ1ZTsgfTtcbnNoYTUxMi5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZDUxMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGE1MTIgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NoYTUxMiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShzaGEyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/sha2.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/signature.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/signature.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: function() { return /* binding */ Signature; }\n/* harmony export */ });\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/index.js */ \"../common/node_modules/ethers/lib.esm/constants/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nclass Signature {\n    #r;\n    #s;\n    #v;\n    #networkV;\n    /**\n     *  The ``r`` value for a signature.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n    get r() { return this.#r; }\n    set r(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */\n    get s() { return this.#s; }\n    set s(_value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(_value);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n        this.#s = value;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */\n    get v() { return this.#v; }\n    set v(value) {\n        const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value, \"value\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get networkV() { return this.#networkV; }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */\n    get yParity() {\n        return (this.v === 27) ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */\n    get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */\n    get compactSerialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([this.r, this.yParityAndS]);\n    }\n    /**\n     *  The serialized representation.\n     */\n    get serialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([this.r, this.s, (this.yParity ? \"0x1c\" : \"0x1b\")]);\n    }\n    /**\n     *  @private\n     */\n    constructor(guard, r, s, v) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */\n    clone() {\n        const clone = new Signature(_guard, this.r, this.s, this.v);\n        if (this.networkV) {\n            clone.#networkV = this.networkV;\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */\n    toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: ((networkV != null) ? networkV.toString() : null),\n            r: this.r, s: this.s, v: this.v,\n        };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */\n    static getChainId(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if ((bv == BN_27) || (bv == BN_28)) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */\n    static getChainIdV(chainId, v) {\n        return ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(chainId) * BN_2) + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */\n    static getNormalizedV(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return (bv & BN_1) ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */\n    static from(sig) {\n        function assertError(check, message) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, _constants_index_js__WEBPACK_IMPORTED_MODULE_1__.ZeroHash, _constants_index_js__WEBPACK_IMPORTED_MODULE_1__.ZeroHash, 27);\n        }\n        if (typeof (sig) === \"string\") {\n            const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = (s[0] & 0x80) ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                assertError((s[0] & 0x80) === 0, \"non-canonical s\");\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = (function (s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS);\n                bytes[0] &= 0x7f;\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n            }\n            assertError(false, \"missing s\");\n        })(sig.s, sig.yParityAndS);\n        assertError(((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(s)[0] & 0x80) == 0, \"non-canonical s\");\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = (function (_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_v);\n                return {\n                    networkV: ((v >= BN_35) ? v : undefined),\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                return { v: (((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS)[0] & 0x80) ? 28 : 27) };\n            }\n            if (yParity != null) {\n                switch ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(yParity, \"sig.yParity\")) {\n                    case 0: return { v: 27 };\n                    case 1: return { v: 28 };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        })(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            result.#networkV = networkV;\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n}\n//# sourceMappingURL=signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRDtBQUNvSDtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFZLENBQUMsMERBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsUUFBUSwrREFBYyxDQUFDLDJEQUFVO0FBQ2pDLGtCQUFrQix3REFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFFBQVEsK0RBQWMsQ0FBQywyREFBVTtBQUNqQyxzQkFBc0Isd0RBQU87QUFDN0IsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrQkFBa0IsMERBQVM7QUFDM0IsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSxPQUFPLFNBQVMsT0FBTyxjQUFjLGFBQWEsY0FBYyxnQkFBZ0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseURBQVEsRUFBRSx5REFBUTtBQUMzRDtBQUNBO0FBQ0EsMEJBQTBCLHlEQUFRO0FBQ2xDO0FBQ0EsMEJBQTBCLHdEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3REFBTztBQUN2RDtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3REFBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUFXO0FBQ3ZDLDhCQUE4Qix5REFBUTtBQUN0QztBQUNBLHVCQUF1Qix3REFBTztBQUM5QjtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQix5REFBUTtBQUM3QixrQkFBa0I7QUFDbEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQSwwQkFBMEIsMERBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUFXO0FBQ3ZDLHlCQUF5QixLQUFLLHlEQUFRO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBd0IsMERBQVM7QUFDakMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBEQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25hdHVyZS5qcz84MWJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFplcm9IYXNoIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXROdW1iZXIsIGhleGxpZnksIHRvQmVBcnJheSwgaXNIZXhTdHJpbmcsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydFByaXZhdGUgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8vIENvbnN0YW50c1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgQk5fMjcgPSBCaWdJbnQoMjcpO1xuY29uc3QgQk5fMjggPSBCaWdJbnQoMjgpO1xuY29uc3QgQk5fMzUgPSBCaWdJbnQoMzUpO1xuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiB0b1VpbnQyNTYodmFsdWUpIHtcbiAgICByZXR1cm4gemVyb1BhZFZhbHVlKHRvQmVBcnJheSh2YWx1ZSksIDMyKTtcbn1cbi8qKlxuICogIEEgU2lnbmF0dXJlICBAVE9ET1xuICpcbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86U2lnbmluZ1xuICovXG5leHBvcnQgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAjcjtcbiAgICAjcztcbiAgICAjdjtcbiAgICAjbmV0d29ya1Y7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHJgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyByZXByZXNlbnRzIHRoZSBgYHhgYCBjb29yZGluYXRlIG9mIGEgXCJyZWZlcmVuY2VcIiBvclxuICAgICAqICBjaGFsbGVuZ2UgcG9pbnQsIGZyb20gd2hpY2ggdGhlIGBgeWBgIGNhbiBiZSBjb21wdXRlZC5cbiAgICAgKi9cbiAgICBnZXQgcigpIHsgcmV0dXJuIHRoaXMuI3I7IH1cbiAgICBzZXQgcih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKHZhbHVlKSA9PT0gMzIsIFwiaW52YWxpZCByXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiNyID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGBzYGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGdldCBzKCkgeyByZXR1cm4gdGhpcy4jczsgfVxuICAgIHNldCBzKF92YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKF92YWx1ZSkgPT09IDMyLCBcImludmFsaWQgc1wiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGV4bGlmeShfdmFsdWUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMCwgMykpIDwgOCwgXCJub24tY2Fub25pY2FsIHNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHZgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgU2luY2UgYSBnaXZlbiBgYHhgYCB2YWx1ZSBmb3IgYGByYGAgaGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMgZm9yXG4gICAgICogIGl0cyBjb3JyZXNwb25kaW4gYGB5YGAsIHRoZSBgYHZgYCBpbmRpY2F0ZXMgd2hpY2ggb2YgdGhlIHR3byBgYHlgYFxuICAgICAqICB2YWx1ZXMgdG8gdXNlLlxuICAgICAqXG4gICAgICogIEl0IGlzIG5vcm1hbGl6ZWQgdG8gdGhlIHZhbHVlcyBgYDI3YGAgb3IgYGAyOGBgIGZvciBsZWdhY3lcbiAgICAgKiAgcHVycG9zZXMuXG4gICAgICovXG4gICAgZ2V0IHYoKSB7IHJldHVybiB0aGlzLiN2OyB9XG4gICAgc2V0IHYodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdiA9IGdldE51bWJlcih2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodiA9PT0gMjcgfHwgdiA9PT0gMjgsIFwiaW52YWxpZCB2XCIsIFwidlwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEVJUC0xNTUgYGB2YGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbmV0d29ya1YoKSB7IHJldHVybiB0aGlzLiNuZXR3b3JrVjsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgZm9yIEVJUC0xNTUgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCB0aGlzIHZhbHVlIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBsZWdhY3lDaGFpbklkKCkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5nZXRDaGFpbklkKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgeVBhcml0eWBgIGZvciB0aGUgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNlZSBgYHZgYCBmb3IgbW9yZSBkZXRhaWxzIG9uIGhvdyB0aGlzIHZhbHVlIGlzIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52ID09PSAyNykgPyAwIDogMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgYHlQYXJpdHlgYFxuICAgICAqICBhbmQgYGBzYGAgY29tcGFjdGVkIGludG8gYSBzaW5nbGUgYGBieXRlczMyYGAuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHlBbmRTKCkge1xuICAgICAgICAvLyBUaGUgRUlQLTIwOTggY29tcGFjdCByZXByZXNlbnRhdGlvblxuICAgICAgICBjb25zdCB5UGFyaXR5QW5kUyA9IGdldEJ5dGVzKHRoaXMucyk7XG4gICAgICAgIGlmICh0aGlzLnlQYXJpdHkpIHtcbiAgICAgICAgICAgIHlQYXJpdHlBbmRTWzBdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkoeVBhcml0eUFuZFMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjA5OF1dIGNvbXBhY3QgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZ2V0IGNvbXBhY3RTZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFt0aGlzLnIsIHRoaXMueVBhcml0eUFuZFNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFt0aGlzLnIsIHRoaXMucywgKHRoaXMueVBhcml0eSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCByLCBzLCB2KSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJTaWduYXR1cmVcIik7XG4gICAgICAgIHRoaXMuI3IgPSByO1xuICAgICAgICB0aGlzLiNzID0gcztcbiAgICAgICAgdGhpcy4jdiA9IHY7XG4gICAgICAgIHRoaXMuI25ldHdvcmtWID0gbnVsbDtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gYFNpZ25hdHVyZSB7IHI6IFwiJHt0aGlzLnJ9XCIsIHM6IFwiJHt0aGlzLnN9XCIsIHlQYXJpdHk6ICR7dGhpcy55UGFyaXR5fSwgbmV0d29ya1Y6ICR7dGhpcy5uZXR3b3JrVn0gfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IGlkZW50aWNhbCBbW1NpZ25hdHVyZV1dLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCB0aGlzLnIsIHRoaXMucywgdGhpcy52KTtcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya1YpIHtcbiAgICAgICAgICAgIGNsb25lLiNuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIGBgSlNPTi5zdHJpbmdpZnlgYC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcInNpZ25hdHVyZVwiLFxuICAgICAgICAgICAgbmV0d29ya1Y6ICgobmV0d29ya1YgIT0gbnVsbCkgPyBuZXR3b3JrVi50b1N0cmluZygpIDogbnVsbCksXG4gICAgICAgICAgICByOiB0aGlzLnIsIHM6IHRoaXMucywgdjogdGhpcy52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgY2hhaW4gSUQgZnJvbSB0aGUgYGB2YGAgaW4gYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDUpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDYpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGFpbklkKHYpIHtcbiAgICAgICAgY29uc3QgYnYgPSBnZXRCaWdJbnQodiwgXCJ2XCIpO1xuICAgICAgICAvLyBUaGUgdiBpcyBub3QgYW4gRUlQLTE1NSB2LCBzbyBpdCBpcyB0aGUgdW5zcGVjaWZpZWQgY2hhaW4gSURcbiAgICAgICAgaWYgKChidiA9PSBCTl8yNykgfHwgKGJ2ID09IEJOXzI4KSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFkIHZhbHVlIGZvciBhbiBFSVAtMTU1IHZcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnYgPj0gQk5fMzUsIFwiaW52YWxpZCBFSVAtMTU1IHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICByZXR1cm4gKGJ2IC0gQk5fMzUpIC8gQk5fMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGBgdmBgIGZvciBhIGNoYWluIElEIGZvciBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBMZWdhY3kgdHJhbnNhY3Rpb25zIHdoaWNoIHVzZSBbW2xpbmstZWlwLTE1NV1dIGhpamFjayB0aGUgYGB2YGBcbiAgICAgKiAgcHJvcGVydHkgdG8gaW5jbHVkZSB0aGUgY2hhaW4gSUQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWRWKDUsIDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyOClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgdikge1xuICAgICAgICByZXR1cm4gKGdldEJpZ0ludChjaGFpbklkKSAqIEJOXzIpICsgQmlnSW50KDM1ICsgdiAtIDI3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIG5vcm1hbGl6ZWQgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIGZyb20gYSBgYHlQYXJpcnR5YGAsXG4gICAgICogIGEgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIG9yIGEgbGVnYWN5IFtbbGluay1laXAtMTU1XV0gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgLy8gVGhlIHZhbHVlcyAwIGFuZCAxIGltcGx5IHYgaXMgYWN0dWFsbHkgeVBhcml0eVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigwKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIExlZ2FjeSBub24tRUlQLTE1NTkgdHJhbnNhY3Rpb24gKGkuZS4gMjcgb3IgMjgpXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIExlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9uIChpLmUuID49IDM1KVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig0NilcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBJbnZhbGlkIHZhbHVlcyB0aHJvd1xuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig1KVxuICAgICAqICAgIC8vX2Vycm9yOlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXROb3JtYWxpemVkVih2KSB7XG4gICAgICAgIGNvbnN0IGJ2ID0gZ2V0QmlnSW50KHYpO1xuICAgICAgICBpZiAoYnYgPT09IEJOXzAgfHwgYnYgPT09IEJOXzI3KSB7XG4gICAgICAgICAgICByZXR1cm4gMjc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ2ID09PSBCTl8xIHx8IGJ2ID09PSBCTl8yOCkge1xuICAgICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgdlwiLCBcInZcIiwgdik7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgRUlQLTE1NSB2IG1lYW5zIG9kZCBpcyAyNyBhbmQgZXZlbiBpcyAyOFxuICAgICAgICByZXR1cm4gKGJ2ICYgQk5fMSkgPyAyNyA6IDI4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1NpZ25hdHVyZV1dLlxuICAgICAqXG4gICAgICogIElmIG5vICUlc2lnJSUgaXMgcHJvdmlkZWQsIGEgbmV3IFtbU2lnbmF0dXJlXV0gaXMgY3JlYXRlZFxuICAgICAqICB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlc2lnJSUgaXMgYSBzdHJpbmcsIGl0IGlzIHBhcnNlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShzaWcpIHtcbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0RXJyb3IoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBcInNpZ25hdHVyZVwiLCBzaWcpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHNpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIFplcm9IYXNoLCBaZXJvSGFzaCwgMjcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHNpZykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoc2lnLCBcInNpZ25hdHVyZVwiKTtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYnl0ZXMuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gKHNbMF0gJiAweDgwKSA/IDI4IDogMjc7XG4gICAgICAgICAgICAgICAgc1swXSAmPSAweDdmO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgaGV4bGlmeShzKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoKHNbMF0gJiAweDgwKSA9PT0gMCwgXCJub24tY2Fub25pY2FsIHNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVihieXRlc1s2NF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgaGV4bGlmeShzKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJpbnZhbGlkIHJhdyBzaWduYXR1cmUgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWcuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgclxuICAgICAgICBjb25zdCBfciA9IHNpZy5yO1xuICAgICAgICBhc3NlcnRFcnJvcihfciAhPSBudWxsLCBcIm1pc3NpbmcgclwiKTtcbiAgICAgICAgY29uc3QgciA9IHRvVWludDI1Nihfcik7XG4gICAgICAgIC8vIEdldCBzOyBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh3ZSBjaGVjayBjb25zaXN0ZW5jeSBiZWxvdylcbiAgICAgICAgY29uc3QgcyA9IChmdW5jdGlvbiAocywgeVBhcml0eUFuZFMpIHtcbiAgICAgICAgICAgIGlmIChzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9VaW50MjU2KHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihpc0hleFN0cmluZyh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh5UGFyaXR5QW5kUyk7XG4gICAgICAgICAgICAgICAgYnl0ZXNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJtaXNzaW5nIHNcIik7XG4gICAgICAgIH0pKHNpZy5zLCBzaWcueVBhcml0eUFuZFMpO1xuICAgICAgICBhc3NlcnRFcnJvcigoZ2V0Qnl0ZXMocylbMF0gJiAweDgwKSA9PSAwLCBcIm5vbi1jYW5vbmljYWwgc1wiKTtcbiAgICAgICAgLy8gR2V0IHY7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCB7IG5ldHdvcmtWLCB2IH0gPSAoZnVuY3Rpb24gKF92LCB5UGFyaXR5QW5kUywgeVBhcml0eSkge1xuICAgICAgICAgICAgaWYgKF92ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gZ2V0QmlnSW50KF92KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrVjogKCh2ID49IEJOXzM1KSA/IHYgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB2OiBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYodilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihpc0hleFN0cmluZyh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdjogKChnZXRCeXRlcyh5UGFyaXR5QW5kUylbMF0gJiAweDgwKSA/IDI4IDogMjcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChnZXROdW1iZXIoeVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiB7IHY6IDI3IH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHsgdjogMjggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyB2XCIpO1xuICAgICAgICB9KShzaWcudiwgc2lnLnlQYXJpdHlBbmRTLCBzaWcueVBhcml0eSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCBzLCB2KTtcbiAgICAgICAgaWYgKG5ldHdvcmtWKSB7XG4gICAgICAgICAgICByZXN1bHQuI25ldHdvcmtWID0gbmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbXVsdGlwbGUgb2YgdiwgeVBhcml0eSwgeVBhcml0eUFuZFMgd2UgZ2l2ZW4sIGNoZWNrIHRoZXkgbWF0Y2hcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHkgPT0gbnVsbCB8fCBnZXROdW1iZXIoc2lnLnlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikgPT09IHJlc3VsdC55UGFyaXR5LCBcInlQYXJpdHkgbWlzbWF0Y2hcIik7XG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5QW5kUyA9PSBudWxsIHx8IHNpZy55UGFyaXR5QW5kUyA9PT0gcmVzdWx0LnlQYXJpdHlBbmRTLCBcInlQYXJpdHlBbmRTIG1pc21hdGNoXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/signature.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/crypto/signing-key.js":
/*!*******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/crypto/signing-key.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: function() { return /* binding */ SigningKey; }\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"../../node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _signature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signature.js */ \"../common/node_modules/ethers/lib.esm/crypto/signature.js\");\n/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */\n\n\n\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */\nclass SigningKey {\n    #privateKey;\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */\n    constructor(privateKey) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(privateKey);\n    }\n    /**\n     *  The private key.\n     */\n    get privateKey() { return this.#privateKey; }\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */\n    get publicKey() { return SigningKey.computePublicKey(this.#privateKey); }\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */\n    get compressedPublicKey() { return SigningKey.computePublicKey(this.#privateKey, true); }\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */\n    sign(digest) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.sign((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(digest), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(this.#privateKey), {\n            lowS: true\n        });\n        return _signature_js__WEBPACK_IMPORTED_MODULE_2__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(sig.r, 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(sig.s, 32),\n            v: (sig.recovery ? 0x1c : 0x1b)\n        });\n    }\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */\n    computeSharedSecret(other) {\n        const pubKey = SigningKey.computePublicKey(other);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.getSharedSecret((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(this.#privateKey), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(pubKey), false));\n    }\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */\n    static computePublicKey(key, compressed) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(key, \"key\");\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.getPublicKey(bytes, !!compressed);\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(pubKey);\n        }\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n        const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.ProjectivePoint.fromHex(bytes);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(point.toRawBytes(compressed));\n    }\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */\n    static recoverPublicKey(digest, signature) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _signature_js__WEBPACK_IMPORTED_MODULE_2__.Signature.from(signature);\n        let secpSig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.Signature.fromCompact((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([sig.r, sig.s])));\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\n        const pubKey = secpSig.recoverPublicKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(digest));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(pubKey != null, \"invalid signature for digest\", \"signature\", signature);\n        return \"0x\" + pubKey.toHex(false);\n    }\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */\n    static addPoints(p0, p1, compressed) {\n        const pub0 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_1__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n    }\n}\n//# sourceMappingURL=signing-key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2lnbmluZy1rZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDNkQ7QUFDdEU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLENBQUMsMkRBQVU7QUFDakMsMkJBQTJCLHdEQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWMsQ0FBQywyREFBVTtBQUNqQyxvQkFBb0IsOERBQVMsTUFBTSw2REFBWSxVQUFVLDZEQUFZO0FBQ3JFO0FBQ0EsU0FBUztBQUNULGVBQWUsb0RBQVM7QUFDeEIsZUFBZSx3REFBTztBQUN0QixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTyxDQUFDLDhEQUFTLGlCQUFpQiw2REFBWSxvQkFBb0IseURBQVE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFRO0FBQzVCO0FBQ0E7QUFDQSwyQkFBMkIsOERBQVM7QUFDcEMsbUJBQW1CLHdEQUFPO0FBQzFCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4REFBUztBQUMvQixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLENBQUMsMkRBQVU7QUFDakMsb0JBQW9CLG9EQUFTO0FBQzdCLHNCQUFzQiw4REFBUyx1QkFBdUIsNkRBQVksQ0FBQyx1REFBTTtBQUN6RTtBQUNBLGdEQUFnRCw2REFBWTtBQUM1RCxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFTO0FBQzlCLHFCQUFxQiw4REFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2lnbmluZy1rZXkuanM/NTIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBZGQgZGV0YWlscyBhYm91dCBzaWduaW5nIGhlcmUuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpTaWduaW5nICBbYWJvdXQtc2lnbmluZ11cbiAqL1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFMZW5ndGgsIGdldEJ5dGVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnksIHRvQmVIZXgsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi9zaWduYXR1cmUuanNcIjtcbi8qKlxuICogIEEgKipTaWduaW5nS2V5KiogcHJvdmlkZXMgaGlnaC1sZXZlbCBhY2Nlc3MgdG8gdGhlIGVsbGlwdGljIGN1cnZlXG4gKiAgY3J5cHRvZ3JhcGh5IChFQ0MpIG9wZXJhdGlvbnMgYW5kIGtleSBtYW5hZ2VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgU2lnbmluZ0tleSB7XG4gICAgI3ByaXZhdGVLZXk7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipTaWduaW5nS2V5KiogZm9yICUlcHJpdmF0ZUtleSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChwcml2YXRlS2V5KSA9PT0gMzIsIFwiaW52YWxpZCBwcml2YXRlIGtleVwiLCBcInByaXZhdGVLZXlcIiwgXCJbUkVEQUNURURdXCIpO1xuICAgICAgICB0aGlzLiNwcml2YXRlS2V5ID0gaGV4bGlmeShwcml2YXRlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcml2YXRlIGtleS5cbiAgICAgKi9cbiAgICBnZXQgcHJpdmF0ZUtleSgpIHsgcmV0dXJuIHRoaXMuI3ByaXZhdGVLZXk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGAweDA0YGAgYW5kIGJlIDEzMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZyAodGhlIGBgMHhgYCBwcmVmaXggYW5kIDEzMCBoZXhhZGVjaW1hbCBuaWJibGVzKS5cbiAgICAgKi9cbiAgICBnZXQgcHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXkpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIGVpdGhlciB0aGUgcHJlZml4IGBgMHgwMmBgIG9yIGBgMHgwM2BgXG4gICAgICogIGFuZCBiZSA2OCBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAzMyBoZXhhZGVjaW1hbFxuICAgICAqICBuaWJibGVzKVxuICAgICAqL1xuICAgIGdldCBjb21wcmVzc2VkUHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXksIHRydWUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgJSVkaWdlc3QlJS5cbiAgICAgKi9cbiAgICBzaWduKGRpZ2VzdCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICBjb25zdCBzaWcgPSBzZWNwMjU2azEuc2lnbihnZXRCeXRlc0NvcHkoZGlnZXN0KSwgZ2V0Qnl0ZXNDb3B5KHRoaXMuI3ByaXZhdGVLZXkpLCB7XG4gICAgICAgICAgICBsb3dTOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb20oe1xuICAgICAgICAgICAgcjogdG9CZUhleChzaWcuciwgMzIpLFxuICAgICAgICAgICAgczogdG9CZUhleChzaWcucywgMzIpLFxuICAgICAgICAgICAgdjogKHNpZy5yZWNvdmVyeSA/IDB4MWMgOiAweDFiKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFtbbGluay13aWtpLWVjZGhdXSBzaGFyZWQgc2VjcmV0IGJldHdlZW4gdGhpc1xuICAgICAqICBwcml2YXRlIGtleSBhbmQgdGhlICUlb3RoZXIlJSBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhlICUlb3RoZXIlJSBrZXkgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSxcbiAgICAgKiAgYSBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJpYyBrZXkgb3IgYXByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEJlc3QgcHJhY3RpY2UgaXMgdXN1YWxseSB0byB1c2UgYSBjcnlwdG9ncmFwaGljIGhhc2ggb24gdGhlXG4gICAgICogIHJldHVybmVkIHZhbHVlIGJlZm9yZSB1c2luZyBpdCBhcyBhIHN5bWV0cmljIHNlY3JldC5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBzaWduMSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXQtMVwiKSlcbiAgICAgKiAgICBzaWduMiA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXQtMlwiKSlcbiAgICAgKlxuICAgICAqICAgIC8vIE5vdGljZSB0aGF0IHByaXZBLmNvbXB1dGVTaGFyZWRTZWNyZXQocHViQikuLi5cbiAgICAgKiAgICBzaWduMS5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24yLnB1YmxpY0tleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyAuLi5pcyBlcXVhbCB0byBwcml2Qi5jb21wdXRlU2hhcmVkU2VjcmV0KHB1YkEpLlxuICAgICAqICAgIHNpZ24yLmNvbXB1dGVTaGFyZWRTZWNyZXQoc2lnbjEucHVibGljS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBjb21wdXRlU2hhcmVkU2VjcmV0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHB1YktleSA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShvdGhlcik7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHNlY3AyNTZrMS5nZXRTaGFyZWRTZWNyZXQoZ2V0Qnl0ZXNDb3B5KHRoaXMuI3ByaXZhdGVLZXkpLCBnZXRCeXRlcyhwdWJLZXkpLCBmYWxzZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgcHVibGljIGtleSBmb3IgJSVrZXklJSwgb3B0aW9uYWxseSAlJWNvbXByZXNzZWQlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVrZXklJSBtYXkgYmUgYW55IHR5cGUgb2Yga2V5LCBhIHJhdyBwdWJsaWMga2V5LCBhXG4gICAgICogIGNvbXByZXNzZWQvdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgb3IgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgc2lnbiA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXRcIikpO1xuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIGNvbXByZXNzZWQgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnByaXZhdGVLZXksIHRydWUpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIGZhbHNlKTtcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBDb21wcmVzc2VkIGEgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnB1YmxpY0tleSwgdHJ1ZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wdXRlUHVibGljS2V5KGtleSwgY29tcHJlc3NlZCkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBnZXRCeXRlcyhrZXksIFwia2V5XCIpO1xuICAgICAgICAvLyBwcml2YXRlIGtleVxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgICAgICAgICAgY29uc3QgcHViS2V5ID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShieXRlcywgISFjb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KHB1YktleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmF3IHB1YmxpYyBrZXk7IHVzZSB1bmNvbXByZXNzZWQga2V5IHdpdGggMHgwNCBwcmVmaXhcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YiA9IG5ldyBVaW50OEFycmF5KDY1KTtcbiAgICAgICAgICAgIHB1YlswXSA9IDB4MDQ7XG4gICAgICAgICAgICBwdWIuc2V0KGJ5dGVzLCAxKTtcbiAgICAgICAgICAgIGJ5dGVzID0gcHViO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkocG9pbnQudG9SYXdCeXRlcyhjb21wcmVzc2VkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwdWJsaWMga2V5IGZvciB0aGUgcHJpdmF0ZSBrZXkgd2hpY2ggcHJvZHVjZWQgdGhlXG4gICAgICogICUlc2lnbmF0dXJlJSUgZm9yIHRoZSBnaXZlbiAlJWRpZ2VzdCUlLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIGtleSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXRcIikpXG4gICAgICogICAgZGlnZXN0ID0gaWQoXCJoZWxsbyB3b3JsZFwiKVxuICAgICAqICAgIHNpZyA9IGtleS5zaWduKGRpZ2VzdClcbiAgICAgKlxuICAgICAqICAgIC8vIE5vdGljZSB0aGUgc2lnbmVyIHB1YmxpYyBrZXkuLi5cbiAgICAgKiAgICBrZXkucHVibGljS2V5XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gdGhlIHJlY292ZXJlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgoZGlnZXN0KSA9PT0gMzIsIFwiaW52YWxpZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSk7XG4gICAgICAgIGxldCBzZWNwU2lnID0gc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tQ29tcGFjdChnZXRCeXRlc0NvcHkoY29uY2F0KFtzaWcuciwgc2lnLnNdKSkpO1xuICAgICAgICBzZWNwU2lnID0gc2VjcFNpZy5hZGRSZWNvdmVyeUJpdChzaWcueVBhcml0eSk7XG4gICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3BTaWcucmVjb3ZlclB1YmxpY0tleShnZXRCeXRlc0NvcHkoZGlnZXN0KSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHB1YktleSAhPSBudWxsLCBcImludmFsaWQgc2lnbmF0dXJlIGZvciBkaWdlc3RcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHB1YktleS50b0hleChmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwb2ludCByZXN1bHRpbmcgZnJvbSBhZGRpbmcgdGhlIGVsbGlwaWMgY3VydmUgcG9pbnRzXG4gICAgICogICUlcDAlJSBhbmQgJSVwMSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGEgY29tbW9uIGZ1bmN0aW9uIG1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcmVxdWlyZSwgYnV0XG4gICAgICogIGNhbiBiZSB1c2VmdWwgZm9yIGNlcnRhaW4gcHJpdmFjeS1zcGVjaWZpYyB0ZWNobmlxdWVzLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBpdCBpcyB1c2VkIGJ5IFtbSEROb2RlV2FsbGV0XV0gdG8gY29tcHV0ZSBjaGlsZFxuICAgICAqICBhZGRyZXNzZXMgZnJvbSBwYXJlbnQgcHVibGljIGtleXMgYW5kIGNoYWluIGNvZGVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQb2ludHMocDAsIHAxLCBjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IHB1YjAgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAwKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICBjb25zdCBwdWIxID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMSkuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHB1YjAuYWRkKHB1YjEpLnRvSGV4KCEhY29tcHJlc3NlZCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmluZy1rZXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/crypto/signing-key.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/ethers.js":
/*!*******************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/ethers.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.AbiCoder; },\n/* harmony export */   AbstractProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.AbstractProvider; },\n/* harmony export */   AbstractSigner: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.AbstractSigner; },\n/* harmony export */   AlchemyProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.AlchemyProvider; },\n/* harmony export */   AnkrProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.AnkrProvider; },\n/* harmony export */   BaseContract: function() { return /* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.BaseContract; },\n/* harmony export */   BaseWallet: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.BaseWallet; },\n/* harmony export */   Block: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.Block; },\n/* harmony export */   BlockscoutProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.BlockscoutProvider; },\n/* harmony export */   BrowserProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.BrowserProvider; },\n/* harmony export */   ChainstackProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.ChainstackProvider; },\n/* harmony export */   CloudflareProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.CloudflareProvider; },\n/* harmony export */   ConstructorFragment: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.ConstructorFragment; },\n/* harmony export */   Contract: function() { return /* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.Contract; },\n/* harmony export */   ContractEventPayload: function() { return /* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.ContractEventPayload; },\n/* harmony export */   ContractFactory: function() { return /* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.ContractFactory; },\n/* harmony export */   ContractTransactionReceipt: function() { return /* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.ContractTransactionReceipt; },\n/* harmony export */   ContractTransactionResponse: function() { return /* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.ContractTransactionResponse; },\n/* harmony export */   ContractUnknownEventPayload: function() { return /* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.ContractUnknownEventPayload; },\n/* harmony export */   EnsPlugin: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.EnsPlugin; },\n/* harmony export */   EnsResolver: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.EnsResolver; },\n/* harmony export */   ErrorDescription: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.ErrorDescription; },\n/* harmony export */   ErrorFragment: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.ErrorFragment; },\n/* harmony export */   EtherSymbol: function() { return /* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.EtherSymbol; },\n/* harmony export */   EtherscanPlugin: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.EtherscanPlugin; },\n/* harmony export */   EtherscanProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.EtherscanProvider; },\n/* harmony export */   EventFragment: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.EventFragment; },\n/* harmony export */   EventLog: function() { return /* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.EventLog; },\n/* harmony export */   EventPayload: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.EventPayload; },\n/* harmony export */   FallbackFragment: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.FallbackFragment; },\n/* harmony export */   FallbackProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.FallbackProvider; },\n/* harmony export */   FeeData: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.FeeData; },\n/* harmony export */   FeeDataNetworkPlugin: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.FeeDataNetworkPlugin; },\n/* harmony export */   FetchCancelSignal: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchCancelSignal; },\n/* harmony export */   FetchRequest: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchRequest; },\n/* harmony export */   FetchResponse: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchResponse; },\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.FetchUrlFeeDataNetworkPlugin; },\n/* harmony export */   FixedNumber: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FixedNumber; },\n/* harmony export */   Fragment: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.Fragment; },\n/* harmony export */   FunctionFragment: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.FunctionFragment; },\n/* harmony export */   GasCostPlugin: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.GasCostPlugin; },\n/* harmony export */   HDNodeVoidWallet: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.HDNodeVoidWallet; },\n/* harmony export */   HDNodeWallet: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.HDNodeWallet; },\n/* harmony export */   Indexed: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.Indexed; },\n/* harmony export */   InfuraProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.InfuraProvider; },\n/* harmony export */   InfuraWebSocketProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.InfuraWebSocketProvider; },\n/* harmony export */   Interface: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.Interface; },\n/* harmony export */   IpcSocketProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.IpcSocketProvider; },\n/* harmony export */   JsonRpcApiProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.JsonRpcApiProvider; },\n/* harmony export */   JsonRpcProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.JsonRpcProvider; },\n/* harmony export */   JsonRpcSigner: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.JsonRpcSigner; },\n/* harmony export */   LangEn: function() { return /* reexport safe */ _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__.LangEn; },\n/* harmony export */   Log: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.Log; },\n/* harmony export */   LogDescription: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.LogDescription; },\n/* harmony export */   MaxInt256: function() { return /* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.MaxInt256; },\n/* harmony export */   MaxUint256: function() { return /* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.MaxUint256; },\n/* harmony export */   MessagePrefix: function() { return /* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.MessagePrefix; },\n/* harmony export */   MinInt256: function() { return /* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.MinInt256; },\n/* harmony export */   Mnemonic: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.Mnemonic; },\n/* harmony export */   MulticoinProviderPlugin: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.MulticoinProviderPlugin; },\n/* harmony export */   N: function() { return /* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.N; },\n/* harmony export */   NamedFragment: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.NamedFragment; },\n/* harmony export */   Network: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.Network; },\n/* harmony export */   NetworkPlugin: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.NetworkPlugin; },\n/* harmony export */   NonceManager: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.NonceManager; },\n/* harmony export */   ParamType: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.ParamType; },\n/* harmony export */   PocketProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.PocketProvider; },\n/* harmony export */   QuickNodeProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.QuickNodeProvider; },\n/* harmony export */   Result: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.Result; },\n/* harmony export */   Signature: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature; },\n/* harmony export */   SigningKey: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.SigningKey; },\n/* harmony export */   SocketBlockSubscriber: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.SocketBlockSubscriber; },\n/* harmony export */   SocketEventSubscriber: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.SocketEventSubscriber; },\n/* harmony export */   SocketPendingSubscriber: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.SocketPendingSubscriber; },\n/* harmony export */   SocketProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.SocketProvider; },\n/* harmony export */   SocketSubscriber: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.SocketSubscriber; },\n/* harmony export */   StructFragment: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.StructFragment; },\n/* harmony export */   Transaction: function() { return /* reexport safe */ _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.Transaction; },\n/* harmony export */   TransactionDescription: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.TransactionDescription; },\n/* harmony export */   TransactionReceipt: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.TransactionReceipt; },\n/* harmony export */   TransactionResponse: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.TransactionResponse; },\n/* harmony export */   Typed: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.Typed; },\n/* harmony export */   TypedDataEncoder: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.TypedDataEncoder; },\n/* harmony export */   UndecodedEventLog: function() { return /* reexport safe */ _contract_index_js__WEBPACK_IMPORTED_MODULE_4__.UndecodedEventLog; },\n/* harmony export */   UnmanagedSubscriber: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.UnmanagedSubscriber; },\n/* harmony export */   Utf8ErrorFuncs: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.Utf8ErrorFuncs; },\n/* harmony export */   VoidSigner: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.VoidSigner; },\n/* harmony export */   Wallet: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.Wallet; },\n/* harmony export */   WebSocketProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.WebSocketProvider; },\n/* harmony export */   WeiPerEther: function() { return /* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.WeiPerEther; },\n/* harmony export */   Wordlist: function() { return /* reexport safe */ _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__.Wordlist; },\n/* harmony export */   WordlistOwl: function() { return /* reexport safe */ _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__.WordlistOwl; },\n/* harmony export */   WordlistOwlA: function() { return /* reexport safe */ _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__.WordlistOwlA; },\n/* harmony export */   ZeroAddress: function() { return /* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroAddress; },\n/* harmony export */   ZeroHash: function() { return /* reexport safe */ _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash; },\n/* harmony export */   accessListify: function() { return /* reexport safe */ _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.accessListify; },\n/* harmony export */   assert: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.assert; },\n/* harmony export */   assertArgument: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.assertArgument; },\n/* harmony export */   assertArgumentCount: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.assertArgumentCount; },\n/* harmony export */   assertNormalize: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.assertNormalize; },\n/* harmony export */   assertPrivate: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.assertPrivate; },\n/* harmony export */   authorizationify: function() { return /* reexport safe */ _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.authorizationify; },\n/* harmony export */   checkResultErrors: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.checkResultErrors; },\n/* harmony export */   computeAddress: function() { return /* reexport safe */ _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.computeAddress; },\n/* harmony export */   computeHmac: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.computeHmac; },\n/* harmony export */   concat: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.concat; },\n/* harmony export */   copyRequest: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.copyRequest; },\n/* harmony export */   dataLength: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.dataLength; },\n/* harmony export */   dataSlice: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.dataSlice; },\n/* harmony export */   decodeBase58: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.decodeBase58; },\n/* harmony export */   decodeBase64: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.decodeBase64; },\n/* harmony export */   decodeBytes32String: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.decodeBytes32String; },\n/* harmony export */   decodeRlp: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.decodeRlp; },\n/* harmony export */   decryptCrowdsaleJson: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.decryptCrowdsaleJson; },\n/* harmony export */   decryptKeystoreJson: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.decryptKeystoreJson; },\n/* harmony export */   decryptKeystoreJsonSync: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.decryptKeystoreJsonSync; },\n/* harmony export */   defaultPath: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.defaultPath; },\n/* harmony export */   defineProperties: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.defineProperties; },\n/* harmony export */   dnsEncode: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.dnsEncode; },\n/* harmony export */   encodeBase58: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.encodeBase58; },\n/* harmony export */   encodeBase64: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.encodeBase64; },\n/* harmony export */   encodeBytes32String: function() { return /* reexport safe */ _abi_index_js__WEBPACK_IMPORTED_MODULE_1__.encodeBytes32String; },\n/* harmony export */   encodeRlp: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.encodeRlp; },\n/* harmony export */   encryptKeystoreJson: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.encryptKeystoreJson; },\n/* harmony export */   encryptKeystoreJsonSync: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.encryptKeystoreJsonSync; },\n/* harmony export */   ensNormalize: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.ensNormalize; },\n/* harmony export */   formatEther: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.formatEther; },\n/* harmony export */   formatUnits: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.formatUnits; },\n/* harmony export */   fromTwos: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.fromTwos; },\n/* harmony export */   getAccountPath: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.getAccountPath; },\n/* harmony export */   getAddress: function() { return /* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress; },\n/* harmony export */   getBigInt: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt; },\n/* harmony export */   getBytes: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBytes; },\n/* harmony export */   getBytesCopy: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBytesCopy; },\n/* harmony export */   getCreate2Address: function() { return /* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getCreate2Address; },\n/* harmony export */   getCreateAddress: function() { return /* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getCreateAddress; },\n/* harmony export */   getDefaultProvider: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.getDefaultProvider; },\n/* harmony export */   getIcapAddress: function() { return /* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getIcapAddress; },\n/* harmony export */   getIndexedAccountPath: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.getIndexedAccountPath; },\n/* harmony export */   getNumber: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber; },\n/* harmony export */   getUint: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getUint; },\n/* harmony export */   hashAuthorization: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.hashAuthorization; },\n/* harmony export */   hashMessage: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.hashMessage; },\n/* harmony export */   hexlify: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.hexlify; },\n/* harmony export */   id: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.id; },\n/* harmony export */   isAddress: function() { return /* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.isAddress; },\n/* harmony export */   isAddressable: function() { return /* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.isAddressable; },\n/* harmony export */   isBytesLike: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.isBytesLike; },\n/* harmony export */   isCallException: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.isCallException; },\n/* harmony export */   isCrowdsaleJson: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.isCrowdsaleJson; },\n/* harmony export */   isError: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.isError; },\n/* harmony export */   isHexString: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.isHexString; },\n/* harmony export */   isKeystoreJson: function() { return /* reexport safe */ _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__.isKeystoreJson; },\n/* harmony export */   isValidName: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.isValidName; },\n/* harmony export */   keccak256: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.keccak256; },\n/* harmony export */   lock: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.lock; },\n/* harmony export */   makeError: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.makeError; },\n/* harmony export */   mask: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.mask; },\n/* harmony export */   namehash: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.namehash; },\n/* harmony export */   parseEther: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.parseEther; },\n/* harmony export */   parseUnits: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.parseUnits; },\n/* harmony export */   pbkdf2: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.pbkdf2; },\n/* harmony export */   randomBytes: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.randomBytes; },\n/* harmony export */   recoverAddress: function() { return /* reexport safe */ _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.recoverAddress; },\n/* harmony export */   resolveAddress: function() { return /* reexport safe */ _address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress; },\n/* harmony export */   resolveProperties: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.resolveProperties; },\n/* harmony export */   ripemd160: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.ripemd160; },\n/* harmony export */   scrypt: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.scrypt; },\n/* harmony export */   scryptSync: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.scryptSync; },\n/* harmony export */   sha256: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.sha256; },\n/* harmony export */   sha512: function() { return /* reexport safe */ _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.sha512; },\n/* harmony export */   showThrottleMessage: function() { return /* reexport safe */ _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.showThrottleMessage; },\n/* harmony export */   solidityPacked: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.solidityPacked; },\n/* harmony export */   solidityPackedKeccak256: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.solidityPackedKeccak256; },\n/* harmony export */   solidityPackedSha256: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.solidityPackedSha256; },\n/* harmony export */   stripZerosLeft: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.stripZerosLeft; },\n/* harmony export */   toBeArray: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeArray; },\n/* harmony export */   toBeHex: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeHex; },\n/* harmony export */   toBigInt: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBigInt; },\n/* harmony export */   toNumber: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toNumber; },\n/* harmony export */   toQuantity: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toQuantity; },\n/* harmony export */   toTwos: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toTwos; },\n/* harmony export */   toUtf8Bytes: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toUtf8Bytes; },\n/* harmony export */   toUtf8CodePoints: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toUtf8CodePoints; },\n/* harmony export */   toUtf8String: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toUtf8String; },\n/* harmony export */   uuidV4: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.uuidV4; },\n/* harmony export */   verifyAuthorization: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.verifyAuthorization; },\n/* harmony export */   verifyMessage: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.verifyMessage; },\n/* harmony export */   verifyTypedData: function() { return /* reexport safe */ _hash_index_js__WEBPACK_IMPORTED_MODULE_6__.verifyTypedData; },\n/* harmony export */   version: function() { return /* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_0__.version; },\n/* harmony export */   wordlists: function() { return /* reexport safe */ _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__.wordlists; },\n/* harmony export */   zeroPadBytes: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.zeroPadBytes; },\n/* harmony export */   zeroPadValue: function() { return /* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.zeroPadValue; }\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version.js */ \"../common/node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abi/index.js */ \"../common/node_modules/ethers/lib.esm/abi/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants/index.js */ \"../common/node_modules/ethers/lib.esm/constants/index.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contract/index.js */ \"../common/node_modules/ethers/lib.esm/contract/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hash/index.js */ \"../common/node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _providers_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./providers/index.js */ \"../common/node_modules/ethers/lib.esm/providers/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _wallet_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./wallet/index.js */ \"../common/node_modules/ethers/lib.esm/wallet/index.js\");\n/* harmony import */ var _wordlists_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./wordlists/index.js */ \"../common/node_modules/ethers/lib.esm/wordlists/index.js\");\n/////////////////////////////\n//\n\n\n\n\n\n\n\n\n\n\n\n\n// dummy change; to pick-up ws security issue changes\n//# sourceMappingURL=ethers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9ldGhlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDd0M7QUFDd1M7QUFDak07QUFDSjtBQUM0RTtBQUMzRDtBQUMrRjtBQUM2aUI7QUFDbHJCO0FBQ3FrQjtBQUNsWjtBQUMzTTtBQUM5RixpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vZXRoZXJzLmpzPzNhYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG5leHBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb24uanNcIjtcbmV4cG9ydCB7IGRlY29kZUJ5dGVzMzJTdHJpbmcsIGVuY29kZUJ5dGVzMzJTdHJpbmcsIEFiaUNvZGVyLCBDb25zdHJ1Y3RvckZyYWdtZW50LCBFcnJvckZyYWdtZW50LCBFdmVudEZyYWdtZW50LCBGcmFnbWVudCwgRmFsbGJhY2tGcmFnbWVudCwgRnVuY3Rpb25GcmFnbWVudCwgTmFtZWRGcmFnbWVudCwgUGFyYW1UeXBlLCBTdHJ1Y3RGcmFnbWVudCwgY2hlY2tSZXN1bHRFcnJvcnMsIEVycm9yRGVzY3JpcHRpb24sIEluZGV4ZWQsIEludGVyZmFjZSwgTG9nRGVzY3JpcHRpb24sIFJlc3VsdCwgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiwgVHlwZWQsIH0gZnJvbSBcIi4vYWJpL2luZGV4LmpzXCI7XG5leHBvcnQgeyBnZXRBZGRyZXNzLCBnZXRJY2FwQWRkcmVzcywgZ2V0Q3JlYXRlQWRkcmVzcywgZ2V0Q3JlYXRlMkFkZHJlc3MsIGlzQWRkcmVzc2FibGUsIGlzQWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5leHBvcnQgeyBaZXJvQWRkcmVzcywgV2VpUGVyRXRoZXIsIE1heFVpbnQyNTYsIE1pbkludDI1NiwgTWF4SW50MjU2LCBOLCBaZXJvSGFzaCwgRXRoZXJTeW1ib2wsIE1lc3NhZ2VQcmVmaXggfSBmcm9tIFwiLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmV4cG9ydCB7IEJhc2VDb250cmFjdCwgQ29udHJhY3QsIENvbnRyYWN0RmFjdG9yeSwgQ29udHJhY3RFdmVudFBheWxvYWQsIENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0LCBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UsIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCwgRXZlbnRMb2csIFVuZGVjb2RlZEV2ZW50TG9nIH0gZnJvbSBcIi4vY29udHJhY3QvaW5kZXguanNcIjtcbmV4cG9ydCB7IGNvbXB1dGVIbWFjLCByYW5kb21CeXRlcywga2VjY2FrMjU2LCByaXBlbWQxNjAsIHNoYTI1Niwgc2hhNTEyLCBwYmtkZjIsIHNjcnlwdCwgc2NyeXB0U3luYywgbG9jaywgU2lnbmF0dXJlLCBTaWduaW5nS2V5IH0gZnJvbSBcIi4vY3J5cHRvL2luZGV4LmpzXCI7XG5leHBvcnQgeyBpZCwgZW5zTm9ybWFsaXplLCBpc1ZhbGlkTmFtZSwgbmFtZWhhc2gsIGRuc0VuY29kZSwgaGFzaEF1dGhvcml6YXRpb24sIHZlcmlmeUF1dGhvcml6YXRpb24sIGhhc2hNZXNzYWdlLCB2ZXJpZnlNZXNzYWdlLCBzb2xpZGl0eVBhY2tlZCwgc29saWRpdHlQYWNrZWRLZWNjYWsyNTYsIHNvbGlkaXR5UGFja2VkU2hhMjU2LCBUeXBlZERhdGFFbmNvZGVyLCB2ZXJpZnlUeXBlZERhdGEgfSBmcm9tIFwiLi9oYXNoL2luZGV4LmpzXCI7XG5leHBvcnQgeyBnZXREZWZhdWx0UHJvdmlkZXIsIEJsb2NrLCBGZWVEYXRhLCBMb2csIFRyYW5zYWN0aW9uUmVjZWlwdCwgVHJhbnNhY3Rpb25SZXNwb25zZSwgQWJzdHJhY3RTaWduZXIsIE5vbmNlTWFuYWdlciwgVm9pZFNpZ25lciwgQWJzdHJhY3RQcm92aWRlciwgRmFsbGJhY2tQcm92aWRlciwgSnNvblJwY0FwaVByb3ZpZGVyLCBKc29uUnBjUHJvdmlkZXIsIEpzb25ScGNTaWduZXIsIEJyb3dzZXJQcm92aWRlciwgQWxjaGVteVByb3ZpZGVyLCBBbmtyUHJvdmlkZXIsIEJsb2Nrc2NvdXRQcm92aWRlciwgQ2hhaW5zdGFja1Byb3ZpZGVyLCBDbG91ZGZsYXJlUHJvdmlkZXIsIEV0aGVyc2NhblByb3ZpZGVyLCBJbmZ1cmFQcm92aWRlciwgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIsIFBvY2tldFByb3ZpZGVyLCBRdWlja05vZGVQcm92aWRlciwgSXBjU29ja2V0UHJvdmlkZXIsIFNvY2tldFByb3ZpZGVyLCBXZWJTb2NrZXRQcm92aWRlciwgRW5zUmVzb2x2ZXIsIE5ldHdvcmssIEVuc1BsdWdpbiwgRXRoZXJzY2FuUGx1Z2luLCBGZWVEYXRhTmV0d29ya1BsdWdpbiwgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiwgR2FzQ29zdFBsdWdpbiwgTmV0d29ya1BsdWdpbiwgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4sIFNvY2tldEJsb2NrU3Vic2NyaWJlciwgU29ja2V0RXZlbnRTdWJzY3JpYmVyLCBTb2NrZXRQZW5kaW5nU3Vic2NyaWJlciwgU29ja2V0U3Vic2NyaWJlciwgVW5tYW5hZ2VkU3Vic2NyaWJlciwgY29weVJlcXVlc3QsIHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9wcm92aWRlcnMvaW5kZXguanNcIjtcbmV4cG9ydCB7IGFjY2Vzc0xpc3RpZnksIGF1dGhvcml6YXRpb25pZnksIGNvbXB1dGVBZGRyZXNzLCByZWNvdmVyQWRkcmVzcywgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHsgZGVjb2RlQmFzZTU4LCBlbmNvZGVCYXNlNTgsIGRlY29kZUJhc2U2NCwgZW5jb2RlQmFzZTY0LCBjb25jYXQsIGRhdGFMZW5ndGgsIGRhdGFTbGljZSwgZ2V0Qnl0ZXMsIGdldEJ5dGVzQ29weSwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIGlzQnl0ZXNMaWtlLCBzdHJpcFplcm9zTGVmdCwgemVyb1BhZEJ5dGVzLCB6ZXJvUGFkVmFsdWUsIGRlZmluZVByb3BlcnRpZXMsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRBcmd1bWVudENvdW50LCBhc3NlcnROb3JtYWxpemUsIGFzc2VydFByaXZhdGUsIG1ha2VFcnJvciwgaXNDYWxsRXhjZXB0aW9uLCBpc0Vycm9yLCBFdmVudFBheWxvYWQsIEZldGNoUmVxdWVzdCwgRmV0Y2hSZXNwb25zZSwgRmV0Y2hDYW5jZWxTaWduYWwsIEZpeGVkTnVtYmVyLCBnZXRCaWdJbnQsIGdldE51bWJlciwgZ2V0VWludCwgdG9CZUFycmF5LCB0b0JpZ0ludCwgdG9CZUhleCwgdG9OdW1iZXIsIHRvUXVhbnRpdHksIGZyb21Ud29zLCB0b1R3b3MsIG1hc2ssIGZvcm1hdEV0aGVyLCBwYXJzZUV0aGVyLCBmb3JtYXRVbml0cywgcGFyc2VVbml0cywgdG9VdGY4Qnl0ZXMsIHRvVXRmOENvZGVQb2ludHMsIHRvVXRmOFN0cmluZywgVXRmOEVycm9yRnVuY3MsIGRlY29kZVJscCwgZW5jb2RlUmxwLCB1dWlkVjQsIH0gZnJvbSBcIi4vdXRpbHMvaW5kZXguanNcIjtcbmV4cG9ydCB7IE1uZW1vbmljLCBCYXNlV2FsbGV0LCBIRE5vZGVXYWxsZXQsIEhETm9kZVZvaWRXYWxsZXQsIFdhbGxldCwgZGVmYXVsdFBhdGgsIGdldEFjY291bnRQYXRoLCBnZXRJbmRleGVkQWNjb3VudFBhdGgsIGlzQ3Jvd2RzYWxlSnNvbiwgaXNLZXlzdG9yZUpzb24sIGRlY3J5cHRDcm93ZHNhbGVKc29uLCBkZWNyeXB0S2V5c3RvcmVKc29uU3luYywgZGVjcnlwdEtleXN0b3JlSnNvbiwgZW5jcnlwdEtleXN0b3JlSnNvbiwgZW5jcnlwdEtleXN0b3JlSnNvblN5bmMsIH0gZnJvbSBcIi4vd2FsbGV0L2luZGV4LmpzXCI7XG5leHBvcnQgeyBXb3JkbGlzdCwgTGFuZ0VuLCBXb3JkbGlzdE93bCwgV29yZGxpc3RPd2xBLCB3b3JkbGlzdHMgfSBmcm9tIFwiLi93b3JkbGlzdHMvaW5kZXguanNcIjtcbi8vIGR1bW15IGNoYW5nZTsgdG8gcGljay11cCB3cyBzZWN1cml0eSBpc3N1ZSBjaGFuZ2VzXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldGhlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/ethers.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/hash/authorization.js":
/*!*******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/hash/authorization.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashAuthorization: function() { return /* binding */ hashAuthorization; },\n/* harmony export */   verifyAuthorization: function() { return /* binding */ verifyAuthorization; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\n\n\n/**\n *  Computes the [[link-eip-7702]] authorization digest to sign.\n */\nfunction hashAuthorization(auth) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (auth.address) === \"string\", \"invalid address for hashAuthorization\", \"auth.address\", auth);\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x05\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)([\n            (auth.chainId != null) ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(auth.chainId) : \"0x\",\n            (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(auth.address),\n            (auth.nonce != null) ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(auth.nonce) : \"0x\",\n        ])\n    ]));\n}\n/**\n *  Return the address of the private key that produced\n *  the signature %%sig%% during signing for %%message%%.\n */\nfunction verifyAuthorization(auth, sig) {\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.recoverAddress)(hashAuthorization(auth), sig);\n}\n//# sourceMappingURL=authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL2F1dGhvcml6YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlEO0FBQ0Y7QUFDVTtBQUN3QjtBQUNqRjtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksK0RBQWM7QUFDbEIsV0FBVywyREFBUyxDQUFDLHVEQUFNO0FBQzNCLGdCQUFnQiwwREFBUztBQUN6QixxQ0FBcUMsMERBQVM7QUFDOUMsWUFBWSw2REFBVTtBQUN0QixtQ0FBbUMsMERBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcscUVBQWM7QUFDekI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL2F1dGhvcml6YXRpb24uanM/MTQ1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgY29uY2F0LCBlbmNvZGVSbHAsIHRvQmVBcnJheSB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQ29tcHV0ZXMgdGhlIFtbbGluay1laXAtNzcwMl1dIGF1dGhvcml6YXRpb24gZGlnZXN0IHRvIHNpZ24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoQXV0aG9yaXphdGlvbihhdXRoKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhdXRoLmFkZHJlc3MpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgYWRkcmVzcyBmb3IgaGFzaEF1dGhvcml6YXRpb25cIiwgXCJhdXRoLmFkZHJlc3NcIiwgYXV0aCk7XG4gICAgcmV0dXJuIGtlY2NhazI1Nihjb25jYXQoW1xuICAgICAgICBcIjB4MDVcIiwgZW5jb2RlUmxwKFtcbiAgICAgICAgICAgIChhdXRoLmNoYWluSWQgIT0gbnVsbCkgPyB0b0JlQXJyYXkoYXV0aC5jaGFpbklkKSA6IFwiMHhcIixcbiAgICAgICAgICAgIGdldEFkZHJlc3MoYXV0aC5hZGRyZXNzKSxcbiAgICAgICAgICAgIChhdXRoLm5vbmNlICE9IG51bGwpID8gdG9CZUFycmF5KGF1dGgubm9uY2UpIDogXCIweFwiLFxuICAgICAgICBdKVxuICAgIF0pKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgYWRkcmVzcyBvZiB0aGUgcHJpdmF0ZSBrZXkgdGhhdCBwcm9kdWNlZFxuICogIHRoZSBzaWduYXR1cmUgJSVzaWclJSBkdXJpbmcgc2lnbmluZyBmb3IgJSVtZXNzYWdlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlBdXRob3JpemF0aW9uKGF1dGgsIHNpZykge1xuICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyhoYXNoQXV0aG9yaXphdGlvbihhdXRoKSwgc2lnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/hash/authorization.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/hash/id.js":
/*!********************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/hash/id.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: function() { return /* binding */ id; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */\nfunction id(value) {\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n}\n//# sourceMappingURL=id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL2lkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsMkRBQVMsQ0FBQyw0REFBVztBQUNoQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvaWQuanM/YzBkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQSBzaW1wbGUgaGFzaGluZyBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiBVVEYtOCBzdHJpbmdzIHRvXG4gKiAgY29tcHV0ZSBhbiAzMi1ieXRlIGlkZW50aWZpZXIuXG4gKlxuICogIFRoaXMgc2ltcGx5IGNvbXB1dGVzIHRoZSBbVVRGLTggYnl0ZXNdKHRvVXRmOEJ5dGVzKSBhbmQgY29tcHV0ZXNcbiAqICB0aGUgW1trZWNjYWsyNTZdXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBpZChcImhlbGxvIHdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZCh2YWx1ZSkge1xuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModmFsdWUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/hash/id.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/hash/index.js":
/*!***********************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/hash/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: function() { return /* reexport safe */ _typed_data_js__WEBPACK_IMPORTED_MODULE_5__.TypedDataEncoder; },\n/* harmony export */   dnsEncode: function() { return /* reexport safe */ _namehash_js__WEBPACK_IMPORTED_MODULE_2__.dnsEncode; },\n/* harmony export */   ensNormalize: function() { return /* reexport safe */ _namehash_js__WEBPACK_IMPORTED_MODULE_2__.ensNormalize; },\n/* harmony export */   hashAuthorization: function() { return /* reexport safe */ _authorization_js__WEBPACK_IMPORTED_MODULE_0__.hashAuthorization; },\n/* harmony export */   hashMessage: function() { return /* reexport safe */ _message_js__WEBPACK_IMPORTED_MODULE_3__.hashMessage; },\n/* harmony export */   id: function() { return /* reexport safe */ _id_js__WEBPACK_IMPORTED_MODULE_1__.id; },\n/* harmony export */   isValidName: function() { return /* reexport safe */ _namehash_js__WEBPACK_IMPORTED_MODULE_2__.isValidName; },\n/* harmony export */   namehash: function() { return /* reexport safe */ _namehash_js__WEBPACK_IMPORTED_MODULE_2__.namehash; },\n/* harmony export */   solidityPacked: function() { return /* reexport safe */ _solidity_js__WEBPACK_IMPORTED_MODULE_4__.solidityPacked; },\n/* harmony export */   solidityPackedKeccak256: function() { return /* reexport safe */ _solidity_js__WEBPACK_IMPORTED_MODULE_4__.solidityPackedKeccak256; },\n/* harmony export */   solidityPackedSha256: function() { return /* reexport safe */ _solidity_js__WEBPACK_IMPORTED_MODULE_4__.solidityPackedSha256; },\n/* harmony export */   verifyAuthorization: function() { return /* reexport safe */ _authorization_js__WEBPACK_IMPORTED_MODULE_0__.verifyAuthorization; },\n/* harmony export */   verifyMessage: function() { return /* reexport safe */ _message_js__WEBPACK_IMPORTED_MODULE_3__.verifyMessage; },\n/* harmony export */   verifyTypedData: function() { return /* reexport safe */ _typed_data_js__WEBPACK_IMPORTED_MODULE_5__.verifyTypedData; }\n/* harmony export */ });\n/* harmony import */ var _authorization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./authorization.js */ \"../common/node_modules/ethers/lib.esm/hash/authorization.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./id.js */ \"../common/node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _namehash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./namehash.js */ \"../common/node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _message_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message.js */ \"../common/node_modules/ethers/lib.esm/hash/message.js\");\n/* harmony import */ var _solidity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./solidity.js */ \"../common/node_modules/ethers/lib.esm/hash/solidity.js\");\n/* harmony import */ var _typed_data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typed-data.js */ \"../common/node_modules/ethers/lib.esm/hash/typed-data.js\");\n/**\n *  Utilities for common tasks involving hashing. Also see\n *  [cryptographic hashing](about-crypto-hashing).\n *\n *  @_section: api/hashing:Hashing Utilities  [about-hashing]\n */\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRFO0FBQy9DO0FBQ2tEO0FBQ3JCO0FBQ29DO0FBQzFCO0FBQ3BFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvaW5kZXguanM/YjhjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBVdGlsaXRpZXMgZm9yIGNvbW1vbiB0YXNrcyBpbnZvbHZpbmcgaGFzaGluZy4gQWxzbyBzZWVcbiAqICBbY3J5cHRvZ3JhcGhpYyBoYXNoaW5nXShhYm91dC1jcnlwdG8taGFzaGluZykuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL2hhc2hpbmc6SGFzaGluZyBVdGlsaXRpZXMgIFthYm91dC1oYXNoaW5nXVxuICovXG5leHBvcnQgeyBoYXNoQXV0aG9yaXphdGlvbiwgdmVyaWZ5QXV0aG9yaXphdGlvbiB9IGZyb20gXCIuL2F1dGhvcml6YXRpb24uanNcIjtcbmV4cG9ydCB7IGlkIH0gZnJvbSBcIi4vaWQuanNcIjtcbmV4cG9ydCB7IGVuc05vcm1hbGl6ZSwgaXNWYWxpZE5hbWUsIG5hbWVoYXNoLCBkbnNFbmNvZGUgfSBmcm9tIFwiLi9uYW1laGFzaC5qc1wiO1xuZXhwb3J0IHsgaGFzaE1lc3NhZ2UsIHZlcmlmeU1lc3NhZ2UgfSBmcm9tIFwiLi9tZXNzYWdlLmpzXCI7XG5leHBvcnQgeyBzb2xpZGl0eVBhY2tlZCwgc29saWRpdHlQYWNrZWRLZWNjYWsyNTYsIHNvbGlkaXR5UGFja2VkU2hhMjU2IH0gZnJvbSBcIi4vc29saWRpdHkuanNcIjtcbmV4cG9ydCB7IFR5cGVkRGF0YUVuY29kZXIsIHZlcmlmeVR5cGVkRGF0YSB9IGZyb20gXCIuL3R5cGVkLWRhdGEuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/hash/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/hash/message.js":
/*!*************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/hash/message.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashMessage: function() { return /* binding */ hashMessage; },\n/* harmony export */   verifyMessage: function() { return /* binding */ verifyMessage; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/index.js */ \"../common/node_modules/ethers/lib.esm/constants/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\n\n\n/**\n *  Computes the [[link-eip-191]] personal-sign message digest to sign.\n *\n *  This prefixes the message with [[MessagePrefix]] and the decimal length\n *  of %%message%% and computes the [[keccak256]] digest.\n *\n *  If %%message%% is a string, it is converted to its UTF-8 bytes\n *  first. To compute the digest of a [[DataHexString]], it must be converted\n *  to [bytes](getBytes).\n *\n *  @example:\n *    hashMessage(\"Hello World\")\n *    //_result:\n *\n *    // Hashes the SIX (6) string characters, i.e.\n *    // [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\n *    hashMessage(\"0x4243\")\n *    //_result:\n *\n *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\n *    hashMessage(getBytes(\"0x4243\"))\n *    //_result:\n *\n *    // ...which is equal to using data\n *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))\n *    //_result:\n *\n */\nfunction hashMessage(message) {\n    if (typeof (message) === \"string\") {\n        message = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(message);\n    }\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(_constants_index_js__WEBPACK_IMPORTED_MODULE_2__.MessagePrefix),\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(String(message.length)),\n        message\n    ]));\n}\n/**\n *  Return the address of the private key that produced\n *  the signature %%sig%% during signing for %%message%%.\n */\nfunction verifyMessage(message, sig) {\n    const digest = hashMessage(message);\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.recoverAddress)(digest, sig);\n}\n//# sourceMappingURL=message.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL21lc3NhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStDO0FBQ087QUFDRztBQUNEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQiw0REFBVztBQUM3QjtBQUNBLFdBQVcsMkRBQVMsQ0FBQyx1REFBTTtBQUMzQixRQUFRLDREQUFXLENBQUMsOERBQWE7QUFDakMsUUFBUSw0REFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxXQUFXLHFFQUFjO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9tZXNzYWdlLmpzPzIwOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTWVzc2FnZVByZWZpeCB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBDb21wdXRlcyB0aGUgW1tsaW5rLWVpcC0xOTFdXSBwZXJzb25hbC1zaWduIG1lc3NhZ2UgZGlnZXN0IHRvIHNpZ24uXG4gKlxuICogIFRoaXMgcHJlZml4ZXMgdGhlIG1lc3NhZ2Ugd2l0aCBbW01lc3NhZ2VQcmVmaXhdXSBhbmQgdGhlIGRlY2ltYWwgbGVuZ3RoXG4gKiAgb2YgJSVtZXNzYWdlJSUgYW5kIGNvbXB1dGVzIHRoZSBbW2tlY2NhazI1Nl1dIGRpZ2VzdC5cbiAqXG4gKiAgSWYgJSVtZXNzYWdlJSUgaXMgYSBzdHJpbmcsIGl0IGlzIGNvbnZlcnRlZCB0byBpdHMgVVRGLTggYnl0ZXNcbiAqICBmaXJzdC4gVG8gY29tcHV0ZSB0aGUgZGlnZXN0IG9mIGEgW1tEYXRhSGV4U3RyaW5nXV0sIGl0IG11c3QgYmUgY29udmVydGVkXG4gKiAgdG8gW2J5dGVzXShnZXRCeXRlcykuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgaGFzaE1lc3NhZ2UoXCJIZWxsbyBXb3JsZFwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEhhc2hlcyB0aGUgU0lYICg2KSBzdHJpbmcgY2hhcmFjdGVycywgaS5lLlxuICogICAgLy8gWyBcIjBcIiwgXCJ4XCIsIFwiNFwiLCBcIjJcIiwgXCI0XCIsIFwiM1wiIF1cbiAqICAgIGhhc2hNZXNzYWdlKFwiMHg0MjQzXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSGFzaGVzIHRoZSBUV08gKDIpIGJ5dGVzIFsgMHg0MiwgMHg0MyBdLi4uXG4gKiAgICBoYXNoTWVzc2FnZShnZXRCeXRlcyhcIjB4NDI0M1wiKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyAuLi53aGljaCBpcyBlcXVhbCB0byB1c2luZyBkYXRhXG4gKiAgICBoYXNoTWVzc2FnZShuZXcgVWludDhBcnJheShbIDB4NDIsIDB4NDMgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0b1V0ZjhCeXRlcyhtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIGtlY2NhazI1Nihjb25jYXQoW1xuICAgICAgICB0b1V0ZjhCeXRlcyhNZXNzYWdlUHJlZml4KSxcbiAgICAgICAgdG9VdGY4Qnl0ZXMoU3RyaW5nKG1lc3NhZ2UubGVuZ3RoKSksXG4gICAgICAgIG1lc3NhZ2VcbiAgICBdKSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIGFkZHJlc3Mgb2YgdGhlIHByaXZhdGUga2V5IHRoYXQgcHJvZHVjZWRcbiAqICB0aGUgc2lnbmF0dXJlICUlc2lnJSUgZHVyaW5nIHNpZ25pbmcgZm9yICUlbWVzc2FnZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZShtZXNzYWdlLCBzaWcpIHtcbiAgICBjb25zdCBkaWdlc3QgPSBoYXNoTWVzc2FnZShtZXNzYWdlKTtcbiAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/hash/message.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/hash/namehash.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/hash/namehash.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: function() { return /* binding */ dnsEncode; },\n/* harmony export */   ensNormalize: function() { return /* binding */ ensNormalize; },\n/* harmony export */   isValidName: function() { return /* binding */ isValidName; },\n/* harmony export */   namehash: function() { return /* binding */ namehash; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"../../node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n\n\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(ensNormalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */\nfunction ensNormalize(name) {\n    try {\n        if (name.length === 0) {\n            throw new Error(\"empty label\");\n        }\n        return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\n    }\n}\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */\nfunction isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */\nfunction namehash(name) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof (name) === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(name.length, `invalid ENS name (empty label)`, \"name\", name);\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([result, (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((comps.pop()))]));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(result);\n}\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */\nfunction dnsEncode(name, _maxLength) {\n    const length = (_maxLength != null) ? _maxLength : 63;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(ensNameSplit(name).map((comp) => {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, \"name\", name);\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL25hbWVoYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0M7QUFDa0M7QUFDMUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYyx1Q0FBdUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWMseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFFQUFhO0FBQzVCO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLDZCQUE2QixjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwrREFBYyxnREFBZ0Q7QUFDbEUsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQVMsQ0FBQyx1REFBTSxVQUFVLDJEQUFTO0FBQ3BEO0FBQ0EsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCLFdBQVcsd0RBQU8sQ0FBQyx1REFBTTtBQUN6QixRQUFRLCtEQUFjLGlDQUFpQyxzQkFBc0IsVUFBVSxRQUFRO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9uYW1laGFzaC5qcz9kOWZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgaGV4bGlmeSwgYXNzZXJ0QXJndW1lbnQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBlbnNfbm9ybWFsaXplIH0gZnJvbSBcIkBhZHJhZmZ5L2Vucy1ub3JtYWxpemVcIjtcbmNvbnN0IFplcm9zID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuWmVyb3MuZmlsbCgwKTtcbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50KGNvbXApIHtcbiAgICBhc3NlcnRBcmd1bWVudChjb21wLmxlbmd0aCAhPT0gMCwgXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIiwgXCJjb21wXCIsIGNvbXApO1xuICAgIHJldHVybiBjb21wO1xufVxuZnVuY3Rpb24gZW5zTmFtZVNwbGl0KG5hbWUpIHtcbiAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzKGVuc05vcm1hbGl6ZShuYW1lKSk7XG4gICAgY29uc3QgY29tcHMgPSBbXTtcbiAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBzO1xuICAgIH1cbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkID0gYnl0ZXNbaV07XG4gICAgICAgIC8vIEEgc2VwYXJhdG9yIChpLmUuIFwiLlwiKTsgY29weSB0aGlzIGNvbXBvbmVudFxuICAgICAgICBpZiAoZCA9PT0gMHgyZSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0LCBpKSkpO1xuICAgICAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXJlIHdhcyBhIHN0cmF5IHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lXG4gICAgYXNzZXJ0QXJndW1lbnQobGFzdCA8IGJ5dGVzLmxlbmd0aCwgXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCkpKTtcbiAgICByZXR1cm4gY29tcHM7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBFTlMgJSVuYW1lJSUgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc05vcm1hbGl6ZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBsYWJlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5zX25vcm1hbGl6ZShuYW1lKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBFTlMgbmFtZSAoJHtlcnJvci5tZXNzYWdlfSlgLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJW5hbWUlJSBpcyBhIHZhbGlkIEVOUyBuYW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZE5hbWUobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoZW5zTmFtZVNwbGl0KG5hbWUpLmxlbmd0aCAhPT0gMCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgW1tsaW5rLW5hbWVoYXNoXV0gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBFTlMgbmFtZTsgbm90IGEgc3RyaW5nXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBhc3NlcnRBcmd1bWVudChuYW1lLmxlbmd0aCwgYGludmFsaWQgRU5TIG5hbWUgKGVtcHR5IGxhYmVsKWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgY29uc3QgY29tcHMgPSBlbnNOYW1lU3BsaXQobmFtZSk7XG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBrZWNjYWsyNTYoY29uY2F0KFtyZXN1bHQsIGtlY2NhazI1NigoY29tcHMucG9wKCkpKV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIEROUyBlbmNvZGVkICUlbmFtZSUlLlxuICpcbiAqICBUaGlzIGlzIHVzZWQgZm9yIHZhcmlvdXMgcGFydHMgb2YgRU5TIG5hbWUgcmVzb2x1dGlvbiwgc3VjaFxuICogIGFzIHRoZSB3aWxkY2FyZCByZXNvbHV0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG5zRW5jb2RlKG5hbWUsIF9tYXhMZW5ndGgpIHtcbiAgICBjb25zdCBsZW5ndGggPSAoX21heExlbmd0aCAhPSBudWxsKSA/IF9tYXhMZW5ndGggOiA2MztcbiAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggPD0gMjU1LCBcIkROUyBlbmNvZGVkIGxhYmVsIGNhbm5vdCBleGNlZWQgMjU1XCIsIFwibGVuZ3RoXCIsIGxlbmd0aCk7XG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KGVuc05hbWVTcGxpdChuYW1lKS5tYXAoKGNvbXApID0+IHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoY29tcC5sZW5ndGggPD0gbGVuZ3RoLCBgbGFiZWwgJHtKU09OLnN0cmluZ2lmeShuYW1lKX0gZXhjZWVkcyAke2xlbmd0aH0gYnl0ZXNgLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY29tcC5sZW5ndGggKyAxKTtcbiAgICAgICAgYnl0ZXMuc2V0KGNvbXAsIDEpO1xuICAgICAgICBieXRlc1swXSA9IGJ5dGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9KSkpICsgXCIwMFwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/hash/namehash.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/hash/solidity.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/hash/solidity.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   solidityPacked: function() { return /* binding */ solidityPacked; },\n/* harmony export */   solidityPackedKeccak256: function() { return /* binding */ solidityPackedKeccak256; },\n/* harmony export */   solidityPackedSha256: function() { return /* binding */ solidityPackedSha256; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\n\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nfunction _pack(type, value, isArray) {\n    switch (type) {\n        case \"address\":\n            if (isArray) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(value, 32));\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value));\n        case \"string\":\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(value);\n        case \"bytes\":\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n        case \"bool\":\n            value = (!!value ? \"0x01\" : \"0x00\");\n            if (isArray) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(value, 32));\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n    }\n    let match = type.match(regexNumber);\n    if (match) {\n        let signed = (match[1] === \"int\");\n        let size = parseInt(match[2] || \"256\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((!match[2] || match[2] === String(size)) && (size % 8 === 0) && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\n        if (isArray) {\n            size = 256;\n        }\n        if (signed) {\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toTwos)(value, size);\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value), size / 8));\n    }\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(String(size) === match[1] && size !== 0 && size <= 32, \"invalid bytes type\", \"type\", type);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(value) === size, `invalid value for ${type}`, \"value\", value);\n        if (isArray) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadBytes)(value, 32));\n        }\n        return value;\n    }\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(count === value.length, `invalid array length for ${type}`, \"value\", value);\n        const result = [];\n        value.forEach(function (value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result));\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid type\", \"type\", type);\n}\n// @TODO: Array Enum\n/**\n *   Computes the [[link-solc-packed]] representation of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPacked(types, values) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n    const tight = [];\n    types.forEach(function (type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(tight));\n}\n/**\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPackedKeccak256(types, values) {\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(solidityPacked(types, values));\n}\n/**\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPackedSha256(types, values) {\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(solidityPacked(types, values));\n}\n//# sourceMappingURL=solidity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL3NvbGlkaXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpRDtBQUMrQjtBQUNzRTtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBUSxDQUFDLDZEQUFZO0FBQzVDO0FBQ0EsbUJBQW1CLHlEQUFRLENBQUMsNkRBQVU7QUFDdEM7QUFDQSxtQkFBbUIsNERBQVc7QUFDOUI7QUFDQSxtQkFBbUIseURBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFRLENBQUMsNkRBQVk7QUFDNUM7QUFDQSxtQkFBbUIseURBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQU07QUFDMUI7QUFDQSxlQUFlLHlEQUFRLENBQUMsNkRBQVksQ0FBQywwREFBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEIsUUFBUSwrREFBYyxDQUFDLDJEQUFVLHVDQUF1QyxLQUFLO0FBQzdFO0FBQ0EsbUJBQW1CLHlEQUFRLENBQUMsNkRBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLHFEQUFxRCxLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLHlEQUFRLENBQUMsdURBQU07QUFDOUI7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksK0RBQWMsMERBQTBELFlBQVksY0FBYztBQUN0RztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyx3REFBTyxDQUFDLHVEQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLDJEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHdEQUFPO0FBQ2xCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9zb2xpZGl0eS5qcz8wMDM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IGFzIF9rZWNjYWsyNTYsIHNoYTI1NiBhcyBfc2hhMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCeXRlcywgaGV4bGlmeSwgdG9CZUFycmF5LCB0b1R3b3MsIHRvVXRmOEJ5dGVzLCB6ZXJvUGFkQnl0ZXMsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IHJlZ2V4Qnl0ZXMgPSBuZXcgUmVnRXhwKFwiXmJ5dGVzKFswLTldKykkXCIpO1xuY29uc3QgcmVnZXhOdW1iZXIgPSBuZXcgUmVnRXhwKFwiXih1P2ludCkoWzAtOV0qKSRcIik7XG5jb25zdCByZWdleEFycmF5ID0gbmV3IFJlZ0V4cChcIl4oLiopXFxcXFsoWzAtOV0qKVxcXFxdJFwiKTtcbmZ1bmN0aW9uIF9wYWNrKHR5cGUsIHZhbHVlLCBpc0FycmF5KSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyh6ZXJvUGFkVmFsdWUodmFsdWUsIDMyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoZ2V0QWRkcmVzcyh2YWx1ZSkpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gdG9VdGY4Qnl0ZXModmFsdWUpO1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICB2YWx1ZSA9ICghIXZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyh6ZXJvUGFkVmFsdWUodmFsdWUsIDMyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4TnVtYmVyKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJpbnRcIik7XG4gICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCghbWF0Y2hbMl0gfHwgbWF0Y2hbMl0gPT09IFN0cmluZyhzaXplKSkgJiYgKHNpemUgJSA4ID09PSAwKSAmJiBzaXplICE9PSAwICYmIHNpemUgPD0gMjU2LCBcImludmFsaWQgbnVtYmVyIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgc2l6ZSA9IDI1NjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvVHdvcyh2YWx1ZSwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEJ5dGVzKHplcm9QYWRWYWx1ZSh0b0JlQXJyYXkodmFsdWUpLCBzaXplIC8gOCkpO1xuICAgIH1cbiAgICBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhCeXRlcyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KFN0cmluZyhzaXplKSA9PT0gbWF0Y2hbMV0gJiYgc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgodmFsdWUpID09PSBzaXplLCBgaW52YWxpZCB2YWx1ZSBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKHplcm9QYWRCeXRlcyh2YWx1ZSwgMzIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIG1hdGNoID0gdHlwZS5tYXRjaChyZWdleEFycmF5KTtcbiAgICBpZiAobWF0Y2ggJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBwYXJzZUludChtYXRjaFsyXSB8fCBTdHJpbmcodmFsdWUubGVuZ3RoKSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGNvdW50ID09PSB2YWx1ZS5sZW5ndGgsIGBpbnZhbGlkIGFycmF5IGxlbmd0aCBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKF9wYWNrKGJhc2VUeXBlLCB2YWx1ZSwgdHJ1ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGNvbmNhdChyZXN1bHQpKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbn1cbi8vIEBUT0RPOiBBcnJheSBFbnVtXG4vKipcbiAqICAgQ29tcHV0ZXMgdGhlIFtbbGluay1zb2xjLXBhY2tlZF1dIHJlcHJlc2VudGF0aW9uIG9mICUldmFsdWVzJSVcbiAqICAgcmVzcGVjdGl2ZWx5IHRvIHRoZWlyICUldHlwZXMlJS5cbiAqXG4gKiAgIEBleGFtcGxlOlxuICogICAgICAgYWRkciA9IFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCJcbiAqICAgICAgIHNvbGlkaXR5UGFja2VkKFsgXCJhZGRyZXNzXCIsIFwidWludFwiIF0sIFsgYWRkciwgNDUgXSk7XG4gKiAgICAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb2xpZGl0eVBhY2tlZCh0eXBlcywgdmFsdWVzKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZXMubGVuZ3RoID09PSB2YWx1ZXMubGVuZ3RoLCBcIndyb25nIG51bWJlciBvZiB2YWx1ZXM7IGV4cGVjdGVkICR7IHR5cGVzLmxlbmd0aCB9XCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG4gICAgY29uc3QgdGlnaHQgPSBbXTtcbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgICAgICB0aWdodC5wdXNoKF9wYWNrKHR5cGUsIHZhbHVlc1tpbmRleF0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQodGlnaHQpKTtcbn1cbi8qKlxuICogICBDb21wdXRlcyB0aGUgW1tsaW5rLXNvbGMtcGFja2VkXV0gW1trZWNjYWsyNTZdXSBoYXNoIG9mICUldmFsdWVzJSVcbiAqICAgcmVzcGVjdGl2ZWx5IHRvIHRoZWlyICUldHlwZXMlJS5cbiAqXG4gKiAgIEBleGFtcGxlOlxuICogICAgICAgYWRkciA9IFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCJcbiAqICAgICAgIHNvbGlkaXR5UGFja2VkS2VjY2FrMjU2KFsgXCJhZGRyZXNzXCIsIFwidWludFwiIF0sIFsgYWRkciwgNDUgXSk7XG4gKiAgICAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb2xpZGl0eVBhY2tlZEtlY2NhazI1Nih0eXBlcywgdmFsdWVzKSB7XG4gICAgcmV0dXJuIF9rZWNjYWsyNTYoc29saWRpdHlQYWNrZWQodHlwZXMsIHZhbHVlcykpO1xufVxuLyoqXG4gKiAgIENvbXB1dGVzIHRoZSBbW2xpbmstc29sYy1wYWNrZWRdXSBbW3NoYTI1Nl1dIGhhc2ggb2YgJSV2YWx1ZXMlJVxuICogICByZXNwZWN0aXZlbHkgdG8gdGhlaXIgJSV0eXBlcyUlLlxuICpcbiAqICAgQGV4YW1wbGU6XG4gKiAgICAgICBhZGRyID0gXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIlxuICogICAgICAgc29saWRpdHlQYWNrZWRTaGEyNTYoWyBcImFkZHJlc3NcIiwgXCJ1aW50XCIgXSwgWyBhZGRyLCA0NSBdKTtcbiAqICAgICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvbGlkaXR5UGFja2VkU2hhMjU2KHR5cGVzLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gX3NoYTI1Nihzb2xpZGl0eVBhY2tlZCh0eXBlcywgdmFsdWVzKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2xpZGl0eS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/hash/solidity.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/hash/typed-data.js":
/*!****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/hash/typed-data.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: function() { return /* binding */ TypedDataEncoder; },\n/* harmony export */   verifyTypedData: function() { return /* binding */ verifyTypedData; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./id.js */ \"../common/node_modules/ethers/lib.esm/hash/id.js\");\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\n\n\n\n\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([bytes, padding.slice(padOffset)]);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n}\nconst hexTrue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(BN_1, 32);\nconst hexFalse = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (_value) {\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_value, \"domain.chainId\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toQuantity)(value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value).toLowerCase();\n        }\n        catch (error) { }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value, \"domain.salt\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d+)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.mask)(BN_MAX_UINT256, signed ? (width - 1) : width);\n            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1) : BN_0;\n            return function (_value) {\n                const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_value, \"value\");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(signed ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toTwos)(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function (value) {\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(value);\n        };\n        case \"string\": return function (value) {\n            return (0,_id_js__WEBPACK_IMPORTED_MODULE_3__.id)(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\n// foo[][3] => { base: \"foo\", index: \"[][3]\", array: {\n//     base: \"foo\", prefix: \"foo[]\", count: 3 } }\nfunction splitArray(type) {\n    const match = type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n        return {\n            base: match[1],\n            index: (match[2] + match[4]),\n            array: {\n                base: match[1],\n                prefix: (match[1] + match[2]),\n                count: (match[5] ? parseInt(match[5]) : -1),\n            }\n        };\n    }\n    return { base: type };\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */\nclass TypedDataEncoder {\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only remaining type with\n     *  no parent nodes.\n     */\n    primaryType;\n    #types;\n    /**\n     *  The types.\n     */\n    get types() {\n        return JSON.parse(this.#types);\n    }\n    #fullTypes;\n    #encoderCache;\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */\n    constructor(_types) {\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        const types = {};\n        Object.keys(_types).forEach((type) => {\n            types[type] = _types[type].map(({ name, type }) => {\n                // Normalize the base type (unless name conflict)\n                let { base, index } = splitArray(type);\n                if (base === \"int\" && !_types[\"int\"]) {\n                    base = \"int256\";\n                }\n                if (base === \"uint\" && !_types[\"uint\"]) {\n                    base = \"uint256\";\n                }\n                return { name, type: (base + (index || \"\")) };\n            });\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        this.#types = JSON.stringify(types);\n        for (const name in types) {\n            const uniqueNames = new Set();\n            for (const field of types[name]) {\n                // Check each field has a unique name\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", _types);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = splitArray(field.type).base;\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", _types);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n) => (parents.get(n).length === 0));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", _types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", _types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { primaryType: primaryTypes[0] });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", _types);\n            found.add(type);\n            for (const child of links.get(type)) {\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found) {\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes) {\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\"));\n        }\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */\n    getEncoder(type) {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n    #getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            const subtype = array.prefix;\n            const subEncoder = this.getEncoder(subtype);\n            return (value) => {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256);\n                }\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0,_id_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.#fullTypes.get(type));\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) {\n                        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(values);\n            };\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */\n    encodeType(name) {\n        const result = this.#fullTypes.get(name);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */\n    hashStruct(name, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, \"value\", value);\n            return value.map((v) => this._visit(array.prefix, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static encode(domain, types, value) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static hash(domain, types, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */\n    static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for (const key in domain) {\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value) => {\n            if (type === \"address\" && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value) => {\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return { domain, value };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        // Get the normalized types\n        types = encoder.types;\n        const typesWithDomain = Object.assign({}, types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nfunction verifyTypedData(domain, types, value, signature) {\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n}\n//# sourceMappingURL=typed-data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL3R5cGVkLWRhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLFdBQVcsa0NBQWtDO0FBQ0k7QUFDRjtBQUNVO0FBQ2dIO0FBQzVJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5REFBUTtBQUMxQjtBQUNBO0FBQ0EsZUFBZSx1REFBTTtBQUNyQjtBQUNBLFdBQVcsd0RBQU87QUFDbEI7QUFDQSxnQkFBZ0Isd0RBQU87QUFDdkIsaUJBQWlCLHdEQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWMsMERBQTBELG9CQUFvQixhQUFhLElBQUk7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQVM7QUFDL0IsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFVO0FBQ3pCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFVO0FBQzdCO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCLEtBQUs7QUFDTDtBQUNBLHNCQUFzQix5REFBUTtBQUM5QixRQUFRLCtEQUFjO0FBQ3RCLGVBQWUsd0RBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQixnQ0FBZ0MscURBQUk7QUFDcEM7QUFDQTtBQUNBLDhCQUE4QiwwREFBUztBQUN2QyxnQkFBZ0IsK0RBQWMsMEVBQTBFLEtBQUs7QUFDN0csdUJBQXVCLHdEQUFPLFVBQVUsdURBQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWM7QUFDMUI7QUFDQSw4QkFBOEIseURBQVE7QUFDdEMsZ0JB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LG9DQUFvQztBQUNuRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQU8sQ0FBQyx5REFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMERBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0RBQWM7QUFDdEM7QUFDQTtBQUNBLGdCQUFnQiwrREFBYztBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHFFQUFjO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC90eXBlZC1kYXRhLmpzPzJjMzEiXSwic291cmNlc0NvbnRlbnQiOlsiLy9pbXBvcnQgeyBUeXBlZERhdGFEb21haW4sIFR5cGVkRGF0YUZpZWxkIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3ZpZGVyYWJzdHJhY3Qtc2lnbmVyXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGhleGxpZnksIGlzSGV4U3RyaW5nLCBtYXNrLCB0b0JlSGV4LCB0b1F1YW50aXR5LCB0b1R3b3MsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4vaWQuanNcIjtcbmNvbnN0IHBhZGRpbmcgPSBuZXcgVWludDhBcnJheSgzMik7XG5wYWRkaW5nLmZpbGwoMCk7XG5jb25zdCBCTl9fMSA9IEJpZ0ludCgtMSk7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOX01BWF9VSU5UMjU2ID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuO1xuO1xuZnVuY3Rpb24gaGV4UGFkUmlnaHQodmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHZhbHVlKTtcbiAgICBjb25zdCBwYWRPZmZzZXQgPSBieXRlcy5sZW5ndGggJSAzMjtcbiAgICBpZiAocGFkT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW2J5dGVzLCBwYWRkaW5nLnNsaWNlKHBhZE9mZnNldCldKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xufVxuY29uc3QgaGV4VHJ1ZSA9IHRvQmVIZXgoQk5fMSwgMzIpO1xuY29uc3QgaGV4RmFsc2UgPSB0b0JlSGV4KEJOXzAsIDMyKTtcbmNvbnN0IGRvbWFpbkZpZWxkVHlwZXMgPSB7XG4gICAgbmFtZTogXCJzdHJpbmdcIixcbiAgICB2ZXJzaW9uOiBcInN0cmluZ1wiLFxuICAgIGNoYWluSWQ6IFwidWludDI1NlwiLFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBcImFkZHJlc3NcIixcbiAgICBzYWx0OiBcImJ5dGVzMzJcIlxufTtcbmNvbnN0IGRvbWFpbkZpZWxkTmFtZXMgPSBbXG4gICAgXCJuYW1lXCIsIFwidmVyc2lvblwiLCBcImNoYWluSWRcIiwgXCJ2ZXJpZnlpbmdDb250cmFjdFwiLCBcInNhbHRcIlxuXTtcbmZ1bmN0aW9uIGNoZWNrU3RyaW5nKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBmb3IgJHtKU09OLnN0cmluZ2lmeShrZXkpfWAsIGBkb21haW4uJHtrZXl9YCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn1cbmNvbnN0IGRvbWFpbkNoZWNrcyA9IHtcbiAgICBuYW1lOiBjaGVja1N0cmluZyhcIm5hbWVcIiksXG4gICAgdmVyc2lvbjogY2hlY2tTdHJpbmcoXCJ2ZXJzaW9uXCIpLFxuICAgIGNoYWluSWQ6IGZ1bmN0aW9uIChfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcImRvbWFpbi5jaGFpbklkXCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAwLCBcImludmFsaWQgY2hhaW4gSURcIiwgXCJkb21haW4uY2hhaW5JZFwiLCBfdmFsdWUpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9RdWFudGl0eSh2YWx1ZSk7XG4gICAgfSxcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwidmVyaWZ5aW5nQ29udHJhY3RcImAsIFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNhbHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHZhbHVlLCBcImRvbWFpbi5zYWx0XCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChieXRlcy5sZW5ndGggPT09IDMyLCBgaW52YWxpZCBkb21haW4gdmFsdWUgXCJzYWx0XCJgLCBcImRvbWFpbi5zYWx0XCIsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRCYXNlRW5jb2Rlcih0eXBlKSB7XG4gICAgLy8gaW50WFggYW5kIHVpbnRYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKHU/KWludChcXGQrKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSAobWF0Y2hbMV0gPT09IFwiXCIpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh3aWR0aCAlIDggPT09IDAgJiYgd2lkdGggIT09IDAgJiYgd2lkdGggPD0gMjU2ICYmIG1hdGNoWzJdID09PSBTdHJpbmcod2lkdGgpLCBcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNVcHBlciA9IG1hc2soQk5fTUFYX1VJTlQyNTYsIHNpZ25lZCA/ICh3aWR0aCAtIDEpIDogd2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzTG93ZXIgPSBzaWduZWQgPyAoKGJvdW5kc1VwcGVyICsgQk5fMSkgKiBCTl9fMSkgOiBCTl8wO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gYm91bmRzTG93ZXIgJiYgdmFsdWUgPD0gYm91bmRzVXBwZXIsIGB2YWx1ZSBvdXQtb2YtYm91bmRzIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvQmVIZXgoc2lnbmVkID8gdG9Ud29zKHZhbHVlLCAyNTYpIDogdmFsdWUsIDMyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYnl0ZXNYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh3aWR0aCAhPT0gMCAmJiB3aWR0aCA8PSAzMiAmJiBtYXRjaFsxXSA9PT0gU3RyaW5nKHdpZHRoKSwgXCJpbnZhbGlkIGJ5dGVzIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChieXRlcy5sZW5ndGggPT09IHdpZHRoLCBgaW52YWxpZCBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4UGFkUmlnaHQodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZHJlc3NcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWRWYWx1ZShnZXRBZGRyZXNzKHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCghdmFsdWUpID8gaGV4RmFsc2UgOiBoZXhUcnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJ5dGVzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZW5jb2RlVHlwZShuYW1lLCBmaWVsZHMpIHtcbiAgICByZXR1cm4gYCR7bmFtZX0oJHtmaWVsZHMubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4gKHR5cGUgKyBcIiBcIiArIG5hbWUpKS5qb2luKFwiLFwiKX0pYDtcbn1cbi8vIGZvb1tdWzNdID0+IHsgYmFzZTogXCJmb29cIiwgaW5kZXg6IFwiW11bM11cIiwgYXJyYXk6IHtcbi8vICAgICBiYXNlOiBcImZvb1wiLCBwcmVmaXg6IFwiZm9vW11cIiwgY291bnQ6IDMgfSB9XG5mdW5jdGlvbiBzcGxpdEFycmF5KHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14oW15cXHg1Yl0qKSgoXFx4NWJcXGQqXFx4NWQpKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXNlOiBtYXRjaFsxXSxcbiAgICAgICAgICAgIGluZGV4OiAobWF0Y2hbMl0gKyBtYXRjaFs0XSksXG4gICAgICAgICAgICBhcnJheToge1xuICAgICAgICAgICAgICAgIGJhc2U6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIHByZWZpeDogKG1hdGNoWzFdICsgbWF0Y2hbMl0pLFxuICAgICAgICAgICAgICAgIGNvdW50OiAobWF0Y2hbNV0gPyBwYXJzZUludChtYXRjaFs1XSkgOiAtMSksXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IGJhc2U6IHR5cGUgfTtcbn1cbi8qKlxuICogIEEgKipUeXBlZERhdGFFbmNvZGUqKiBwcmVwYXJlcyBhbmQgZW5jb2RlcyBbW2xpbmstZWlwLTcxMl1dIHBheWxvYWRzXG4gKiAgZm9yIHNpZ25lZCB0eXBlZCBkYXRhLlxuICpcbiAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgdGhvc2UgdGhhdCB3aXNoIHRvIGNvbXB1dGUgdmFyaW91cyBjb21wb25lbnRzIG9mIGFcbiAqICB0eXBlZCBkYXRhIGhhc2gsIHByaW1hcnkgdHlwZXMsIG9yIHN1Yi1jb21wb25lbnRzLCBidXQgZ2VuZXJhbGx5IHRoZVxuICogIGhpZ2hlciBsZXZlbCBbW1NpZ25lci1zaWduVHlwZWREYXRhXV0gaXMgbW9yZSB1c2VmdWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBUeXBlZERhdGFFbmNvZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByaW1hcnkgdHlwZSBmb3IgdGhlIHN0cnVjdHVyZWQgW1t0eXBlc11dLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZGVyaXZlZCBhdXRvbWF0aWNhbGx5IGZyb20gdGhlIFtbdHlwZXNdXSwgc2luY2Ugbm9cbiAgICAgKiAgcmVjdXJzaW9uIGlzIHBvc3NpYmxlLCBvbmNlIHRoZSBEQUcgZm9yIHRoZSB0eXBlcyBpcyBjb25zdHVyY3RlZFxuICAgICAqICBpbnRlcm5hbGx5LCB0aGUgcHJpbWFyeSB0eXBlIG11c3QgYmUgdGhlIG9ubHkgcmVtYWluaW5nIHR5cGUgd2l0aFxuICAgICAqICBubyBwYXJlbnQgbm9kZXMuXG4gICAgICovXG4gICAgcHJpbWFyeVR5cGU7XG4gICAgI3R5cGVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZXMuXG4gICAgICovXG4gICAgZ2V0IHR5cGVzKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLiN0eXBlcyk7XG4gICAgfVxuICAgICNmdWxsVHlwZXM7XG4gICAgI2VuY29kZXJDYWNoZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwZXJmb3JtcyBhbGwgbmVjZXNzYXJ5IGNoZWNraW5nIHRoYXQgdHlwZXMgYXJlIHZhbGlkIGFuZFxuICAgICAqICBkbyBub3QgdmlvbGF0ZSB0aGUgW1tsaW5rLWVpcC03MTJdXSBzdHJ1Y3R1cmFsIGNvbnN0cmFpbnRzIGFzXG4gICAgICogIHdlbGwgYXMgY29tcHV0ZXMgdGhlIFtbcHJpbWFyeVR5cGVdXS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfdHlwZXMpIHtcbiAgICAgICAgdGhpcy4jZnVsbFR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNlbmNvZGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0IHR5cGVzIHRvIHRoZWlyIGRpcmVjdCBjaGlsZCBzdHJ1Y3RzXG4gICAgICAgIGNvbnN0IGxpbmtzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdHMgdG8gc3RydWN0cyB3aGljaCBjb250YWluIHRoZW0gYXMgYSBjaGlsZFxuICAgICAgICBjb25zdCBwYXJlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIGFsbCBzdWJ0eXBlcyB3aXRoaW4gYSBnaXZlbiBzdHJ1Y3RcbiAgICAgICAgY29uc3Qgc3VidHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKF90eXBlcykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgdHlwZXNbdHlwZV0gPSBfdHlwZXNbdHlwZV0ubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYmFzZSB0eXBlICh1bmxlc3MgbmFtZSBjb25mbGljdClcbiAgICAgICAgICAgICAgICBsZXQgeyBiYXNlLCBpbmRleCB9ID0gc3BsaXRBcnJheSh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZSA9PT0gXCJpbnRcIiAmJiAhX3R5cGVzW1wiaW50XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBcImludDI1NlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmFzZSA9PT0gXCJ1aW50XCIgJiYgIV90eXBlc1tcInVpbnRcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IFwidWludDI1NlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lLCB0eXBlOiAoYmFzZSArIChpbmRleCB8fCBcIlwiKSkgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlua3Muc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBwYXJlbnRzLnNldCh0eXBlLCBbXSk7XG4gICAgICAgICAgICBzdWJ0eXBlcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI3R5cGVzID0gSlNPTi5zdHJpbmdpZnkodHlwZXMpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggZmllbGQgaGFzIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghdW5pcXVlTmFtZXMuaGFzKGZpZWxkLm5hbWUpLCBgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWUgJHtKU09OLnN0cmluZ2lmeShmaWVsZC5uYW1lKX0gaW4gJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYmFzZSB0eXBlIChkcm9wIGFueSBhcnJheSBzcGVjaWZpZXJzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VUeXBlID0gc3BsaXRBcnJheShmaWVsZC50eXBlKS5iYXNlO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGJhc2VUeXBlICE9PSBuYW1lLCBgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgYSBiYXNlIGVuY29kaW5nIHR5cGU/XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKGJhc2VUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocGFyZW50cy5oYXMoYmFzZVR5cGUpLCBgdW5rbm93biB0eXBlICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbGlua2FnZVxuICAgICAgICAgICAgICAgIHBhcmVudHMuZ2V0KGJhc2VUeXBlKS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIGxpbmtzLmdldChuYW1lKS5hZGQoYmFzZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERlZHVjZSB0aGUgcHJpbWFyeSB0eXBlXG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlcyA9IEFycmF5LmZyb20ocGFyZW50cy5rZXlzKCkpLmZpbHRlcigobikgPT4gKHBhcmVudHMuZ2V0KG4pLmxlbmd0aCA9PT0gMCkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwcmltYXJ5VHlwZXMubGVuZ3RoICE9PSAwLCBcIm1pc3NpbmcgcHJpbWFyeSB0eXBlXCIsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHJpbWFyeVR5cGVzLmxlbmd0aCA9PT0gMSwgYGFtYmlndW91cyBwcmltYXJ5IHR5cGVzIG9yIHVudXNlZCB0eXBlczogJHtwcmltYXJ5VHlwZXMubWFwKCh0KSA9PiAoSlNPTi5zdHJpbmdpZnkodCkpKS5qb2luKFwiLCBcIil9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJpbWFyeVR5cGU6IHByaW1hcnlUeXBlc1swXSB9KTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlc1xuICAgICAgICBmdW5jdGlvbiBjaGVja0NpcmN1bGFyKHR5cGUsIGZvdW5kKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghZm91bmQuaGFzKHR5cGUpLCBgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICBmb3VuZC5hZGQodHlwZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGxpbmtzLmdldCh0eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50cy5oYXMoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGNoZWNrQ2lyY3VsYXIoY2hpbGQsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGFsbCBhbmNlc3RvcnMgYXMgaGF2aW5nIHRoaXMgZGVjZW5kYW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJ0eXBlIG9mIGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGVzLmdldChzdWJ0eXBlKS5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0NpcmN1bGFyKHRoaXMucHJpbWFyeVR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIC8vIENvbXB1dGUgZWFjaCBmdWxseSBkZXNjcmliZSB0eXBlXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHNldF0gb2Ygc3VidHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuZnJvbShzZXQpO1xuICAgICAgICAgICAgc3Quc29ydCgpO1xuICAgICAgICAgICAgdGhpcy4jZnVsbFR5cGVzLnNldChuYW1lLCBlbmNvZGVUeXBlKG5hbWUsIHR5cGVzW25hbWVdKSArIHN0Lm1hcCgodCkgPT4gZW5jb2RlVHlwZSh0LCB0eXBlc1t0XSkpLmpvaW4oXCJcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm50aGUgZW5jb2RlciBmb3IgdGhlIHNwZWNpZmljICUldHlwZSUlLlxuICAgICAqL1xuICAgIGdldEVuY29kZXIodHlwZSkge1xuICAgICAgICBsZXQgZW5jb2RlciA9IHRoaXMuI2VuY29kZXJDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghZW5jb2Rlcikge1xuICAgICAgICAgICAgZW5jb2RlciA9IHRoaXMuI2dldEVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICB0aGlzLiNlbmNvZGVyQ2FjaGUuc2V0KHR5cGUsIGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgIH1cbiAgICAjZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IGFycmF5ID0gc3BsaXRBcnJheSh0eXBlKS5hcnJheTtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gYXJyYXkucHJlZml4O1xuICAgICAgICAgICAgY29uc3Qgc3ViRW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihzdWJ0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhcnJheS5jb3VudCA9PT0gLTEgfHwgYXJyYXkuY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7YXJyYXkuY291bnR9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHZhbHVlLm1hcChzdWJFbmNvZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jZnVsbFR5cGVzLmhhcyhzdWJ0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGtlY2NhazI1Nik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoY29uY2F0KHJlc3VsdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFR5cGUgPSBpZCh0aGlzLiNmdWxsVHlwZXMuZ2V0KHR5cGUpKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBmaWVsZHMubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWVbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jZnVsbFR5cGVzLmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnVuc2hpZnQoZW5jb2RlZFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXQodmFsdWVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGwgdHlwZSBmb3IgJSVuYW1lJSUuXG4gICAgICovXG4gICAgZW5jb2RlVHlwZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2Z1bGxUeXBlcy5nZXQobmFtZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdCwgYHVua25vd24gdHlwZTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgJSV0eXBlJSUuXG4gICAgICovXG4gICAgZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGhhc2ggb2YgJSV2YWx1ZSUlIGZvciB0aGUgdHlwZSBvZiAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBoYXNoU3RydWN0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy5lbmNvZGVEYXRhKG5hbWUsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGxlZCBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cbiAgICAgKi9cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRGF0YSh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGhhc2ggb2YgdGhlIGZ1bGx5IGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgW1t0eXBlc11dLlxuICAgICAqL1xuICAgIGhhc2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaFN0cnVjdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfdmlzaXQodHlwZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgYXJyYXkgPSBzcGxpdEFycmF5KHR5cGUpLmFycmF5O1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFycmF5LmNvdW50ID09PSAtMSB8fCBhcnJheS5jb3VudCA9PT0gdmFsdWUubGVuZ3RoLCBgYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHthcnJheS5jb3VudH1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IHRoaXMuX3Zpc2l0KGFycmF5LnByZWZpeCwgdiwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKGFjY3VtLCB7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdGhpcy5fdmlzaXQodHlwZSwgdmFsdWVbbmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYWxsICUlY2FsYmFjayUlIGZvciBlYWNoIHZhbHVlIGluICUldmFsdWUlJSwgcGFzc2luZyB0aGUgdHlwZSBhbmRcbiAgICAgKiAgY29tcG9uZW50IHdpdGhpbiAlJXZhbHVlJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHJlcGxhY2luZyBhZGRyZXNzZXMgb3Igb3RoZXIgdHJhbnNmb3JtYXRpb24gdGhhdFxuICAgICAqICBtYXkgYmUgZGVzaXJlZCBvbiBlYWNoIGNvbXBvbmVudCwgYmFzZWQgb24gaXRzIHR5cGUuXG4gICAgICovXG4gICAgdmlzaXQodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcHJpbWFyeSB0eXBlIGZvciAlJXR5cGVzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFByaW1hcnlUeXBlKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLnByaW1hcnlUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoZWQgc3RydWN0IGZvciAlJXZhbHVlJSUgdXNpbmcgJSV0eXBlcyUlIGFuZCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaFN0cnVjdChuYW1lLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRvbWFpbiBoYXNoIGZvciAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoRG9tYWluKGRvbWFpbikge1xuICAgICAgICBjb25zdCBkb21haW5GaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKGRvbWFpbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZG9tYWluRmllbGRUeXBlc1tuYW1lXTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGUsIGBpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcImRvbWFpblwiLCBkb21haW4pO1xuICAgICAgICAgICAgZG9tYWluRmllbGRzLnB1c2goeyBuYW1lLCB0eXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvbWFpbkZpZWxkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGEubmFtZSkgLSBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYi5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmhhc2hTdHJ1Y3QoXCJFSVA3MTJEb21haW5cIiwgeyBFSVA3MTJEb21haW46IGRvbWFpbkZpZWxkcyB9LCBkb21haW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBlbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBcIjB4MTkwMVwiLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbiksXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2godmFsdWUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYoVHlwZWREYXRhRW5jb2Rlci5lbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRvIHRoZSB2YWx1ZSBmcm9tIHJlc29sdmluZyBhbGwgYWRkcmVzc2VzIGluICUldmFsdWUlJSBmb3JcbiAgICAgKiAlJXR5cGVzJSUgYW5kIHRoZSAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyByZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIHJlc29sdmVOYW1lKSB7XG4gICAgICAgIC8vIE1ha2UgYSBjb3B5IHRvIGlzb2xhdGUgaXQgZnJvbSB0aGUgb2JqZWN0IHBhc3NlZCBpblxuICAgICAgICBkb21haW4gPSBPYmplY3QuYXNzaWduKHt9LCBkb21haW4pO1xuICAgICAgICAvLyBBbGxvdyBwYXNzaW5nIG51bGwgdG8gaWdub3JlIHZhbHVlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRvbWFpbikge1xuICAgICAgICAgICAgaWYgKGRvbWFpbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCBhbGwgRU5TIG5hbWVzXG4gICAgICAgIGNvbnN0IGVuc0NhY2hlID0ge307XG4gICAgICAgIC8vIERvIHdlIG5lZWQgdG8gbG9vayB1cCB0aGUgZG9tYWluJ3MgdmVyaWZ5aW5nQ29udHJhY3Q/XG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgIWlzSGV4U3RyaW5nKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCwgMjApKSB7XG4gICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byB1c2UgdGhlIGVuY29kZXIgdG8gdmlzaXQgYWxsIHRoZSBiYXNlIHZhbHVlc1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgLy8gR2V0IGEgbGlzdCBvZiBhbGwgdGhlIGFkZHJlc3Nlc1xuICAgICAgICBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhaXNIZXhTdHJpbmcodmFsdWUsIDIwKSkge1xuICAgICAgICAgICAgICAgIGVuc0NhY2hlW3ZhbHVlXSA9IFwiMHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIExvb2t1cCBlYWNoIG5hbWVcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVuc0NhY2hlKSB7XG4gICAgICAgICAgICBlbnNDYWNoZVtuYW1lXSA9IGF3YWl0IHJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdKSB7XG4gICAgICAgICAgICBkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgPSBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGFkZHJlc3NcbiAgICAgICAgdmFsdWUgPSBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5zQ2FjaGVbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgZG9tYWluLCB2YWx1ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgSlNPTi1lbmNvZGVkIHBheWxvYWQgZXhwZWN0ZWQgYnkgbm9kZXMgd2hpY2ggaW1wbGVtZW50XG4gICAgICogIHRoZSBKU09OLVJQQyBbW2xpbmstZWlwLTcxMl1dIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGF5bG9hZChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZG9tYWluIGZpZWxkc1xuICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKTtcbiAgICAgICAgLy8gRGVyaXZlIHRoZSBFSVA3MTJEb21haW4gU3RydWN0IHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGNvbnN0IGRvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgICBjb25zdCBkb21haW5UeXBlcyA9IFtdO1xuICAgICAgICBkb21haW5GaWVsZE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tYWluW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW5WYWx1ZXNbbmFtZV0gPSBkb21haW5DaGVja3NbbmFtZV0odmFsdWUpO1xuICAgICAgICAgICAgZG9tYWluVHlwZXMucHVzaCh7IG5hbWUsIHR5cGU6IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgLy8gR2V0IHRoZSBub3JtYWxpemVkIHR5cGVzXG4gICAgICAgIHR5cGVzID0gZW5jb2Rlci50eXBlcztcbiAgICAgICAgY29uc3QgdHlwZXNXaXRoRG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZXMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID09IG51bGwsIFwidHlwZXMgbXVzdCBub3QgY29udGFpbiBFSVA3MTJEb21haW4gdHlwZVwiLCBcInR5cGVzLkVJUDcxMkRvbWFpblwiLCB0eXBlcyk7XG4gICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlcyBhbmQgdHlwZXNcbiAgICAgICAgZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZXM6IHR5cGVzV2l0aERvbWFpbixcbiAgICAgICAgICAgIGRvbWFpbjogZG9tYWluVmFsdWVzLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IGVuY29kZXIucHJpbWFyeVR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBieXRlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKikvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShnZXRCeXRlcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1aW50IG9yIGludFxuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgYWRkcmVzcyB1c2VkIHRvIHNpZ24gdGhlIHR5cGVkIGRhdGEgZm9yIHRoZSAlJXNpZ25hdHVyZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5VHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3MoVHlwZWREYXRhRW5jb2Rlci5oYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSwgc2lnbmF0dXJlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/hash/typed-data.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/index.js":
/*!******************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ethers: function() { return /* reexport module object */ _ethers_js__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _ethers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ethers.js */ \"../common/node_modules/ethers/lib.esm/ethers.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _ethers_js__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"ethers\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _ethers_js__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/**\n *  The Application Programming Interface (API) is the collection of\n *  functions, classes and types offered by the Ethers library.\n *\n *  @_section: api:Application Programming Interface  [about-api]\n *  @_navTitle: API\n */\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDO0FBQ3BCO0FBQ1U7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaW5kZXguanM/NzliNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBUaGUgQXBwbGljYXRpb24gUHJvZ3JhbW1pbmcgSW50ZXJmYWNlIChBUEkpIGlzIHRoZSBjb2xsZWN0aW9uIG9mXG4gKiAgZnVuY3Rpb25zLCBjbGFzc2VzIGFuZCB0eXBlcyBvZmZlcmVkIGJ5IHRoZSBFdGhlcnMgbGlicmFyeS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGk6QXBwbGljYXRpb24gUHJvZ3JhbW1pbmcgSW50ZXJmYWNlICBbYWJvdXQtYXBpXVxuICogIEBfbmF2VGl0bGU6IEFQSVxuICovXG5pbXBvcnQgKiBhcyBldGhlcnMgZnJvbSBcIi4vZXRoZXJzLmpzXCI7XG5leHBvcnQgeyBldGhlcnMgfTtcbmV4cG9ydCAqIGZyb20gXCIuL2V0aGVycy5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/abstract-provider.js":
/*!****************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/abstract-provider.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProvider: function() { return /* binding */ AbstractProvider; },\n/* harmony export */   UnmanagedSubscriber: function() { return /* binding */ UnmanagedSubscriber; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/index.js */ \"../common/node_modules/ethers/lib.esm/constants/index.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../contract/index.js */ \"../common/node_modules/ethers/lib.esm/contract/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"../common/node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _ens_resolver_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ens-resolver.js */ \"../common/node_modules/ethers/lib.esm/providers/ens-resolver.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./format.js */ \"../common/node_modules/ethers/lib.esm/providers/format.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./provider.js */ \"../common/node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./subscriber-polling.js */ \"../common/node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\n\n\n\n\n\n\n\n\n\n\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n    return (value && typeof (value.then) === \"function\");\n}\nfunction getTag(prefix, value) {\n    return prefix + \":\" + JSON.stringify(value, (k, v) => {\n        if (v == null) {\n            return \"null\";\n        }\n        if (typeof (v) === \"bigint\") {\n            return `bigint:${v.toString()}`;\n        }\n        if (typeof (v) === \"string\") {\n            return v.toLowerCase();\n        }\n        // Sort object keys\n        if (typeof (v) === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key) => {\n                accum[key] = v[key];\n                return accum;\n            }, {});\n        }\n        return v;\n    });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nclass UnmanagedSubscriber {\n    /**\n     *  The name fof the event.\n     */\n    name;\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name) { (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name }); }\n    start() { }\n    stop() { }\n    pause(dropWhilePaused) { }\n    resume() { }\n}\nfunction copy(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n    items = Array.from((new Set(items)).values());\n    items.sort();\n    return items;\n}\nasync function getSubscription(_event, provider) {\n    if (_event == null) {\n        throw new Error(\"invalid event\");\n    }\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) {\n        _event = { topics: _event };\n    }\n    if (typeof (_event) === \"string\") {\n        switch (_event) {\n            case \"block\":\n            case \"debug\":\n            case \"error\":\n            case \"finalized\":\n            case \"network\":\n            case \"pending\":\n            case \"safe\": {\n                return { type: _event, tag: _event };\n            }\n        }\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return { type: \"transaction\", tag: getTag(\"tx\", { hash }), hash };\n    }\n    if (_event.orphan) {\n        const event = _event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return { type: \"orphan\", tag: getTag(\"orphan\", event), filter: copy(event) };\n    }\n    if ((_event.address || _event.topics)) {\n        const event = _event;\n        const filter = {\n            topics: ((event.topics || []).map((t) => {\n                if (t == null) {\n                    return null;\n                }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t) => t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            }))\n        };\n        if (event.address) {\n            const addresses = [];\n            const promises = [];\n            const addAddress = (addr) => {\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(addr)) {\n                    addresses.push(addr);\n                }\n                else {\n                    promises.push((async () => {\n                        addresses.push(await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(addr, provider));\n                    })());\n                }\n            };\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            }\n            else {\n                addAddress(event.address);\n            }\n            if (promises.length) {\n                await Promise.all(promises);\n            }\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()));\n        }\n        return { filter, tag: getTag(\"event\", filter), type: \"event\" };\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() { return (new Date()).getTime(); }\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nclass AbstractProvider {\n    #subs;\n    #plugins;\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState;\n    #destroyed;\n    #networkPromise;\n    #anyNetwork;\n    #performCache;\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber;\n    #nextTimer;\n    #timers;\n    #disableCcipRead;\n    #options;\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */\n    constructor(_network, options) {\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        }\n        else if (_network) {\n            const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(() => { this.emit(\"network\", network, null); }, 0);\n        }\n        else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n        this.#lastBlockNumber = -1;\n        this.#performCache = new Map();\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n        this.#destroyed = false;\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n        this.#disableCcipRead = false;\n    }\n    get pollingInterval() { return this.#options.pollingInterval; }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */\n    get provider() { return this; }\n    /**\n     *  Returns all the registered plug-ins.\n     */\n    get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */\n    attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.connect(this));\n        return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */\n    getPlugin(name) {\n        return (this.#plugins.get(name)) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */\n    get disableCcipRead() { return this.#disableCcipRead; }\n    set disableCcipRead(value) { this.#disableCcipRead = !!value; }\n    // Shares multiple identical requests made during the same 250ms\n    async #perform(req) {\n        const timeout = this.#options.cacheTimeout;\n        // Caching disabled\n        if (timeout < 0) {\n            return await this._perform(req);\n        }\n        // Create a tag\n        const tag = getTag(req.method, req);\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n            this.#performCache.set(tag, perform);\n            setTimeout(() => {\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n        return await perform;\n    }\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */\n    async ccipReadFetch(tx, calldata, urls) {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n            return null;\n        }\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n        const errorMessages = [];\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = { data, sender };\n            }\n            this.emit(\"debug\", { action: \"sendCcipReadFetchRequest\", request, index: i, urls });\n            let errorMessage = \"unknown error\";\n            // Fetch the resource...\n            let resp;\n            try {\n                resp = await request.send();\n            }\n            catch (error) {\n                // ...low-level fetch error (missing host, bad SSL, etc.),\n                // so try next URL\n                errorMessages.push(error.message);\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result: { error } });\n                continue;\n            }\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", { action: \"receiveCcipReadFetchResult\", request, result });\n                    return result.data;\n                }\n                if (result.message) {\n                    errorMessage = result.message;\n                }\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result });\n            }\n            catch (error) { }\n            // 4xx indicates the result is not present; stop\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", { reason: \"404_MISSING_RESOURCE\", transaction: tx, info: { url, errorMessage } });\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx, info: { urls, errorMessages }\n        });\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */\n    _wrapBlock(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.Block((0,_format_js__WEBPACK_IMPORTED_MODULE_4__.formatBlock)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */\n    _wrapLog(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.Log((0,_format_js__WEBPACK_IMPORTED_MODULE_4__.formatLog)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */\n    _wrapTransactionReceipt(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.TransactionReceipt((0,_format_js__WEBPACK_IMPORTED_MODULE_4__.formatTransactionReceipt)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */\n    _wrapTransactionResponse(tx, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.TransactionResponse((0,_format_js__WEBPACK_IMPORTED_MODULE_4__.formatTransactionResponse)(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */\n    _detectNetwork() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */\n    async _perform(req) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n    // State\n    async getBlockNumber() {\n        const blockNumber = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) {\n            this.#lastBlockNumber = blockNumber;\n        }\n        return blockNumber;\n    }\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */\n    _getAddress(address) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */\n    _getBlockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n                return blockTag;\n        }\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(blockTag)) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(blockTag, 32)) {\n                return blockTag;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toQuantity)(blockTag);\n        }\n        if (typeof (blockTag) === \"bigint\") {\n            blockTag = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(blockTag, \"blockTag\");\n        }\n        if (typeof (blockTag) === \"number\") {\n            if (blockTag >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toQuantity)(blockTag);\n            }\n            if (this.#lastBlockNumber >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toQuantity)(this.#lastBlockNumber + blockTag);\n            }\n            return this.getBlockNumber().then((b) => (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toQuantity)(b + blockTag));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */\n    _getFilter(filter) {\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || []).map((t) => {\n            if (t == null) {\n                return null;\n            }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t) => t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n        const blockHash = (\"blockHash\" in filter) ? filter.blockHash : undefined;\n        const resolve = (_address, fromBlock, toBlock) => {\n            let address = undefined;\n            switch (_address.length) {\n                case 0: break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n            const filter = {};\n            if (address) {\n                filter.address = address;\n            }\n            if (topics.length) {\n                filter.topics = topics;\n            }\n            if (fromBlock) {\n                filter.fromBlock = fromBlock;\n            }\n            if (toBlock) {\n                filter.toBlock = toBlock;\n            }\n            if (blockHash) {\n                filter.blockHash = blockHash;\n            }\n            return filter;\n        };\n        // Addresses could be async (ENS names or Addressables)\n        let address = [];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address) {\n                    address.push(this._getAddress(addr));\n                }\n            }\n            else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n        let fromBlock = undefined;\n        if (\"fromBlock\" in filter) {\n            fromBlock = this._getBlockTag(filter.fromBlock);\n        }\n        let toBlock = undefined;\n        if (\"toBlock\" in filter) {\n            toBlock = this._getBlockTag(filter.toBlock);\n        }\n        if (address.filter((a) => (typeof (a) !== \"string\")).length ||\n            (fromBlock != null && typeof (fromBlock) !== \"string\") ||\n            (toBlock != null && typeof (toBlock) !== \"string\")) {\n            return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n        return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resolves to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */\n    _getTransactionRequest(_request) {\n        const request = (0,_provider_js__WEBPACK_IMPORTED_MODULE_3__.copyRequest)(_request);\n        const promises = [];\n        [\"to\", \"from\"].forEach((key) => {\n            if (request[key] == null) {\n                return;\n            }\n            const addr = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(request[key], this);\n            if (isPromise(addr)) {\n                promises.push((async function () { request[key] = await addr; })());\n            }\n            else {\n                request[key] = addr;\n            }\n        });\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push((async function () { request.blockTag = await blockTag; })());\n            }\n            else {\n                request.blockTag = blockTag;\n            }\n        }\n        if (promises.length) {\n            return (async function () {\n                await Promise.all(promises);\n                return request;\n            })();\n        }\n        return request;\n    }\n    async getNetwork() {\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async () => {\n                try {\n                    const network = await this._detectNetwork();\n                    this.emit(\"network\", network, null);\n                    return network;\n                }\n                catch (error) {\n                    if (this.#networkPromise === detectNetwork) {\n                        this.#networkPromise = null;\n                    }\n                    throw error;\n                }\n            })();\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n        const networkPromise = this.#networkPromise;\n        const [expected, actual] = await Promise.all([\n            networkPromise,\n            this._detectNetwork() // The actual connected network\n        ]);\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            }\n            else {\n                // Otherwise, we do not allow changes to the underlying network\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n        return expected.clone();\n    }\n    async getFeeData() {\n        const network = await this.getNetwork();\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice, priorityFee } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getGasPrice\" });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"%response\");\n                    }\n                    catch (error) { }\n                    return null;\n                })()),\n                priorityFee: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getPriorityFee\" });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"%response\");\n                    }\n                    catch (error) { }\n                    return null;\n                })())\n            });\n            let maxFeePerGas = null;\n            let maxPriorityFeePerGas = null;\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = (priorityFee != null) ? priorityFee : BigInt(\"1000000000\");\n                maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;\n            }\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_3__.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n        return await getFeeDataFunc();\n    }\n    async estimateGas(_tx) {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) {\n            tx = await tx;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }\n    async #call(tx, blockTag, attempt) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })\n        });\n        // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n        const transaction = (0,_provider_js__WEBPACK_IMPORTED_MODULE_3__.copyRequest)(tx);\n        try {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(await this._perform({ method: \"call\", transaction, blockTag }));\n        }\n        catch (error) {\n            // CCIP Read OffchainLookup\n            if (!this.disableCcipRead && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isCallException)(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(error.data, 0, 4) === \"0x556f1830\") {\n                const data = error.data;\n                const txSender = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(transaction.to, this);\n                // Parse the CCIP Read Arguments\n                let ccipArgs;\n                try {\n                    ccipArgs = parseOffchainLookup((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(error.data, 4));\n                }\n                catch (error) {\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, error.message, \"OFFCHAIN_FAULT\", {\n                        reason: \"BAD_DATA\", transaction, info: { data }\n                    });\n                }\n                // Check the sender of the OffchainLookup matches the transaction\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                    action: \"call\",\n                    data,\n                    reason: \"OffchainLookup\",\n                    transaction: transaction,\n                    invocation: null,\n                    revert: {\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        name: \"OffchainLookup\",\n                        args: ccipArgs.errorArgs\n                    }\n                });\n                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                    reason: \"FETCH_FAILED\", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs }\n                });\n                const tx = {\n                    to: txSender,\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])\n                };\n                this.emit(\"debug\", { action: \"sendCcipReadCall\", transaction: tx });\n                try {\n                    const result = await this.#call(tx, blockTag, attempt + 1);\n                    this.emit(\"debug\", { action: \"receiveCcipReadCallResult\", transaction: Object.assign({}, tx), result });\n                    return result;\n                }\n                catch (error) {\n                    this.emit(\"debug\", { action: \"receiveCcipReadCallError\", transaction: Object.assign({}, tx), error });\n                    throw error;\n                }\n            }\n            throw error;\n        }\n    }\n    async #checkNetwork(promise) {\n        const { value } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n    async call(_tx) {\n        const { tx, blockTag } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n    }\n    // Account\n    async #getAccountValue(request, _address, _blockTag) {\n        let address = this._getAddress(_address);\n        let blockTag = this._getBlockTag(_blockTag);\n        if (typeof (address) !== \"string\" || typeof (blockTag) !== \"string\") {\n            [address, blockTag] = await Promise.all([address, blockTag]);\n        }\n        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));\n    }\n    async getBalance(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }\n    async getTransactionCount(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }\n    async getCode(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }\n    async getStorage(address, _position, blockTag) {\n        const position = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_position, \"position\");\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }\n    // Write\n    async broadcastTransaction(signedTx) {\n        const { blockNumber, hash, network } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            blockNumber: this.getBlockNumber(),\n            hash: this._perform({\n                method: \"broadcastTransaction\",\n                signedTransaction: signedTx\n            }),\n            network: this.getNetwork()\n        });\n        const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n    }\n    async #getBlock(block, includeTransactions) {\n        // @TODO: Add CustomBlockPlugin check\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            });\n        }\n        let blockTag = this._getBlockTag(block);\n        if (typeof (blockTag) !== \"string\") {\n            blockTag = await blockTag;\n        }\n        return await this.#perform({\n            method: \"getBlock\", blockTag, includeTransactions\n        });\n    }\n    // Queries\n    async getBlock(block, prefetchTxs) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapBlock(params, network);\n    }\n    async getTransaction(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapTransactionResponse(params, network);\n    }\n    async getTransactionReceipt(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) {\n            return null;\n        }\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({ method: \"getTransaction\", hash });\n            if (tx == null) {\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n        return this._wrapTransactionReceipt(params, network);\n    }\n    async getTransactionResult(hash) {\n        const { result } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) {\n            return null;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(result);\n    }\n    // Bloom-filter Queries\n    async getLogs(_filter) {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) {\n            filter = await filter;\n        }\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getLogs\", filter })\n        });\n        return params.map((p) => this._wrapLog(p, network));\n    }\n    // ENS\n    _getProvider(chainId) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n    async getResolver(name) {\n        return await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_6__.EnsResolver.fromName(this, name);\n    }\n    async getAvatar(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAvatar();\n        }\n        return null;\n    }\n    async resolveName(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAddress();\n        }\n        return null;\n    }\n    async lookupAddress(address) {\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        const node = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.namehash)(address.substring(2).toLowerCase() + \".addr.reverse\");\n        try {\n            const ensAddr = await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_6__.EnsResolver.getEnsAddress(this);\n            const ensContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_8__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === _constants_index_js__WEBPACK_IMPORTED_MODULE_9__.ZeroAddress) {\n                return null;\n            }\n            const resolverContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_8__.Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) {\n                return null;\n            }\n            return name;\n        }\n        catch (error) {\n            // No data was returned from the resolver\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n            // Something reerted\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                return null;\n            }\n            throw error;\n        }\n        return null;\n    }\n    async waitForTransaction(hash, _confirms, timeout) {\n        const confirms = (_confirms != null) ? _confirms : 1;\n        if (confirms === 0) {\n            return this.getTransactionReceipt(hash);\n        }\n        return new Promise(async (resolve, reject) => {\n            let timer = null;\n            const listener = (async (blockNumber) => {\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                }\n                catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            });\n            if (timeout != null) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"timeout\", \"TIMEOUT\", { reason: \"timeout\" }));\n                }, timeout);\n            }\n            listener(await this.getBlockNumber());\n        });\n    }\n    async waitForBlock(blockTag) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */\n    _clearTimeout(timerId) {\n        const timer = this.#timers.get(timerId);\n        if (!timer) {\n            return;\n        }\n        if (timer.timer) {\n            clearTimeout(timer.timer);\n        }\n        this.#timers.delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */\n    _setTimeout(_func, timeout) {\n        if (timeout == null) {\n            timeout = 0;\n        }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n        if (this.paused) {\n            this.#timers.set(timerId, { timer: null, func, time: timeout });\n        }\n        else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, { timer, func, time: getTime() });\n        }\n        return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */\n    _forEachSubscriber(func) {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */\n    _getSubscriber(sub) {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__.PollingBlockSubscriber(this);\n                subscriber.pollingInterval = this.pollingInterval;\n                return subscriber;\n            }\n            case \"safe\":\n            case \"finalized\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__.PollingBlockTagSubscriber(this, sub.type);\n            case \"event\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__.PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__.PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_10__.PollingOrphanSubscriber(this, sub.filter);\n        }\n        throw new Error(`unsupported event: ${sub.type}`);\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */\n    _recoverSubscriber(oldSub, newSub) {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) {\n                    sub.subscriber.stop();\n                }\n                sub.subscriber = newSub;\n                if (sub.started) {\n                    newSub.start();\n                }\n                if (this.#pausedState != null) {\n                    newSub.pause(this.#pausedState);\n                }\n                break;\n            }\n        }\n    }\n    async #hasSub(event, emitArgs) {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({ orphan: \"drop-log\", log: emitArgs[0] }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n    async #getSub(event) {\n        const subscription = await getSubscription(event, this);\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };\n            this.#subs.set(tag, sub);\n        }\n        return sub;\n    }\n    async on(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async once(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async emit(event, ...args) {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) {\n            return false;\n        }\n        ;\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\n            const payload = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.EventPayload(this, (once ? null : listener), event);\n            try {\n                listener.call(this, ...args, payload);\n            }\n            catch (error) { }\n            return !once;\n        });\n        if (sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return (count > 0);\n    }\n    async listenerCount(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        let total = 0;\n        for (const { listeners } of this.#subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n    async listeners(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result = [];\n        for (const { listeners } of this.#subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n    async off(event, listener) {\n        const sub = await this.#hasSub(event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return this;\n    }\n    async removeAllListeners(event) {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) {\n                subscriber.stop();\n            }\n            this.#subs.delete(tag);\n        }\n        else {\n            for (const [tag, { started, subscriber }] of this.#subs) {\n                if (started) {\n                    subscriber.stop();\n                }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    // Alias for \"on\"\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    // Alias for \"off\"\n    async removeListener(event, listener) {\n        return this.off(event, listener);\n    }\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */\n    get destroyed() {\n        return this.#destroyed;\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */\n    destroy() {\n        // Stop all listeners\n        this.removeAllListeners();\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n        this.#destroyed = true;\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */\n    get paused() { return (this.#pausedState != null); }\n    set paused(pause) {\n        if (!!pause === this.paused) {\n            return;\n        }\n        if (this.paused) {\n            this.resume();\n        }\n        else {\n            this.pause(false);\n        }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */\n    pause(dropWhilePaused) {\n        this.#lastBlockNumber = -1;\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) {\n                return;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n        for (const timer of this.#timers.values()) {\n            // Clear the timer\n            if (timer.timer) {\n                clearTimeout(timer.timer);\n            }\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n    /**\n     *  Resume the provider.\n     */\n    resume() {\n        if (this.#pausedState == null) {\n            return;\n        }\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\nfunction _parseString(result, start) {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8String)(bytes);\n        }\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    try {\n        const offset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(result, start, start + 32));\n        const length = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(result, offset, offset + 32));\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(result, offset + 32, offset + 32 + length);\n    }\n    catch (error) { }\n    return null;\n}\nfunction numPad(value) {\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(empty);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n    const result = {\n        sender: \"\", urls: [], calldata: \"\", selector: \"\", extraData: \"\", errorArgs: []\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n    const sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, 0, 32);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(sender, 0, 12) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(sender, 12);\n    // Read the URLs from the response\n    try {\n        const urls = [];\n        const urlsOffset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, 32, 64));\n        const urlsLength = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, urlsOffset, urlsOffset + 32));\n        const urlsData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, urlsOffset + 32);\n        for (let u = 0; u < urlsLength; u++) {\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) {\n                throw new Error(\"abort\");\n            }\n            urls.push(url);\n        }\n        result.urls = urls;\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) {\n            throw new Error(\"abort\");\n        }\n        result.calldata = calldata;\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n    // Get the callbackSelector (bytes4)\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, 100, 128) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)(data, 96, 100);\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) {\n            throw new Error(\"abort\");\n        }\n        result.extraData = extraData;\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k) => result[k]);\n    return result;\n}\n//# sourceMappingURL=abstract-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUU7QUFDYjtBQUNKO0FBQ0o7QUFDVTtBQUNxTztBQUMzTztBQUMwRDtBQUNuRTtBQUNtRTtBQUNpRTtBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpRUFBZ0IsU0FBUyxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQVc7QUFDbkI7QUFDQSxpQkFBaUIseUNBQXlDLE1BQU07QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQVc7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REFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJLHVEQUFNLENBQUMsMERBQVMscUJBQXFCLDBEQUFTO0FBQ2xEO0FBQ0EsS0FBSztBQUNMLHNCQUFzQiwwREFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanM/YWNhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBUaGUgYXZhaWxhYmxlIHByb3ZpZGVycyBzaG91bGQgc3VmZmljZSBmb3IgbW9zdCBkZXZlbG9wZXJzIHB1cnBvc2VzLFxuICogIGJ1dCB0aGUgW1tBYnN0cmFjdFByb3ZpZGVyXV0gY2xhc3MgaGFzIG1hbnkgZmVhdHVyZXMgd2hpY2ggZW5hYmxlXG4gKiAgc3ViLWNsYXNzaW5nIGl0IGZvciBzcGVjaWZpYyBwdXJwb3Nlcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyOiBTdWJjbGFzc2luZyBQcm92aWRlciAgW2Fic3RyYWN0LXByb3ZpZGVyXVxuICovXG4vLyBAVE9ET1xuLy8gRXZlbnQgY29hbGVzY2VuY2Vcbi8vICAgV2hlbiB3ZSByZWdpc3RlciBhbiBldmVudCB3aXRoIGFuIGFzeW5jIHZhbHVlIChlLmcuIGFkZHJlc3MgaXMgYSBTaWduZXJcbi8vICAgb3IgRU5TIG5hbWUpLCB3ZSBuZWVkIHRvIGFkZCBpdCBpbW1laWRhdGVseSBmb3IgdGhlIEV2ZW50IEFQSSwgYnV0IGFsc29cbi8vICAgbmVlZCB0aW1lIHRvIHJlc29sdmUgdGhlIGFkZHJlc3MuIFVwb24gcmVzb2x2aW5nIHRoZSBhZGRyZXNzLCB3ZSBuZWVkIHRvXG4vLyAgIG1pZ3JhdGUgdGhlIGxpc3RlbmVyIHRvIHRoZSBzdGF0aWMgZXZlbnQuIFdlIGFsc28gbmVlZCB0byBtYWludGFpbiBhIG1hcFxuLy8gICBvZiBTaWduZXIvRU5TIG5hbWUgdG8gYWRkcmVzcyBzbyB3ZSBjYW4gc3luYyByZXNwb25kIHRvIGxpc3RlbmVyQ291bnQuXG5pbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBaZXJvQWRkcmVzcyB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBuYW1laGFzaCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBkYXRhU2xpY2UsIGhleGxpZnksIGlzSGV4U3RyaW5nLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXROdW1iZXIsIGlzQ2FsbEV4Y2VwdGlvbiwgaXNFcnJvciwgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBGZXRjaFJlcXVlc3QsIHRvQmVBcnJheSwgdG9RdWFudGl0eSwgZGVmaW5lUHJvcGVydGllcywgRXZlbnRQYXlsb2FkLCByZXNvbHZlUHJvcGVydGllcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBFbnNSZXNvbHZlciB9IGZyb20gXCIuL2Vucy1yZXNvbHZlci5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0QmxvY2ssIGZvcm1hdExvZywgZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0LCBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4vZm9ybWF0LmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xuaW1wb3J0IHsgY29weVJlcXVlc3QsIEJsb2NrLCBGZWVEYXRhLCBMb2csIFRyYW5zYWN0aW9uUmVjZWlwdCwgVHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyLCBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyLCBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyLCBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciwgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiO1xuLy8gQ29uc3RhbnRzXG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgTUFYX0NDSVBfUkVESVJFQ1RTID0gMTA7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBnZXRUYWcocHJlZml4LCB2YWx1ZSkge1xuICAgIHJldHVybiBwcmVmaXggKyBcIjpcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoaywgdikgPT4ge1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgYmlnaW50OiR7di50b1N0cmluZygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydCBvYmplY3Qga2V5c1xuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHYpO1xuICAgICAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtrZXldID0gdltrZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9KTtcbn1cbi8qKlxuICogIEFuICoqVW5tYW5hZ2VkU3Vic2NyaWJlcioqIGlzIHVzZWZ1bCBmb3IgZXZlbnRzIHdoaWNoIGRvIG5vdCByZXF1aXJlXG4gKiAgYW55IGFkZGl0aW9uYWwgbWFuYWdlbWVudCwgc3VjaCBhcyBgYFwiZGVidWdcImBgIHdoaWNoIG9ubHkgcmVxdWlyZXNcbiAqICBlbWl0IGluIHN5bmNocm9ub3VzIGV2ZW50IGxvb3AgdHJpZ2dlcmVkIGNhbGxzLlxuICovXG5leHBvcnQgY2xhc3MgVW5tYW5hZ2VkU3Vic2NyaWJlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIGZvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IFVubWFuYWdlZFN1YnNjcmliZXIgd2l0aCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7IGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pOyB9XG4gICAgc3RhcnQoKSB7IH1cbiAgICBzdG9wKCkgeyB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IH1cbiAgICByZXN1bWUoKSB7IH1cbn1cbmZ1bmN0aW9uIGNvcHkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gY29uY2lzaWZ5KGl0ZW1zKSB7XG4gICAgaXRlbXMgPSBBcnJheS5mcm9tKChuZXcgU2V0KGl0ZW1zKSkudmFsdWVzKCkpO1xuICAgIGl0ZW1zLnNvcnQoKTtcbiAgICByZXR1cm4gaXRlbXM7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWJzY3JpcHRpb24oX2V2ZW50LCBwcm92aWRlcikge1xuICAgIGlmIChfZXZlbnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGV2ZW50XCIpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdG9waWMgYXJyYXkgaW5mbyBhbiBFdmVudEZpbHRlclxuICAgIGlmIChBcnJheS5pc0FycmF5KF9ldmVudCkpIHtcbiAgICAgICAgX2V2ZW50ID0geyB0b3BpY3M6IF9ldmVudCB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChfZXZlbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN3aXRjaCAoX2V2ZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICBjYXNlIFwibmV0d29ya1wiOlxuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBfZXZlbnQsIHRhZzogX2V2ZW50IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKF9ldmVudCwgMzIpKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBfZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0cmFuc2FjdGlvblwiLCB0YWc6IGdldFRhZyhcInR4XCIsIHsgaGFzaCB9KSwgaGFzaCB9O1xuICAgIH1cbiAgICBpZiAoX2V2ZW50Lm9ycGhhbikge1xuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICAgICAgLy8gQFRPRE86IFNob3VsZCBsb3dlcmNhc2UgYW5kIHdoYXRub3QgdGhpbmdzIGhlcmUgaW5zdGVhZCBvZiBjb3B5Li4uXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwib3JwaGFuXCIsIHRhZzogZ2V0VGFnKFwib3JwaGFuXCIsIGV2ZW50KSwgZmlsdGVyOiBjb3B5KGV2ZW50KSB9O1xuICAgIH1cbiAgICBpZiAoKF9ldmVudC5hZGRyZXNzIHx8IF9ldmVudC50b3BpY3MpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICB0b3BpY3M6ICgoZXZlbnQudG9waWNzIHx8IFtdKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZlbnQuYWRkcmVzcykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYWRkQWRkcmVzcyA9IChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYXdhaXQgcmVzb2x2ZUFkZHJlc3MoYWRkciwgcHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuYWRkcmVzcy5mb3JFYWNoKGFkZEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQWRkcmVzcyhldmVudC5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGNvbmNpc2lmeShhZGRyZXNzZXMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaWx0ZXIsIHRhZzogZ2V0VGFnKFwiZXZlbnRcIiwgZmlsdGVyKSwgdHlwZTogXCJldmVudFwiIH07XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gUHJvdmlkZXJFdmVudFwiLCBcImV2ZW50XCIsIF9ldmVudCk7XG59XG5mdW5jdGlvbiBnZXRUaW1lKCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgY2FjaGVUaW1lb3V0OiAyNTAsXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXG59O1xuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFByb3ZpZGVyKiogcHJvdmlkZXMgYSBiYXNlIGNsYXNzIGZvciBvdGhlciBzdWItY2xhc3NlcyB0b1xuICogIGltcGxlbWVudCB0aGUgW1tQcm92aWRlcl1dIEFQSSBieSBub3JtYWxpemluZyBpbnB1dCBhcmd1bWVudHMgYW5kXG4gKiAgZm9ybWF0dGluZyBvdXRwdXQgcmVzdWx0cyBhcyB3ZWxsIGFzIHRyYWNraW5nIGV2ZW50cyBmb3IgY29uc2lzdGVudFxuICogIGJlaGF2aW91ciBvbiBhbiBldmVudHVhbGx5LWNvbnNpc3RlbnQgbmV0d29yay5cbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0UHJvdmlkZXIge1xuICAgICNzdWJzO1xuICAgICNwbHVnaW5zO1xuICAgIC8vIG51bGw9dW5wYXVzZWQsIHRydWU9cGF1c2VkK2Ryb3BXaGlsZVBhdXNlZCwgZmFsc2U9cGF1c2VkXG4gICAgI3BhdXNlZFN0YXRlO1xuICAgICNkZXN0cm95ZWQ7XG4gICAgI25ldHdvcmtQcm9taXNlO1xuICAgICNhbnlOZXR3b3JrO1xuICAgICNwZXJmb3JtQ2FjaGU7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIG51bWJlciBpZiBydW5uaW5nIGFuIGV2ZW50IG9yIC0xIGlmIG5vIFwiYmxvY2tcIiBldmVudFxuICAgICNsYXN0QmxvY2tOdW1iZXI7XG4gICAgI25leHRUaW1lcjtcbiAgICAjdGltZXJzO1xuICAgICNkaXNhYmxlQ2NpcFJlYWQ7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkFic3RyYWN0UHJvdmlkZXIqKiBjb25uZWN0ZWQgdG8gJSVuZXR3b3JrJSUsIG9yXG4gICAgICogIHVzZSB0aGUgdmFyaW91cyBuZXR3b3JrIGRldGVjdGlvbiBjYXBhYmlsaXRpZXMgdG8gZGlzY292ZXIgdGhlXG4gICAgICogIFtbTmV0d29ya11dIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICBpZiAoX25ldHdvcmsgPT09IFwiYW55XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9uZXR3b3JrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG5ldHdvcmspO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7IH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xuICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3N1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI25leHRUaW1lciA9IDE7XG4gICAgICAgIHRoaXMuI3RpbWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNvcHRpb25zLnBvbGxpbmdJbnRlcnZhbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdGhpc2BgLCB0byBhbGxvdyBhbiAqKkFic3RyYWN0UHJvdmlkZXIqKiB0byBpbXBsZW1lbnRcbiAgICAgKiAgdGhlIFtbQ29udHJhY3RSdW5uZXJdXSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZ2V0IHByb3ZpZGVyKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFsbCB0aGUgcmVnaXN0ZXJlZCBwbHVnLWlucy5cbiAgICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jcGx1Z2lucy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBdHRhY2ggYSBuZXcgcGx1Zy1pbi5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNvbm5lY3QodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCBhIHBsdWdpbiBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcGx1Z2lucy5nZXQobmFtZSkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcmV2ZW50IGFueSBDQ0lQLXJlYWQgb3BlcmF0aW9uLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgcmVxdWVzdGVkXG4gICAgICogIGluIGEgW1tjYWxsXV0gdXNpbmcgYGBlbmFibGVDY2lwUmVhZGBgLlxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlQ2NpcFJlYWQoKSB7IHJldHVybiB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQ7IH1cbiAgICBzZXQgZGlzYWJsZUNjaXBSZWFkKHZhbHVlKSB7IHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9ICEhdmFsdWU7IH1cbiAgICAvLyBTaGFyZXMgbXVsdGlwbGUgaWRlbnRpY2FsIHJlcXVlc3RzIG1hZGUgZHVyaW5nIHRoZSBzYW1lIDI1MG1zXG4gICAgYXN5bmMgI3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLiNvcHRpb25zLmNhY2hlVGltZW91dDtcbiAgICAgICAgLy8gQ2FjaGluZyBkaXNhYmxlZFxuICAgICAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgdGFnXG4gICAgICAgIGNvbnN0IHRhZyA9IGdldFRhZyhyZXEubWV0aG9kLCByZXEpO1xuICAgICAgICBsZXQgcGVyZm9ybSA9IHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKTtcbiAgICAgICAgaWYgKCFwZXJmb3JtKSB7XG4gICAgICAgICAgICBwZXJmb3JtID0gdGhpcy5fcGVyZm9ybShyZXEpO1xuICAgICAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlLnNldCh0YWcsIHBlcmZvcm0pO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BlcmZvcm1DYWNoZS5nZXQodGFnKSA9PT0gcGVyZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZGF0YSBmb3IgZXhlY3V0aW5nIHRoZSBDQ0lQLXJlYWQgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBjY2lwUmVhZEZldGNoKHR4LCBjYWxsZGF0YSwgdXJscykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2NpcFJlYWQgfHwgdXJscy5sZW5ndGggPT09IDAgfHwgdHgudG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdHgudG8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxzW2ldO1xuICAgICAgICAgICAgLy8gVVJMIGV4cGFuc2lvblxuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHVybC5yZXBsYWNlKFwie3NlbmRlcn1cIiwgc2VuZGVyKS5yZXBsYWNlKFwie2RhdGF9XCIsIGRhdGEpO1xuICAgICAgICAgICAgLy8gSWYgbm8ge2RhdGF9IGlzIHByZXNlbnQsIHVzZSBQT1NUOyBvdGhlcndpc2UgR0VUXG4gICAgICAgICAgICAvL2NvbnN0IGpzb246IHN0cmluZyB8IG51bGwgPSAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPj0gMCkgPyBudWxsOiBKU09OLnN0cmluZ2lmeSh7IGRhdGEsIHNlbmRlciB9KTtcbiAgICAgICAgICAgIC8vY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hKc29uKHsgdXJsOiBocmVmLCBlcnJvclBhc3NUaHJvdWdoOiB0cnVlIH0sIGpzb24sICh2YWx1ZSwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vICAgIHZhbHVlLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgICAvLyAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvL30pO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoaHJlZik7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0geyBkYXRhLCBzZW5kZXIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRDY2lwUmVhZEZldGNoUmVxdWVzdFwiLCByZXF1ZXN0LCBpbmRleDogaSwgdXJscyB9KTtcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcInVua25vd24gZXJyb3JcIjtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSByZXNvdXJjZS4uLlxuICAgICAgICAgICAgbGV0IHJlc3A7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3AgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIC4uLmxvdy1sZXZlbCBmZXRjaCBlcnJvciAobWlzc2luZyBob3N0LCBiYWQgU1NMLCBldGMuKSxcbiAgICAgICAgICAgICAgICAvLyBzbyB0cnkgbmV4dCBVUkxcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hFcnJvclwiLCByZXF1ZXN0LCByZXN1bHQ6IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcC5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hSZXN1bHRcIiwgcmVxdWVzdCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSByZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hFcnJvclwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gNHh4IGluZGljYXRlcyB0aGUgcmVzdWx0IGlzIG5vdCBwcmVzZW50OyBzdG9wXG4gICAgICAgICAgICBhc3NlcnQocmVzcC5zdGF0dXNDb2RlIDwgNDAwIHx8IHJlc3Auc3RhdHVzQ29kZSA+PSA1MDAsIGByZXNwb25zZSBub3QgZm91bmQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlfWAsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwgeyByZWFzb246IFwiNDA0X01JU1NJTkdfUkVTT1VSQ0VcIiwgdHJhbnNhY3Rpb246IHR4LCBpbmZvOiB7IHVybCwgZXJyb3JNZXNzYWdlIH0gfSk7XG4gICAgICAgICAgICAvLyA1eHggaW5kaWNhdGVzIHNlcnZlciBpc3N1ZTsgdHJ5IHRoZSBuZXh0IHVybFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlcy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0pKS5qb2luKFwiLCBcIil9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiNTAwX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LCBpbmZvOiB7IHVybHMsIGVycm9yTWVzc2FnZXMgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGJsb2NrIGJlZm9yZVxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXG4gICAgICogIHN1Yi1jbGFzcyBvZiBbW0Jsb2NrXV0uXG4gICAgICovXG4gICAgX3dyYXBCbG9jayh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrKGZvcm1hdEJsb2NrKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSBsb2cgYmVmb3JlXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbTG9nXV0uXG4gICAgICovXG4gICAgX3dyYXBMb2codmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2coZm9ybWF0TG9nKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxuICAgICAqICByZWNlaXB0IGJlZm9yZSByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW5cbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVjZWlwdF1dLlxuICAgICAqL1xuICAgIF93cmFwVHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZWNlaXB0KGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgdHJhbnNhY3Rpb25cbiAgICAgKiAgcmVzcG9uc2UgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxuICAgICAqICBhbHRlcm5hdGUgc3ViLWNsYXNzIG9mIFtbVHJhbnNhY3Rpb25SZXNwb25zZV1dLlxuICAgICAqL1xuICAgIF93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UoZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh0eCksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIE5ldHdvcmssIGZvcmNpbmcgYSBuZXR3b3JrIGRldGVjdGlvbiB1c2luZyB3aGF0ZXZlclxuICAgICAqICB0ZWNobmlxdWUgdGhlIHN1Yi1jbGFzcyByZXF1aXJlcy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzLlxuICAgICAqL1xuICAgIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwic3ViLWNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgdGhpc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiX2RldGVjdE5ldHdvcmtcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIHNob3VsZCB1c2UgdGhpcyB0byBwZXJmb3JtIGFsbCBidWlsdC1pbiBvcGVyYXRpb25zLiBBbGxcbiAgICAgKiAgbWV0aG9kcyBzYW5pdGl6ZXMgYW5kIG5vcm1hbGl6ZXMgdGhlIHZhbHVlcyBwYXNzZWQgaW50byB0aGlzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgYHVuc3VwcG9ydGVkIG1ldGhvZDogJHtyZXEubWV0aG9kfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogcmVxLm1ldGhvZCxcbiAgICAgICAgICAgIGluZm86IHJlcVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gU3RhdGVcbiAgICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBnZXROdW1iZXIoYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRCbG9ja051bWJlclwiIH0pLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWFkZHJlc3MlJSwgcmVzb2x2aW5nIEVOU1xuICAgICAqICBuYW1lcyBhbmQgW1tBZGRyZXNzYWJsZV1dIG9iamVjdHMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGFuXG4gICAgICogIGFkZHJlc3MuXG4gICAgICovXG4gICAgX2dldEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3MoYWRkcmVzcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgdmFsaWQgYmxvY2sgdGFnIGZvciAlJWJsb2NrVGFnJSUsIHJlc29sdmluZ1xuICAgICAqICBuZWdhdGl2ZSB2YWx1ZXMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWQgYmxvY2sgdGFnLlxuICAgICAqL1xuICAgIF9nZXRCbG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChibG9ja1RhZykge1xuICAgICAgICAgICAgY2FzZSBcImVhcmxpZXN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICBjYXNlIFwibGF0ZXN0XCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrVGFnLCAzMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eShibG9ja1RhZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGdldE51bWJlcihibG9ja1RhZywgXCJibG9ja1RhZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChibG9ja1RhZyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkoYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodGhpcy4jbGFzdEJsb2NrTnVtYmVyICsgYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChiKSA9PiB0b1F1YW50aXR5KGIgKyBibG9ja1RhZykpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgYmxvY2tUYWdcIiwgXCJibG9ja1RhZ1wiLCBibG9ja1RhZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgZmlsdGVyIGZvciAlJWZpbHRlciUlLCByZXNvbHZpbmcgYW55IEVOU1xuICAgICAqICBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0IGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXG4gICAgICogIGZpbHRlci5cbiAgICAgKi9cbiAgICBfZ2V0RmlsdGVyKGZpbHRlcikge1xuICAgICAgICAvLyBDcmVhdGUgYSBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRvcGljc1xuICAgICAgICBjb25zdCB0b3BpY3MgPSAoZmlsdGVyLnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJsb2NrSGFzaCA9IChcImJsb2NrSGFzaFwiIGluIGZpbHRlcikgPyBmaWx0ZXIuYmxvY2tIYXNoIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gKF9hZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc3dpdGNoIChfYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBfYWRkcmVzcy5zb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUJsb2NrICE9IG51bGwgfHwgdG9CbG9jayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmlsdGVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9waWNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IGZyb21CbG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSB0b0Jsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci5ibG9ja0hhc2ggPSBibG9ja0hhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBZGRyZXNzZXMgY291bGQgYmUgYXN5bmMgKEVOUyBuYW1lcyBvciBBZGRyZXNzYWJsZXMpXG4gICAgICAgIGxldCBhZGRyZXNzID0gW107XG4gICAgICAgIGlmIChmaWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIG9mIGZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGFkZHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLnB1c2godGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBmcm9tQmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcImZyb21CbG9ja1wiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgZnJvbUJsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLmZyb21CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvQmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcInRvQmxvY2tcIiBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHRvQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIudG9CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3MuZmlsdGVyKChhKSA9PiAodHlwZW9mIChhKSAhPT0gXCJzdHJpbmdcIikpLmxlbmd0aCB8fFxuICAgICAgICAgICAgKGZyb21CbG9jayAhPSBudWxsICYmIHR5cGVvZiAoZnJvbUJsb2NrKSAhPT0gXCJzdHJpbmdcIikgfHxcbiAgICAgICAgICAgICh0b0Jsb2NrICE9IG51bGwgJiYgdHlwZW9mICh0b0Jsb2NrKSAhPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbUHJvbWlzZS5hbGwoYWRkcmVzcyksIGZyb21CbG9jaywgdG9CbG9ja10pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoYWRkcmVzcywgZnJvbUJsb2NrLCB0b0Jsb2NrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSB0cmFuc2FjdGlvbiBmb3IgJSVyZXF1ZXN0JSUsIHJlc29sdmluZ1xuICAgICAqICBhbnkgRU5TIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZFxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF9yZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjb3B5UmVxdWVzdChfcmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIFtcInRvXCIsIFwiZnJvbVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSByZXNvbHZlQWRkcmVzcyhyZXF1ZXN0W2tleV0sIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShhZGRyKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdFtrZXldID0gYXdhaXQgYWRkcjsgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0W2tleV0gPSBhZGRyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlcXVlc3QuYmxvY2tUYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhyZXF1ZXN0LmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0LmJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7IH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ibG9ja1RhZyA9IGJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGFzeW5jIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IG5ldHdvcmsgd2FzIHNldCBhbmQgdGhpcyBpcyBvdXIgZmlyc3QgdGltZVxuICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGV0ZWN0IHRoZSBjdXJyZW50IG5ldHdvcmsgKHNoYXJlZCB3aXRoIGFsbCBjYWxscylcbiAgICAgICAgICAgIGNvbnN0IGRldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLl9kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09PSBkZXRlY3ROZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gZGV0ZWN0TmV0d29yaztcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgZGV0ZWN0TmV0d29yaykuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrUHJvbWlzZSA9IHRoaXMuI25ldHdvcmtQcm9taXNlO1xuICAgICAgICBjb25zdCBbZXhwZWN0ZWQsIGFjdHVhbF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBuZXR3b3JrUHJvbWlzZSxcbiAgICAgICAgICAgIHRoaXMuX2RldGVjdE5ldHdvcmsoKSAvLyBUaGUgYWN0dWFsIGNvbm5lY3RlZCBuZXR3b3JrXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoZXhwZWN0ZWQuY2hhaW5JZCAhPT0gYWN0dWFsLmNoYWluSWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIFwiYW55XCIgbmV0d29yayBjYW4gY2hhbmdlLCBzbyBub3RpZnkgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBhY3R1YWwsIGV4cGVjdGVkKTtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG5ldHdvcmsgaWYgc29tZXRoaW5nIGVsc2UgaGFzbid0IGFscmVhZHkgY2hhbmdlZCBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PT0gbmV0d29ya1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYWN0dWFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGRvIG5vdCBhbGxvdyBjaGFuZ2VzIHRvIHRoZSB1bmRlcmx5aW5nIG5ldHdvcmtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGBuZXR3b3JrIGNoYW5nZWQ6ICR7ZXhwZWN0ZWQuY2hhaW5JZH0gPT4gJHthY3R1YWwuY2hhaW5JZH0gYCwgXCJORVRXT1JLX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiY2hhbmdlZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkLmNsb25lKCk7XG4gICAgfVxuICAgIGFzeW5jIGdldEZlZURhdGEoKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgY29uc3QgZ2V0RmVlRGF0YUZ1bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IF9ibG9jaywgZ2FzUHJpY2UsIHByaW9yaXR5RmVlIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgX2Jsb2NrOiB0aGlzLiNnZXRCbG9jayhcImxhdGVzdFwiLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6ICgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldEdhc1ByaWNlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpKSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eUZlZTogKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0UHJpb3JpdHlGZWVcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUsIFwiJXJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pKCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBtYXhGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG1heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgcmVjb21tZW5kZWQgRUlQLTE1NTkgaGV1cmlzdGljcyBmb3IgZmVlIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5fd3JhcEJsb2NrKF9ibG9jaywgbmV0d29yayk7XG4gICAgICAgICAgICBpZiAoYmxvY2sgJiYgYmxvY2suYmFzZUZlZVBlckdhcykge1xuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gKHByaW9yaXR5RmVlICE9IG51bGwpID8gcHJpb3JpdHlGZWUgOiBCaWdJbnQoXCIxMDAwMDAwMDAwXCIpO1xuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IChibG9jay5iYXNlRmVlUGVyR2FzICogQk5fMikgKyBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVlRGF0YShnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENoZWNrIGZvciBhIEZlZURhdGFOZXRXb3JrUGx1Z2luXG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xuICAgICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KHBsdWdpbi51cmwpO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHBsdWdpbi5wcm9jZXNzRnVuYyhnZXRGZWVEYXRhRnVuYywgdGhpcywgcmVxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVlRGF0YShmZWVEYXRhLmdhc1ByaWNlLCBmZWVEYXRhLm1heEZlZVBlckdhcywgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldEZlZURhdGFGdW5jKCk7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKF90eCkge1xuICAgICAgICBsZXQgdHggPSB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSh0eCkpIHtcbiAgICAgICAgICAgIHR4ID0gYXdhaXQgdHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEJpZ0ludChhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJlc3RpbWF0ZUdhc1wiLCB0cmFuc2FjdGlvbjogdHhcbiAgICAgICAgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyAjY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQpIHtcbiAgICAgICAgYXNzZXJ0KGF0dGVtcHQgPCBNQVhfQ0NJUF9SRURJUkVDVFMsIFwiQ0NJUCByZWFkIGV4Y2VlZGVkIG1heGltdW0gcmVkaXJlY3Rpb25zXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcIlRPT19NQU5ZX1JFRElSRUNUU1wiLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4LCB7IGJsb2NrVGFnLCBlbmFibGVDY2lwUmVhZDogdHJ1ZSB9KVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBjYW1lIGluIGFzIGEgUGVyZm9ybUFjdGlvblRyYW5zYWN0aW9uLCBzbyB0by9mcm9tIGFyZSBzYWZlOyB3ZSBjYW4gY2FzdFxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNvcHlSZXF1ZXN0KHR4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuX3BlcmZvcm0oeyBtZXRob2Q6IFwiY2FsbFwiLCB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ0NJUCBSZWFkIE9mZmNoYWluTG9va3VwXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZUNjaXBSZWFkICYmIGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSAmJiBhdHRlbXB0ID49IDAgJiYgYmxvY2tUYWcgPT09IFwibGF0ZXN0XCIgJiYgdHJhbnNhY3Rpb24udG8gIT0gbnVsbCAmJiBkYXRhU2xpY2UoZXJyb3IuZGF0YSwgMCwgNCkgPT09IFwiMHg1NTZmMTgzMFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVycm9yLmRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhTZW5kZXIgPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0cmFuc2FjdGlvbi50bywgdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIENDSVAgUmVhZCBBcmd1bWVudHNcbiAgICAgICAgICAgICAgICBsZXQgY2NpcEFyZ3M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2NpcEFyZ3MgPSBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGFTbGljZShlcnJvci5kYXRhLCA0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGVycm9yLm1lc3NhZ2UsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkJBRF9EQVRBXCIsIHRyYW5zYWN0aW9uLCBpbmZvOiB7IGRhdGEgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHNlbmRlciBvZiB0aGUgT2ZmY2hhaW5Mb29rdXAgbWF0Y2hlcyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBhc3NlcnQoY2NpcEFyZ3Muc2VuZGVyLnRvTG93ZXJDYXNlKCkgPT09IHR4U2VuZGVyLnRvTG93ZXJDYXNlKCksIFwiQ0NJUCBSZWFkIHNlbmRlciBtaXNtYXRjaFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBjY2lwQXJncy5lcnJvckFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNjaXBSZXN1bHQgPSBhd2FpdCB0aGlzLmNjaXBSZWFkRmV0Y2godHJhbnNhY3Rpb24sIGNjaXBBcmdzLmNhbGxkYXRhLCBjY2lwQXJncy51cmxzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoY2NpcFJlc3VsdCAhPSBudWxsLCBcIkNDSVAgUmVhZCBmYWlsZWQgdG8gZmV0Y2ggZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkZFVENIX0ZBSUxFRFwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhOiBlcnJvci5kYXRhLCBlcnJvckFyZ3M6IGNjaXBBcmdzLmVycm9yQXJncyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiB0eFNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY29uY2F0KFtjY2lwQXJncy5zZWxlY3RvciwgZW5jb2RlQnl0ZXMoW2NjaXBSZXN1bHQsIGNjaXBBcmdzLmV4dHJhRGF0YV0pXSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRDY2lwUmVhZENhbGxcIiwgdHJhbnNhY3Rpb246IHR4IH0pO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxSZXN1bHRcIiwgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4KSwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkQ2FsbEVycm9yXCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjY2hlY2tOZXR3b3JrKHByb21pc2UpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICB2YWx1ZTogcHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKF90eCkge1xuICAgICAgICBjb25zdCB7IHR4LCBibG9ja1RhZyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdHg6IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfdHgpLFxuICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKF90eC5ibG9ja1RhZylcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jY2FsbCh0eCwgYmxvY2tUYWcsIF90eC5lbmFibGVDY2lwUmVhZCA/IDAgOiAtMSkpO1xuICAgIH1cbiAgICAvLyBBY2NvdW50XG4gICAgYXN5bmMgI2dldEFjY291bnRWYWx1ZShyZXF1ZXN0LCBfYWRkcmVzcywgX2Jsb2NrVGFnKSB7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhfYWRkcmVzcyk7XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKF9ibG9ja1RhZyk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBbYWRkcmVzcywgYmxvY2tUYWddID0gYXdhaXQgUHJvbWlzZS5hbGwoW2FkZHJlc3MsIGJsb2NrVGFnXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NoZWNrTmV0d29yayh0aGlzLiNwZXJmb3JtKE9iamVjdC5hc3NpZ24ocmVxdWVzdCwgeyBhZGRyZXNzLCBibG9ja1RhZyB9KSkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRCYWxhbmNlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBnZXRCaWdJbnQoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldEJhbGFuY2VcIiB9LCBhZGRyZXNzLCBibG9ja1RhZyksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBnZXROdW1iZXIoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uQ291bnRcIiB9LCBhZGRyZXNzLCBibG9ja1RhZyksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDb2RlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRDb2RlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U3RvcmFnZShhZGRyZXNzLCBfcG9zaXRpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0QmlnSW50KF9wb3NpdGlvbiwgXCJwb3NpdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFN0b3JhZ2VcIiwgcG9zaXRpb24gfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgLy8gV3JpdGVcbiAgICBhc3luYyBicm9hZGNhc3RUcmFuc2FjdGlvbihzaWduZWRUeCkge1xuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBoYXNoLCBuZXR3b3JrIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgaGFzaDogdGhpcy5fcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgc2lnbmVkVHJhbnNhY3Rpb246IHNpZ25lZFR4XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eCA9IFRyYW5zYWN0aW9uLmZyb20oc2lnbmVkVHgpO1xuICAgICAgICBpZiAodHguaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE86IHRoZSByZXR1cm5lZCBoYXNoIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKS5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKTtcbiAgICB9XG4gICAgYXN5bmMgI2dldEJsb2NrKGJsb2NrLCBpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgQ3VzdG9tQmxvY2tQbHVnaW4gY2hlY2tcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrLCAzMikpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QmxvY2tcIiwgYmxvY2tIYXNoOiBibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2spO1xuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gYXdhaXQgYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlcmZvcm0oe1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrVGFnLCBpbmNsdWRlVHJhbnNhY3Rpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBRdWVyaWVzXG4gICAgYXN5bmMgZ2V0QmxvY2soYmxvY2ssIHByZWZldGNoVHhzKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jZ2V0QmxvY2soYmxvY2ssICEhcHJlZmV0Y2hUeHMpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwQmxvY2socGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25cIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UocGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgYmFja2VuZHMgZGlkIG5vdCBiYWNrZmlsbCB0aGUgZWZmZWN0aXZlR2FzUHJpY2UgaW50byBvbGQgdHJhbnNhY3Rpb25zXG4gICAgICAgIC8vIGluIHRoZSByZWNlaXB0LCBzbyB3ZSBsb29rIGl0IHVwIG1hbnVhbGx5IGFuZCBpbmplY3QgaXQuXG4gICAgICAgIGlmIChwYXJhbXMuZ2FzUHJpY2UgPT0gbnVsbCAmJiBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSk7XG4gICAgICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcG9ydCB0aGlzOyBjb3VsZCBub3QgZmluZCB0eCBvciBlZmZlY3RpdmVHYXNQcmljZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtcy5lZmZlY3RpdmVHYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZWNlaXB0KHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVzdWx0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcmVzdWx0OiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQmxvb20tZmlsdGVyIFF1ZXJpZXNcbiAgICBhc3luYyBnZXRMb2dzKF9maWx0ZXIpIHtcbiAgICAgICAgbGV0IGZpbHRlciA9IHRoaXMuX2dldEZpbHRlcihfZmlsdGVyKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShmaWx0ZXIpKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBhd2FpdCBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldExvZ3NcIiwgZmlsdGVyIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1zLm1hcCgocCkgPT4gdGhpcy5fd3JhcExvZyhwLCBuZXR3b3JrKSk7XG4gICAgfVxuICAgIC8vIEVOU1xuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJwcm92aWRlciBjYW5ub3QgY29ubmVjdCB0byB0YXJnZXQgbmV0d29ya1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiX2dldFByb3ZpZGVyKClcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVzb2x2ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgRW5zUmVzb2x2ZXIuZnJvbU5hbWUodGhpcywgbmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEF2YXRhcihuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QXZhdGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVOYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlci5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGxvb2t1cEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnNBZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuZ2V0RW5zQWRkcmVzcyh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGVuc0NvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IGVuc0NvbnRyYWN0LnJlc29sdmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09IG51bGwgfHwgcmVzb2x2ZXIgPT09IFplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlckNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KHJlc29sdmVyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBuYW1lKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCByZXNvbHZlckNvbnRyYWN0Lm5hbWUobm9kZSk7XG4gICAgICAgICAgICAvLyBGYWlsZWQgZm9yd2FyZCByZXNvbHV0aW9uXG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IGF3YWl0IHRoaXMucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gZGF0YSB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgcmVzb2x2ZXJcbiAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJBRF9EQVRBXCIpICYmIGVycm9yLnZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyByZWVydGVkXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBfY29uZmlybXMsIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSAoX2NvbmZpcm1zICE9IG51bGwpID8gX2NvbmZpcm1zIDogMTtcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChhc3luYyAoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFRUVcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ0aW1lb3V0XCIsIFwiVElNRU9VVFwiLCB7IHJlYXNvbjogXCJ0aW1lb3V0XCIgfSkpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXIoYXdhaXQgdGhpcy5nZXRCbG9ja051bWJlcigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JCbG9jayhibG9ja1RhZykge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwibm90IGltcGxlbWVudGVkIHlldFwiLCBcIk5PVF9JTVBMRU1FTlRFRFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwid2FpdEZvckJsb2NrXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDbGVhciBhIHRpbWVyIGNyZWF0ZWQgdXNpbmcgdGhlIFtbX3NldFRpbWVvdXRdXSBtZXRob2QuXG4gICAgICovXG4gICAgX2NsZWFyVGltZW91dCh0aW1lcklkKSB7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy4jdGltZXJzLmdldCh0aW1lcklkKTtcbiAgICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lci50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiN0aW1lcnMuZGVsZXRlKHRpbWVySWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgdGltZXIgdGhhdCB3aWxsIGV4ZWN1dGUgJSVmdW5jJSUgYWZ0ZXIgYXQgbGVhc3QgJSV0aW1lb3V0JSVcbiAgICAgKiAgKGluIG1zKS4gSWYgJSV0aW1lb3V0JSUgaXMgdW5zcGVjaWZpZWQsIHRoZW4gJSVmdW5jJSUgd2lsbCBleGVjdXRlXG4gICAgICogIGluIHRoZSBuZXh0IGV2ZW50IGxvb3AuXG4gICAgICpcbiAgICAgKiAgW1BhdXNpbmddKEFic3RyYWN0UHJvdmlkZXItcGF1c2VkKSB0aGUgcHJvdmlkZXIgd2lsbCBwYXVzZSBhbnlcbiAgICAgKiAgYXNzb2NpYXRlZCB0aW1lcnMuXG4gICAgICovXG4gICAgX3NldFRpbWVvdXQoX2Z1bmMsIHRpbWVvdXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZXJJZCA9IHRoaXMuI25leHRUaW1lcisrO1xuICAgICAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcbiAgICAgICAgICAgIF9mdW5jKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLnNldCh0aW1lcklkLCB7IHRpbWVyOiBudWxsLCBmdW5jLCB0aW1lOiB0aW1lb3V0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmMsIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy4jdGltZXJzLnNldCh0aW1lcklkLCB7IHRpbWVyLCBmdW5jLCB0aW1lOiBnZXRUaW1lKCkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVySWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQZXJmb3JtICUlZnVuYyUlIG9uIGVhY2ggc3Vic2NyaWJlci5cbiAgICAgKi9cbiAgICBfZm9yRWFjaFN1YnNjcmliZXIoZnVuYykge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmdW5jKHN1Yi5zdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gY3VzdG9taXplIHN1YnNjcmlwdGlvblxuICAgICAqICBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICovXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIHN3aXRjaCAoc3ViLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjYXNlIFwibmV0d29ya1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlcihzdWIudHlwZSk7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBuZXcgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMucG9sbGluZ0ludGVydmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXIodGhpcywgc3ViLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgY2FzZSBcInRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHRoaXMsIHN1Yi5oYXNoKTtcbiAgICAgICAgICAgIGNhc2UgXCJvcnBoYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXZlbnQ6ICR7c3ViLnR5cGV9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBhIFtbU3Vic2NyaWJlcl1dIGZhaWxzIGFuZCBuZWVkcyB0byByZXBsYWNlIGl0c2VsZiwgdGhpc1xuICAgICAqICBtZXRob2QgbWF5IGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIHRoaXMgaXMgdXNlZCBmb3IgcHJvdmlkZXJzIHdoZW4gdXNpbmcgdGhlXG4gICAgICogIGBgZXRoX2dldEZpbHRlckNoYW5nZXNgYCBtZXRob2QsIHdoaWNoIGNhbiByZXR1cm4gbnVsbCBpZiBzdGF0ZVxuICAgICAqICBmaWx0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBiYWNrZW5kLCBhbGxvd2luZyB0aGUgU3Vic2NyaWJlclxuICAgICAqICB0byBzd2FwIGluIGEgW1tQb2xsaW5nRXZlbnRTdWJzY3JpYmVyXV0uXG4gICAgICovXG4gICAgX3JlY292ZXJTdWJzY3JpYmVyKG9sZFN1YiwgbmV3U3ViKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3Vic2NyaWJlciA9PT0gb2xkU3ViKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIgPSBuZXdTdWI7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1Yi5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjaGFzU3ViKGV2ZW50LCBlbWl0QXJncykge1xuICAgICAgICBsZXQgc3ViID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxvZyB0aGF0IGlzIHJlbW92aW5nIGFuIGV4aXN0aW5nIGxvZzsgd2UgYWN0dWFsbHkgd2FudFxuICAgICAgICAvLyB0byBlbWl0IGFuIG9ycGhhbiBldmVudCBmb3IgdGhlIHJlbW92ZWQgbG9nXG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJldmVudFwiICYmIGVtaXRBcmdzICYmIGVtaXRBcmdzLmxlbmd0aCA+IDAgJiYgZW1pdEFyZ3NbMF0ucmVtb3ZlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3ViID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKHsgb3JwaGFuOiBcImRyb3AtbG9nXCIsIGxvZzogZW1pdEFyZ3NbMF0gfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3N1YnMuZ2V0KHN1Yi50YWcpIHx8IG51bGw7XG4gICAgfVxuICAgIGFzeW5jICNnZXRTdWIoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgLy8gUHJldmVudCB0YW1wZXJpbmcgd2l0aCBvdXIgdGFnIGluIGFueSBzdWJjbGFzcycgX2dldFN1YnNjcmliZXJcbiAgICAgICAgY29uc3QgdGFnID0gc3Vic2NyaXB0aW9uLnRhZztcbiAgICAgICAgbGV0IHN1YiA9IHRoaXMuI3N1YnMuZ2V0KHRhZyk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gdGhpcy5fZ2V0U3Vic2NyaWJlcihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2FibGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgY29uc3QgbmFtZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHN1YiA9IHsgc3Vic2NyaWJlciwgdGFnLCBhZGRyZXNzYWJsZU1hcCwgbmFtZU1hcCwgc3RhcnRlZDogZmFsc2UsIGxpc3RlbmVyczogW10gfTtcbiAgICAgICAgICAgIHRoaXMuI3N1YnMuc2V0KHRhZywgc3ViKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IGZhbHNlIH0pO1xuICAgICAgICBpZiAoIXN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdGFydCgpO1xuICAgICAgICAgICAgc3ViLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoIXN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdGFydCgpO1xuICAgICAgICAgICAgc3ViLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IHN1YnNjcmlwdGlvbiBvciBpZiBhIHJlY2VudCBlbWl0IHJlbW92ZWRcbiAgICAgICAgLy8gdGhlIGxhc3Qgb2YgdGhlbSAod2hpY2ggYWxzbyBkZWxldGVkIHRoZSBzdWIpIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCFzdWIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbmV3IEV2ZW50UGF5bG9hZCh0aGlzLCAob25jZSA/IG51bGwgOiBsaXN0ZW5lciksIGV2ZW50KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCAuLi5hcmdzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gIW9uY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY291bnQgPiAwKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jaGFzU3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaXN0ZW5lciB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGFnLCBzdGFydGVkLCBzdWJzY3JpYmVyIH0gPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt0YWcsIHsgc3RhcnRlZCwgc3Vic2NyaWJlciB9XSBvZiB0aGlzLiNzdWJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0aGlzIHByb3ZpZGVyIGhhcyBiZWVuIGRlc3Ryb3llZCB1c2luZyB0aGUgW1tkZXN0cm95XV0gbWV0aG9kLlxuICAgICAqXG4gICAgICogIE9uY2UgZGVzdHJveWVkLCBhbGwgcmVzb3VyY2VzIGFyZSByZWNsYWltZWQsIGludGVybmFsIGV2ZW50IGxvb3BzXG4gICAgICogIGFuZCB0aW1lcnMgYXJlIGNsZWFuZWQgdXAgYW5kIG5vIGZ1cnRoZXIgcmVxdWVzdHMgbWF5IGJlIHNlbnQgdG9cbiAgICAgKiAgdGhlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkZXN0cm95ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgdXNlIHRoaXMgdG8gc2h1dGRvd24gYW55IHNvY2tldHMgb3IgcmVsZWFzZSB0aGVpclxuICAgICAqICByZXNvdXJjZXMgYW5kIHJlamVjdCBhbnkgcGVuZGluZyByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBjYWxsIGBgc3VwZXIuZGVzdHJveSgpYGAuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gU3RvcCBhbGwgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIC8vIFNodXQgZG93biBhbGwgdGllbXJzXG4gICAgICAgIGZvciAoY29uc3QgdGltZXJJZCBvZiB0aGlzLiN0aW1lcnMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIHByb3ZpZGVyIGlzIGN1cnJlbnRseSBwYXVzZWQuXG4gICAgICpcbiAgICAgKiAgQSBwYXVzZWQgcHJvdmlkZXIgd2lsbCBub3QgZW1pdCBhbnkgZXZlbnRzLCBhbmQgZ2VuZXJhbGx5IHNob3VsZFxuICAgICAqICBub3QgbWFrZSBhbnkgcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmssIGJ1dCB0aGF0IGlzIHVwIHRvIHN1Yi1jbGFzc2VzXG4gICAgICogIHRvIG1hbmFnZS5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIGBgcGF1c2VkID0gdHJ1ZWBgIGlzIGlkZW50aWNhbCB0byBjYWxsaW5nIGBgLnBhdXNlKGZhbHNlKWBgLFxuICAgICAqICB3aGljaCB3aWxsIGJ1ZmZlciBhbnkgZXZlbnRzIHRoYXQgb2NjdXIgd2hpbGUgcGF1c2VkIHVudGlsIHRoZVxuICAgICAqICBwcm92aWRlciBpcyB1bnBhdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgcGF1c2VkKCkgeyByZXR1cm4gKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpOyB9XG4gICAgc2V0IHBhdXNlZChwYXVzZSkge1xuICAgICAgICBpZiAoISFwYXVzZSA9PT0gdGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGF1c2UgdGhlIHByb3ZpZGVyLiBJZiAlJWRyb3BXaGlsZVBhdXNlZCUlLCBhbnkgZXZlbnRzIHRoYXQgb2NjdXJcbiAgICAgKiAgd2hpbGUgcGF1c2VkIGFyZSBkcm9wcGVkLCBvdGhlcndpc2UgYWxsIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWQgb25jZVxuICAgICAqICB0aGUgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IC0xO1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlID09ICEhZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBjaGFuZ2UgcGF1c2UgdHlwZTsgcmVzdW1lIGZpcnN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicGF1c2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHMpID0+IHMucGF1c2UoZHJvcFdoaWxlUGF1c2VkKSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gISFkcm9wV2hpbGVQYXVzZWQ7XG4gICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy4jdGltZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgdGltZXJcbiAgICAgICAgICAgIGlmICh0aW1lci50aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSBuZWVkZWQgZm9yIHdoZW4gd2UgYmVjb21lIHVucGF1c2VkXG4gICAgICAgICAgICB0aW1lci50aW1lID0gZ2V0VGltZSgpIC0gdGltZXIudGltZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzdW1lIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHMpID0+IHMucmVzdW1lKCkpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy4jdGltZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZSB3aGVuIHdlIHdlcmUgcGF1c2VkXG4gICAgICAgICAgICBsZXQgdGltZW91dCA9IHRpbWVyLnRpbWU7XG4gICAgICAgICAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IHRpbWUgKGluIGNhdXNlIHBhdXNlZCwgc28gd2UgY29uIGNvbXB1dGUgcmVtYWluaW5mIHRpbWUpXG4gICAgICAgICAgICB0aW1lci50aW1lID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVyLmZ1bmMsIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBieXRlcyA9IF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpO1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBnZXROdW1iZXIoZGF0YVNsaWNlKHJlc3VsdCwgc3RhcnQsIHN0YXJ0ICsgMzIpKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIG9mZnNldCwgb2Zmc2V0ICsgMzIpKTtcbiAgICAgICAgcmV0dXJuIGRhdGFTbGljZShyZXN1bHQsIG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIGxlbmd0aCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBudW1QYWQodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcGFkZGVkLnNldChyZXN1bHQsIDMyIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHBhZGRlZDtcbn1cbmZ1bmN0aW9uIGJ5dGVzUGFkKHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZS5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gMzIpICogMzIpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBlbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8vIEFCSSBFbmNvZGVzIGEgc2VyaWVzIG9mIChieXRlcywgYnl0ZXMsIC4uLilcbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKGRhdGFzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgLy8gQWRkIHBsYWNlLWhvbGRlcnMgZm9yIHBvaW50ZXJzIGFzIHdlIGFkZCBpdGVtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZW1wdHkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKGRhdGFzW2ldKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBieXRlcyBvZmZzZXRcbiAgICAgICAgcmVzdWx0W2ldID0gbnVtUGFkKGJ5dGVDb3VudCk7XG4gICAgICAgIC8vIFRoZSBsZW5ndGggYW5kIHBhZGRlZCB2YWx1ZSBvZiBkYXRhXG4gICAgICAgIHJlc3VsdC5wdXNoKG51bVBhZChkYXRhLmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQucHVzaChieXRlc1BhZChkYXRhKSk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMiArIE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDMyKSAqIDMyO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KHJlc3VsdCk7XG59XG5jb25zdCB6ZXJvcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5mdW5jdGlvbiBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNlbmRlcjogXCJcIiwgdXJsczogW10sIGNhbGxkYXRhOiBcIlwiLCBzZWxlY3RvcjogXCJcIiwgZXh0cmFEYXRhOiBcIlwiLCBlcnJvckFyZ3M6IFtdXG4gICAgfTtcbiAgICBhc3NlcnQoZGF0YUxlbmd0aChkYXRhKSA+PSA1ICogMzIsIFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJpbnN1ZmZpY2llbnQgT2ZmY2hhaW5Mb29rdXAgZGF0YVwiXG4gICAgfSk7XG4gICAgY29uc3Qgc2VuZGVyID0gZGF0YVNsaWNlKGRhdGEsIDAsIDMyKTtcbiAgICBhc3NlcnQoZGF0YVNsaWNlKHNlbmRlciwgMCwgMTIpID09PSBkYXRhU2xpY2UoemVyb3MsIDAsIDEyKSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VuZGVyID0gZGF0YVNsaWNlKHNlbmRlciwgMTIpO1xuICAgIC8vIFJlYWQgdGhlIFVSTHMgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmxzID0gW107XG4gICAgICAgIGNvbnN0IHVybHNPZmZzZXQgPSBnZXROdW1iZXIoZGF0YVNsaWNlKGRhdGEsIDMyLCA2NCkpO1xuICAgICAgICBjb25zdCB1cmxzTGVuZ3RoID0gZ2V0TnVtYmVyKGRhdGFTbGljZShkYXRhLCB1cmxzT2Zmc2V0LCB1cmxzT2Zmc2V0ICsgMzIpKTtcbiAgICAgICAgY29uc3QgdXJsc0RhdGEgPSBkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IF9wYXJzZVN0cmluZyh1cmxzRGF0YSwgdSAqIDMyKTtcbiAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJscy5wdXNoKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVybHMgPSB1cmxzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgdXJsc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBDQ0lQIGNhbGxkYXRhIHRvIGZvcndhcmRcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWxsZGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDY0KTtcbiAgICAgICAgaWYgKGNhbGxkYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5jYWxsZGF0YSA9IGNhbGxkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsZGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGNhbGxiYWNrU2VsZWN0b3IgKGJ5dGVzNClcbiAgICBhc3NlcnQoZGF0YVNsaWNlKGRhdGEsIDEwMCwgMTI4KSA9PT0gZGF0YVNsaWNlKHplcm9zLCAwLCAyOCksIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsYmFhY2tTZWxlY3RvclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIlxuICAgIH0pO1xuICAgIHJlc3VsdC5zZWxlY3RvciA9IGRhdGFTbGljZShkYXRhLCA5NiwgMTAwKTtcbiAgICAvLyBHZXQgdGhlIGV4dHJhIGRhdGEgdG8gc2VuZCBiYWNrIHRvIHRoZSBjb250cmFjdCBhcyBjb250ZXh0XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0cmFEYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgMTI4KTtcbiAgICAgICAgaWYgKGV4dHJhRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuZXh0cmFEYXRhID0gZXh0cmFEYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgZXh0cmFEYXRhXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VsdC5lcnJvckFyZ3MgPSBcInNlbmRlcix1cmxzLGNhbGxkYXRhLHNlbGVjdG9yLGV4dHJhRGF0YVwiLnNwbGl0KC8sLykubWFwKChrKSA9PiByZXN1bHRba10pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/abstract-provider.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/abstract-signer.js":
/*!**************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/abstract-signer.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractSigner: function() { return /* binding */ AbstractSigner; },\n/* harmony export */   VoidSigner: function() { return /* binding */ VoidSigner; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ \"../common/node_modules/ethers/lib.esm/providers/provider.js\");\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */\n\n\n\n\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", { operation });\n}\nasync function populate(signer, tx) {\n    let pop = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.copyRequest)(tx);\n    if (pop.to != null) {\n        pop.to = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(from, signer)\n        ]).then(([address, from]) => {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    }\n    else {\n        pop.from = signer.getAddress();\n    }\n    return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */\nclass AbstractSigner {\n    /**\n     *  The provider this signer is connected to.\n     */\n    provider;\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */\n    constructor(provider) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { provider: (provider || null) });\n    }\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await (this.provider).getNetwork();\n        if (pop.chainId != null) {\n            const chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(pop.chainId);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        }\n        else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null);\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        }\n        else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        }\n        else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        }\n        else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    if (pop.authorizationList && pop.authorizationList.length) {\n                        pop.type = 4;\n                    }\n                    else {\n                        pop.type = 2;\n                    }\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    }\n                    else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                }\n                else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                }\n                else {\n                    // getFeeData has failed us.\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            }\n            else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {\n                // Explicitly using EIP-1559 or EIP-4844\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)(pop);\n    }\n    async populateAuthorization(_auth) {\n        const auth = Object.assign({}, _auth);\n        // Add a chain ID if not explicitly set to 0\n        if (auth.chainId == null) {\n            auth.chainId = (await checkProvider(this, \"getNetwork\").getNetwork()).chainId;\n        }\n        // @TODO: Take chain ID into account when populating noce?\n        if (auth.nonce == null) {\n            auth.nonce = await this.getNonce();\n        }\n        return auth;\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n    // @TODO: in v7 move this to be abstract\n    authorize(authorization) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"authorization not implemented for this signer\", \"UNSUPPORTED_OPERATION\", { operation: \"authorize\" });\n    }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */\nclass VoidSigner extends AbstractSigner {\n    /**\n     *  The signer address.\n     */\n    address;\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */\n    constructor(address, provider) {\n        super(provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { address });\n    }\n    async getAddress() { return this.address; }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    #throwUnsupported(suffix, operation) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", { operation });\n    }\n    async signTransaction(tx) {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n}\n//# sourceMappingURL=abstract-signer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FEO0FBQ0M7QUFDcUQ7QUFDL0Q7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFNLHVEQUF1RCxXQUFXO0FBQzVFO0FBQ0E7QUFDQSxjQUFjLHlEQUFXO0FBQ3pCO0FBQ0EsaUJBQWlCLGlFQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFjO0FBQzFCO0FBQ0EsWUFBWSwrREFBYztBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrRUFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLDhCQUE4QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFTO0FBQ3JDLFlBQVksK0RBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQU07QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQU07QUFDMUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQU07QUFDMUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxxQkFBcUIsa0VBQWlCO0FBQ3RDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSxvRkFBb0Ysd0JBQXdCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsU0FBUztBQUMxQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU0sa0NBQWtDLE9BQU8sOEJBQThCLFdBQVc7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9hYnN0cmFjdC1zaWduZXIuanM/YTU5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBHZW5lcmFsbHkgdGhlIFtbV2FsbGV0XV0gYW5kIFtbSnNvblJwY1NpZ25lcl1dIGFuZCB0aGVpciBzdWItY2xhc3Nlc1xuICogIGFyZSBzdWZmaWNlbnQgZm9yIG1vc3QgZGV2ZWxvcGVycywgYnV0IHRoaXMgaXMgcHJvdmlkZWQgdG9cbiAqICBmYXNjaWxpdGF0ZSBtb3JlIGNvbXBsZXggU2lnbmVycy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lcjogU3ViY2xhc3NpbmcgU2lnbmVyIFthYnN0cmFjdC1zaWduZXJdXG4gKi9cbmltcG9ydCB7IHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb3B5UmVxdWVzdCB9IGZyb20gXCIuL3Byb3ZpZGVyLmpzXCI7XG5mdW5jdGlvbiBjaGVja1Byb3ZpZGVyKHNpZ25lciwgb3BlcmF0aW9uKSB7XG4gICAgaWYgKHNpZ25lci5wcm92aWRlcikge1xuICAgICAgICByZXR1cm4gc2lnbmVyLnByb3ZpZGVyO1xuICAgIH1cbiAgICBhc3NlcnQoZmFsc2UsIFwibWlzc2luZyBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlKHNpZ25lciwgdHgpIHtcbiAgICBsZXQgcG9wID0gY29weVJlcXVlc3QodHgpO1xuICAgIGlmIChwb3AudG8gIT0gbnVsbCkge1xuICAgICAgICBwb3AudG8gPSByZXNvbHZlQWRkcmVzcyhwb3AudG8sIHNpZ25lcik7XG4gICAgfVxuICAgIGlmIChwb3AuZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBwb3AuZnJvbTtcbiAgICAgICAgcG9wLmZyb20gPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBzaWduZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgcmVzb2x2ZUFkZHJlc3MoZnJvbSwgc2lnbmVyKVxuICAgICAgICBdKS50aGVuKChbYWRkcmVzcywgZnJvbV0pID0+IHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gZnJvbS50b0xvd2VyQ2FzZSgpLCBcInRyYW5zYWN0aW9uIGZyb20gbWlzbWF0Y2hcIiwgXCJ0eC5mcm9tXCIsIGZyb20pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9wLmZyb20gPSBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMocG9wKTtcbn1cbi8qKlxuICogIEFuICoqQWJzdHJhY3RTaWduZXIqKiBpbmNsdWRlcyBtb3N0IG9mIHRlaCBmdW5jdGlvbmFsaXR5IHJlcXVpcmVkXG4gKiAgdG8gZ2V0IGEgW1tTaWduZXJdXSB3b3JraW5nIGFzIGV4cGVjdGVkLCBidXQgcmVxdWlyZXMgYSBmZXdcbiAqICBTaWduZXItc3BlY2lmaWMgbWV0aG9kcyBiZSBvdmVycmlkZGVuLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgc2lnbmVyIGlzIGNvbm5lY3RlZCB0by5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBTaWduZXIgY29ubmVjdGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvdmlkZXI6IChwcm92aWRlciB8fCBudWxsKSB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIpLmdldFRyYW5zYWN0aW9uQ291bnQoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKTtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVDYWxsKHR4KSB7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgcmV0dXJuIHBvcDtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCBwb3B1bGF0ZSh0aGlzLCB0eCk7XG4gICAgICAgIGlmIChwb3Aubm9uY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9wLm5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZShcInBlbmRpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcC5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3AuZ2FzTGltaXQgPSBhd2FpdCB0aGlzLmVzdGltYXRlR2FzKHBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGNoYWluIElEXG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCAodGhpcy5wcm92aWRlcikuZ2V0TmV0d29yaygpO1xuICAgICAgICBpZiAocG9wLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IGdldEJpZ0ludChwb3AuY2hhaW5JZCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChjaGFpbklkID09PSBuZXR3b3JrLmNoYWluSWQsIFwidHJhbnNhY3Rpb24gY2hhaW5JZCBtaXNtYXRjaFwiLCBcInR4LmNoYWluSWRcIiwgdHguY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3AuY2hhaW5JZCA9IG5ldHdvcmsuY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgYWxsb3cgbWl4aW5nIHByZS1laXAtMTU1OSBhbmQgZWlwLTE1NTkgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBoYXNFaXAxNTU5ID0gKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgIT0gbnVsbCAmJiAocG9wLnR5cGUgPT09IDIgfHwgaGFzRWlwMTU1OSkpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IGdhc1ByaWNlXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwb3AudHlwZSA9PT0gMCB8fCBwb3AudHlwZSA9PT0gMSkgJiYgaGFzRWlwMTU1OSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwicHJlLWVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IG1heEZlZVBlckdhcy9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHBvcC50eXBlID09PSAyIHx8IHBvcC50eXBlID09IG51bGwpICYmIChwb3AubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpKSB7XG4gICAgICAgICAgICAvLyBGdWxseS1mb3JtZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gKHNraXAgZ2V0RmVlRGF0YSlcbiAgICAgICAgICAgIHBvcC50eXBlID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3AudHlwZSA9PT0gMCB8fCBwb3AudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXQgTGVnYWN5IG9yIEVJUC0yOTMwIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgYXNzZXJ0KGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRHYXNQcmljZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcbiAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvcC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgcHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgaWYgKHBvcC50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF1dG8tZGV0ZWN0IHRoZSBpbnRlbmRlZCB0eXBlIG9mIHRoaXMgdHJhbnNhY3Rpb24uLi5cbiAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldHdvcmsgc3VwcG9ydHMgRUlQLTE1NTkhXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZ3JhZGUgdHJhbnNhY3Rpb24gZnJvbSBudWxsIHRvIGVpcC0xNTU5XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuYXV0aG9yaXphdGlvbkxpc3QgJiYgcG9wLmF1dGhvcml6YXRpb25MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgbGVnYWN5IGdhc1ByaWNlIHByb3BlcnR5IG9uIGFuIGVpcC0xNTU5IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB1c2UgZ2FzUHJpY2UgYXMgYm90aCBmZWUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSBwb3AuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcG9wLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wLm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IHN1cHBvcnQgRUlQLTE1NTkuLi5cbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IHRoZXkgYXJlIHRyeWluZyB0byB1c2UgRUlQLTE1NTkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoIWhhc0VpcDE1NTksIFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVJUC0xNTU5XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AuZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHVudHlwZWQgdHJhbnNhY3Rpb24gdG8gbGVnYWN5XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBNYXliZSB0aGlzIHNob2xkIGFsbG93IHR5cGUgMT9cbiAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RmVlRGF0YSBoYXMgZmFpbGVkIHVzLlxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiZmFpbGVkIHRvIGdldCBjb25zaXN0ZW50IGZlZSBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuZ2V0RmVlRGF0YVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAyIHx8IHBvcC50eXBlID09PSAzIHx8IHBvcC50eXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2luZyBFSVAtMTU1OSBvciBFSVAtNDg0NFxuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vQFRPT0Q6IERvbid0IGF3YWl0IGFsbCBvdmVyIHRoZSBwbGFjZTsgc2F2ZSB0aGVtIHVwIGZvclxuICAgICAgICAvLyB0aGUgZW5kIGZvciBiZXR0ZXIgYmF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHBvcCk7XG4gICAgfVxuICAgIGFzeW5jIHBvcHVsYXRlQXV0aG9yaXphdGlvbihfYXV0aCkge1xuICAgICAgICBjb25zdCBhdXRoID0gT2JqZWN0LmFzc2lnbih7fSwgX2F1dGgpO1xuICAgICAgICAvLyBBZGQgYSBjaGFpbiBJRCBpZiBub3QgZXhwbGljaXRseSBzZXQgdG8gMFxuICAgICAgICBpZiAoYXV0aC5jaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgICAgIGF1dGguY2hhaW5JZCA9IChhd2FpdCBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZ2V0TmV0d29ya1wiKS5nZXROZXR3b3JrKCkpLmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IFRha2UgY2hhaW4gSUQgaW50byBhY2NvdW50IHdoZW4gcG9wdWxhdGluZyBub2NlP1xuICAgICAgICBpZiAoYXV0aC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhdXRoLm5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRoO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImVzdGltYXRlR2FzXCIpLmVzdGltYXRlR2FzKGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KSk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwodHgpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJjYWxsXCIpLmNhbGwoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwic2VuZFRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBkZWxldGUgcG9wLmZyb207XG4gICAgICAgIGNvbnN0IHR4T2JqID0gVHJhbnNhY3Rpb24uZnJvbShwb3ApO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuYnJvYWRjYXN0VHJhbnNhY3Rpb24oYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHhPYmopKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IGluIHY3IG1vdmUgdGhpcyB0byBiZSBhYnN0cmFjdFxuICAgIGF1dGhvcml6ZShhdXRob3JpemF0aW9uKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJhdXRob3JpemF0aW9uIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBzaWduZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiYXV0aG9yaXplXCIgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlZvaWRTaWduZXIqKiBpcyBhIGNsYXNzIGRlaXNnbmVkIHRvIGFsbG93IGFuIGFkZHJlc3MgdG8gYmUgdXNlZFxuICogIGluIGFueSBBUEkgd2hpY2ggYWNjZXB0cyBhIFNpZ25lciwgYnV0IGZvciB3aGljaCB0aGVyZSBhcmUgbm9cbiAqICBjcmVkZW50aWFscyBhdmFpbGFibGUgdG8gcGVyZm9ybSBhbnkgYWN0dWFsIHNpZ25pbmcuXG4gKlxuICogIFRoaXMgZm9yIGV4YW1wbGUgYWxsb3cgaW1wZXJzb25hdGluZyBhbiBhY2NvdW50IGZvciB0aGUgcHVycG9zZSBvZlxuICogIHN0YXRpYyBjYWxscyBvciBlc3RpbWF0aW5nIGdhcywgYnV0IGRvZXMgbm90IGFsbG93IHNlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICovXG5leHBvcnQgY2xhc3MgVm9pZFNpZ25lciBleHRlbmRzIEFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNpZ25lciBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipWb2lkU2lnbmVyKiogd2l0aCAlJWFkZHJlc3MlJSBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIHRoaXMuYWRkcmVzczsgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWb2lkU2lnbmVyKHRoaXMuYWRkcmVzcywgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAjdGhyb3dVbnN1cHBvcnRlZChzdWZmaXgsIG9wZXJhdGlvbikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIGBWb2lkU2lnbmVyIGNhbm5vdCBzaWduICR7c3VmZml4fWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgdGhpcy4jdGhyb3dVbnN1cHBvcnRlZChcInRyYW5zYWN0aW9uc1wiLCBcInNpZ25UcmFuc2FjdGlvblwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwibWVzc2FnZXNcIiwgXCJzaWduTWVzc2FnZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHlwZWQtZGF0YVwiLCBcInNpZ25UeXBlZERhdGFcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3Qtc2lnbmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/abstract-signer.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/community.js":
/*!********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/community.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   showThrottleMessage: function() { return /* binding */ showThrottleMessage; }\n/* harmony export */ });\n/**\n *  There are many awesome community services that provide Ethereum\n *  nodes both for developers just starting out and for large-scale\n *  communities.\n *\n *  @_section: api/providers/thirdparty: Community Providers  [thirdparty]\n */\n// Show the throttle message only once per service\nconst shown = new Set();\n/**\n *  Displays a warning in the console when the community resource is\n *  being used too heavily by the app, recommending the developer\n *  acquire their own credentials instead of using the community\n *  credentials.\n *\n *  The notification will only occur once per service.\n */\nfunction showThrottleMessage(service) {\n    if (shown.has(service)) {\n        return;\n    }\n    shown.add(service);\n    console.log(\"========= NOTICE =========\");\n    console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.org/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=community.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvY29tbXVuaXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9jb21tdW5pdHkuanM/MWQ4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBUaGVyZSBhcmUgbWFueSBhd2Vzb21lIGNvbW11bml0eSBzZXJ2aWNlcyB0aGF0IHByb3ZpZGUgRXRoZXJldW1cbiAqICBub2RlcyBib3RoIGZvciBkZXZlbG9wZXJzIGp1c3Qgc3RhcnRpbmcgb3V0IGFuZCBmb3IgbGFyZ2Utc2NhbGVcbiAqICBjb21tdW5pdGllcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6IENvbW11bml0eSBQcm92aWRlcnMgIFt0aGlyZHBhcnR5XVxuICovXG4vLyBTaG93IHRoZSB0aHJvdHRsZSBtZXNzYWdlIG9ubHkgb25jZSBwZXIgc2VydmljZVxuY29uc3Qgc2hvd24gPSBuZXcgU2V0KCk7XG4vKipcbiAqICBEaXNwbGF5cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgd2hlbiB0aGUgY29tbXVuaXR5IHJlc291cmNlIGlzXG4gKiAgYmVpbmcgdXNlZCB0b28gaGVhdmlseSBieSB0aGUgYXBwLCByZWNvbW1lbmRpbmcgdGhlIGRldmVsb3BlclxuICogIGFjcXVpcmUgdGhlaXIgb3duIGNyZWRlbnRpYWxzIGluc3RlYWQgb2YgdXNpbmcgdGhlIGNvbW11bml0eVxuICogIGNyZWRlbnRpYWxzLlxuICpcbiAqICBUaGUgbm90aWZpY2F0aW9uIHdpbGwgb25seSBvY2N1ciBvbmNlIHBlciBzZXJ2aWNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvd1Rocm90dGxlTWVzc2FnZShzZXJ2aWNlKSB7XG4gICAgaWYgKHNob3duLmhhcyhzZXJ2aWNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHNob3duLmFkZChzZXJ2aWNlKTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PSBOT1RJQ0UgPT09PT09PT09XCIpO1xuICAgIGNvbnNvbGUubG9nKGBSZXF1ZXN0LVJhdGUgRXhjZWVkZWQgZm9yICR7c2VydmljZX0gKHRoaXMgbWVzc2FnZSB3aWxsIG5vdCBiZSByZXBlYXRlZClgKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlRoZSBkZWZhdWx0IEFQSSBrZXlzIGZvciBlYWNoIHNlcnZpY2UgYXJlIHByb3ZpZGVkIGFzIGEgaGlnaGx5LXRocm90dGxlZCxcIik7XG4gICAgY29uc29sZS5sb2coXCJjb21tdW5pdHkgcmVzb3VyY2UgZm9yIGxvdy10cmFmZmljIHByb2plY3RzIGFuZCBlYXJseSBwcm90b3R5cGluZy5cIik7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJXaGlsZSB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgY29udGludWUgdG8gZnVuY3Rpb24sIHdlIGhpZ2hseSByZWNvbW1lbmRlZFwiKTtcbiAgICBjb25zb2xlLmxvZyhcInNpZ25pbmcgdXAgZm9yIHlvdXIgb3duIEFQSSBrZXlzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIGluY3JlYXNlIHlvdXJcIik7XG4gICAgY29uc29sZS5sb2coXCJyZXF1ZXN0IHJhdGUvbGltaXQgYW5kIGVuYWJsZSBvdGhlciBwZXJrcywgc3VjaCBhcyBtZXRyaWNzIGFuZCBhZHZhbmNlZCBBUElzLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi9cXC9kb2NzLmV0aGVycy5vcmcvYXBpLWtleXMvXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tdW5pdHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/community.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/default-provider.js":
/*!***************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/default-provider.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultProvider: function() { return /* binding */ getDefaultProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _provider_ankr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./provider-ankr.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-ankr.js\");\n/* harmony import */ var _provider_alchemy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./provider-alchemy.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-alchemy.js\");\n/* harmony import */ var _provider_chainstack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./provider-chainstack.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-chainstack.js\");\n/* harmony import */ var _provider_cloudflare_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./provider-cloudflare.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-cloudflare.js\");\n/* harmony import */ var _provider_etherscan_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./provider-etherscan.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-etherscan.js\");\n/* harmony import */ var _provider_infura_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./provider-infura.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-infura.js\");\n/* harmony import */ var _provider_quicknode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./provider-quicknode.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-quicknode.js\");\n/* harmony import */ var _provider_fallback_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./provider-fallback.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-fallback.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-websocket.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-websocket.js\");\n\n\n\n//import { BlockscoutProvider } from \"./provider-blockscout.js\";\n\n\n\n\n//import { PocketProvider } from \"./provider-pocket.js\";\n\n\n\n\n\nfunction isWebSocketLike(value) {\n    return (value && typeof (value.send) === \"function\" &&\n        typeof (value.close) === \"function\");\n}\nconst Testnets = \"goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt\".split(\" \");\n/**\n *  Returns a default provider for %%network%%.\n *\n *  If %%network%% is a [[WebSocketLike]] or string that begins with\n *  ``\"ws:\"`` or ``\"wss:\"``, a [[WebSocketProvider]] is returned backed\n *  by that WebSocket or URL.\n *\n *  If %%network%% is a string that begins with ``\"HTTP:\"`` or ``\"HTTPS:\"``,\n *  a [[JsonRpcProvider]] is returned connected to that URL.\n *\n *  Otherwise, a default provider is created backed by well-known public\n *  Web3 backends (such as [[link-infura]]) using community-provided API\n *  keys.\n *\n *  The %%options%% allows specifying custom API keys per backend (setting\n *  an API key to ``\"-\"`` will omit that provider) and ``options.exclusive``\n *  can be set to either a backend name or and array of backend names, which\n *  will whitelist **only** those backends.\n *\n *  Current backend strings supported are:\n *  - ``\"alchemy\"``\n *  - ``\"ankr\"``\n *  - ``\"cloudflare\"``\n *  - ``\"chainstack\"``\n *  - ``\"etherscan\"``\n *  - ``\"infura\"``\n *  - ``\"publicPolygon\"``\n *  - ``\"quicknode\"``\n *\n *  @example:\n *    // Connect to a local Geth node\n *    provider = getDefaultProvider(\"http://localhost:8545/\");\n *\n *    // Connect to Ethereum mainnet with any current and future\n *    // third-party services available\n *    provider = getDefaultProvider(\"mainnet\");\n *\n *    // Connect to Polygon, but only allow Etherscan and\n *    // INFURA and use \"MY_API_KEY\" in calls to Etherscan.\n *    provider = getDefaultProvider(\"matic\", {\n *      etherscan: \"MY_API_KEY\",\n *      exclusive: [ \"etherscan\", \"infura\" ]\n *    });\n */\nfunction getDefaultProvider(network, options) {\n    if (options == null) {\n        options = {};\n    }\n    const allowService = (name) => {\n        if (options[name] === \"-\") {\n            return false;\n        }\n        if (typeof (options.exclusive) === \"string\") {\n            return (name === options.exclusive);\n        }\n        if (Array.isArray(options.exclusive)) {\n            return (options.exclusive.indexOf(name) !== -1);\n        }\n        return true;\n    };\n    if (typeof (network) === \"string\" && network.match(/^https?:/)) {\n        return new _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(network);\n    }\n    if (typeof (network) === \"string\" && network.match(/^wss?:/) || isWebSocketLike(network)) {\n        return new _provider_websocket_js__WEBPACK_IMPORTED_MODULE_1__.WebSocketProvider(network);\n    }\n    // Get the network and name, if possible\n    let staticNetwork = null;\n    try {\n        staticNetwork = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(network);\n    }\n    catch (error) { }\n    const providers = [];\n    if (allowService(\"publicPolygon\") && staticNetwork) {\n        if (staticNetwork.name === \"matic\") {\n            providers.push(new _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(\"https:/\\/polygon-rpc.com/\", staticNetwork, { staticNetwork }));\n        }\n        else if (staticNetwork.name === \"matic-amoy\") {\n            providers.push(new _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(\"https:/\\/rpc-amoy.polygon.technology/\", staticNetwork, { staticNetwork }));\n        }\n    }\n    if (allowService(\"alchemy\")) {\n        try {\n            providers.push(new _provider_alchemy_js__WEBPACK_IMPORTED_MODULE_3__.AlchemyProvider(network, options.alchemy));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"ankr\") && options.ankr != null) {\n        try {\n            providers.push(new _provider_ankr_js__WEBPACK_IMPORTED_MODULE_4__.AnkrProvider(network, options.ankr));\n        }\n        catch (error) { }\n    }\n    /* Temporarily remove until custom error issue is fixed\n        if (allowService(\"blockscout\")) {\n            try {\n                providers.push(new BlockscoutProvider(network, options.blockscout));\n            } catch (error) { }\n        }\n    */\n    if (allowService(\"chainstack\")) {\n        try {\n            providers.push(new _provider_chainstack_js__WEBPACK_IMPORTED_MODULE_5__.ChainstackProvider(network, options.chainstack));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"cloudflare\")) {\n        try {\n            providers.push(new _provider_cloudflare_js__WEBPACK_IMPORTED_MODULE_6__.CloudflareProvider(network));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"etherscan\")) {\n        try {\n            providers.push(new _provider_etherscan_js__WEBPACK_IMPORTED_MODULE_7__.EtherscanProvider(network, options.etherscan));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"infura\")) {\n        try {\n            let projectId = options.infura;\n            let projectSecret = undefined;\n            if (typeof (projectId) === \"object\") {\n                projectSecret = projectId.projectSecret;\n                projectId = projectId.projectId;\n            }\n            providers.push(new _provider_infura_js__WEBPACK_IMPORTED_MODULE_8__.InfuraProvider(network, projectId, projectSecret));\n        }\n        catch (error) { }\n    }\n    /*\n        if (options.pocket !== \"-\") {\n            try {\n                let appId = options.pocket;\n                let secretKey: undefined | string = undefined;\n                let loadBalancer: undefined | boolean = undefined;\n                if (typeof(appId) === \"object\") {\n                    loadBalancer = !!appId.loadBalancer;\n                    secretKey = appId.secretKey;\n                    appId = appId.appId;\n                }\n                providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));\n            } catch (error) { console.log(error); }\n        }\n    */\n    if (allowService(\"quicknode\")) {\n        try {\n            let token = options.quicknode;\n            providers.push(new _provider_quicknode_js__WEBPACK_IMPORTED_MODULE_9__.QuickNodeProvider(network, token));\n        }\n        catch (error) { }\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.assert)(providers.length, \"unsupported default network\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getDefaultProvider\"\n    });\n    // No need for a FallbackProvider\n    if (providers.length === 1) {\n        return providers[0];\n    }\n    // We use the floor because public third-party providers can be unreliable,\n    // so a low number of providers with a large quorum will fail too often\n    let quorum = Math.floor(providers.length / 2);\n    if (quorum > 2) {\n        quorum = 2;\n    }\n    // Testnets don't need as strong a security gaurantee and speed is\n    // more useful during testing\n    if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {\n        quorum = 1;\n    }\n    // Provided override qorum takes priority\n    if (options && options.quorum) {\n        quorum = options.quorum;\n    }\n    return new _provider_fallback_js__WEBPACK_IMPORTED_MODULE_11__.FallbackProvider(providers, undefined, { quorum });\n}\n//# sourceMappingURL=default-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZGVmYXVsdC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ087QUFDTTtBQUN4RCxXQUFXLHFCQUFxQjtBQUM4QjtBQUNBO0FBQ0Y7QUFDTjtBQUN0RCxXQUFXLGlCQUFpQjtBQUNnQztBQUNGO0FBQ0Y7QUFDakI7QUFDcUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQWU7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQixxRUFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBZSwrQ0FBK0MsZUFBZTtBQUM1RztBQUNBO0FBQ0EsK0JBQStCLGlFQUFlLDJEQUEyRCxlQUFlO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkRBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUVBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUVBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUVBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0RBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxRUFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3REFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRUFBZ0IseUJBQXlCLFFBQVE7QUFDaEU7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZGVmYXVsdC1wcm92aWRlci5qcz8xYmNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQW5rclByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItYW5rci5qc1wiO1xuaW1wb3J0IHsgQWxjaGVteVByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItYWxjaGVteS5qc1wiO1xuLy9pbXBvcnQgeyBCbG9ja3Njb3V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1ibG9ja3Njb3V0LmpzXCI7XG5pbXBvcnQgeyBDaGFpbnN0YWNrUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1jaGFpbnN0YWNrLmpzXCI7XG5pbXBvcnQgeyBDbG91ZGZsYXJlUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1jbG91ZGZsYXJlLmpzXCI7XG5pbXBvcnQgeyBFdGhlcnNjYW5Qcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWV0aGVyc2Nhbi5qc1wiO1xuaW1wb3J0IHsgSW5mdXJhUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1pbmZ1cmEuanNcIjtcbi8vaW1wb3J0IHsgUG9ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1wb2NrZXQuanNcIjtcbmltcG9ydCB7IFF1aWNrTm9kZVByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItcXVpY2tub2RlLmpzXCI7XG5pbXBvcnQgeyBGYWxsYmFja1Byb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItZmFsbGJhY2suanNcIjtcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBXZWJTb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLXdlYnNvY2tldC5qc1wiO1xuZnVuY3Rpb24gaXNXZWJTb2NrZXRMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnNlbmQpID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mICh2YWx1ZS5jbG9zZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5jb25zdCBUZXN0bmV0cyA9IFwiZ29lcmxpIGtvdmFuIHNlcG9saWEgY2xhc3NpY0tvdHRpIG9wdGltaXNtLWdvZXJsaSBhcmJpdHJ1bS1nb2VybGkgbWF0aWMtbXVtYmFpIGJuYnRcIi5zcGxpdChcIiBcIik7XG4vKipcbiAqICBSZXR1cm5zIGEgZGVmYXVsdCBwcm92aWRlciBmb3IgJSVuZXR3b3JrJSUuXG4gKlxuICogIElmICUlbmV0d29yayUlIGlzIGEgW1tXZWJTb2NrZXRMaWtlXV0gb3Igc3RyaW5nIHRoYXQgYmVnaW5zIHdpdGhcbiAqICBgYFwid3M6XCJgYCBvciBgYFwid3NzOlwiYGAsIGEgW1tXZWJTb2NrZXRQcm92aWRlcl1dIGlzIHJldHVybmVkIGJhY2tlZFxuICogIGJ5IHRoYXQgV2ViU29ja2V0IG9yIFVSTC5cbiAqXG4gKiAgSWYgJSVuZXR3b3JrJSUgaXMgYSBzdHJpbmcgdGhhdCBiZWdpbnMgd2l0aCBgYFwiSFRUUDpcImBgIG9yIGBgXCJIVFRQUzpcImBgLFxuICogIGEgW1tKc29uUnBjUHJvdmlkZXJdXSBpcyByZXR1cm5lZCBjb25uZWN0ZWQgdG8gdGhhdCBVUkwuXG4gKlxuICogIE90aGVyd2lzZSwgYSBkZWZhdWx0IHByb3ZpZGVyIGlzIGNyZWF0ZWQgYmFja2VkIGJ5IHdlbGwta25vd24gcHVibGljXG4gKiAgV2ViMyBiYWNrZW5kcyAoc3VjaCBhcyBbW2xpbmstaW5mdXJhXV0pIHVzaW5nIGNvbW11bml0eS1wcm92aWRlZCBBUElcbiAqICBrZXlzLlxuICpcbiAqICBUaGUgJSVvcHRpb25zJSUgYWxsb3dzIHNwZWNpZnlpbmcgY3VzdG9tIEFQSSBrZXlzIHBlciBiYWNrZW5kIChzZXR0aW5nXG4gKiAgYW4gQVBJIGtleSB0byBgYFwiLVwiYGAgd2lsbCBvbWl0IHRoYXQgcHJvdmlkZXIpIGFuZCBgYG9wdGlvbnMuZXhjbHVzaXZlYGBcbiAqICBjYW4gYmUgc2V0IHRvIGVpdGhlciBhIGJhY2tlbmQgbmFtZSBvciBhbmQgYXJyYXkgb2YgYmFja2VuZCBuYW1lcywgd2hpY2hcbiAqICB3aWxsIHdoaXRlbGlzdCAqKm9ubHkqKiB0aG9zZSBiYWNrZW5kcy5cbiAqXG4gKiAgQ3VycmVudCBiYWNrZW5kIHN0cmluZ3Mgc3VwcG9ydGVkIGFyZTpcbiAqICAtIGBgXCJhbGNoZW15XCJgYFxuICogIC0gYGBcImFua3JcImBgXG4gKiAgLSBgYFwiY2xvdWRmbGFyZVwiYGBcbiAqICAtIGBgXCJjaGFpbnN0YWNrXCJgYFxuICogIC0gYGBcImV0aGVyc2NhblwiYGBcbiAqICAtIGBgXCJpbmZ1cmFcImBgXG4gKiAgLSBgYFwicHVibGljUG9seWdvblwiYGBcbiAqICAtIGBgXCJxdWlja25vZGVcImBgXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gQ29ubmVjdCB0byBhIGxvY2FsIEdldGggbm9kZVxuICogICAgcHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXIoXCJodHRwOi8vbG9jYWxob3N0Ojg1NDUvXCIpO1xuICpcbiAqICAgIC8vIENvbm5lY3QgdG8gRXRoZXJldW0gbWFpbm5ldCB3aXRoIGFueSBjdXJyZW50IGFuZCBmdXR1cmVcbiAqICAgIC8vIHRoaXJkLXBhcnR5IHNlcnZpY2VzIGF2YWlsYWJsZVxuICogICAgcHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXIoXCJtYWlubmV0XCIpO1xuICpcbiAqICAgIC8vIENvbm5lY3QgdG8gUG9seWdvbiwgYnV0IG9ubHkgYWxsb3cgRXRoZXJzY2FuIGFuZFxuICogICAgLy8gSU5GVVJBIGFuZCB1c2UgXCJNWV9BUElfS0VZXCIgaW4gY2FsbHMgdG8gRXRoZXJzY2FuLlxuICogICAgcHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXIoXCJtYXRpY1wiLCB7XG4gKiAgICAgIGV0aGVyc2NhbjogXCJNWV9BUElfS0VZXCIsXG4gKiAgICAgIGV4Y2x1c2l2ZTogWyBcImV0aGVyc2NhblwiLCBcImluZnVyYVwiIF1cbiAqICAgIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgYWxsb3dTZXJ2aWNlID0gKG5hbWUpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy5leGNsdXNpdmUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5hbWUgPT09IG9wdGlvbnMuZXhjbHVzaXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmV4Y2x1c2l2ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAob3B0aW9ucy5leGNsdXNpdmUuaW5kZXhPZihuYW1lKSAhPT0gLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgJiYgbmV0d29yay5tYXRjaCgvXmh0dHBzPzovKSkge1xuICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNQcm92aWRlcihuZXR3b3JrKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgJiYgbmV0d29yay5tYXRjaCgvXndzcz86LykgfHwgaXNXZWJTb2NrZXRMaWtlKG5ldHdvcmspKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViU29ja2V0UHJvdmlkZXIobmV0d29yayk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgbmV0d29yayBhbmQgbmFtZSwgaWYgcG9zc2libGVcbiAgICBsZXQgc3RhdGljTmV0d29yayA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RhdGljTmV0d29yayA9IE5ldHdvcmsuZnJvbShuZXR3b3JrKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICBjb25zdCBwcm92aWRlcnMgPSBbXTtcbiAgICBpZiAoYWxsb3dTZXJ2aWNlKFwicHVibGljUG9seWdvblwiKSAmJiBzdGF0aWNOZXR3b3JrKSB7XG4gICAgICAgIGlmIChzdGF0aWNOZXR3b3JrLm5hbWUgPT09IFwibWF0aWNcIikge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IEpzb25ScGNQcm92aWRlcihcImh0dHBzOi9cXC9wb2x5Z29uLXJwYy5jb20vXCIsIHN0YXRpY05ldHdvcmssIHsgc3RhdGljTmV0d29yayB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGljTmV0d29yay5uYW1lID09PSBcIm1hdGljLWFtb3lcIikge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IEpzb25ScGNQcm92aWRlcihcImh0dHBzOi9cXC9ycGMtYW1veS5wb2x5Z29uLnRlY2hub2xvZ3kvXCIsIHN0YXRpY05ldHdvcmssIHsgc3RhdGljTmV0d29yayB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImFsY2hlbXlcIikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBBbGNoZW15UHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5hbGNoZW15KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImFua3JcIikgJiYgb3B0aW9ucy5hbmtyICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBBbmtyUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5hbmtyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgLyogVGVtcG9yYXJpbHkgcmVtb3ZlIHVudGlsIGN1c3RvbSBlcnJvciBpc3N1ZSBpcyBmaXhlZFxuICAgICAgICBpZiAoYWxsb3dTZXJ2aWNlKFwiYmxvY2tzY291dFwiKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgQmxvY2tzY291dFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuYmxvY2tzY291dCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgKi9cbiAgICBpZiAoYWxsb3dTZXJ2aWNlKFwiY2hhaW5zdGFja1wiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IENoYWluc3RhY2tQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmNoYWluc3RhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICBpZiAoYWxsb3dTZXJ2aWNlKFwiY2xvdWRmbGFyZVwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IENsb3VkZmxhcmVQcm92aWRlcihuZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImV0aGVyc2NhblwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IEV0aGVyc2NhblByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuZXRoZXJzY2FuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImluZnVyYVwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByb2plY3RJZCA9IG9wdGlvbnMuaW5mdXJhO1xuICAgICAgICAgICAgbGV0IHByb2plY3RTZWNyZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChwcm9qZWN0SWQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdFNlY3JldCA9IHByb2plY3RJZC5wcm9qZWN0U2VjcmV0O1xuICAgICAgICAgICAgICAgIHByb2plY3RJZCA9IHByb2plY3RJZC5wcm9qZWN0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgSW5mdXJhUHJvdmlkZXIobmV0d29yaywgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgLypcbiAgICAgICAgaWYgKG9wdGlvbnMucG9ja2V0ICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgYXBwSWQgPSBvcHRpb25zLnBvY2tldDtcbiAgICAgICAgICAgICAgICBsZXQgc2VjcmV0S2V5OiB1bmRlZmluZWQgfCBzdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IGxvYWRCYWxhbmNlcjogdW5kZWZpbmVkIHwgYm9vbGVhbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGFwcElkKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2FkQmFsYW5jZXIgPSAhIWFwcElkLmxvYWRCYWxhbmNlcjtcbiAgICAgICAgICAgICAgICAgICAgc2VjcmV0S2V5ID0gYXBwSWQuc2VjcmV0S2V5O1xuICAgICAgICAgICAgICAgICAgICBhcHBJZCA9IGFwcElkLmFwcElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgUG9ja2V0UHJvdmlkZXIobmV0d29yaywgYXBwSWQsIHNlY3JldEtleSwgbG9hZEJhbGFuY2VyKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgeyBjb25zb2xlLmxvZyhlcnJvcik7IH1cbiAgICAgICAgfVxuICAgICovXG4gICAgaWYgKGFsbG93U2VydmljZShcInF1aWNrbm9kZVwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRva2VuID0gb3B0aW9ucy5xdWlja25vZGU7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgUXVpY2tOb2RlUHJvdmlkZXIobmV0d29yaywgdG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICBhc3NlcnQocHJvdmlkZXJzLmxlbmd0aCwgXCJ1bnN1cHBvcnRlZCBkZWZhdWx0IG5ldHdvcmtcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZ2V0RGVmYXVsdFByb3ZpZGVyXCJcbiAgICB9KTtcbiAgICAvLyBObyBuZWVkIGZvciBhIEZhbGxiYWNrUHJvdmlkZXJcbiAgICBpZiAocHJvdmlkZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXJzWzBdO1xuICAgIH1cbiAgICAvLyBXZSB1c2UgdGhlIGZsb29yIGJlY2F1c2UgcHVibGljIHRoaXJkLXBhcnR5IHByb3ZpZGVycyBjYW4gYmUgdW5yZWxpYWJsZSxcbiAgICAvLyBzbyBhIGxvdyBudW1iZXIgb2YgcHJvdmlkZXJzIHdpdGggYSBsYXJnZSBxdW9ydW0gd2lsbCBmYWlsIHRvbyBvZnRlblxuICAgIGxldCBxdW9ydW0gPSBNYXRoLmZsb29yKHByb3ZpZGVycy5sZW5ndGggLyAyKTtcbiAgICBpZiAocXVvcnVtID4gMikge1xuICAgICAgICBxdW9ydW0gPSAyO1xuICAgIH1cbiAgICAvLyBUZXN0bmV0cyBkb24ndCBuZWVkIGFzIHN0cm9uZyBhIHNlY3VyaXR5IGdhdXJhbnRlZSBhbmQgc3BlZWQgaXNcbiAgICAvLyBtb3JlIHVzZWZ1bCBkdXJpbmcgdGVzdGluZ1xuICAgIGlmIChzdGF0aWNOZXR3b3JrICYmIFRlc3RuZXRzLmluZGV4T2Yoc3RhdGljTmV0d29yay5uYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgcXVvcnVtID0gMTtcbiAgICB9XG4gICAgLy8gUHJvdmlkZWQgb3ZlcnJpZGUgcW9ydW0gdGFrZXMgcHJpb3JpdHlcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnF1b3J1bSkge1xuICAgICAgICBxdW9ydW0gPSBvcHRpb25zLnF1b3J1bTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGYWxsYmFja1Byb3ZpZGVyKHByb3ZpZGVycywgdW5kZWZpbmVkLCB7IHF1b3J1bSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHQtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/default-provider.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/ens-resolver.js":
/*!***********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/ens-resolver.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasicMulticoinProviderPlugin: function() { return /* binding */ BasicMulticoinProviderPlugin; },\n/* harmony export */   EnsResolver: function() { return /* binding */ EnsResolver; },\n/* harmony export */   MulticoinProviderPlugin: function() { return /* binding */ MulticoinProviderPlugin; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/index.js */ \"../common/node_modules/ethers/lib.esm/constants/index.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contract/index.js */ \"../common/node_modules/ethers/lib.esm/contract/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hash/index.js */ \"../common/node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */\n\n\n\n\n\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */\nclass MulticoinProviderPlugin {\n    /**\n     *  The name.\n     */\n    name;\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */\n    constructor(name) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name });\n    }\n    connect(proivder) {\n        return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */\n    supportsCoinType(coinType) {\n        return false;\n    }\n    /**\n     *  Resolves to the encoded %%address%% for %%coinType%%.\n     */\n    async encodeAddress(coinType, address) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Resolves to the decoded %%data%% for %%coinType%%.\n     */\n    async decodeAddress(coinType, data) {\n        throw new Error(\"unsupported coin\");\n    }\n}\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */\nclass BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */\n    constructor() {\n        super(BasicMulticoinPluginId);\n    }\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */\nclass EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider;\n    /**\n     *  The address of the resolver.\n     */\n    address;\n    /**\n     *  The name this resolver was resolved against.\n     */\n    name;\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544;\n    #resolver;\n    constructor(provider, address, name) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { provider, address, name });\n        this.#supports2544 = null;\n        this.#resolver = new _contract_index_js__WEBPACK_IMPORTED_MODULE_1__.Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\",\n        ], provider);\n    }\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */\n    async supportsWildcard() {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async () => {\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                }\n                catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                        return false;\n                    }\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n                    throw error;\n                }\n            })();\n        }\n        return await this.#supports2544;\n    }\n    async #fetch(funcName, params) {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n        // The first parameters is always the nodehash\n        params.unshift((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_2__.namehash)(this.name));\n        let fragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: { funcName }\n            });\n            params = [\n                (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_2__.dnsEncode)(this.name, 255),\n                iface.encodeFunctionData(fragment, params)\n            ];\n            funcName = \"resolve(bytes,bytes)\";\n        }\n        params.push({\n            enableCcipRead: true\n        });\n        try {\n            const result = await this.#resolver[funcName](...params);\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n            return result;\n        }\n        catch (error) {\n            if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                throw error;\n            }\n        }\n        return null;\n    }\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */\n    async getAddress(coinType) {\n        if (coinType == null) {\n            coinType = 60;\n        }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n                // No address\n                if (result == null || result === _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroAddress) {\n                    return null;\n                }\n                return result;\n            }\n            catch (error) {\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                    return null;\n                }\n                throw error;\n            }\n        }\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [ethCoinType]);\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(data, 20)) {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.getAddress)(data);\n            }\n        }\n        let coinPlugin = null;\n        for (const plugin of this.provider.plugins) {\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\n                continue;\n            }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n        if (coinPlugin == null) {\n            return null;\n        }\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [coinType]);\n        // No address\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n        if (address != null) {\n            return address;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${coinType})`,\n            info: { coinType, data }\n        });\n    }\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */\n    async getText(key) {\n        const data = await this.#fetch(\"text(bytes32,string)\", [key]);\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        return data;\n    }\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */\n    async getContentHash() {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n        // No contenthash\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = (ipfs[1] === \"e3010170\") ? \"ipfs\" : \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${scheme}:/\\/${(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeBase58)(\"0x\" + ipfs[2])}`;\n            }\n        }\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${swarm[1]}`;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: { data }\n        });\n    }\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */\n    async getAvatar() {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */\n    async _getAvatar() {\n        const linkage = [{ type: \"name\", value: this.name }];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({ type: \"!avatar\", value: \"\" });\n                return { url: null, linkage };\n            }\n            linkage.push({ type: \"avatar\", value: avatar });\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) {\n                    continue;\n                }\n                const scheme = match[1].toLowerCase();\n                switch (scheme) {\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({ type: \"url\", value: avatar });\n                        return { linkage, url: avatar };\n                    case \"ipfs\": {\n                        const url = getIpfsLink(avatar);\n                        linkage.push({ type: \"ipfs\", value: avatar });\n                        linkage.push({ type: \"url\", value: url });\n                        return { linkage, url };\n                    }\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n                        linkage.push({ type: scheme, value: avatar });\n                        // The owner of this name\n                        const owner = await this.getAddress();\n                        if (owner == null) {\n                            linkage.push({ type: \"!owner\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) {\n                            linkage.push({ type: `!${scheme}caip`, value: (match[2] || \"\") });\n                            return { url: null, linkage };\n                        }\n                        const tokenId = comps[1];\n                        const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_1__.Contract(comps[0], [\n                            // ERC-721\n                            \"function tokenURI(uint) view returns (string)\",\n                            \"function ownerOf(uint) view returns (address)\",\n                            // ERC-1155\n                            \"function uri(uint) view returns (string)\",\n                            \"function balanceOf(address, uint256) view returns (uint)\"\n                        ], this.provider);\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            const tokenOwner = await contract.ownerOf(tokenId);\n                            if (owner !== tokenOwner) {\n                                linkage.push({ type: \"!owner\", value: tokenOwner });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"owner\", value: tokenOwner });\n                        }\n                        else if (scheme === \"erc1155\") {\n                            const balance = await contract.balanceOf(owner, tokenId);\n                            if (!balance) {\n                                linkage.push({ type: \"!balance\", value: \"0\" });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"balance\", value: balance.toString() });\n                        }\n                        // Call the token contract for the metadata URL\n                        let metadataUrl = await contract[selector](tokenId);\n                        if (metadataUrl == null || metadataUrl === \"0x\") {\n                            linkage.push({ type: \"!metadata-url\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        linkage.push({ type: \"metadata-url-base\", value: metadataUrl });\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(tokenId, 32).substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", value: metadataUrl });\n                        }\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n                        linkage.push({ type: \"metadata-url\", value: metadataUrl });\n                        // Get the token metadata\n                        let metadata = {};\n                        const response = await (new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(metadataUrl)).send();\n                        response.assertOk();\n                        try {\n                            metadata = response.bodyJson;\n                        }\n                        catch (error) {\n                            try {\n                                linkage.push({ type: \"!metadata\", value: response.bodyText });\n                            }\n                            catch (error) {\n                                const bytes = response.body;\n                                if (bytes) {\n                                    linkage.push({ type: \"!metadata\", value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes) });\n                                }\n                                return { url: null, linkage };\n                            }\n                            return { url: null, linkage };\n                        }\n                        if (!metadata) {\n                            linkage.push({ type: \"!metadata\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        linkage.push({ type: \"metadata\", value: JSON.stringify(metadata) });\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof (imageUrl) !== \"string\") {\n                            linkage.push({ type: \"!imageUrl\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        }\n                        else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) {\n                                linkage.push({ type: \"!imageUrl-ipfs\", value: imageUrl });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"imageUrl-ipfs\", value: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n                        linkage.push({ type: \"url\", value: imageUrl });\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        }\n        catch (error) { }\n        return { linkage, url: null };\n    }\n    static async getEnsAddress(provider) {\n        const network = await provider.getNetwork();\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n        // No ENS...\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\", info: { network }\n        });\n        return ensPlugin.address;\n    }\n    static async #getResolver(provider, name) {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n        try {\n            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_1__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n            const addr = await contract.resolver((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_2__.namehash)(name), {\n                enableCcipRead: true\n            });\n            if (addr === _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroAddress) {\n                return null;\n            }\n            return addr;\n        }\n        catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n        return null;\n    }\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */\n    static async fromName(provider, name) {\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") {\n                return null;\n            }\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") {\n                return null;\n            }\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) {\n                    return null;\n                }\n                return resolver;\n            }\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n}\n//# sourceMappingURL=ens-resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZW5zLXJlc29sdmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lEO0FBQ0c7QUFDSjtBQUNPO0FBQzBGO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyx5QkFBeUI7QUFDMUQ7QUFDQSw2QkFBNkIsd0RBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3REFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FB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O0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Vucy1yZXNvbHZlci5qcz9hNmM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEVOUyBpcyBhIHNlcnZpY2Ugd2hpY2ggYWxsb3dzIGVhc3ktdG8tcmVtZW1iZXIgbmFtZXMgdG8gbWFwIHRvXG4gKiAgbmV0d29yayBhZGRyZXNzZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXI6RU5TIFJlc29sdmVyICBbYWJvdXQtZW5zLXJzb2x2ZXJdXG4gKi9cbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZG5zRW5jb2RlLCBuYW1laGFzaCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBoZXhsaWZ5LCBpc0hleFN0cmluZywgdG9CZUhleCwgZGVmaW5lUHJvcGVydGllcywgZW5jb2RlQmFzZTU4LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0Vycm9yLCBGZXRjaFJlcXVlc3QgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8vIEBUT0RPOiBUaGlzIHNob3VsZCB1c2UgdGhlIGZldGNoLWRhdGE6aXBmcyBnYXRld2F5XG4vLyBUcmltIG9mZiB0aGUgaXBmczovLyBwcmVmaXggYW5kIHJldHVybiB0aGUgZGVmYXVsdCBnYXRld2F5IFVSTFxuZnVuY3Rpb24gZ2V0SXBmc0xpbmsobGluaykge1xuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZygxMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoNyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBJUEZTIGZvcm1hdFwiLCBcImxpbmtcIiwgbGluayk7XG4gICAgfVxuICAgIHJldHVybiBgaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzLyR7bGlua31gO1xufVxuO1xuO1xuLyoqXG4gKiAgQSBwcm92aWRlciBwbHVnaW4gc3VwZXItY2xhc3MgZm9yIHByb2Nlc3NpbmcgbXVsdGljb2luIGFkZHJlc3MgdHlwZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipNdWx0aWNvaW5Qcm92aWRlclBsdWluZyoqIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHByb2l2ZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJWNvaW5UeXBlJSUgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgcGx1Z2luLlxuICAgICAqL1xuICAgIHN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGVuY29kZWQgJSVhZGRyZXNzJSUgZm9yICUlY29pblR5cGUlJS5cbiAgICAgKi9cbiAgICBhc3luYyBlbmNvZGVBZGRyZXNzKGNvaW5UeXBlLCBhZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGNvaW5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZGVjb2RlZCAlJWRhdGElJSBmb3IgJSVjb2luVHlwZSUlLlxuICAgICAqL1xuICAgIGFzeW5jIGRlY29kZUFkZHJlc3MoY29pblR5cGUsIGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29pblwiKTtcbiAgICB9XG59XG5jb25zdCBCYXNpY011bHRpY29pblBsdWdpbklkID0gXCJvcmcuZXRoZXJzLnBsdWdpbnMucHJvdmlkZXIuQmFzaWNNdWx0aWNvaW5cIjtcbi8qKlxuICogIEEgKipCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luKiogcHJvdmlkZXMgc2VydmljZSBmb3IgY29tbW9uXG4gKiAgY29pbiB0eXBlcywgd2hpY2ggZG8gbm90IHJlcXVpcmUgYWRkaXRpb25hbCBsaWJyYXJpZXMgdG8gZW5jb2RlIG9yXG4gKiAgZGVjb2RlLlxuICovXG5leHBvcnQgY2xhc3MgQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiBleHRlbmRzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCk7XG4gICAgfVxufVxuY29uc3QgbWF0Y2hlcklwZnMgPSBuZXcgUmVnRXhwKFwiXihpcGZzKTovXFwvKC4qKSRcIiwgXCJpXCIpO1xuY29uc3QgbWF0Y2hlcnMgPSBbXG4gICAgbmV3IFJlZ0V4cChcIl4oaHR0cHMpOi9cXC8oLiopJFwiLCBcImlcIiksXG4gICAgbmV3IFJlZ0V4cChcIl4oZGF0YSk6KC4qKSRcIiwgXCJpXCIpLFxuICAgIG1hdGNoZXJJcGZzLFxuICAgIG5ldyBSZWdFeHAoXCJeZWlwMTU1OlswLTldKy8oZXJjWzAtOV0rKTooLiopJFwiLCBcImlcIiksXG5dO1xuLyoqXG4gKiAgQSBjb25uZWN0ZWQgb2JqZWN0IHRvIGEgcmVzb2x2ZWQgRU5TIG5hbWUgcmVzb2x2ZXIsIHdoaWNoIGNhbiBiZVxuICogIHVzZWQgdG8gcXVlcnkgYWRkaXRpb25hbCBkZXRhaWxzLlxuICovXG5leHBvcnQgY2xhc3MgRW5zUmVzb2x2ZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgcmVzb2x2ZXIuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgdGhpcyByZXNvbHZlciB3YXMgcmVzb2x2ZWQgYWdhaW5zdC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8vIEZvciBFSVAtMjU0NCBuYW1lcywgdGhlIGFuY2VzdG9yIHRoYXQgcHJvdmlkZWQgdGhlIHJlc29sdmVyXG4gICAgI3N1cHBvcnRzMjU0NDtcbiAgICAjcmVzb2x2ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByb3ZpZGVyLCBhZGRyZXNzLCBuYW1lIH0pO1xuICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSBudWxsO1xuICAgICAgICB0aGlzLiNyZXNvbHZlciA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBbXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCkgdmlldyByZXR1cm5zIChib29sKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlKGJ5dGVzLCBieXRlcykgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGFkZHIoYnl0ZXMzMiwgdWludCkgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gdGV4dChieXRlczMyLCBzdHJpbmcpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBjb250ZW50aGFzaChieXRlczMyKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICBdLCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0cnVlIGlmIHRoZSByZXNvbHZlciBzdXBwb3J0cyB3aWxkY2FyZCByZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHN1cHBvcnRzV2lsZGNhcmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNzdXBwb3J0czI1NDQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcmVzb2x2ZXIuc3VwcG9ydHNJbnRlcmZhY2UoXCIweDkwNjFiOTIzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2lsZGNhcmQgcmVzb2x2ZXJzIG11c3QgdW5kZXJzdGFuZCBzdXBwb3J0c0ludGVyZmFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0IGZ1dHVyZSBhdHRlbXB0cyB0cnkgYWdhaW4uLi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc3VwcG9ydHMyNTQ0O1xuICAgIH1cbiAgICBhc3luYyAjZmV0Y2goZnVuY05hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBjb25zdCBpZmFjZSA9IHRoaXMuI3Jlc29sdmVyLmludGVyZmFjZTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlcnMgaXMgYWx3YXlzIHRoZSBub2RlaGFzaFxuICAgICAgICBwYXJhbXMudW5zaGlmdChuYW1laGFzaCh0aGlzLm5hbWUpKTtcbiAgICAgICAgbGV0IGZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuc3VwcG9ydHNXaWxkY2FyZCgpKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGlmYWNlLmdldEZ1bmN0aW9uKGZ1bmNOYW1lKTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJtaXNzaW5nIGZyYWdtZW50XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgaW5mbzogeyBmdW5jTmFtZSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtcbiAgICAgICAgICAgICAgICBkbnNFbmNvZGUodGhpcy5uYW1lLCAyNTUpLFxuICAgICAgICAgICAgICAgIGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcGFyYW1zKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZ1bmNOYW1lID0gXCJyZXNvbHZlKGJ5dGVzLGJ5dGVzKVwiO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcmVzb2x2ZXJbZnVuY05hbWVdKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdClbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgJSVjb2luVHlwZSUlIG9yIG51bGwgaWYgdGhlXG4gICAgICogIHByb3ZpZGVkICUlY29pblR5cGUlJSBoYXMgbm90IGJlZW4gY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKGNvaW5UeXBlKSB7XG4gICAgICAgIGlmIChjb2luVHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luVHlwZSA9PT0gNjApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIpXCIpO1xuICAgICAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgZGVjb2RpbmcgaXRzIEVWTSBjYW5vbmljYWwgY2hhaW4gYXMgYW4gRVZNIGNoYWluIGFkZHJlc3MgZmlyc3RcbiAgICAgICAgaWYgKGNvaW5UeXBlID49IDAgJiYgY29pblR5cGUgPCAweDgwMDAwMDAwKSB7XG4gICAgICAgICAgICBsZXQgZXRoQ29pblR5cGUgPSBjb2luVHlwZSArIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2V0aENvaW5UeXBlXSk7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZGF0YSwgMjApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvaW5QbHVnaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnByb3ZpZGVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmICghKHBsdWdpbiBpbnN0YW5jZW9mIE11bHRpY29pblByb3ZpZGVyUGx1Z2luKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsdWdpbi5zdXBwb3J0c0NvaW5UeXBlKGNvaW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIGNvaW5QbHVnaW4gPSBwbHVnaW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5QbHVnaW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyLHVpbnQyNTZcIilcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiYWRkcihieXRlczMyLHVpbnQpXCIsIFtjb2luVHlwZV0pO1xuICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBhZGRyZXNzXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBjb2luUGx1Z2luLmRlY29kZUFkZHJlc3MoY29pblR5cGUsIGRhdGEpO1xuICAgICAgICBpZiAoYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIGNvaW4gZGF0YWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcbiAgICAgICAgICAgIGluZm86IHsgY29pblR5cGUsIGRhdGEgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBFSVAtNjM0IHRleHQgcmVjb3JkIGZvciAlJWtleSUlLCBvciBgYG51bGxgYFxuICAgICAqICBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGV4dChrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwidGV4dChieXRlczMyLHN0cmluZylcIiwgW2tleV0pO1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSc29sdmVzIHRvIHRoZSBjb250ZW50LWhhc2ggb3IgYGBudWxsYGAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbnRlbnRIYXNoKCkge1xuICAgICAgICAvLyBrZWNjYWsyNTYoXCJjb250ZW50aGFzaCgpXCIpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImNvbnRlbnRoYXNoKGJ5dGVzMzIpXCIpO1xuICAgICAgICAvLyBObyBjb250ZW50aGFzaFxuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSVBGUyAoQ0lEOiAxLCBUeXBlOiA3MD1EQUctUEIsIDcyPWxpYnAycC1rZXkpXG4gICAgICAgIGNvbnN0IGlwZnMgPSBkYXRhLm1hdGNoKC9eMHgoZTMwMTAxNzB8ZTUwMTAxNzIpKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcbiAgICAgICAgaWYgKGlwZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IChpcGZzWzFdID09PSBcImUzMDEwMTcwXCIpID8gXCJpcGZzXCIgOiBcImlwbnNcIjtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGlwZnNbNF0sIDE2KTtcbiAgICAgICAgICAgIGlmIChpcGZzWzVdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzY2hlbWV9Oi9cXC8ke2VuY29kZUJhc2U1OChcIjB4XCIgKyBpcGZzWzJdKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN3YXJtIChDSUQ6IDEsIFR5cGU6IHN3YXJtLW1hbmlmZXN0OyBoYXNoL2xlbmd0aCBoYXJkLWNvZGVkIHRvIGtlY2NhazI1Ni8zMilcbiAgICAgICAgY29uc3Qgc3dhcm0gPSBkYXRhLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICBpZiAoc3dhcm0gJiYgc3dhcm1bMV0ubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgcmV0dXJuIGBieno6L1xcLyR7c3dhcm1bMV19YDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvbnRlbnQgaGFzaCBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldENvbnRlbnRIYXNoKClcIixcbiAgICAgICAgICAgIGluZm86IHsgZGF0YSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGF2YXRhciB1cmwgb3IgYGBudWxsYGAgaWYgdGhlIGF2YXRhciBpcyBlaXRoZXJcbiAgICAgKiAgdW5jb25maWd1cmVkIG9yIGluY29ycmVjdGx5IGNvbmZpZ3VyZWQgKGUuZy4gcmVmZXJlbmNlcyBhbiBORlRcbiAgICAgKiAgbm90IG93bmVkIGJ5IHRoZSBhZGRyZXNzKS5cbiAgICAgKlxuICAgICAqICBJZiBkaWFnbm9zaW5nIGlzc3VlcyB3aXRoIGNvbmZpZ3VyYXRpb25zLCB0aGUgW1tfZ2V0QXZhdGFyXV1cbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VmdWwuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXZhdGFyKCkge1xuICAgICAgICBjb25zdCBhdmF0YXIgPSBhd2FpdCB0aGlzLl9nZXRBdmF0YXIoKTtcbiAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGVuIHJlc29sdmluZyBhbiBhdmF0YXIsIHRoZXJlIGFyZSBtYW55IHN0ZXBzIGludm9sdmVkLCBzdWNoXG4gICAgICogIGZldGNoaW5nIG1ldGFkYXRhIGFuZCBwb3NzaWJseSB2YWxpZGF0aW5nIG93bmVyc2hpcCBvZiBhblxuICAgICAqICBORlQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gZXhhbWluZSBlYWNoIHN0ZXAgYW5kIHRoZSB2YWx1ZSBpdFxuICAgICAqICB3YXMgd29ya2luZyBmcm9tLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdmF0YXIoKSB7XG4gICAgICAgIGNvbnN0IGxpbmthZ2UgPSBbeyB0eXBlOiBcIm5hbWVcIiwgdmFsdWU6IHRoaXMubmFtZSB9XTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRlc3QgZGF0YSBmb3IgcmljbW9vLmV0aFxuICAgICAgICAgICAgLy9jb25zdCBhdmF0YXIgPSBcImVpcDE1NToxL2VyYzcyMToweDI2NTM4NWM3ZjQxMzIyMjhBMGQ1NEVCMUE5ZTc0NjBiOTFjMGNDNjgvMjkyMzNcIjtcbiAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKTtcbiAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWF2YXRhclwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYXZhdGFyXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBhdmF0YXIubWF0Y2gobWF0Y2hlcnNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWUgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwc1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogYXZhdGFyIH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpcGZzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGdldElwZnNMaW5rKGF2YXRhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImlwZnNcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiB1cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjNzIxXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmMxMTU1XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgRVJDIHR5cGUsIHVzZSB0b2tlblVSSSh1aW50MjU2KSBvciB1cmwodWludDI1NilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikgPyBcInRva2VuVVJJKHVpbnQyNTYpXCIgOiBcInVyaSh1aW50MjU2KVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogc2NoZW1lLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG93bmVyIG9mIHRoaXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3duZXIgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhb3duZXJcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wcyA9IChtYXRjaFsyXSB8fCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogYCEke3NjaGVtZX1jYWlwYCwgdmFsdWU6IChtYXRjaFsyXSB8fCBcIlwiKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSWQgPSBjb21wc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGNvbXBzWzBdLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTcyMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdG9rZW5VUkkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBvd25lck9mKHVpbnQpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdXJpKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MsIHVpbnQyNTYpIHZpZXcgcmV0dXJucyAodWludClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuT3duZXIgPSBhd2FpdCBjb250cmFjdC5vd25lck9mKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwib3duZXJcIiwgdmFsdWU6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbnRyYWN0LmJhbGFuY2VPZihvd25lciwgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWJhbGFuY2VcIiwgdmFsdWU6IFwiMFwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIHZhbHVlOiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSB0b2tlbiBjb250cmFjdCBmb3IgdGhlIG1ldGFkYXRhIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhVXJsID0gYXdhaXQgY29udHJhY3Rbc2VsZWN0b3JdKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsID09IG51bGwgfHwgbWV0YWRhdGFVcmwgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhLXVybFwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWJhc2VcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybC5yZXBsYWNlKFwie2lkfVwiLCB0b0JlSGV4KHRva2VuSWQsIDMyKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWV4cGFuZGVkXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIG1ldGFkYXRhIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwubWF0Y2goL15pcGZzOi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gZ2V0SXBmc0xpbmsobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmxcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0b2tlbiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChuZXcgRmV0Y2hSZXF1ZXN0KG1ldGFkYXRhVXJsKSkuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSByZXNwb25zZS5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiByZXNwb25zZS5ib2R5VGV4dCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogaGV4bGlmeShieXRlcykgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YVwiLCB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVsbCB0aGUgaW1hZ2UgVVJMIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlVXJsID0gbWV0YWRhdGEuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChpbWFnZVVybCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFpbWFnZVVybFwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZVVybC5tYXRjaCgvXihodHRwczpcXC9cXC98ZGF0YTopL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIGxpbmsgdG8gZ2F0ZXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlwZnMgPSBpbWFnZVVybC5tYXRjaChtYXRjaGVySXBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlwZnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VVcmwgPSBnZXRJcGZzTGluayhpbWFnZVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGltYWdlVXJsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBudWxsIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBnZXRFbnNBZGRyZXNzKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGVuc1BsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRW5zXCIpO1xuICAgICAgICAvLyBObyBFTlMuLi5cbiAgICAgICAgYXNzZXJ0KGVuc1BsdWdpbiwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRFbnNBZGRyZXNzXCIsIGluZm86IHsgbmV0d29yayB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW5zUGx1Z2luLmFkZHJlc3M7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyAjZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3MocHJvdmlkZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoZW5zQWRkciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZXIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiXG4gICAgICAgICAgICBdLCBwcm92aWRlcik7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgY29udHJhY3QucmVzb2x2ZXIobmFtZWhhc2gobmFtZSksIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYWRkciA9PT0gWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRU5TIHJlZ2lzdHJ5IGNhbm5vdCB0aHJvdyBlcnJvcnMgb24gcmVzb2x2ZXIoYnl0ZXMzMiksXG4gICAgICAgICAgICAvLyBzbyBwcm9iYWJseSBhIGxpbmsgZXJyb3JcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgRU5TIHJlc29sdmVyIGZvciAlJW5hbWUlJSB1c2luZyAlJXByb3ZpZGVyJSUgb3JcbiAgICAgKiAgYGBudWxsYGAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tTmFtZShwcm92aWRlciwgbmFtZSkge1xuICAgICAgICBsZXQgY3VycmVudE5hbWUgPSBuYW1lO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lID09PSBcIlwiIHx8IGN1cnJlbnROYW1lID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIHNpbmNlIHRoZSBldGggbm9kZSBjYW5ub3QgY2hhbmdlIGFuZCBkb2VzXG4gICAgICAgICAgICAvLyBub3QgaGF2ZSBhIHdpbGRjYXJkIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJldGhcIiAmJiBjdXJyZW50TmFtZSA9PT0gXCJldGhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgbm9kZSBmb3IgYSByZXNvbHZlclxuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLiNnZXRSZXNvbHZlcihwcm92aWRlciwgY3VycmVudE5hbWUpO1xuICAgICAgICAgICAgLy8gRm91bmQgYSByZXNvbHZlciFcbiAgICAgICAgICAgIGlmIChhZGRyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IG5ldyBFbnNSZXNvbHZlcihwcm92aWRlciwgYWRkciwgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gTGVnYWN5IHJlc29sdmVyIGZvdW5kLCB1c2luZyBFSVAtMjU0NCBzbyBpdCBpc24ndCBzYWZlIHRvIHVzZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSAhPT0gbmFtZSAmJiAhKGF3YWl0IHJlc29sdmVyLnN1cHBvcnRzV2lsZGNhcmQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgIGN1cnJlbnROYW1lID0gY3VycmVudE5hbWUuc3BsaXQoXCIuXCIpLnNsaWNlKDEpLmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5zLXJlc29sdmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/ens-resolver.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/format.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/format.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allowNull: function() { return /* binding */ allowNull; },\n/* harmony export */   arrayOf: function() { return /* binding */ arrayOf; },\n/* harmony export */   formatBlock: function() { return /* binding */ formatBlock; },\n/* harmony export */   formatBoolean: function() { return /* binding */ formatBoolean; },\n/* harmony export */   formatData: function() { return /* binding */ formatData; },\n/* harmony export */   formatHash: function() { return /* binding */ formatHash; },\n/* harmony export */   formatLog: function() { return /* binding */ formatLog; },\n/* harmony export */   formatReceiptLog: function() { return /* binding */ formatReceiptLog; },\n/* harmony export */   formatTransactionReceipt: function() { return /* binding */ formatTransactionReceipt; },\n/* harmony export */   formatTransactionResponse: function() { return /* binding */ formatTransactionResponse; },\n/* harmony export */   formatUint256: function() { return /* binding */ formatUint256; },\n/* harmony export */   object: function() { return /* binding */ object; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/**\n *  @_ignore\n */\n\n\n\n\nconst BN_0 = BigInt(0);\nfunction allowNull(format, nullValue) {\n    return (function (value) {\n        if (value == null) {\n            return nullValue;\n        }\n        return format(value);\n    });\n}\nfunction arrayOf(format, allowNull) {\n    return ((array) => {\n        if (allowNull && array == null) {\n            return null;\n        }\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        return array.map((i) => format(i));\n    });\n}\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nfunction object(format, altNames) {\n    return ((value) => {\n        const result = {};\n        for (const key in format) {\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey in value)) {\n                for (const altKey of altNames[key]) {\n                    if (altKey in value) {\n                        srcKey = altKey;\n                        break;\n                    }\n                }\n            }\n            try {\n                const nv = format[key](value[srcKey]);\n                if (nv !== undefined) {\n                    result[key] = nv;\n                }\n            }\n            catch (error) {\n                const message = (error instanceof Error) ? error.message : \"not-an-error\";\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid value for value.${key} (${message})`, \"BAD_DATA\", { value });\n            }\n        }\n        return result;\n    });\n}\nfunction formatBoolean(value) {\n    switch (value) {\n        case true:\n        case \"true\":\n            return true;\n        case false:\n        case \"false\":\n            return false;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, \"value\", value);\n}\nfunction formatData(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, true), \"invalid data\", \"value\", value);\n    return value;\n}\nfunction formatHash(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}\nfunction formatUint256(value) {\n    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(value, 32);\n}\nconst _formatLog = object({\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress,\n    blockHash: formatHash,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n    removed: allowNull(formatBoolean, false),\n    topics: arrayOf(formatHash),\n    transactionHash: formatHash,\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n}, {\n    index: [\"logIndex\"]\n});\nfunction formatLog(value) {\n    return _formatLog(value);\n}\nconst _formatBlock = object({\n    hash: allowNull(formatHash),\n    parentHash: formatHash,\n    parentBeaconBlockRoot: allowNull(formatHash, null),\n    number: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n    timestamp: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n    nonce: allowNull(formatData),\n    difficulty: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\n    gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\n    stateRoot: allowNull(formatHash, null),\n    receiptsRoot: allowNull(formatHash, null),\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null),\n    excessBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null),\n    miner: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress),\n    prevRandao: allowNull(formatHash, null),\n    extraData: formatData,\n    baseFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)\n}, {\n    prevRandao: [\"mixHash\"]\n});\nfunction formatBlock(value) {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx) => {\n        if (typeof (tx) === \"string\") {\n            return tx;\n        }\n        return formatTransactionResponse(tx);\n    });\n    return result;\n}\nconst _formatReceiptLog = object({\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n    transactionHash: formatHash,\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress,\n    topics: arrayOf(formatHash),\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n    blockHash: formatHash,\n}, {\n    index: [\"logIndex\"]\n});\nfunction formatReceiptLog(value) {\n    return _formatReceiptLog(value);\n}\nconst _formatTransactionReceipt = object({\n    to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress, null),\n    from: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress, null),\n    contractAddress: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress, null),\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n    root: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify),\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null),\n    logsBloom: allowNull(formatData),\n    blockHash: formatHash,\n    hash: formatHash,\n    logs: arrayOf(formatReceiptLog),\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n    //confirmations: allowNull(getNumber, null),\n    cumulativeGasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\n    effectiveGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt),\n    blobGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null),\n    status: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber),\n    type: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber, 0)\n}, {\n    effectiveGasPrice: [\"gasPrice\"],\n    hash: [\"transactionHash\"],\n    index: [\"transactionIndex\"],\n});\nfunction formatTransactionReceipt(value) {\n    return _formatTransactionReceipt(value);\n}\nfunction formatTransactionResponse(value) {\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value.to) === BN_0) {\n        value.to = \"0x0000000000000000000000000000000000000000\";\n    }\n    const result = object({\n        hash: formatHash,\n        // Some nodes do not return this, usually test nodes (like Ganache)\n        index: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber, undefined),\n        type: (value) => {\n            if (value === \"0x\" || value == null) {\n                return 0;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\n        },\n        accessList: allowNull(_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.accessListify, null),\n        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),\n        authorizationList: allowNull(arrayOf((v) => {\n            return {\n                address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(v.address),\n                chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(v.chainId),\n                nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(v.nonce),\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from(v.signature ? v.signature : v)\n            };\n        }, false), null),\n        blockHash: allowNull(formatHash, null),\n        blockNumber: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber, null),\n        transactionIndex: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber, null),\n        from: _address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress,\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n        gasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt),\n        maxPriorityFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt),\n        maxFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt),\n        maxFeePerBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null),\n        gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\n        to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress, null),\n        value: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt,\n        nonce: _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber,\n        data: formatData,\n        creates: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress, null),\n        chainId: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt, null)\n    }, {\n        data: [\"input\"],\n        gasLimit: [\"gas\"],\n        index: [\"transactionIndex\"]\n    })(value);\n    // If to and creates are empty, populate the creates from the value\n    if (result.to == null && result.creates == null) {\n        result.creates = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getCreateAddress)(result);\n    }\n    // @TODO: Check fee data\n    // Add an access list to supported transaction types\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n        result.accessList = [];\n    }\n    // Compute the signature\n    if (value.signature) {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from(value.signature);\n    }\n    else {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from(value);\n    }\n    // Some backends omit ChainId on legacy transactions, but we can compute it\n    if (result.chainId == null) {\n        const chainId = result.signature.legacyChainId;\n        if (chainId != null) {\n            result.chainId = chainId;\n        }\n    }\n    // @TODO: check chainID\n    /*\n    if (value.chainId != null) {\n        let chainId = value.chainId;\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        result.chainId = chainId;\n\n    } else {\n        let chainId = value.networkId;\n\n        // geth-etc returns chainId\n        if (chainId == null && result.v == null) {\n            chainId = value.chainId;\n        }\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        if (typeof(chainId) !== \"number\" && result.v != null) {\n            chainId = (result.v - 35) / 2;\n            if (chainId < 0) { chainId = 0; }\n            chainId = parseInt(chainId);\n        }\n\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n        result.chainId = chainId;\n    }\n    */\n    // 0x0000... should actually be null\n    if (result.blockHash && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(result.blockHash) === BN_0) {\n        result.blockHash = null;\n    }\n    return result;\n}\n//# sourceMappingURL=format.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZm9ybWF0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDbUU7QUFDcEI7QUFDUztBQUM2RDtBQUNySDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBTSxtQ0FBbUMsS0FBSyxHQUFHLFFBQVEsa0JBQWtCLE9BQU87QUFDbEc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYywwQkFBMEIsRUFBRSxzQkFBc0I7QUFDcEU7QUFDTztBQUNQLElBQUksK0RBQWMsQ0FBQyw0REFBVztBQUM5QjtBQUNBO0FBQ087QUFDUCxJQUFJLCtEQUFjLENBQUMsNERBQVc7QUFDOUI7QUFDQTtBQUNPO0FBQ1AsU0FBUyw0REFBVztBQUNwQjtBQUNBO0FBQ0EsV0FBVyw2REFBWTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSx5REFBVTtBQUN2QjtBQUNBLGlCQUFpQixzREFBUztBQUMxQjtBQUNBLFdBQVcsc0RBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFTO0FBQy9CLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQVM7QUFDckIsZUFBZSxzREFBUztBQUN4QjtBQUNBLGdCQUFnQixzREFBUztBQUN6QixjQUFjLHNEQUFTO0FBQ3ZCLGFBQWEsc0RBQVM7QUFDdEI7QUFDQTtBQUNBLDJCQUEyQixzREFBUztBQUNwQyw2QkFBNkIsc0RBQVM7QUFDdEMscUJBQXFCLHlEQUFVO0FBQy9CO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQVM7QUFDdEMsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBUztBQUMvQixpQkFBaUIsc0RBQVM7QUFDMUI7QUFDQSxhQUFhLHlEQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxXQUFXLHNEQUFTO0FBQ3BCO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlEQUFVO0FBQzVCLG9CQUFvQix5REFBVTtBQUM5QiwrQkFBK0IseURBQVU7QUFDekM7QUFDQSxXQUFXLHNEQUFTO0FBQ3BCLG9CQUFvQixvREFBTztBQUMzQixhQUFhLHNEQUFTO0FBQ3RCLDJCQUEyQixzREFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzREFBUztBQUMxQjtBQUNBLHVCQUF1QixzREFBUztBQUNoQyxpQ0FBaUMsc0RBQVM7QUFDMUMsNEJBQTRCLHNEQUFTO0FBQ3JDLHNCQUFzQixzREFBUztBQUMvQixvQkFBb0Isc0RBQVM7QUFDN0IsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCO0FBQ2xCLG9CQUFvQiwwREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFTO0FBQzVCLFNBQVM7QUFDVCw4QkFBOEIsZ0VBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZEQUFVO0FBQ25DLHlCQUF5QiwwREFBUztBQUNsQyx1QkFBdUIsMERBQVM7QUFDaEMsMkJBQTJCLHVEQUFTO0FBQ3BDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLHNEQUFTO0FBQ3hDLG9DQUFvQyxzREFBUztBQUM3QyxjQUFjLHlEQUFVO0FBQ3hCO0FBQ0EsNEJBQTRCLHNEQUFTO0FBQ3JDLHdDQUF3QyxzREFBUztBQUNqRCxnQ0FBZ0Msc0RBQVM7QUFDekMsb0NBQW9DLHNEQUFTO0FBQzdDLGtCQUFrQixzREFBUztBQUMzQixzQkFBc0IseURBQVU7QUFDaEMsZUFBZSxzREFBUztBQUN4QixlQUFlLHNEQUFTO0FBQ3hCO0FBQ0EsMkJBQTJCLHlEQUFVO0FBQ3JDLDJCQUEyQixzREFBUztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUIsbUVBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdURBQVM7QUFDcEM7QUFDQTtBQUNBLDJCQUEyQix1REFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMERBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZm9ybWF0LmpzP2QwNTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q3JlYXRlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmV4cG9ydCBmdW5jdGlvbiBhbGxvd051bGwoZm9ybWF0LCBudWxsVmFsdWUpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheU9mKGZvcm1hdCwgYWxsb3dOdWxsKSB7XG4gICAgcmV0dXJuICgoYXJyYXkpID0+IHtcbiAgICAgICAgaWYgKGFsbG93TnVsbCAmJiBhcnJheSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoaSkgPT4gZm9ybWF0KGkpKTtcbiAgICB9KTtcbn1cbi8vIFJlcXVpcmVzIGFuIG9iamVjdCB3aGljaCBtYXRjaGVzIGEgZmxlZXQgb2Ygb3RoZXIgZm9ybWF0dGVyc1xuLy8gQW55IEZvcm1hdEZ1bmMgbWF5IHJldHVybiBgdW5kZWZpbmVkYCB0byBoYXZlIHRoZSB2YWx1ZSBvbWl0dGVkXG4vLyBmcm9tIHRoZSByZXN1bHQgb2JqZWN0LiBDYWxscyBwcmVzZXJ2ZSBgdGhpc2AuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KGZvcm1hdCwgYWx0TmFtZXMpIHtcbiAgICByZXR1cm4gKCh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZm9ybWF0KSB7XG4gICAgICAgICAgICBsZXQgc3JjS2V5ID0ga2V5O1xuICAgICAgICAgICAgaWYgKGFsdE5hbWVzICYmIGtleSBpbiBhbHROYW1lcyAmJiAhKHNyY0tleSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsdEtleSBvZiBhbHROYW1lc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHRLZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0tleSA9IGFsdEtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBudiA9IGZvcm1hdFtrZXldKHZhbHVlW3NyY0tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChudiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gbnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSA/IGVycm9yLm1lc3NhZ2UgOiBcIm5vdC1hbi1lcnJvclwiO1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgdmFsdWUgZm9yIHZhbHVlLiR7a2V5fSAoJHttZXNzYWdlfSlgLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCb29sZWFuKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBib29sZWFuOyAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRhKHZhbHVlKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpLCBcImludmFsaWQgZGF0YVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0SGFzaCh2YWx1ZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlLCAzMiksIFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVaW50MjU2KHZhbHVlKSB7XG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuICAgIH1cbiAgICByZXR1cm4gemVyb1BhZFZhbHVlKHZhbHVlLCAzMik7XG59XG5jb25zdCBfZm9ybWF0TG9nID0gb2JqZWN0KHtcbiAgICBhZGRyZXNzOiBnZXRBZGRyZXNzLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICByZW1vdmVkOiBhbGxvd051bGwoZm9ybWF0Qm9vbGVhbiwgZmFsc2UpLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgdHJhbnNhY3Rpb25JbmRleDogZ2V0TnVtYmVyLFxufSwge1xuICAgIGluZGV4OiBbXCJsb2dJbmRleFwiXVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TG9nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRMb2codmFsdWUpO1xufVxuY29uc3QgX2Zvcm1hdEJsb2NrID0gb2JqZWN0KHtcbiAgICBoYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCksXG4gICAgcGFyZW50SGFzaDogZm9ybWF0SGFzaCxcbiAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICBudW1iZXI6IGdldE51bWJlcixcbiAgICB0aW1lc3RhbXA6IGdldE51bWJlcixcbiAgICBub25jZTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxuICAgIGRpZmZpY3VsdHk6IGdldEJpZ0ludCxcbiAgICBnYXNMaW1pdDogZ2V0QmlnSW50LFxuICAgIGdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBzdGF0ZVJvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICByZWNlaXB0c1Jvb3Q6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICBibG9iR2FzVXNlZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXG4gICAgZXhjZXNzQmxvYkdhczogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXG4gICAgbWluZXI6IGFsbG93TnVsbChnZXRBZGRyZXNzKSxcbiAgICBwcmV2UmFuZGFvOiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgZXh0cmFEYXRhOiBmb3JtYXREYXRhLFxuICAgIGJhc2VGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpXG59LCB7XG4gICAgcHJldlJhbmRhbzogW1wibWl4SGFzaFwiXVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QmxvY2sodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBfZm9ybWF0QmxvY2sodmFsdWUpO1xuICAgIHJlc3VsdC50cmFuc2FjdGlvbnMgPSB2YWx1ZS50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh0eCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IF9mb3JtYXRSZWNlaXB0TG9nID0gb2JqZWN0KHtcbiAgICB0cmFuc2FjdGlvbkluZGV4OiBnZXROdW1iZXIsXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgYWRkcmVzczogZ2V0QWRkcmVzcyxcbiAgICB0b3BpY3M6IGFycmF5T2YoZm9ybWF0SGFzaCksXG4gICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbn0sIHtcbiAgICBpbmRleDogW1wibG9nSW5kZXhcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJlY2VpcHRMb2codmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFJlY2VpcHRMb2codmFsdWUpO1xufVxuY29uc3QgX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCA9IG9iamVjdCh7XG4gICAgdG86IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICBmcm9tOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgY29udHJhY3RBZGRyZXNzOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICByb290OiBhbGxvd051bGwoaGV4bGlmeSksXG4gICAgZ2FzVXNlZDogZ2V0QmlnSW50LFxuICAgIGJsb2JHYXNVc2VkOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICBsb2dzQmxvb206IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG4gICAgaGFzaDogZm9ybWF0SGFzaCxcbiAgICBsb2dzOiBhcnJheU9mKGZvcm1hdFJlY2VpcHRMb2cpLFxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXG4gICAgLy9jb25maXJtYXRpb25zOiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICBjdW11bGF0aXZlR2FzVXNlZDogZ2V0QmlnSW50LFxuICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICBibG9iR2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgIHN0YXR1czogYWxsb3dOdWxsKGdldE51bWJlciksXG4gICAgdHlwZTogYWxsb3dOdWxsKGdldE51bWJlciwgMClcbn0sIHtcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogW1wiZ2FzUHJpY2VcIl0sXG4gICAgaGFzaDogW1widHJhbnNhY3Rpb25IYXNoXCJdLFxuICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdLFxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodmFsdWUpIHtcbiAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXG4gICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3NcbiAgICBpZiAodmFsdWUudG8gJiYgZ2V0QmlnSW50KHZhbHVlLnRvKSA9PT0gQk5fMCkge1xuICAgICAgICB2YWx1ZS50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG9iamVjdCh7XG4gICAgICAgIGhhc2g6IGZvcm1hdEhhc2gsXG4gICAgICAgIC8vIFNvbWUgbm9kZXMgZG8gbm90IHJldHVybiB0aGlzLCB1c3VhbGx5IHRlc3Qgbm9kZXMgKGxpa2UgR2FuYWNoZSlcbiAgICAgICAgaW5kZXg6IGFsbG93TnVsbChnZXROdW1iZXIsIHVuZGVmaW5lZCksXG4gICAgICAgIHR5cGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4XCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGFsbG93TnVsbChhY2Nlc3NMaXN0aWZ5LCBudWxsKSxcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlczogYWxsb3dOdWxsKGFycmF5T2YoZm9ybWF0SGFzaCwgdHJ1ZSksIG51bGwpLFxuICAgICAgICBhdXRob3JpemF0aW9uTGlzdDogYWxsb3dOdWxsKGFycmF5T2YoKHYpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyh2LmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGdldEJpZ0ludCh2LmNoYWluSWQpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBnZXRCaWdJbnQodi5ub25jZSksXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbSh2LnNpZ25hdHVyZSA/IHYuc2lnbmF0dXJlIDogdilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIGZhbHNlKSwgbnVsbCksXG4gICAgICAgIGJsb2NrSGFzaDogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgICAgICBibG9ja051bWJlcjogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgICAgICBmcm9tOiBnZXRBZGRyZXNzLFxuICAgICAgICAvLyBlaXRoZXIgKGdhc1ByaWNlKSBvciAobWF4UHJpb3JpdHlGZWVQZXJHYXMgKyBtYXhGZWVQZXJHYXMpIG11c3QgYmUgc2V0XG4gICAgICAgIGdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICAgICAgZ2FzTGltaXQ6IGdldEJpZ0ludCxcbiAgICAgICAgdG86IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICAgICAgdmFsdWU6IGdldEJpZ0ludCxcbiAgICAgICAgbm9uY2U6IGdldE51bWJlcixcbiAgICAgICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICAgICAgY3JlYXRlczogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgICAgICBjaGFpbklkOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKVxuICAgIH0sIHtcbiAgICAgICAgZGF0YTogW1wiaW5wdXRcIl0sXG4gICAgICAgIGdhc0xpbWl0OiBbXCJnYXNcIl0sXG4gICAgICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdXG4gICAgfSkodmFsdWUpO1xuICAgIC8vIElmIHRvIGFuZCBjcmVhdGVzIGFyZSBlbXB0eSwgcG9wdWxhdGUgdGhlIGNyZWF0ZXMgZnJvbSB0aGUgdmFsdWVcbiAgICBpZiAocmVzdWx0LnRvID09IG51bGwgJiYgcmVzdWx0LmNyZWF0ZXMgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuY3JlYXRlcyA9IGdldENyZWF0ZUFkZHJlc3MocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQFRPRE86IENoZWNrIGZlZSBkYXRhXG4gICAgLy8gQWRkIGFuIGFjY2VzcyBsaXN0IHRvIHN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlc1xuICAgIGlmICgodmFsdWUudHlwZSA9PT0gMSB8fCB2YWx1ZS50eXBlID09PSAyKSAmJiB2YWx1ZS5hY2Nlc3NMaXN0ID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgc2lnbmF0dXJlXG4gICAgaWYgKHZhbHVlLnNpZ25hdHVyZSkge1xuICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odmFsdWUuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNvbWUgYmFja2VuZHMgb21pdCBDaGFpbklkIG9uIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIGJ1dCB3ZSBjYW4gY29tcHV0ZSBpdFxuICAgIGlmIChyZXN1bHQuY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSByZXN1bHQuc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChjaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAVE9ETzogY2hlY2sgY2hhaW5JRFxuICAgIC8qXG4gICAgaWYgKHZhbHVlLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICBsZXQgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG5cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUubmV0d29ya0lkO1xuXG4gICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxuICAgICAgICBpZiAoY2hhaW5JZCA9PSBudWxsICYmIHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSB2YWx1ZS5jaGFpbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIgJiYgcmVzdWx0LnYgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IChyZXN1bHQudiAtIDM1KSAvIDI7XG4gICAgICAgICAgICBpZiAoY2hhaW5JZCA8IDApIHsgY2hhaW5JZCA9IDA7IH1cbiAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHsgY2hhaW5JZCA9IDA7IH1cblxuICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgfVxuICAgICovXG4gICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG4gICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgZ2V0QmlnSW50KHJlc3VsdC5ibG9ja0hhc2gpID09PSBCTl8wKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/format.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/index.js":
/*!****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProvider: function() { return /* reexport safe */ _abstract_provider_js__WEBPACK_IMPORTED_MODULE_0__.AbstractProvider; },\n/* harmony export */   AbstractSigner: function() { return /* reexport safe */ _abstract_signer_js__WEBPACK_IMPORTED_MODULE_1__.AbstractSigner; },\n/* harmony export */   AlchemyProvider: function() { return /* reexport safe */ _provider_alchemy_js__WEBPACK_IMPORTED_MODULE_12__.AlchemyProvider; },\n/* harmony export */   AnkrProvider: function() { return /* reexport safe */ _provider_ankr_js__WEBPACK_IMPORTED_MODULE_14__.AnkrProvider; },\n/* harmony export */   Block: function() { return /* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.Block; },\n/* harmony export */   BlockscoutProvider: function() { return /* reexport safe */ _provider_blockscout_js__WEBPACK_IMPORTED_MODULE_13__.BlockscoutProvider; },\n/* harmony export */   BrowserProvider: function() { return /* reexport safe */ _provider_browser_js__WEBPACK_IMPORTED_MODULE_11__.BrowserProvider; },\n/* harmony export */   ChainstackProvider: function() { return /* reexport safe */ _provider_chainstack_js__WEBPACK_IMPORTED_MODULE_16__.ChainstackProvider; },\n/* harmony export */   CloudflareProvider: function() { return /* reexport safe */ _provider_cloudflare_js__WEBPACK_IMPORTED_MODULE_15__.CloudflareProvider; },\n/* harmony export */   EnsPlugin: function() { return /* reexport safe */ _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__.EnsPlugin; },\n/* harmony export */   EnsResolver: function() { return /* reexport safe */ _ens_resolver_js__WEBPACK_IMPORTED_MODULE_4__.EnsResolver; },\n/* harmony export */   EtherscanPlugin: function() { return /* reexport safe */ _provider_etherscan_js__WEBPACK_IMPORTED_MODULE_17__.EtherscanPlugin; },\n/* harmony export */   EtherscanProvider: function() { return /* reexport safe */ _provider_etherscan_js__WEBPACK_IMPORTED_MODULE_17__.EtherscanProvider; },\n/* harmony export */   FallbackProvider: function() { return /* reexport safe */ _provider_fallback_js__WEBPACK_IMPORTED_MODULE_9__.FallbackProvider; },\n/* harmony export */   FeeData: function() { return /* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.FeeData; },\n/* harmony export */   FeeDataNetworkPlugin: function() { return /* reexport safe */ _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__.FeeDataNetworkPlugin; },\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: function() { return /* reexport safe */ _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__.FetchUrlFeeDataNetworkPlugin; },\n/* harmony export */   GasCostPlugin: function() { return /* reexport safe */ _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__.GasCostPlugin; },\n/* harmony export */   InfuraProvider: function() { return /* reexport safe */ _provider_infura_js__WEBPACK_IMPORTED_MODULE_18__.InfuraProvider; },\n/* harmony export */   InfuraWebSocketProvider: function() { return /* reexport safe */ _provider_infura_js__WEBPACK_IMPORTED_MODULE_18__.InfuraWebSocketProvider; },\n/* harmony export */   IpcSocketProvider: function() { return /* reexport safe */ _provider_ipcsocket_js__WEBPACK_IMPORTED_MODULE_21__.IpcSocketProvider; },\n/* harmony export */   JsonRpcApiProvider: function() { return /* reexport safe */ _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_10__.JsonRpcApiProvider; },\n/* harmony export */   JsonRpcProvider: function() { return /* reexport safe */ _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_10__.JsonRpcProvider; },\n/* harmony export */   JsonRpcSigner: function() { return /* reexport safe */ _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_10__.JsonRpcSigner; },\n/* harmony export */   Log: function() { return /* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.Log; },\n/* harmony export */   MulticoinProviderPlugin: function() { return /* reexport safe */ _ens_resolver_js__WEBPACK_IMPORTED_MODULE_4__.MulticoinProviderPlugin; },\n/* harmony export */   Network: function() { return /* reexport safe */ _network_js__WEBPACK_IMPORTED_MODULE_5__.Network; },\n/* harmony export */   NetworkPlugin: function() { return /* reexport safe */ _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__.NetworkPlugin; },\n/* harmony export */   NonceManager: function() { return /* reexport safe */ _signer_noncemanager_js__WEBPACK_IMPORTED_MODULE_6__.NonceManager; },\n/* harmony export */   PocketProvider: function() { return /* reexport safe */ _provider_pocket_js__WEBPACK_IMPORTED_MODULE_19__.PocketProvider; },\n/* harmony export */   QuickNodeProvider: function() { return /* reexport safe */ _provider_quicknode_js__WEBPACK_IMPORTED_MODULE_20__.QuickNodeProvider; },\n/* harmony export */   SocketBlockSubscriber: function() { return /* reexport safe */ _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__.SocketBlockSubscriber; },\n/* harmony export */   SocketEventSubscriber: function() { return /* reexport safe */ _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__.SocketEventSubscriber; },\n/* harmony export */   SocketPendingSubscriber: function() { return /* reexport safe */ _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__.SocketPendingSubscriber; },\n/* harmony export */   SocketProvider: function() { return /* reexport safe */ _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__.SocketProvider; },\n/* harmony export */   SocketSubscriber: function() { return /* reexport safe */ _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__.SocketSubscriber; },\n/* harmony export */   TransactionReceipt: function() { return /* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.TransactionReceipt; },\n/* harmony export */   TransactionResponse: function() { return /* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.TransactionResponse; },\n/* harmony export */   UnmanagedSubscriber: function() { return /* reexport safe */ _abstract_provider_js__WEBPACK_IMPORTED_MODULE_0__.UnmanagedSubscriber; },\n/* harmony export */   VoidSigner: function() { return /* reexport safe */ _abstract_signer_js__WEBPACK_IMPORTED_MODULE_1__.VoidSigner; },\n/* harmony export */   WebSocketProvider: function() { return /* reexport safe */ _provider_websocket_js__WEBPACK_IMPORTED_MODULE_23__.WebSocketProvider; },\n/* harmony export */   copyRequest: function() { return /* reexport safe */ _provider_js__WEBPACK_IMPORTED_MODULE_8__.copyRequest; },\n/* harmony export */   getDefaultProvider: function() { return /* reexport safe */ _default_provider_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultProvider; },\n/* harmony export */   showThrottleMessage: function() { return /* reexport safe */ _community_js__WEBPACK_IMPORTED_MODULE_2__.showThrottleMessage; }\n/* harmony export */ });\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-provider.js */ \"../common/node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-signer.js */ \"../common/node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./community.js */ \"../common/node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _default_provider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./default-provider.js */ \"../common/node_modules/ethers/lib.esm/providers/default-provider.js\");\n/* harmony import */ var _ens_resolver_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ens-resolver.js */ \"../common/node_modules/ethers/lib.esm/providers/ens-resolver.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _signer_noncemanager_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./signer-noncemanager.js */ \"../common/node_modules/ethers/lib.esm/providers/signer-noncemanager.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins-network.js */ \"../common/node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./provider.js */ \"../common/node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _provider_fallback_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./provider-fallback.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-fallback.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var _provider_browser_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./provider-browser.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var _provider_alchemy_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./provider-alchemy.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-alchemy.js\");\n/* harmony import */ var _provider_blockscout_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./provider-blockscout.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-blockscout.js\");\n/* harmony import */ var _provider_ankr_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./provider-ankr.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-ankr.js\");\n/* harmony import */ var _provider_cloudflare_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./provider-cloudflare.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-cloudflare.js\");\n/* harmony import */ var _provider_chainstack_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./provider-chainstack.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-chainstack.js\");\n/* harmony import */ var _provider_etherscan_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./provider-etherscan.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-etherscan.js\");\n/* harmony import */ var _provider_infura_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./provider-infura.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-infura.js\");\n/* harmony import */ var _provider_pocket_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./provider-pocket.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-pocket.js\");\n/* harmony import */ var _provider_quicknode_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./provider-quicknode.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-quicknode.js\");\n/* harmony import */ var _provider_ipcsocket_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./provider-ipcsocket.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js\");\n/* harmony import */ var _provider_socket_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./provider-socket.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-socket.js\");\n/* harmony import */ var _provider_websocket_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./provider-websocket.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-websocket.js\");\n/**\n *  A **Provider** provides a connection to the blockchain, whch can be\n *  used to query its current state, simulate execution and send transactions\n *  to update the state.\n *\n *  It is one of the most fundamental components of interacting with a\n *  blockchain application, and there are many ways to connect, such as over\n *  HTTP, WebSockets or injected providers such as [MetaMask](link-metamask).\n *\n *  @_section: api/providers:Providers  [about-providers]\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n /*-browser*/\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytFO0FBQ1o7QUFDZDtBQUNNO0FBQ2M7QUFDbEM7QUFDaUI7QUFDNEU7QUFHNUc7QUFDa0M7QUFDaUM7QUFDbkM7QUFDQTtBQUNNO0FBQ1o7QUFDWTtBQUNBO0FBQ2U7QUFDRTtBQUN6QjtBQUNNO0FBQ0EsQ0FBQztBQUNoQztBQUN5QjtBQUNNO0FBQ21FO0FBQy9IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9pbmRleC5qcz9jMWE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEEgKipQcm92aWRlcioqIHByb3ZpZGVzIGEgY29ubmVjdGlvbiB0byB0aGUgYmxvY2tjaGFpbiwgd2hjaCBjYW4gYmVcbiAqICB1c2VkIHRvIHF1ZXJ5IGl0cyBjdXJyZW50IHN0YXRlLCBzaW11bGF0ZSBleGVjdXRpb24gYW5kIHNlbmQgdHJhbnNhY3Rpb25zXG4gKiAgdG8gdXBkYXRlIHRoZSBzdGF0ZS5cbiAqXG4gKiAgSXQgaXMgb25lIG9mIHRoZSBtb3N0IGZ1bmRhbWVudGFsIGNvbXBvbmVudHMgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhXG4gKiAgYmxvY2tjaGFpbiBhcHBsaWNhdGlvbiwgYW5kIHRoZXJlIGFyZSBtYW55IHdheXMgdG8gY29ubmVjdCwgc3VjaCBhcyBvdmVyXG4gKiAgSFRUUCwgV2ViU29ja2V0cyBvciBpbmplY3RlZCBwcm92aWRlcnMgc3VjaCBhcyBbTWV0YU1hc2tdKGxpbmstbWV0YW1hc2spLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnM6UHJvdmlkZXJzICBbYWJvdXQtcHJvdmlkZXJzXVxuICovXG5leHBvcnQgeyBBYnN0cmFjdFByb3ZpZGVyLCBVbm1hbmFnZWRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIjtcbmV4cG9ydCB7IEFic3RyYWN0U2lnbmVyLCBWb2lkU2lnbmVyLCB9IGZyb20gXCIuL2Fic3RyYWN0LXNpZ25lci5qc1wiO1xuZXhwb3J0IHsgc2hvd1Rocm90dGxlTWVzc2FnZSB9IGZyb20gXCIuL2NvbW11bml0eS5qc1wiO1xuZXhwb3J0IHsgZ2V0RGVmYXVsdFByb3ZpZGVyIH0gZnJvbSBcIi4vZGVmYXVsdC1wcm92aWRlci5qc1wiO1xuZXhwb3J0IHsgRW5zUmVzb2x2ZXIsIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIH0gZnJvbSBcIi4vZW5zLXJlc29sdmVyLmpzXCI7XG5leHBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xuZXhwb3J0IHsgTm9uY2VNYW5hZ2VyIH0gZnJvbSBcIi4vc2lnbmVyLW5vbmNlbWFuYWdlci5qc1wiO1xuZXhwb3J0IHsgTmV0d29ya1BsdWdpbiwgR2FzQ29zdFBsdWdpbiwgRW5zUGx1Z2luLCBGZWVEYXRhTmV0d29ya1BsdWdpbiwgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiwgfSBmcm9tIFwiLi9wbHVnaW5zLW5ldHdvcmsuanNcIjtcbmV4cG9ydCB7IEJsb2NrLCBGZWVEYXRhLCBMb2csIFRyYW5zYWN0aW9uUmVjZWlwdCwgVHJhbnNhY3Rpb25SZXNwb25zZSwgY29weVJlcXVlc3QsXG4vL3Jlc29sdmVUcmFuc2FjdGlvblJlcXVlc3QsXG4gfSBmcm9tIFwiLi9wcm92aWRlci5qc1wiO1xuZXhwb3J0IHsgRmFsbGJhY2tQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWZhbGxiYWNrLmpzXCI7XG5leHBvcnQgeyBKc29uUnBjQXBpUHJvdmlkZXIsIEpzb25ScGNQcm92aWRlciwgSnNvblJwY1NpZ25lciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcbmV4cG9ydCB7IEJyb3dzZXJQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWJyb3dzZXIuanNcIjtcbmV4cG9ydCB7IEFsY2hlbXlQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWFsY2hlbXkuanNcIjtcbmV4cG9ydCB7IEJsb2Nrc2NvdXRQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWJsb2Nrc2NvdXQuanNcIjtcbmV4cG9ydCB7IEFua3JQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWFua3IuanNcIjtcbmV4cG9ydCB7IENsb3VkZmxhcmVQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWNsb3VkZmxhcmUuanNcIjtcbmV4cG9ydCB7IENoYWluc3RhY2tQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWNoYWluc3RhY2suanNcIjtcbmV4cG9ydCB7IEV0aGVyc2NhblByb3ZpZGVyLCBFdGhlcnNjYW5QbHVnaW4gfSBmcm9tIFwiLi9wcm92aWRlci1ldGhlcnNjYW4uanNcIjtcbmV4cG9ydCB7IEluZnVyYVByb3ZpZGVyLCBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWluZnVyYS5qc1wiO1xuZXhwb3J0IHsgUG9ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1wb2NrZXQuanNcIjtcbmV4cG9ydCB7IFF1aWNrTm9kZVByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItcXVpY2tub2RlLmpzXCI7XG5pbXBvcnQgeyBJcGNTb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWlwY3NvY2tldC5qc1wiOyAvKi1icm93c2VyKi9cbmV4cG9ydCB7IElwY1NvY2tldFByb3ZpZGVyIH07XG5leHBvcnQgeyBTb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLXNvY2tldC5qc1wiO1xuZXhwb3J0IHsgV2ViU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci13ZWJzb2NrZXQuanNcIjtcbmV4cG9ydCB7IFNvY2tldFN1YnNjcmliZXIsIFNvY2tldEJsb2NrU3Vic2NyaWJlciwgU29ja2V0UGVuZGluZ1N1YnNjcmliZXIsIFNvY2tldEV2ZW50U3Vic2NyaWJlciB9IGZyb20gXCIuL3Byb3ZpZGVyLXNvY2tldC5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/network.js":
/*!******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/network.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: function() { return /* binding */ Network; }\n/* harmony export */ });\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins-network.js */ \"../common/node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */\n\n\n\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/\nconst Networks = new Map();\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */\nclass Network {\n    #name;\n    #chainId;\n    #plugins;\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */\n    constructor(name, chainId) {\n        this.#name = name;\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(chainId);\n        this.#plugins = new Map();\n    }\n    /**\n     *  Returns a JSON-compatible representation of a Network.\n     */\n    toJSON() {\n        return { name: this.name, chainId: String(this.chainId) };\n    }\n    /**\n     *  The network common name.\n     *\n     *  This is the canonical name, as networks migh have multiple\n     *  names.\n     */\n    get name() { return this.#name; }\n    set name(value) { this.#name = value; }\n    /**\n     *  The network chain ID.\n     */\n    get chainId() { return this.#chainId; }\n    set chainId(value) { this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"chainId\"); }\n    /**\n     *  Returns true if %%other%% matches this network. Any chain ID\n     *  must match, and if no chain ID is present, the name must match.\n     *\n     *  This method does not currently check for additional properties,\n     *  such as ENS address or plug-in compatibility.\n     */\n    matches(other) {\n        if (other == null) {\n            return false;\n        }\n        if (typeof (other) === \"string\") {\n            try {\n                return (this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other));\n            }\n            catch (error) { }\n            return (this.name === other);\n        }\n        if (typeof (other) === \"number\" || typeof (other) === \"bigint\") {\n            try {\n                return (this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other));\n            }\n            catch (error) { }\n            return false;\n        }\n        if (typeof (other) === \"object\") {\n            if (other.chainId != null) {\n                try {\n                    return (this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other.chainId));\n                }\n                catch (error) { }\n                return false;\n            }\n            if (other.name != null) {\n                return (this.name === other.name);\n            }\n            return false;\n        }\n        return false;\n    }\n    /**\n     *  Returns the list of plugins currently attached to this Network.\n     */\n    get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new %%plugin%% to this Network. The network name\n     *  must be unique, excluding any fragment.\n     */\n    attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.clone());\n        return this;\n    }\n    /**\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\n     *  with fragments will not be returned unless %%name%% includes\n     *  a fragment.\n     */\n    getPlugin(name) {\n        return (this.#plugins.get(name)) || null;\n    }\n    /**\n     *  Gets a list of all plugins that match %%name%%, with otr without\n     *  a fragment.\n     */\n    getPlugins(basename) {\n        return (this.plugins.filter((p) => (p.name.split(\"#\")[0] === basename)));\n    }\n    /**\n     *  Create a copy of this Network.\n     */\n    clone() {\n        const clone = new Network(this.name, this.chainId);\n        this.plugins.forEach((plugin) => {\n            clone.attachPlugin(plugin.clone());\n        });\n        return clone;\n    }\n    /**\n     *  Compute the intrinsic gas required for a transaction.\n     *\n     *  A GasCostPlugin can be attached to override the default\n     *  values.\n     */\n    computeIntrinsicGas(tx) {\n        const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || (new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin());\n        let gas = costs.txBase;\n        if (tx.to == null) {\n            gas += costs.txCreate;\n        }\n        if (tx.data) {\n            for (let i = 2; i < tx.data.length; i += 2) {\n                if (tx.data.substring(i, i + 2) === \"00\") {\n                    gas += costs.txDataZero;\n                }\n                else {\n                    gas += costs.txDataNonzero;\n                }\n            }\n        }\n        if (tx.accessList) {\n            const accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.accessListify)(tx.accessList);\n            for (const addr in accessList) {\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n            }\n        }\n        return gas;\n    }\n    /**\n     *  Returns a new Network for the %%network%% name or chainId.\n     */\n    static from(network) {\n        injectCommonNetworks();\n        // Default network\n        if (network == null) {\n            return Network.from(\"mainnet\");\n        }\n        // Canonical name or chain ID\n        if (typeof (network) === \"number\") {\n            network = BigInt(network);\n        }\n        if (typeof (network) === \"string\" || typeof (network) === \"bigint\") {\n            const networkFunc = Networks.get(network);\n            if (networkFunc) {\n                return networkFunc();\n            }\n            if (typeof (network) === \"bigint\") {\n                return new Network(\"unknown\", network);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unknown network\", \"network\", network);\n        }\n        // Clonable with network-like abilities\n        if (typeof (network.clone) === \"function\") {\n            const clone = network.clone();\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n            //}\n            return clone;\n        }\n        // Networkish\n        if (typeof (network) === \"object\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (network.name) === \"string\" && typeof (network.chainId) === \"number\", \"invalid network object name or chainId\", \"network\", network);\n            const custom = new Network((network.name), (network.chainId));\n            if (network.ensAddress || network.ensNetwork != null) {\n                custom.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(network.ensAddress, network.ensNetwork));\n            }\n            //if ((<any>network).layerOneConnection) {\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n            //}\n            return custom;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid network\", \"network\", network);\n    }\n    /**\n     *  Register %%nameOrChainId%% with a function which returns\n     *  an instance of a Network representing that chain.\n     */\n    static register(nameOrChainId, networkFunc) {\n        if (typeof (nameOrChainId) === \"number\") {\n            nameOrChainId = BigInt(nameOrChainId);\n        }\n        const existing = Networks.get(nameOrChainId);\n        if (existing) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, \"nameOrChainId\", nameOrChainId);\n        }\n        Networks.set(nameOrChainId, networkFunc);\n    }\n}\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value, decimals) {\n    const value = String(_value);\n    if (!value.match(/^[0-9.]+$/)) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Break into [ whole, fraction ]\n    const comps = value.split(\".\");\n    if (comps.length === 1) {\n        comps.push(\"\");\n    }\n    // More than 1 decimal point or too many fractional positions\n    if (comps.length !== 2) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Pad the fraction to 9 decimalplaces\n    while (comps[1].length < decimals) {\n        comps[1] += \"0\";\n    }\n    // Too many decimals and some non-zero ending, take the ceiling\n    if (comps[1].length > 9) {\n        let frac = BigInt(comps[1].substring(0, 9));\n        if (!comps[1].substring(9).match(/^0+$/)) {\n            frac++;\n        }\n        comps[1] = frac.toString();\n    }\n    return BigInt(comps[0] + comps[1]);\n}\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url) {\n    return new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {\n        // Prevent Cloudflare from blocking our request in node.js\n        request.setHeader(\"User-Agent\", \"ethers\");\n        let response;\n        try {\n            const [_response, _feeData] = await Promise.all([\n                request.send(), fetchFeeData()\n            ]);\n            response = _response;\n            const payload = response.bodyJson.standard;\n            const feeData = {\n                gasPrice: _feeData.gasPrice,\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9),\n            };\n            return feeData;\n        }\n        catch (error) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, \"SERVER_ERROR\", { request, response, error });\n        }\n    });\n}\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks() {\n    if (injected) {\n        return;\n    }\n    injected = true;\n    /// Register popular Ethereum networks\n    function registerEth(name, chainId, options) {\n        const func = function () {\n            const network = new Network(name, chainId);\n            // We use 0 to disable ENS\n            if (options.ensNetwork != null) {\n                network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(null, options.ensNetwork));\n            }\n            network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin());\n            (options.plugins || []).forEach((plugin) => {\n                network.attachPlugin(plugin);\n            });\n            return network;\n        };\n        // Register the network by name and chain ID\n        Network.register(name, func);\n        Network.register(chainId, func);\n        if (options.altNames) {\n            options.altNames.forEach((name) => {\n                Network.register(name, func);\n            });\n        }\n    }\n    registerEth(\"mainnet\", 1, { ensNetwork: 1, altNames: [\"homestead\"] });\n    registerEth(\"ropsten\", 3, { ensNetwork: 3 });\n    registerEth(\"rinkeby\", 4, { ensNetwork: 4 });\n    registerEth(\"goerli\", 5, { ensNetwork: 5 });\n    registerEth(\"kovan\", 42, { ensNetwork: 42 });\n    registerEth(\"sepolia\", 11155111, { ensNetwork: 11155111 });\n    registerEth(\"holesky\", 17000, { ensNetwork: 17000 });\n    registerEth(\"classic\", 61, {});\n    registerEth(\"classicKotti\", 6, {});\n    registerEth(\"arbitrum\", 42161, {\n        ensNetwork: 1,\n    });\n    registerEth(\"arbitrum-goerli\", 421613, {});\n    registerEth(\"arbitrum-sepolia\", 421614, {});\n    registerEth(\"base\", 8453, { ensNetwork: 1 });\n    registerEth(\"base-goerli\", 84531, {});\n    registerEth(\"base-sepolia\", 84532, {});\n    registerEth(\"bnb\", 56, { ensNetwork: 1 });\n    registerEth(\"bnbt\", 97, {});\n    registerEth(\"linea\", 59144, { ensNetwork: 1 });\n    registerEth(\"linea-goerli\", 59140, {});\n    registerEth(\"linea-sepolia\", 59141, {});\n    registerEth(\"matic\", 137, {\n        ensNetwork: 1,\n        plugins: [\n            getGasStationPlugin(\"https:/\\/gasstation.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"matic-amoy\", 80002, {});\n    registerEth(\"matic-mumbai\", 80001, {\n        altNames: [\"maticMumbai\", \"maticmum\"],\n        plugins: [\n            getGasStationPlugin(\"https:/\\/gasstation-testnet.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"optimism\", 10, {\n        ensNetwork: 1,\n        plugins: []\n    });\n    registerEth(\"optimism-goerli\", 420, {});\n    registerEth(\"optimism-sepolia\", 11155420, {});\n    registerEth(\"xdai\", 100, { ensNetwork: 1 });\n}\n//# sourceMappingURL=network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvbmV0d29yay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dEO0FBQ2M7QUFDd0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIseUJBQXlCLGdCQUFnQiwwREFBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwREFBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMERBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLDhEQUFhO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvRUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQjtBQUNBO0FBQ0Esd0NBQXdDLDBEQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWMsbUNBQW1DLDhCQUE4QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZFQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBTSx1REFBdUQsNEJBQTRCLHNCQUFzQiwwQkFBMEI7QUFDcko7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwREFBUztBQUNsRDtBQUNBLHFDQUFxQyw4REFBYTtBQUNsRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdDQUFnQyx3Q0FBd0M7QUFDeEUsZ0NBQWdDLGVBQWU7QUFDL0MsZ0NBQWdDLGVBQWU7QUFDL0MsK0JBQStCLGVBQWU7QUFDOUMsK0JBQStCLGdCQUFnQjtBQUMvQyx1Q0FBdUMsc0JBQXNCO0FBQzdELG9DQUFvQyxtQkFBbUI7QUFDdkQsaUNBQWlDO0FBQ2pDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMLDZDQUE2QztBQUM3Qyw4Q0FBOEM7QUFDOUMsZ0NBQWdDLGVBQWU7QUFDL0Msd0NBQXdDO0FBQ3hDLHlDQUF5QztBQUN6Qyw2QkFBNkIsZUFBZTtBQUM1Qyw4QkFBOEI7QUFDOUIsa0NBQWtDLGVBQWU7QUFDakQseUNBQXlDO0FBQ3pDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQ0FBMEM7QUFDMUMsZ0RBQWdEO0FBQ2hELCtCQUErQixlQUFlO0FBQzlDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanM/MjNkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBICoqTmV0d29yayoqIGVuY2Fwc3VsYXRlcyB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvXG4gKiAgaW50ZXJhY3Qgd2l0aCBhIHNwZWNpZmljIGNoYWluLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnM6TmV0d29ya3MgIFtuZXR3b3Jrc11cbiAqL1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBFbnNQbHVnaW4sIEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4sIEdhc0Nvc3RQbHVnaW4gfSBmcm9tIFwiLi9wbHVnaW5zLW5ldHdvcmsuanNcIjtcbi8qICogKiAqXG4vLyBOZXR3b3JrcyB3aGljaCBvcGVyYXRpb24gYWdhaW5zdCBhbiBMMiBjYW4gdXNlIHRoaXMgcGx1Z2luIHRvXG4vLyBzcGVjaWZ5IGhvdyB0byBhY2Nlc3MgTDEsIGZvciB0aGUgcHVycG9zZSBvZiByZXNvbHZpbmcgRU5TLFxuLy8gZm9yIGV4YW1wbGUuXG5leHBvcnQgY2xhc3MgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgcmVhZG9ubHkgcHJvdmlkZXIhOiBQcm92aWRlcjtcbi8vIEBUT0RPOiBSZW5hbWUgdG8gQ2hhaW5BY2Nlc3MgYW5kIGFsbG93IGZvciBjb25uZWN0aW5nIHRvIGFueSBjaGFpblxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyOiBQcm92aWRlcikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5sYXllci1vbmUtY29ubmVjdGlvblwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllczxMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4+KHRoaXMsIHsgcHJvdmlkZXIgfSk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4odGhpcy5wcm92aWRlcik7XG4gICAgfVxufVxuKi9cbmNvbnN0IE5ldHdvcmtzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiAgQSAqKk5ldHdvcmsqKiBwcm92aWRlcyBhY2Nlc3MgdG8gYSBjaGFpbidzIHByb3BlcnRpZXMgYW5kIGFsbG93c1xuICogIGZvciBwbHVnLWlucyB0byBleHRlbmQgZnVuY3Rpb25hbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmsge1xuICAgICNuYW1lO1xuICAgICNjaGFpbklkO1xuICAgICNwbHVnaW5zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTmV0d29yayoqIGZvciAlJW5hbWUlJSBhbmQgJSVjaGFpbklkJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgY2hhaW5JZCkge1xuICAgICAgICB0aGlzLiNuYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludChjaGFpbklkKTtcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24gb2YgYSBOZXR3b3JrLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogdGhpcy5uYW1lLCBjaGFpbklkOiBTdHJpbmcodGhpcy5jaGFpbklkKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5ldHdvcmsgY29tbW9uIG5hbWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB0aGUgY2Fub25pY2FsIG5hbWUsIGFzIG5ldHdvcmtzIG1pZ2ggaGF2ZSBtdWx0aXBsZVxuICAgICAqICBuYW1lcy5cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuI25hbWU7IH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkgeyB0aGlzLiNuYW1lID0gdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5ldHdvcmsgY2hhaW4gSUQuXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludCh2YWx1ZSwgXCJjaGFpbklkXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgbWF0Y2hlcyB0aGlzIG5ldHdvcmsuIEFueSBjaGFpbiBJRFxuICAgICAqICBtdXN0IG1hdGNoLCBhbmQgaWYgbm8gY2hhaW4gSUQgaXMgcHJlc2VudCwgdGhlIG5hbWUgbXVzdCBtYXRjaC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjdXJyZW50bHkgY2hlY2sgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllcyxcbiAgICAgKiAgc3VjaCBhcyBFTlMgYWRkcmVzcyBvciBwbHVnLWluIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgbWF0Y2hlcyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIChvdGhlcikgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlci5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgcGx1Z2lucyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyAlJXBsdWdpbiUlIHRvIHRoaXMgTmV0d29yay4gVGhlIG5ldHdvcmsgbmFtZVxuICAgICAqICBtdXN0IGJlIHVuaXF1ZSwgZXhjbHVkaW5nIGFueSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNsb25lKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcGx1Z2luLCBpZiBhbnksIG1hdGNoaW5nICUlbmFtZSUlIGV4YWN0bHkuIFBsdWdpbnNcbiAgICAgKiAgd2l0aCBmcmFnbWVudHMgd2lsbCBub3QgYmUgcmV0dXJuZWQgdW5sZXNzICUlbmFtZSUlIGluY2x1ZGVzXG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldHMgYSBsaXN0IG9mIGFsbCBwbHVnaW5zIHRoYXQgbWF0Y2ggJSVuYW1lJSUsIHdpdGggb3RyIHdpdGhvdXRcbiAgICAgKiAgYSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW5zKGJhc2VuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wbHVnaW5zLmZpbHRlcigocCkgPT4gKHAubmFtZS5zcGxpdChcIiNcIilbMF0gPT09IGJhc2VuYW1lKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIE5ldHdvcmsuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IE5ldHdvcmsodGhpcy5uYW1lLCB0aGlzLmNoYWluSWQpO1xuICAgICAgICB0aGlzLnBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICBjbG9uZS5hdHRhY2hQbHVnaW4ocGx1Z2luLmNsb25lKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBBIEdhc0Nvc3RQbHVnaW4gY2FuIGJlIGF0dGFjaGVkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4gICAgICogIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb21wdXRlSW50cmluc2ljR2FzKHR4KSB7XG4gICAgICAgIGNvbnN0IGNvc3RzID0gdGhpcy5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5HYXNDb3N0XCIpIHx8IChuZXcgR2FzQ29zdFBsdWdpbigpKTtcbiAgICAgICAgbGV0IGdhcyA9IGNvc3RzLnR4QmFzZTtcbiAgICAgICAgaWYgKHR4LnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eENyZWF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZGF0YSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0eC5kYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEuc3Vic3RyaW5nKGksIGkgKyAyKSA9PT0gXCIwMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFaZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YU5vbnplcm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeSh0eC5hY2Nlc3NMaXN0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBpbiBhY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4QWNjZXNzTGlzdEFkZHJlc3MgKyBjb3N0cy50eEFjY2Vzc0xpc3RTdG9yYWdlS2V5ICogYWNjZXNzTGlzdFthZGRyXS5zdG9yYWdlS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgTmV0d29yayBmb3IgdGhlICUlbmV0d29yayUlIG5hbWUgb3IgY2hhaW5JZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShuZXR3b3JrKSB7XG4gICAgICAgIGluamVjdENvbW1vbk5ldHdvcmtzKCk7XG4gICAgICAgIC8vIERlZmF1bHQgbmV0d29ya1xuICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKFwibWFpbm5ldFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5vbmljYWwgbmFtZSBvciBjaGFpbiBJRFxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbmV0d29yayA9IEJpZ0ludChuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKG5ldHdvcmspID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrRnVuYyA9IE5ldHdvcmtzLmdldChuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrRnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrRnVuYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmsoXCJ1bmtub3duXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbG9uYWJsZSB3aXRoIG5ldHdvcmstbGlrZSBhYmlsaXRpZXNcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jbG9uZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBuZXR3b3JrLmNsb25lKCk7XG4gICAgICAgICAgICAvL2lmICh0eXBlb2YobmV0d29yay5uYW1lKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV0d29ya2lzaFxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuZXR3b3JrLm5hbWUpID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiAobmV0d29yay5jaGFpbklkKSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIG5ldHdvcmsgb2JqZWN0IG5hbWUgb3IgY2hhaW5JZFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICBjb25zdCBjdXN0b20gPSBuZXcgTmV0d29yaygobmV0d29yay5uYW1lKSwgKG5ldHdvcmsuY2hhaW5JZCkpO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBuZXR3b3JrLmVuc05ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbS5hdHRhY2hQbHVnaW4obmV3IEVuc1BsdWdpbihuZXR3b3JrLmVuc0FkZHJlc3MsIG5ldHdvcmsuZW5zTmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiAoKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4oKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSk7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlZ2lzdGVyICUlbmFtZU9yQ2hhaW5JZCUlIHdpdGggYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zXG4gICAgICogIGFuIGluc3RhbmNlIG9mIGEgTmV0d29yayByZXByZXNlbnRpbmcgdGhhdCBjaGFpbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXIobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAobmFtZU9yQ2hhaW5JZCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5hbWVPckNoYWluSWQgPSBCaWdJbnQobmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBOZXR3b3Jrcy5nZXQobmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBjb25mbGljdGluZyBuZXR3b3JrIGZvciAke0pTT04uc3RyaW5naWZ5KGV4aXN0aW5nLm5hbWUpfWAsIFwibmFtZU9yQ2hhaW5JZFwiLCBuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBOZXR3b3Jrcy5zZXQobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpO1xuICAgIH1cbn1cbi8vIFdlIGRvbid0IHdhbnQgdG8gYnJpbmcgaW4gZm9ybWF0VW5pdHMgYmVjYXVzZSBpdCBpcyBiYWNrZWQgYnlcbi8vIEZpeGVkTnVtYmVyIGFuZCB3ZSB3YW50IHRvIGtlZXAgTmV0d29ya3MgdGlueS4gVGhlIHZhbHVlc1xuLy8gaW5jbHVkZWQgYnkgdGhlIEdhcyBTdGF0aW9ucyBhcmUgYWxzbyBJRUVFIDc1NCB3aXRoIGxvdHMgb2Zcbi8vIHJvdW5kaW5nIGlzc3VlcyBhbmQgZXhjZWVkIHRoZSBzdHJpY3QgY2hlY2tzIGZvcm1hdFVuaXRzIGhhcy5cbmZ1bmN0aW9uIHBhcnNlVW5pdHMoX3ZhbHVlLCBkZWNpbWFscykge1xuICAgIGNvbnN0IHZhbHVlID0gU3RyaW5nKF92YWx1ZSk7XG4gICAgaWYgKCF2YWx1ZS5tYXRjaCgvXlswLTkuXSskLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xuICAgIH1cbiAgICAvLyBCcmVhayBpbnRvIFsgd2hvbGUsIGZyYWN0aW9uIF1cbiAgICBjb25zdCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbXBzLnB1c2goXCJcIik7XG4gICAgfVxuICAgIC8vIE1vcmUgdGhhbiAxIGRlY2ltYWwgcG9pbnQgb3IgdG9vIG1hbnkgZnJhY3Rpb25hbCBwb3NpdGlvbnNcbiAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gUGFkIHRoZSBmcmFjdGlvbiB0byA5IGRlY2ltYWxwbGFjZXNcbiAgICB3aGlsZSAoY29tcHNbMV0ubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgY29tcHNbMV0gKz0gXCIwXCI7XG4gICAgfVxuICAgIC8vIFRvbyBtYW55IGRlY2ltYWxzIGFuZCBzb21lIG5vbi16ZXJvIGVuZGluZywgdGFrZSB0aGUgY2VpbGluZ1xuICAgIGlmIChjb21wc1sxXS5sZW5ndGggPiA5KSB7XG4gICAgICAgIGxldCBmcmFjID0gQmlnSW50KGNvbXBzWzFdLnN1YnN0cmluZygwLCA5KSk7XG4gICAgICAgIGlmICghY29tcHNbMV0uc3Vic3RyaW5nKDkpLm1hdGNoKC9eMCskLykpIHtcbiAgICAgICAgICAgIGZyYWMrKztcbiAgICAgICAgfVxuICAgICAgICBjb21wc1sxXSA9IGZyYWMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChjb21wc1swXSArIGNvbXBzWzFdKTtcbn1cbi8vIFVzZWQgYnkgUG9seWdvbiB0byB1c2UgYSBnYXMgc3RhdGlvbiBmb3IgZmVlIGRhdGFcbmZ1bmN0aW9uIGdldEdhc1N0YXRpb25QbHVnaW4odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKHVybCwgYXN5bmMgKGZldGNoRmVlRGF0YSwgcHJvdmlkZXIsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgLy8gUHJldmVudCBDbG91ZGZsYXJlIGZyb20gYmxvY2tpbmcgb3VyIHJlcXVlc3QgaW4gbm9kZS5qc1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcIlVzZXItQWdlbnRcIiwgXCJldGhlcnNcIik7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtfcmVzcG9uc2UsIF9mZWVEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKSwgZmV0Y2hGZWVEYXRhKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBfcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzcG9uc2UuYm9keUpzb24uc3RhbmRhcmQ7XG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0ge1xuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBfZmVlRGF0YS5nYXNQcmljZSxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhGZWUsIDkpLFxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4UHJpb3JpdHlGZWUsIDkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmZWVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgd2l0aCBwb2x5Z29uIGdhcyBzdGF0aW9uICgke0pTT04uc3RyaW5naWZ5KHJlcXVlc3QudXJsKX0pYCwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIFNlZTogaHR0cHM6Ly9jaGFpbmxpc3Qub3JnXG5sZXQgaW5qZWN0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluamVjdENvbW1vbk5ldHdvcmtzKCkge1xuICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICAvLy8gUmVnaXN0ZXIgcG9wdWxhciBFdGhlcmV1bSBuZXR3b3Jrc1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXRoKG5hbWUsIGNoYWluSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXcgTmV0d29yayhuYW1lLCBjaGFpbklkKTtcbiAgICAgICAgICAgIC8vIFdlIHVzZSAwIHRvIGRpc2FibGUgRU5TXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbnNOZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihuZXcgRW5zUGx1Z2luKG51bGwsIG9wdGlvbnMuZW5zTmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IEdhc0Nvc3RQbHVnaW4oKSk7XG4gICAgICAgICAgICAob3B0aW9ucy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIG5ldHdvcmsgYnkgbmFtZSBhbmQgY2hhaW4gSURcbiAgICAgICAgTmV0d29yay5yZWdpc3RlcihuYW1lLCBmdW5jKTtcbiAgICAgICAgTmV0d29yay5yZWdpc3RlcihjaGFpbklkLCBmdW5jKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWx0TmFtZXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYWx0TmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlckV0aChcIm1haW5uZXRcIiwgMSwgeyBlbnNOZXR3b3JrOiAxLCBhbHROYW1lczogW1wiaG9tZXN0ZWFkXCJdIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwicm9wc3RlblwiLCAzLCB7IGVuc05ldHdvcms6IDMgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJyaW5rZWJ5XCIsIDQsIHsgZW5zTmV0d29yazogNCB9KTtcbiAgICByZWdpc3RlckV0aChcImdvZXJsaVwiLCA1LCB7IGVuc05ldHdvcms6IDUgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJrb3ZhblwiLCA0MiwgeyBlbnNOZXR3b3JrOiA0MiB9KTtcbiAgICByZWdpc3RlckV0aChcInNlcG9saWFcIiwgMTExNTUxMTEsIHsgZW5zTmV0d29yazogMTExNTUxMTEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJob2xlc2t5XCIsIDE3MDAwLCB7IGVuc05ldHdvcms6IDE3MDAwIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY1wiLCA2MSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY0tvdHRpXCIsIDYsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImFyYml0cnVtXCIsIDQyMTYxLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bS1nb2VybGlcIiwgNDIxNjEzLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bS1zZXBvbGlhXCIsIDQyMTYxNCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZVwiLCA4NDUzLCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJiYXNlLWdvZXJsaVwiLCA4NDUzMSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1zZXBvbGlhXCIsIDg0NTMyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJcIiwgNTYsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImJuYnRcIiwgOTcsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhXCIsIDU5MTQ0LCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1nb2VybGlcIiwgNTkxNDAsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhLXNlcG9saWFcIiwgNTkxNDEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljXCIsIDEzNywge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24ucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljLWFtb3lcIiwgODAwMDIsIHt9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljLW11bWJhaVwiLCA4MDAwMSwge1xuICAgICAgICBhbHROYW1lczogW1wibWF0aWNNdW1iYWlcIiwgXCJtYXRpY211bVwiXSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLXRlc3RuZXQucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtXCIsIDEwLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgICAgIHBsdWdpbnM6IFtdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbS1nb2VybGlcIiwgNDIwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbS1zZXBvbGlhXCIsIDExMTU1NDIwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJ4ZGFpXCIsIDEwMCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/network.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/plugins-network.js":
/*!**************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/plugins-network.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnsPlugin: function() { return /* binding */ EnsPlugin; },\n/* harmony export */   FeeDataNetworkPlugin: function() { return /* binding */ FeeDataNetworkPlugin; },\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: function() { return /* binding */ FetchUrlFeeDataNetworkPlugin; },\n/* harmony export */   GasCostPlugin: function() { return /* binding */ GasCostPlugin; },\n/* harmony export */   NetworkPlugin: function() { return /* binding */ NetworkPlugin; }\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/properties.js */ \"../common/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\n/**\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\n */\nclass NetworkPlugin {\n    /**\n     *  The name of the plugin.\n     *\n     *  It is recommended to use reverse-domain-notation, which permits\n     *  unique names with a known authority as well as hierarchal entries.\n     */\n    name;\n    /**\n     *  Creates a new **NetworkPlugin**.\n     */\n    constructor(name) {\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { name });\n    }\n    /**\n     *  Creates a copy of this plugin.\n     */\n    clone() {\n        return new NetworkPlugin(this.name);\n    }\n}\n/**\n *  A **GasCostPlugin** allows a network to provide alternative values when\n *  computing the intrinsic gas required for a transaction.\n */\nclass GasCostPlugin extends NetworkPlugin {\n    /**\n     *  The block number to treat these values as valid from.\n     *\n     *  This allows a hardfork to have updated values included as well as\n     *  mulutiple hardforks to be supported.\n     */\n    effectiveBlock;\n    /**\n     *  The transactions base fee.\n     */\n    txBase;\n    /**\n     *  The fee for creating a new account.\n     */\n    txCreate;\n    /**\n     *  The fee per zero-byte in the data.\n     */\n    txDataZero;\n    /**\n     *  The fee per non-zero-byte in the data.\n     */\n    txDataNonzero;\n    /**\n     *  The fee per storage key in the [[link-eip-2930]] access list.\n     */\n    txAccessListStorageKey;\n    /**\n     *  The fee per address in the [[link-eip-2930]] access list.\n     */\n    txAccessListAddress;\n    /**\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\n     *  latest block or another GasCostPlugin supercedes that block number,\n     *  with the associated %%costs%%.\n     */\n    constructor(effectiveBlock, costs) {\n        if (effectiveBlock == null) {\n            effectiveBlock = 0;\n        }\n        super(`org.ethers.network.plugins.GasCost#${(effectiveBlock || 0)}`);\n        const props = { effectiveBlock };\n        function set(name, nullish) {\n            let value = (costs || {})[name];\n            if (value == null) {\n                value = nullish;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof (value) === \"number\", `invalud value for ${name}`, \"costs\", costs);\n            props[name] = value;\n        }\n        set(\"txBase\", 21000);\n        set(\"txCreate\", 32000);\n        set(\"txDataZero\", 4);\n        set(\"txDataNonzero\", 16);\n        set(\"txAccessListStorageKey\", 1900);\n        set(\"txAccessListAddress\", 2400);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, props);\n    }\n    clone() {\n        return new GasCostPlugin(this.effectiveBlock, this);\n    }\n}\n/**\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\n *  Contract address and the target network to use when using that\n *  contract.\n *\n *  Various testnets have their own instance of the contract to use, but\n *  in general, the mainnet instance supports multi-chain addresses and\n *  should be used.\n */\nclass EnsPlugin extends NetworkPlugin {\n    /**\n     *  The ENS Registrty Contract address.\n     */\n    address;\n    /**\n     *  The chain ID that the ENS contract lives on.\n     */\n    targetNetwork;\n    /**\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\n     *  if unspecified.\n     */\n    constructor(address, targetNetwork) {\n        super(\"org.ethers.plugins.network.Ens\");\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            address: (address || EnsAddress),\n            targetNetwork: ((targetNetwork == null) ? 1 : targetNetwork)\n        });\n    }\n    clone() {\n        return new EnsPlugin(this.address, this.targetNetwork);\n    }\n}\n/**\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\n *  means to specify its fee data.\n *\n *  For example, a network which does not support [[link-eip-1559]] may\n *  choose to use a Gas Station site to approximate the gas price.\n */\nclass FeeDataNetworkPlugin extends NetworkPlugin {\n    #feeDataFunc;\n    /**\n     *  The fee data function provided to the constructor.\n     */\n    get feeDataFunc() {\n        return this.#feeDataFunc;\n    }\n    /**\n     *  Creates a new **FeeDataNetworkPlugin**.\n     */\n    constructor(feeDataFunc) {\n        super(\"org.ethers.plugins.network.FeeData\");\n        this.#feeDataFunc = feeDataFunc;\n    }\n    /**\n     *  Resolves to the fee data.\n     */\n    async getFeeData(provider) {\n        return await this.#feeDataFunc(provider);\n    }\n    clone() {\n        return new FeeDataNetworkPlugin(this.#feeDataFunc);\n    }\n}\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    #url;\n    #processFunc;\n    /**\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\n     */\n    get url() { return this.#url; }\n    /**\n     *  The callback to use when computing the FeeData.\n     */\n    get processFunc() { return this.#processFunc; }\n    /**\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\n     *  be used when computing the fee data for the network.\n     */\n    constructor(url, processFunc) {\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        this.#url = url;\n        this.#processFunc = processFunc;\n    }\n    // We are immutable, so we can serve as our own clone\n    clone() { return this; }\n}\n/*\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\n\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\n        super(\"org.ethers.network-plugins.custom-block\");\n        this.#blockFunc = blockFunc;\n        this.#blockWithTxsFunc = blockWithTxsFunc;\n    }\n\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\n        return await this.#blockFunc(provider, block);\n    }\n\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\n        return await this.#blockWithTxsFunc(provider, block);\n    }\n\n    clone(): CustomBlockNetworkPlugin {\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\n    }\n}\n*/\n//# sourceMappingURL=plugins-network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcGx1Z2lucy1uZXR3b3JrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDUDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQWdCLFNBQVMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNCQUFzQjtBQUMxRSx3QkFBd0I7QUFDeEI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYyxtREFBbUQsS0FBSztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBZ0I7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wbHVnaW5zLW5ldHdvcmsuanM/N2RhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBFbnNBZGRyZXNzID0gXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIjtcbi8qKlxuICogIEEgKipOZXR3b3JrUGx1Z2luKiogcHJvdmlkZXMgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IG9uIGEgW1tOZXR3b3JrXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqICBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgcmV2ZXJzZS1kb21haW4tbm90YXRpb24sIHdoaWNoIHBlcm1pdHNcbiAgICAgKiAgdW5pcXVlIG5hbWVzIHdpdGggYSBrbm93biBhdXRob3JpdHkgYXMgd2VsbCBhcyBoaWVyYXJjaGFsIGVudHJpZXMuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmtQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmV0d29ya1BsdWdpbih0aGlzLm5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipHYXNDb3N0UGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFsdGVybmF0aXZlIHZhbHVlcyB3aGVuXG4gKiAgY29tcHV0aW5nIHRoZSBpbnRyaW5zaWMgZ2FzIHJlcXVpcmVkIGZvciBhIHRyYW5zYWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgR2FzQ29zdFBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIHRvIHRyZWF0IHRoZXNlIHZhbHVlcyBhcyB2YWxpZCBmcm9tLlxuICAgICAqXG4gICAgICogIFRoaXMgYWxsb3dzIGEgaGFyZGZvcmsgdG8gaGF2ZSB1cGRhdGVkIHZhbHVlcyBpbmNsdWRlZCBhcyB3ZWxsIGFzXG4gICAgICogIG11bHV0aXBsZSBoYXJkZm9ya3MgdG8gYmUgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIGVmZmVjdGl2ZUJsb2NrO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb25zIGJhc2UgZmVlLlxuICAgICAqL1xuICAgIHR4QmFzZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBmb3IgY3JlYXRpbmcgYSBuZXcgYWNjb3VudC5cbiAgICAgKi9cbiAgICB0eENyZWF0ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgemVyby1ieXRlIGluIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHR4RGF0YVplcm87XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIG5vbi16ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgdHhEYXRhTm9uemVybztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgc3RvcmFnZSBrZXkgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxuICAgICAqL1xuICAgIHR4QWNjZXNzTGlzdFN0b3JhZ2VLZXk7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIGFkZHJlc3MgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxuICAgICAqL1xuICAgIHR4QWNjZXNzTGlzdEFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgR2FzQ29zdFBsdWdpbiBmcm9tICUlZWZmZWN0aXZlQmxvY2slJSB1bnRpbCB0aGVcbiAgICAgKiAgbGF0ZXN0IGJsb2NrIG9yIGFub3RoZXIgR2FzQ29zdFBsdWdpbiBzdXBlcmNlZGVzIHRoYXQgYmxvY2sgbnVtYmVyLFxuICAgICAqICB3aXRoIHRoZSBhc3NvY2lhdGVkICUlY29zdHMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlZmZlY3RpdmVCbG9jaywgY29zdHMpIHtcbiAgICAgICAgaWYgKGVmZmVjdGl2ZUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGVmZmVjdGl2ZUJsb2NrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihgb3JnLmV0aGVycy5uZXR3b3JrLnBsdWdpbnMuR2FzQ29zdCMkeyhlZmZlY3RpdmVCbG9jayB8fCAwKX1gKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7IGVmZmVjdGl2ZUJsb2NrIH07XG4gICAgICAgIGZ1bmN0aW9uIHNldChuYW1lLCBudWxsaXNoKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoY29zdHMgfHwge30pW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGxpc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiwgYGludmFsdWQgdmFsdWUgZm9yICR7bmFtZX1gLCBcImNvc3RzXCIsIGNvc3RzKTtcbiAgICAgICAgICAgIHByb3BzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KFwidHhCYXNlXCIsIDIxMDAwKTtcbiAgICAgICAgc2V0KFwidHhDcmVhdGVcIiwgMzIwMDApO1xuICAgICAgICBzZXQoXCJ0eERhdGFaZXJvXCIsIDQpO1xuICAgICAgICBzZXQoXCJ0eERhdGFOb256ZXJvXCIsIDE2KTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0U3RvcmFnZUtleVwiLCAxOTAwKTtcbiAgICAgICAgc2V0KFwidHhBY2Nlc3NMaXN0QWRkcmVzc1wiLCAyNDAwKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCBwcm9wcyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdhc0Nvc3RQbHVnaW4odGhpcy5lZmZlY3RpdmVCbG9jaywgdGhpcyk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipFbnNQbHVnaW4qKiBhbGxvd3MgYSBbW05ldHdvcmtdXSB0byBzcGVjaWZ5IHRoZSBFTlMgUmVnaXN0cnlcbiAqICBDb250cmFjdCBhZGRyZXNzIGFuZCB0aGUgdGFyZ2V0IG5ldHdvcmsgdG8gdXNlIHdoZW4gdXNpbmcgdGhhdFxuICogIGNvbnRyYWN0LlxuICpcbiAqICBWYXJpb3VzIHRlc3RuZXRzIGhhdmUgdGhlaXIgb3duIGluc3RhbmNlIG9mIHRoZSBjb250cmFjdCB0byB1c2UsIGJ1dFxuICogIGluIGdlbmVyYWwsIHRoZSBtYWlubmV0IGluc3RhbmNlIHN1cHBvcnRzIG11bHRpLWNoYWluIGFkZHJlc3NlcyBhbmRcbiAqICBzaG91bGQgYmUgdXNlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuc1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgRU5TIFJlZ2lzdHJ0eSBDb250cmFjdCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGF0IHRoZSBFTlMgY29udHJhY3QgbGl2ZXMgb24uXG4gICAgICovXG4gICAgdGFyZ2V0TmV0d29yaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkVuc1BsdWdpbioqIGNvbm5lY3RlZCB0byAlJWFkZHJlc3MlJSBvbiB0aGVcbiAgICAgKiAgJSV0YXJnZXROZXR3b3JrJSUuIFRoZSBkZWZhdWx0IEVOUyBhZGRyZXNzIGFuZCBtYWlubmV0IGlzIHVzZWRcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgdGFyZ2V0TmV0d29yaykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkVuc1wiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBhZGRyZXNzOiAoYWRkcmVzcyB8fCBFbnNBZGRyZXNzKSxcbiAgICAgICAgICAgIHRhcmdldE5ldHdvcms6ICgodGFyZ2V0TmV0d29yayA9PSBudWxsKSA/IDEgOiB0YXJnZXROZXR3b3JrKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW5zUGx1Z2luKHRoaXMuYWRkcmVzcywgdGhpcy50YXJnZXROZXR3b3JrKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiBhbGxvd3MgYSBuZXR3b3JrIHRvIHByb3ZpZGUgYW5kIGFsdGVybmF0ZVxuICogIG1lYW5zIHRvIHNwZWNpZnkgaXRzIGZlZSBkYXRhLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgYSBuZXR3b3JrIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgW1tsaW5rLWVpcC0xNTU5XV0gbWF5XG4gKiAgY2hvb3NlIHRvIHVzZSBhIEdhcyBTdGF0aW9uIHNpdGUgdG8gYXBwcm94aW1hdGUgdGhlIGdhcyBwcmljZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgI2ZlZURhdGFGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIGRhdGEgZnVuY3Rpb24gcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGdldCBmZWVEYXRhRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZlZURhdGFGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZlZURhdGFOZXR3b3JrUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZmVlRGF0YUZ1bmMpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZWVEYXRhXCIpO1xuICAgICAgICB0aGlzLiNmZWVEYXRhRnVuYyA9IGZlZURhdGFGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGZlZSBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEZlZURhdGEocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZlZURhdGFGdW5jKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmVlRGF0YU5ldHdvcmtQbHVnaW4odGhpcy4jZmVlRGF0YUZ1bmMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgI3VybDtcbiAgICAjcHJvY2Vzc0Z1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBVUkwgdG8gaW5pdGlhbGl6ZSB0aGUgRmV0Y2hSZXF1ZXN0IHdpdGggaW4gJSVwcm9jZXNzRnVuYyUlLlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNhbGxiYWNrIHRvIHVzZSB3aGVuIGNvbXB1dGluZyB0aGUgRmVlRGF0YS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7IHJldHVybiB0aGlzLiNwcm9jZXNzRnVuYzsgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbioqIHdoaWNoIHdpbGxcbiAgICAgKiAgYmUgdXNlZCB3aGVuIGNvbXB1dGluZyB0aGUgZmVlIGRhdGEgZm9yIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5GZXRjaFVybEZlZURhdGFQbHVnaW5cIik7XG4gICAgICAgIHRoaXMuI3VybCA9IHVybDtcbiAgICAgICAgdGhpcy4jcHJvY2Vzc0Z1bmMgPSBwcm9jZXNzRnVuYztcbiAgICB9XG4gICAgLy8gV2UgYXJlIGltbXV0YWJsZSwgc28gd2UgY2FuIHNlcnZlIGFzIG91ciBvd24gY2xvbmVcbiAgICBjbG9uZSgpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbi8qXG5leHBvcnQgY2xhc3MgQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgcmVhZG9ubHkgI2Jsb2NrRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pID0+IEJsb2NrPHN0cmluZz47XG4gICAgcmVhZG9ubHkgI2Jsb2NrV2l0aFR4c0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPikgPT4gQmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT47XG5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+LCBibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+KSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5uZXR3b3JrLXBsdWdpbnMuY3VzdG9tLWJsb2NrXCIpO1xuICAgICAgICB0aGlzLiNibG9ja0Z1bmMgPSBibG9ja0Z1bmM7XG4gICAgICAgIHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMgPSBibG9ja1dpdGhUeHNGdW5jO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2NrKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pOiBQcm9taXNlPEJsb2NrPHN0cmluZz4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jsb2NrRnVuYyhwcm92aWRlciwgYmxvY2spO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2NraW9ucyhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPik6IFByb21pc2U8QmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4ge1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbih0aGlzLiNibG9ja0Z1bmMsIHRoaXMuI2Jsb2NrV2l0aFR4c0Z1bmMpO1xuICAgIH1cbn1cbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW5zLW5ldHdvcmsuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/plugins-network.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-alchemy.js":
/*!***************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-alchemy.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlchemyProvider: function() { return /* binding */ AlchemyProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./community.js */ \"../common/node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\n *  [[link-alchemy]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)\n *  - Base (``base``)\n *  - Base Goerlia Testnet (``base-goerli``)\n *  - Base Sepolia Testnet (``base-sepolia``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\n *  - Polygon (``matic``)\n *  - Polygon Amoy Testnet (``matic-amoy``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection: api/providers/thirdparty:Alchemy  [providers-alchemy]\n */\n\n\n\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"eth-mainnet.alchemyapi.io\";\n        case \"goerli\":\n            return \"eth-goerli.g.alchemy.com\";\n        case \"sepolia\":\n            return \"eth-sepolia.g.alchemy.com\";\n        case \"arbitrum\":\n            return \"arb-mainnet.g.alchemy.com\";\n        case \"arbitrum-goerli\":\n            return \"arb-goerli.g.alchemy.com\";\n        case \"arbitrum-sepolia\":\n            return \"arb-sepolia.g.alchemy.com\";\n        case \"base\":\n            return \"base-mainnet.g.alchemy.com\";\n        case \"base-goerli\":\n            return \"base-goerli.g.alchemy.com\";\n        case \"base-sepolia\":\n            return \"base-sepolia.g.alchemy.com\";\n        case \"matic\":\n            return \"polygon-mainnet.g.alchemy.com\";\n        case \"matic-amoy\":\n            return \"polygon-amoy.g.alchemy.com\";\n        case \"matic-mumbai\":\n            return \"polygon-mumbai.g.alchemy.com\";\n        case \"optimism\":\n            return \"opt-mainnet.g.alchemy.com\";\n        case \"optimism-goerli\":\n            return \"opt-goerli.g.alchemy.com\";\n        case \"optimism-sepolia\":\n            return \"opt-sepolia.g.alchemy.com\";\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **AlchemyProvider** connects to the [[link-alchemy]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-alchemy-signup).\n *\n *  @_docloc: api/providers/thirdparty\n */\nclass AlchemyProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\n    apiKey;\n    constructor(_network, apiKey) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const request = AlchemyProvider.getRequest(network, apiKey);\n        super(request, network, { staticNetwork: network });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { apiKey });\n    }\n    _getProvider(chainId) {\n        try {\n            return new AlchemyProvider(chainId, this.apiKey);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    async _perform(req) {\n        // https://docs.alchemy.com/reference/trace-transaction\n        if (req.method === \"getTransactionResult\") {\n            const { trace, tx } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                trace: this.send(\"trace_transaction\", [req.hash]),\n                tx: this.getTransaction(req.hash)\n            });\n            if (trace == null || tx == null) {\n                return null;\n            }\n            let data;\n            let error = false;\n            try {\n                data = trace[0].result.output;\n                error = (trace[0].error === \"Reverted\");\n            }\n            catch (error) { }\n            if (data) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!error, \"an error occurred during transaction executions\", \"CALL_EXCEPTION\", {\n                    action: \"getTransactionResult\",\n                    data,\n                    reason: null,\n                    transaction: tx,\n                    invocation: null,\n                    revert: null // @TODO\n                });\n                return data;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"could not parse trace result\", \"BAD_DATA\", { value: trace });\n        }\n        return await super._perform(req);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n    static getRequest(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/v2/${apiKey}`);\n        request.allowGzip = true;\n        if (apiKey === defaultApiKey) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)(\"alchemy\");\n                return true;\n            };\n        }\n        return request;\n    }\n}\n//# sourceMappingURL=provider-alchemy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYWxjaGVteS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RztBQUN6RDtBQUNkO0FBQ2lCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIsaUVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsUUFBUSxpRUFBZ0IsU0FBUyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSxRQUFRLGtFQUFpQjtBQUN6RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxZQUFZLHVEQUFNLHNEQUFzRCxjQUFjO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFZLGFBQWEsc0JBQXNCLE1BQU0sT0FBTztBQUN4RjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci1hbGNoZW15LmpzP2NlNTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgW1tsaW5rLWFsY2hlbXldXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXG4gKlxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcbiAqXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcbiAqICAtIEdvZXJsaSBUZXN0bmV0IChgYGdvZXJsaWBgKVxuICogIC0gU2Vwb2xpYSBUZXN0bmV0IChgYHNlcG9saWFgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBBcmJpdHJ1bSBHb2VybGkgVGVzdG5ldCAoYGBhcmJpdHJ1bS1nb2VybGlgYClcbiAqICAtIEFyYml0cnVtIFNlcG9saWEgVGVzdG5ldCAoYGBhcmJpdHJ1bS1zZXBvbGlhYGApXG4gKiAgLSBCYXNlIChgYGJhc2VgYClcbiAqICAtIEJhc2UgR29lcmxpYSBUZXN0bmV0IChgYGJhc2UtZ29lcmxpYGApXG4gKiAgLSBCYXNlIFNlcG9saWEgVGVzdG5ldCAoYGBiYXNlLXNlcG9saWFgYClcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXG4gKiAgLSBPcHRpbWlzbSBHb2VybGkgVGVzdG5ldCAoYGBvcHRpbWlzbS1nb2VybGlgYClcbiAqICAtIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoYGBvcHRpbWlzbS1zZXBvbGlhYGApXG4gKiAgLSBQb2x5Z29uIChgYG1hdGljYGApXG4gKiAgLSBQb2x5Z29uIEFtb3kgVGVzdG5ldCAoYGBtYXRpYy1hbW95YGApXG4gKiAgLSBQb2x5Z29uIE11bWJhaSBUZXN0bmV0IChgYG1hdGljLW11bWJhaWBgKVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpBbGNoZW15ICBbcHJvdmlkZXJzLWFsY2hlbXldXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBGZXRjaFJlcXVlc3QgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9jb21tdW5pdHkuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCI7XG5jb25zdCBkZWZhdWx0QXBpS2V5ID0gXCJfZ2c3d1NTaTBLTUJzZEtuR1ZmSER1ZXE2eE1COUVrQ1wiO1xuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGgtbWFpbm5ldC5hbGNoZW15YXBpLmlvXCI7XG4gICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aC1nb2VybGkuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwic2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoLXNlcG9saWEuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYi1tYWlubmV0LmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYXJiLWdvZXJsaS5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJhcmItc2Vwb2xpYS5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLW1haW5uZXQuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwiYmFzZS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImJhc2UtZ29lcmxpLmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcImJhc2Utc2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYmFzZS1zZXBvbGlhLmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5Z29uLW1haW5uZXQuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwibWF0aWMtYW1veVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1hbW95LmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1tdW1iYWkuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwib3B0aW1pc21cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm9wdC1tYWlubmV0LmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0LWdvZXJsaS5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJvcHQtc2Vwb2xpYS5nLmFsY2hlbXkuY29tXCI7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xufVxuLyoqXG4gKiAgVGhlICoqQWxjaGVteVByb3ZpZGVyKiogY29ubmVjdHMgdG8gdGhlIFtbbGluay1hbGNoZW15XV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1hbGNoZW15LXNpZ251cCkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHlcbiAqL1xuZXhwb3J0IGNsYXNzIEFsY2hlbXlQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XG4gICAgYXBpS2V5O1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIF9uZXR3b3JrID0gXCJtYWlubmV0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gQWxjaGVteVByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgc3VwZXIocmVxdWVzdCwgbmV0d29yaywgeyBzdGF0aWNOZXR3b3JrOiBuZXR3b3JrIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXBpS2V5IH0pO1xuICAgIH1cbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGNoZW15UHJvdmlkZXIoY2hhaW5JZCwgdGhpcy5hcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xuICAgICAgICAvLyBodHRwczovL2RvY3MuYWxjaGVteS5jb20vcmVmZXJlbmNlL3RyYWNlLXRyYW5zYWN0aW9uXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhY2UsIHR4IH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgdHJhY2U6IHRoaXMuc2VuZChcInRyYWNlX3RyYW5zYWN0aW9uXCIsIFtyZXEuaGFzaF0pLFxuICAgICAgICAgICAgICAgIHR4OiB0aGlzLmdldFRyYW5zYWN0aW9uKHJlcS5oYXNoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT0gbnVsbCB8fCB0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdHJhY2VbMF0ucmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICh0cmFjZVswXS5lcnJvciA9PT0gXCJSZXZlcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGFzc2VydCghZXJyb3IsIFwiYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbnNcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBudWxsIC8vIEBUT0RPXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY291bGQgbm90IHBhcnNlIHRyYWNlIHJlc3VsdFwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRyYWNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5fcGVyZm9ybShyZXEpO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS92Mi8ke2FwaUtleX1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICBpZiAoYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNob3dUaHJvdHRsZU1lc3NhZ2UoXCJhbGNoZW15XCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1hbGNoZW15LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-alchemy.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-ankr.js":
/*!************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-ankr.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnkrProvider: function() { return /* binding */ AnkrProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./community.js */ \"../common/node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\n *  [[link-ankr]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Arbitrum (``arbitrum``)\n *  - Base (``base``)\n *  - Base Goerlia Testnet (``base-goerli``)\n *  - Base Sepolia Testnet (``base-sepolia``)\n *  - BNB (``bnb``)\n *  - BNB Testnet (``bnbt``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection: api/providers/thirdparty:Ankr  [providers-ankr]\n */\n\n\n\n\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"rpc.ankr.com/eth\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli\";\n        case \"sepolia\":\n            return \"rpc.ankr.com/eth_sepolia\";\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum\";\n        case \"base\":\n            return \"rpc.ankr.com/base\";\n        case \"base-goerli\":\n            return \"rpc.ankr.com/base_goerli\";\n        case \"base-sepolia\":\n            return \"rpc.ankr.com/base_sepolia\";\n        case \"bnb\":\n            return \"rpc.ankr.com/bsc\";\n        case \"bnbt\":\n            return \"rpc.ankr.com/bsc_testnet_chapel\";\n        case \"matic\":\n            return \"rpc.ankr.com/polygon\";\n        case \"matic-mumbai\":\n            return \"rpc.ankr.com/polygon_mumbai\";\n        case \"optimism\":\n            return \"rpc.ankr.com/optimism\";\n        case \"optimism-goerli\":\n            return \"rpc.ankr.com/optimism_testnet\";\n        case \"optimism-sepolia\":\n            return \"rpc.ankr.com/optimism_sepolia\";\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **AnkrProvider** connects to the [[link-ankr]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-ankr-signup).\n */\nclass AnkrProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\n    /**\n     *  The API key for the Ankr connection.\n     */\n    apiKey;\n    /**\n     *  Create a new **AnkrProvider**.\n     *\n     *  By default connecting to ``mainnet`` with a highly throttled\n     *  API key.\n     */\n    constructor(_network, apiKey) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        // Ankr does not support filterId, so we force polling\n        const options = { polling: true, staticNetwork: network };\n        const request = AnkrProvider.getRequest(network, apiKey);\n        super(request, network, options);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { apiKey });\n    }\n    _getProvider(chainId) {\n        try {\n            return new AnkrProvider(chainId, this.apiKey);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%% with\n     *  %%apiKey%%.\n     */\n    static getRequest(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/${apiKey}`);\n        request.allowGzip = true;\n        if (apiKey === defaultApiKey) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)(\"AnkrProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n    getRpcError(payload, error) {\n        if (payload.method === \"eth_sendRawTransaction\") {\n            if (error && error.error && error.error.message === \"INTERNAL_ERROR: could not replace existing tx\") {\n                error.error.message = \"replacement transaction underpriced\";\n            }\n        }\n        return super.getRpcError(payload, error);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=provider-ankr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYW5rci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUY7QUFDOUI7QUFDZDtBQUNpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQixpRUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQVksYUFBYSxzQkFBc0IsR0FBRyxPQUFPO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci1hbmtyLmpzP2Q4YTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgW1tsaW5rLWFua3JdXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXG4gKlxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcbiAqXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcbiAqICAtIEdvZXJsaSBUZXN0bmV0IChgYGdvZXJsaWBgKVxuICogIC0gU2Vwb2xpYSBUZXN0bmV0IChgYHNlcG9saWFgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBCYXNlIChgYGJhc2VgYClcbiAqICAtIEJhc2UgR29lcmxpYSBUZXN0bmV0IChgYGJhc2UtZ29lcmxpYGApXG4gKiAgLSBCYXNlIFNlcG9saWEgVGVzdG5ldCAoYGBiYXNlLXNlcG9saWFgYClcbiAqICAtIEJOQiAoYGBibmJgYClcbiAqICAtIEJOQiBUZXN0bmV0IChgYGJuYnRgYClcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXG4gKiAgLSBPcHRpbWlzbSBHb2VybGkgVGVzdG5ldCAoYGBvcHRpbWlzbS1nb2VybGlgYClcbiAqICAtIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoYGBvcHRpbWlzbS1zZXBvbGlhYGApXG4gKiAgLSBQb2x5Z29uIChgYG1hdGljYGApXG4gKiAgLSBQb2x5Z29uIE11bWJhaSBUZXN0bmV0IChgYG1hdGljLW11bWJhaWBgKVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpBbmtyICBbcHJvdmlkZXJzLWFua3JdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEZldGNoUmVxdWVzdCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9jb21tdW5pdHkuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCI7XG5jb25zdCBkZWZhdWx0QXBpS2V5ID0gXCI5ZjdkOTI5YjAxOGNkZmZiMzM4NTE3ZWZhMDZmNTgzNTllODZmZjFmZmQzNTBiYzg4OTczODUyMzY1OWU3OTcyXCI7XG5mdW5jdGlvbiBnZXRIb3N0KG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGhcIjtcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2V0aF9nb2VybGlcIjtcbiAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGhfc2Vwb2xpYVwiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9hcmJpdHJ1bVwiO1xuICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2Jhc2VcIjtcbiAgICAgICAgY2FzZSBcImJhc2UtZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYmFzZV9nb2VybGlcIjtcbiAgICAgICAgY2FzZSBcImJhc2Utc2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL2Jhc2Vfc2Vwb2xpYVwiO1xuICAgICAgICBjYXNlIFwiYm5iXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYnNjXCI7XG4gICAgICAgIGNhc2UgXCJibmJ0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYnNjX3Rlc3RuZXRfY2hhcGVsXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL3BvbHlnb25cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL3BvbHlnb25fbXVtYmFpXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL29wdGltaXNtXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9vcHRpbWlzbV90ZXN0bmV0XCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vb3B0aW1pc21fc2Vwb2xpYVwiO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuYW1lKTtcbn1cbi8qKlxuICogIFRoZSAqKkFua3JQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstYW5rcl1dXG4gKiAgSlNPTi1SUEMgZW5kLXBvaW50cy5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgYSBoaWdobHktdGhyb3R0bGVkIEFQSSBrZXkgaXMgdXNlZCwgd2hpY2ggaXNcbiAqICBhcHByb3ByaWF0ZSBmb3IgcXVpY2sgcHJvdG90eXBlcyBhbmQgc2ltcGxlIHNjcmlwdHMuIFRvXG4gKiAgZ2FpbiBhY2Nlc3MgdG8gYW4gaW5jcmVhc2VkIHJhdGUtbGltaXQsIGl0IGlzIGhpZ2hseVxuICogIHJlY29tbWVuZGVkIHRvIFtzaWduIHVwIGhlcmVdKGxpbmstYW5rci1zaWdudXApLlxuICovXG5leHBvcnQgY2xhc3MgQW5rclByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIEFQSSBrZXkgZm9yIHRoZSBBbmtyIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYXBpS2V5O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipBbmtyUHJvdmlkZXIqKi5cbiAgICAgKlxuICAgICAqICBCeSBkZWZhdWx0IGNvbm5lY3RpbmcgdG8gYGBtYWlubmV0YGAgd2l0aCBhIGhpZ2hseSB0aHJvdHRsZWRcbiAgICAgKiAgQVBJIGtleS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGlmIChfbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICBfbmV0d29yayA9IFwibWFpbm5ldFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBOZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwaUtleSA9IGRlZmF1bHRBcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW5rciBkb2VzIG5vdCBzdXBwb3J0IGZpbHRlcklkLCBzbyB3ZSBmb3JjZSBwb2xsaW5nXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHBvbGxpbmc6IHRydWUsIHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IEFua3JQcm92aWRlci5nZXRSZXF1ZXN0KG5ldHdvcmssIGFwaUtleSk7XG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXBpS2V5IH0pO1xuICAgIH1cbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbmtyUHJvdmlkZXIoY2hhaW5JZCwgdGhpcy5hcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgcHJlcGFyZWQgcmVxdWVzdCBmb3IgY29ubmVjdGluZyB0byAlJW5ldHdvcmslJSB3aXRoXG4gICAgICogICUlYXBpS2V5JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS8ke2FwaUtleX1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICBpZiAoYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNob3dUaHJvdHRsZU1lc3NhZ2UoXCJBbmtyUHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBlcnJvcikge1xuICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuZXJyb3IgJiYgZXJyb3IuZXJyb3IubWVzc2FnZSA9PT0gXCJJTlRFUk5BTF9FUlJPUjogY291bGQgbm90IHJlcGxhY2UgZXhpc3RpbmcgdHhcIikge1xuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yLm1lc3NhZ2UgPSBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItYW5rci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-ankr.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-blockscout.js":
/*!******************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-blockscout.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockscoutProvider: function() { return /* binding */ BlockscoutProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\n *  [[link-blockscout]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Holesky Testnet (``holesky``)\n *  - Ethereum Classic (``classic``)\n *  - Arbitrum (``arbitrum``)\n *  - Base (``base``)\n *  - Base Sepolia Testnet (``base-sepolia``)\n *  - Gnosis (``xdai``)\n *  - Optimism (``optimism``)\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\n *  - Polygon (``matic``)\n *\n *  @_subsection: api/providers/thirdparty:Blockscout  [providers-blockscout]\n */\n\n\n\nfunction getUrl(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"https:/\\/eth.blockscout.com/api/eth-rpc\";\n        case \"sepolia\":\n            return \"https:/\\/eth-sepolia.blockscout.com/api/eth-rpc\";\n        case \"holesky\":\n            return \"https:/\\/eth-holesky.blockscout.com/api/eth-rpc\";\n        case \"classic\":\n            return \"https:/\\/etc.blockscout.com/api/eth-rpc\";\n        case \"arbitrum\":\n            return \"https:/\\/arbitrum.blockscout.com/api/eth-rpc\";\n        case \"base\":\n            return \"https:/\\/base.blockscout.com/api/eth-rpc\";\n        case \"base-sepolia\":\n            return \"https:/\\/base-sepolia.blockscout.com/api/eth-rpc\";\n        case \"matic\":\n            return \"https:/\\/polygon.blockscout.com/api/eth-rpc\";\n        case \"optimism\":\n            return \"https:/\\/optimism.blockscout.com/api/eth-rpc\";\n        case \"optimism-sepolia\":\n            return \"https:/\\/optimism-sepolia.blockscout.com/api/eth-rpc\";\n        case \"xdai\":\n            return \"https:/\\/gnosis.blockscout.com/api/eth-rpc\";\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **BlockscoutProvider** connects to the [[link-blockscout]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-blockscout).\n */\nclass BlockscoutProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\n    /**\n     *  The API key.\n     */\n    apiKey;\n    /**\n     *  Creates a new **BlockscoutProvider**.\n     */\n    constructor(_network, apiKey) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\n        if (apiKey == null) {\n            apiKey = null;\n        }\n        const request = BlockscoutProvider.getRequest(network);\n        super(request, network, { staticNetwork: network });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { apiKey });\n    }\n    _getProvider(chainId) {\n        try {\n            return new BlockscoutProvider(chainId, this.apiKey);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    isCommunityResource() {\n        return (this.apiKey === null);\n    }\n    getRpcRequest(req) {\n        // Blockscout enforces the TAG argument for estimateGas\n        const resp = super.getRpcRequest(req);\n        if (resp && resp.method === \"eth_estimateGas\" && resp.args.length == 1) {\n            resp.args = resp.args.slice();\n            resp.args.push(\"latest\");\n        }\n        return resp;\n    }\n    getRpcError(payload, _error) {\n        const error = _error ? _error.error : null;\n        // Blockscout currently drops the VM result and replaces it with a\n        // human-readable string, so we need to make it machine-readable.\n        if (error && error.code === -32015 && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(error.data || \"\", true)) {\n            const panicCodes = {\n                \"assert(false)\": \"01\",\n                \"arithmetic underflow or overflow\": \"11\",\n                \"division or modulo by zero\": \"12\",\n                \"out-of-bounds array access; popping on an empty array\": \"31\",\n                \"out-of-bounds access of an array or bytesN\": \"32\"\n            };\n            let panicCode = \"\";\n            if (error.message === \"VM execution error.\") {\n                // eth_call passes this message\n                panicCode = panicCodes[error.data] || \"\";\n            }\n            else if (panicCodes[error.message || \"\"]) {\n                panicCode = panicCodes[error.message || \"\"];\n            }\n            if (panicCode) {\n                error.message += ` (reverted: ${error.data})`;\n                error.data = \"0x4e487b7100000000000000000000000000000000000000000000000000000000000000\" + panicCode;\n            }\n        }\n        else if (error && error.code === -32000) {\n            if (error.message === \"wrong transaction nonce\") {\n                error.message += \" (nonce too low)\";\n            }\n        }\n        return super.getRpcError(payload, _error);\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%%\n     *  with %%apiKey%%.\n     */\n    static getRequest(network) {\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(getUrl(network.name));\n        request.allowGzip = true;\n        return request;\n    }\n}\n//# sourceMappingURL=provider-blockscout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYmxvY2tzY291dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRztBQUN6RDtBQUNpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsaUVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsUUFBUSxpRUFBZ0IsU0FBUyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0REFBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWJsb2Nrc2NvdXQuanM/MTA1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBbW2xpbmstYmxvY2tzY291dF1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gU2Vwb2xpYSBUZXN0bmV0IChgYHNlcG9saWFgYClcbiAqICAtIEhvbGVza3kgVGVzdG5ldCAoYGBob2xlc2t5YGApXG4gKiAgLSBFdGhlcmV1bSBDbGFzc2ljIChgYGNsYXNzaWNgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBCYXNlIChgYGJhc2VgYClcbiAqICAtIEJhc2UgU2Vwb2xpYSBUZXN0bmV0IChgYGJhc2Utc2Vwb2xpYWBgKVxuICogIC0gR25vc2lzIChgYHhkYWlgYClcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXG4gKiAgLSBPcHRpbWlzbSBTZXBvbGlhIFRlc3RuZXQgKGBgb3B0aW1pc20tc2Vwb2xpYWBgKVxuICogIC0gUG9seWdvbiAoYGBtYXRpY2BgKVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpCbG9ja3Njb3V0ICBbcHJvdmlkZXJzLWJsb2Nrc2NvdXRdXG4gKi9cbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBkZWZpbmVQcm9wZXJ0aWVzLCBGZXRjaFJlcXVlc3QsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiO1xuZnVuY3Rpb24gZ2V0VXJsKG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9ldGguYmxvY2tzY291dC5jb20vYXBpL2V0aC1ycGNcIjtcbiAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9ldGgtc2Vwb2xpYS5ibG9ja3Njb3V0LmNvbS9hcGkvZXRoLXJwY1wiO1xuICAgICAgICBjYXNlIFwiaG9sZXNreVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2V0aC1ob2xlc2t5LmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XG4gICAgICAgIGNhc2UgXCJjbGFzc2ljXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvZXRjLmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FyYml0cnVtLmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYmFzZS5ibG9ja3Njb3V0LmNvbS9hcGkvZXRoLXJwY1wiO1xuICAgICAgICBjYXNlIFwiYmFzZS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYmFzZS1zZXBvbGlhLmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL3BvbHlnb24uYmxvY2tzY291dC5jb20vYXBpL2V0aC1ycGNcIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvb3B0aW1pc20uYmxvY2tzY291dC5jb20vYXBpL2V0aC1ycGNcIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLXNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9vcHRpbWlzbS1zZXBvbGlhLmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XG4gICAgICAgIGNhc2UgXCJ4ZGFpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvZ25vc2lzLmJsb2Nrc2NvdXQuY29tL2FwaS9ldGgtcnBjXCI7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xufVxuLyoqXG4gKiAgVGhlICoqQmxvY2tzY291dFByb3ZpZGVyKiogY29ubmVjdHMgdG8gdGhlIFtbbGluay1ibG9ja3Njb3V0XV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1ibG9ja3Njb3V0KS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2Nrc2NvdXRQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBBUEkga2V5LlxuICAgICAqL1xuICAgIGFwaUtleTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkJsb2Nrc2NvdXRQcm92aWRlcioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIF9uZXR3b3JrID0gXCJtYWlubmV0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gQmxvY2tzY291dFByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yayk7XG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIG5ldHdvcmssIHsgc3RhdGljTmV0d29yazogbmV0d29yayB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFwaUtleSB9KTtcbiAgICB9XG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tzY291dFByb3ZpZGVyKGNoYWluSWQsIHRoaXMuYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09PSBudWxsKTtcbiAgICB9XG4gICAgZ2V0UnBjUmVxdWVzdChyZXEpIHtcbiAgICAgICAgLy8gQmxvY2tzY291dCBlbmZvcmNlcyB0aGUgVEFHIGFyZ3VtZW50IGZvciBlc3RpbWF0ZUdhc1xuICAgICAgICBjb25zdCByZXNwID0gc3VwZXIuZ2V0UnBjUmVxdWVzdChyZXEpO1xuICAgICAgICBpZiAocmVzcCAmJiByZXNwLm1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIiAmJiByZXNwLmFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHJlc3AuYXJncyA9IHJlc3AuYXJncy5zbGljZSgpO1xuICAgICAgICAgICAgcmVzcC5hcmdzLnB1c2goXCJsYXRlc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfVxuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIF9lcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvciA9IF9lcnJvciA/IF9lcnJvci5lcnJvciA6IG51bGw7XG4gICAgICAgIC8vIEJsb2Nrc2NvdXQgY3VycmVudGx5IGRyb3BzIHRoZSBWTSByZXN1bHQgYW5kIHJlcGxhY2VzIGl0IHdpdGggYVxuICAgICAgICAvLyBodW1hbi1yZWFkYWJsZSBzdHJpbmcsIHNvIHdlIG5lZWQgdG8gbWFrZSBpdCBtYWNoaW5lLXJlYWRhYmxlLlxuICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gLTMyMDE1ICYmICFpc0hleFN0cmluZyhlcnJvci5kYXRhIHx8IFwiXCIsIHRydWUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYW5pY0NvZGVzID0ge1xuICAgICAgICAgICAgICAgIFwiYXNzZXJ0KGZhbHNlKVwiOiBcIjAxXCIsXG4gICAgICAgICAgICAgICAgXCJhcml0aG1ldGljIHVuZGVyZmxvdyBvciBvdmVyZmxvd1wiOiBcIjExXCIsXG4gICAgICAgICAgICAgICAgXCJkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiOiBcIjEyXCIsXG4gICAgICAgICAgICAgICAgXCJvdXQtb2YtYm91bmRzIGFycmF5IGFjY2VzczsgcG9wcGluZyBvbiBhbiBlbXB0eSBhcnJheVwiOiBcIjMxXCIsXG4gICAgICAgICAgICAgICAgXCJvdXQtb2YtYm91bmRzIGFjY2VzcyBvZiBhbiBhcnJheSBvciBieXRlc05cIjogXCIzMlwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHBhbmljQ29kZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gXCJWTSBleGVjdXRpb24gZXJyb3IuXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBldGhfY2FsbCBwYXNzZXMgdGhpcyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgcGFuaWNDb2RlID0gcGFuaWNDb2Rlc1tlcnJvci5kYXRhXSB8fCBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFuaWNDb2Rlc1tlcnJvci5tZXNzYWdlIHx8IFwiXCJdKSB7XG4gICAgICAgICAgICAgICAgcGFuaWNDb2RlID0gcGFuaWNDb2Rlc1tlcnJvci5tZXNzYWdlIHx8IFwiXCJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhbmljQ29kZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgKz0gYCAocmV2ZXJ0ZWQ6ICR7ZXJyb3IuZGF0YX0pYDtcbiAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gXCIweDRlNDg3YjcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiArIHBhbmljQ29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSAtMzIwMDApIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSBcIndyb25nIHRyYW5zYWN0aW9uIG5vbmNlXCIpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlICs9IFwiIChub25jZSB0b28gbG93KVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRScGNFcnJvcihwYXlsb2FkLCBfZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHByZXBhcmVkIHJlcXVlc3QgZm9yIGNvbm5lY3RpbmcgdG8gJSVuZXR3b3JrJSVcbiAgICAgKiAgd2l0aCAlJWFwaUtleSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZXF1ZXN0KG5ldHdvcmspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoZ2V0VXJsKG5ldHdvcmsubmFtZSkpO1xuICAgICAgICByZXF1ZXN0LmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWJsb2Nrc2NvdXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-blockscout.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-browser.js":
/*!***************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-browser.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrowserProvider: function() { return /* binding */ BrowserProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n\n\n;\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */\nclass BrowserProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcApiPollingProvider {\n    #request;\n    #providerInfo;\n    /**\n     *  Connect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%.\n     */\n    constructor(ethereum, network, _options) {\n        // Copy the options\n        const options = Object.assign({}, ((_options != null) ? _options : {}), { batchMaxCount: 1 });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(ethereum && ethereum.request, \"invalid EIP-1193 provider\", \"ethereum\", ethereum);\n        super(network, options);\n        this.#providerInfo = null;\n        if (_options && _options.providerInfo) {\n            this.#providerInfo = _options.providerInfo;\n        }\n        this.#request = async (method, params) => {\n            const payload = { method, params };\n            this.emit(\"debug\", { action: \"sendEip1193Request\", payload });\n            try {\n                const result = await ethereum.request(payload);\n                this.emit(\"debug\", { action: \"receiveEip1193Result\", result });\n                return result;\n            }\n            catch (e) {\n                const error = new Error(e.message);\n                error.code = e.code;\n                error.data = e.data;\n                error.payload = payload;\n                this.emit(\"debug\", { action: \"receiveEip1193Error\", error });\n                throw error;\n            }\n        };\n    }\n    get providerInfo() {\n        return this.#providerInfo;\n    }\n    async send(method, params) {\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n        try {\n            const result = await this.#request(payload.method, payload.params || []);\n            return [{ id: payload.id, result }];\n        }\n        catch (e) {\n            return [{\n                    id: payload.id,\n                    error: { code: e.code, data: e.data, message: e.message }\n                }];\n        }\n    }\n    getRpcError(payload, error) {\n        error = JSON.parse(JSON.stringify(error));\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\n        // them into Ethers standard errors.\n        switch (error.error.code || -1) {\n            case 4001:\n                error.error.message = `ethers-user-denied: ${error.error.message}`;\n                break;\n            case 4200:\n                error.error.message = `ethers-unsupported: ${error.error.message}`;\n                break;\n        }\n        return super.getRpcError(payload, error);\n    }\n    /**\n     *  Resolves to ``true`` if the provider manages the %%address%%.\n     */\n    async hasSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accounts = await this.send(\"eth_accounts\", []);\n        if (typeof (address) === \"number\") {\n            return (accounts.length > address);\n        }\n        address = address.toLowerCase();\n        return accounts.filter((a) => (a.toLowerCase() === address)).length !== 0;\n    }\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        if (!(await this.hasSigner(address))) {\n            try {\n                await this.#request(\"eth_requestAccounts\", []);\n            }\n            catch (error) {\n                const payload = error.payload;\n                throw this.getRpcError(payload, { id: payload.id, error });\n            }\n        }\n        return await super.getSigner(address);\n    }\n    /**\n     *  Discover and connect to a Provider in the Browser using the\n     *  [[link-eip-6963]] discovery mechanism. If no providers are\n     *  present, ``null`` is resolved.\n     */\n    static async discover(options) {\n        if (options == null) {\n            options = {};\n        }\n        if (options.provider) {\n            return new BrowserProvider(options.provider);\n        }\n        const context = options.window ? options.window :\n            (typeof (window) !== \"undefined\") ? window : null;\n        if (context == null) {\n            return null;\n        }\n        const anyProvider = options.anyProvider;\n        if (anyProvider && context.ethereum) {\n            return new BrowserProvider(context.ethereum);\n        }\n        if (!(\"addEventListener\" in context && \"dispatchEvent\" in context\n            && \"removeEventListener\" in context)) {\n            return null;\n        }\n        const timeout = options.timeout ? options.timeout : 300;\n        if (timeout === 0) {\n            return null;\n        }\n        return await (new Promise((resolve, reject) => {\n            let found = [];\n            const addProvider = (event) => {\n                found.push(event.detail);\n                if (anyProvider) {\n                    finalize();\n                }\n            };\n            const finalize = () => {\n                clearTimeout(timer);\n                if (found.length) {\n                    // If filtering is provided:\n                    if (options && options.filter) {\n                        // Call filter, with a copies of found provider infos\n                        const filtered = options.filter(found.map(i => Object.assign({}, (i.info))));\n                        if (filtered == null) {\n                            // No provider selected\n                            resolve(null);\n                        }\n                        else if (filtered instanceof BrowserProvider) {\n                            // Custom provider created\n                            resolve(filtered);\n                        }\n                        else {\n                            // Find the matching provider\n                            let match = null;\n                            if (filtered.uuid) {\n                                const matches = found.filter(f => (filtered.uuid === f.info.uuid));\n                                // @TODO: What should happen if multiple values\n                                //        for the same UUID?\n                                match = matches[0];\n                            }\n                            if (match) {\n                                const { provider, info } = match;\n                                resolve(new BrowserProvider(provider, undefined, {\n                                    providerInfo: info\n                                }));\n                            }\n                            else {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"filter returned unknown info\", \"UNSUPPORTED_OPERATION\", {\n                                    value: filtered\n                                }));\n                            }\n                        }\n                    }\n                    else {\n                        // Pick the first found provider\n                        const { provider, info } = found[0];\n                        resolve(new BrowserProvider(provider, undefined, {\n                            providerInfo: info\n                        }));\n                    }\n                }\n                else {\n                    // Nothing found\n                    resolve(null);\n                }\n                context.removeEventListener(\"eip6963:announceProvider\", addProvider);\n            };\n            const timer = setTimeout(() => { finalize(); }, timeout);\n            context.addEventListener(\"eip6963:announceProvider\", addProvider);\n            context.dispatchEvent(new Event(\"eip6963:requestProvider\"));\n        }));\n    }\n}\n//# sourceMappingURL=provider-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEQ7QUFDSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIsMkVBQXlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscUNBQXFDLEtBQUssa0JBQWtCO0FBQ3BHLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGlDQUFpQyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBLHFDQUFxQyx3Q0FBd0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0NBQXNDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsb0JBQW9CO0FBQ2pGO0FBQ0E7QUFDQSw2REFBNkQsb0JBQW9CO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHVCQUF1QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsdUNBQXVDLDBEQUFTO0FBQ2hEO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci1icm93c2VyLmpzPzljZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcbjtcbi8qKlxuICogIEEgKipCcm93c2VyUHJvdmlkZXIqKiBpcyBpbnRlbmRlZCB0byB3cmFwIGFuIGluamVjdGVkIHByb3ZpZGVyIHdoaWNoXG4gKiAgYWRoZXJlcyB0byB0aGUgW1tsaW5rLWVpcC0xMTkzXV0gc3RhbmRhcmQsIHdoaWNoIG1vc3QgKGlmIG5vdCBhbGwpXG4gKiAgY3VycmVudGx5IGRvLlxuICovXG5leHBvcnQgY2xhc3MgQnJvd3NlclByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB7XG4gICAgI3JlcXVlc3Q7XG4gICAgI3Byb3ZpZGVySW5mbztcbiAgICAvKipcbiAgICAgKiAgQ29ubmVjdCB0byB0aGUgJSVldGhlcmV1bSUlIHByb3ZpZGVyLCBvcHRpb25hbGx5IGZvcmNpbmcgdGhlXG4gICAgICogICUlbmV0d29yayUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV0aGVyZXVtLCBuZXR3b3JrLCBfb3B0aW9ucykge1xuICAgICAgICAvLyBDb3B5IHRoZSBvcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCAoKF9vcHRpb25zICE9IG51bGwpID8gX29wdGlvbnMgOiB7fSksIHsgYmF0Y2hNYXhDb3VudDogMSB9KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZXRoZXJldW0gJiYgZXRoZXJldW0ucmVxdWVzdCwgXCJpbnZhbGlkIEVJUC0xMTkzIHByb3ZpZGVyXCIsIFwiZXRoZXJldW1cIiwgZXRoZXJldW0pO1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXJJbmZvID0gbnVsbDtcbiAgICAgICAgaWYgKF9vcHRpb25zICYmIF9vcHRpb25zLnByb3ZpZGVySW5mbykge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXJJbmZvID0gX29wdGlvbnMucHJvdmlkZXJJbmZvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSBhc3luYyAobWV0aG9kLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IG1ldGhvZCwgcGFyYW1zIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kRWlwMTE5M1JlcXVlc3RcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRWlwMTE5M1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gZS5jb2RlO1xuICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICAgICAgZXJyb3IucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVpcDExOTNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHByb3ZpZGVySW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb3ZpZGVySW5mbztcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kKHBheWxvYWQpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIUFycmF5LmlzQXJyYXkocGF5bG9hZCksIFwiRUlQLTExOTMgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaCByZXF1ZXN0XCIsIFwicGF5bG9hZFwiLCBwYXlsb2FkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3JlcXVlc3QocGF5bG9hZC5tZXRob2QsIHBheWxvYWQucGFyYW1zIHx8IFtdKTtcbiAgICAgICAgICAgIHJldHVybiBbeyBpZDogcGF5bG9hZC5pZCwgcmVzdWx0IH1dO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBheWxvYWQuaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6IGUuY29kZSwgZGF0YTogZS5kYXRhLCBtZXNzYWdlOiBlLm1lc3NhZ2UgfVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKSB7XG4gICAgICAgIGVycm9yID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgICAvLyBFSVAtMTE5MyBnaXZlcyB1cyBzb21lIG1hY2hpbmUtcmVhZGFibGUgZXJyb3IgY29kZXMsIHNvIHJld3JpdGVcbiAgICAgICAgLy8gdGhlbSBpbnRvIEV0aGVycyBzdGFuZGFyZCBlcnJvcnMuXG4gICAgICAgIHN3aXRjaCAoZXJyb3IuZXJyb3IuY29kZSB8fCAtMSkge1xuICAgICAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yLm1lc3NhZ2UgPSBgZXRoZXJzLXVzZXItZGVuaWVkOiAke2Vycm9yLmVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDIwMDpcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gYGV0aGVycy11bnN1cHBvcnRlZDogJHtlcnJvci5lcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIHRoZSBwcm92aWRlciBtYW5hZ2VzIHRoZSAlJWFkZHJlc3MlJS5cbiAgICAgKi9cbiAgICBhc3luYyBoYXNTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFjY291bnRzLmxlbmd0aCA+IGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5maWx0ZXIoKGEpID0+IChhLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MpKS5sZW5ndGggIT09IDA7XG4gICAgfVxuICAgIGFzeW5jIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuaGFzU2lnbmVyKGFkZHJlc3MpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNyZXF1ZXN0KFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZXJyb3IucGF5bG9hZDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHsgaWQ6IHBheWxvYWQuaWQsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5nZXRTaWduZXIoYWRkcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEaXNjb3ZlciBhbmQgY29ubmVjdCB0byBhIFByb3ZpZGVyIGluIHRoZSBCcm93c2VyIHVzaW5nIHRoZVxuICAgICAqICBbW2xpbmstZWlwLTY5NjNdXSBkaXNjb3ZlcnkgbWVjaGFuaXNtLiBJZiBubyBwcm92aWRlcnMgYXJlXG4gICAgICogIHByZXNlbnQsIGBgbnVsbGBgIGlzIHJlc29sdmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBkaXNjb3ZlcihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCcm93c2VyUHJvdmlkZXIob3B0aW9ucy5wcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IG9wdGlvbnMud2luZG93ID8gb3B0aW9ucy53aW5kb3cgOlxuICAgICAgICAgICAgKHR5cGVvZiAod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIikgPyB3aW5kb3cgOiBudWxsO1xuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbnlQcm92aWRlciA9IG9wdGlvbnMuYW55UHJvdmlkZXI7XG4gICAgICAgIGlmIChhbnlQcm92aWRlciAmJiBjb250ZXh0LmV0aGVyZXVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJyb3dzZXJQcm92aWRlcihjb250ZXh0LmV0aGVyZXVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShcImFkZEV2ZW50TGlzdGVuZXJcIiBpbiBjb250ZXh0ICYmIFwiZGlzcGF0Y2hFdmVudFwiIGluIGNvbnRleHRcbiAgICAgICAgICAgICYmIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiIGluIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8gb3B0aW9ucy50aW1lb3V0IDogMzAwO1xuICAgICAgICBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZFByb3ZpZGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChldmVudC5kZXRhaWwpO1xuICAgICAgICAgICAgICAgIGlmIChhbnlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5hbGl6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZmlsdGVyaW5nIGlzIHByb3ZpZGVkOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBmaWx0ZXIsIHdpdGggYSBjb3BpZXMgb2YgZm91bmQgcHJvdmlkZXIgaW5mb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gb3B0aW9ucy5maWx0ZXIoZm91bmQubWFwKGkgPT4gT2JqZWN0LmFzc2lnbih7fSwgKGkuaW5mbykpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHByb3ZpZGVyIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgQnJvd3NlclByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHByb3ZpZGVyIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZpbHRlcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWQudXVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZm91bmQuZmlsdGVyKGYgPT4gKGZpbHRlcmVkLnV1aWQgPT09IGYuaW5mby51dWlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBXaGF0IHNob3VsZCBoYXBwZW4gaWYgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICBmb3IgdGhlIHNhbWUgVVVJRD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgaW5mbyB9ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEJyb3dzZXJQcm92aWRlcihwcm92aWRlciwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlckluZm86IGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcImZpbHRlciByZXR1cm5lZCB1bmtub3duIGluZm9cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZpbHRlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQaWNrIHRoZSBmaXJzdCBmb3VuZCBwcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgaW5mbyB9ID0gZm91bmRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBCcm93c2VyUHJvdmlkZXIocHJvdmlkZXIsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVySW5mbzogaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiLCBhZGRQcm92aWRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgZmluYWxpemUoKTsgfSwgdGltZW91dCk7XG4gICAgICAgICAgICBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOmFubm91bmNlUHJvdmlkZXJcIiwgYWRkUHJvdmlkZXIpO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImVpcDY5NjM6cmVxdWVzdFByb3ZpZGVyXCIpKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-browser.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-chainstack.js":
/*!******************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-chainstack.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChainstackProvider: function() { return /* binding */ ChainstackProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./community.js */ \"../common/node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\n *  [[link-chainstack]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Arbitrum (``arbitrum``)\n *  - BNB Smart Chain Mainnet (``bnb``)\n *  - Polygon (``matic``)\n *\n *  @_subsection: api/providers/thirdparty:Chainstack  [providers-chainstack]\n */\n\n\n\n\nfunction getApiKey(name) {\n    switch (name) {\n        case \"mainnet\": return \"39f1d67cedf8b7831010a665328c9197\";\n        case \"arbitrum\": return \"0550c209db33c3abf4cc927e1e18cea1\";\n        case \"bnb\": return \"98b5a77e531614387366f6fc5da097f8\";\n        case \"matic\": return \"cd9d4d70377471aa7c142ec4a4205249\";\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"ethereum-mainnet.core.chainstack.com\";\n        case \"arbitrum\":\n            return \"arbitrum-mainnet.core.chainstack.com\";\n        case \"bnb\":\n            return \"bsc-mainnet.core.chainstack.com\";\n        case \"matic\":\n            return \"polygon-mainnet.core.chainstack.com\";\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **ChainstackProvider** connects to the [[link-chainstack]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-chainstack).\n */\nclass ChainstackProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\n    /**\n     *  The API key for the Chainstack connection.\n     */\n    apiKey;\n    /**\n     *  Creates a new **ChainstackProvider**.\n     */\n    constructor(_network, apiKey) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\n        if (apiKey == null) {\n            apiKey = getApiKey(network.name);\n        }\n        const request = ChainstackProvider.getRequest(network, apiKey);\n        super(request, network, { staticNetwork: network });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { apiKey });\n    }\n    _getProvider(chainId) {\n        try {\n            return new ChainstackProvider(chainId, this.apiKey);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    isCommunityResource() {\n        return (this.apiKey === getApiKey(this._network.name));\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%%\n     *  with %%apiKey%% and %%projectSecret%%.\n     */\n    static getRequest(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = getApiKey(network.name);\n        }\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/${apiKey}`);\n        request.allowGzip = true;\n        if (apiKey === getApiKey(network.name)) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)(\"ChainstackProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n}\n//# sourceMappingURL=provider-chainstack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItY2hhaW5zdGFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21GO0FBQzlCO0FBQ2Q7QUFDaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsaUVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsUUFBUSxpRUFBZ0IsU0FBUyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFZLGFBQWEsc0JBQXNCLEdBQUcsT0FBTztBQUNyRjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci1jaGFpbnN0YWNrLmpzP2I4ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgW1tsaW5rLWNoYWluc3RhY2tdXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXG4gKlxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcbiAqXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gTWFpbm5ldCAoYGBibmJgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6Q2hhaW5zdGFjayAgW3Byb3ZpZGVycy1jaGFpbnN0YWNrXVxuICovXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBGZXRjaFJlcXVlc3QsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vY29tbXVuaXR5LmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiO1xuZnVuY3Rpb24gZ2V0QXBpS2V5KG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm1haW5uZXRcIjogcmV0dXJuIFwiMzlmMWQ2N2NlZGY4Yjc4MzEwMTBhNjY1MzI4YzkxOTdcIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6IHJldHVybiBcIjA1NTBjMjA5ZGIzM2MzYWJmNGNjOTI3ZTFlMThjZWExXCI7XG4gICAgICAgIGNhc2UgXCJibmJcIjogcmV0dXJuIFwiOThiNWE3N2U1MzE2MTQzODczNjZmNmZjNWRhMDk3ZjhcIjtcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6IHJldHVybiBcImNkOWQ0ZDcwMzc3NDcxYWE3YzE0MmVjNGE0MjA1MjQ5XCI7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcmV1bS1tYWlubmV0LmNvcmUuY2hhaW5zdGFjay5jb21cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJhcmJpdHJ1bS1tYWlubmV0LmNvcmUuY2hhaW5zdGFjay5jb21cIjtcbiAgICAgICAgY2FzZSBcImJuYlwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYnNjLW1haW5uZXQuY29yZS5jaGFpbnN0YWNrLmNvbVwiO1xuICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbWFpbm5ldC5jb3JlLmNoYWluc3RhY2suY29tXCI7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xufVxuLyoqXG4gKiAgVGhlICoqQ2hhaW5zdGFja1Byb3ZpZGVyKiogY29ubmVjdHMgdG8gdGhlIFtbbGluay1jaGFpbnN0YWNrXV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1jaGFpbnN0YWNrKS5cbiAqL1xuZXhwb3J0IGNsYXNzIENoYWluc3RhY2tQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBBUEkga2V5IGZvciB0aGUgQ2hhaW5zdGFjayBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFwaUtleTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkNoYWluc3RhY2tQcm92aWRlcioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIF9uZXR3b3JrID0gXCJtYWlubmV0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZ2V0QXBpS2V5KG5ldHdvcmsubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IENoYWluc3RhY2tQcm92aWRlci5nZXRSZXF1ZXN0KG5ldHdvcmssIGFwaUtleSk7XG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIG5ldHdvcmssIHsgc3RhdGljTmV0d29yazogbmV0d29yayB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFwaUtleSB9KTtcbiAgICB9XG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW5zdGFja1Byb3ZpZGVyKGNoYWluSWQsIHRoaXMuYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09PSBnZXRBcGlLZXkodGhpcy5fbmV0d29yay5uYW1lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgcHJlcGFyZWQgcmVxdWVzdCBmb3IgY29ubmVjdGluZyB0byAlJW5ldHdvcmslJVxuICAgICAqICB3aXRoICUlYXBpS2V5JSUgYW5kICUlcHJvamVjdFNlY3JldCUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZXF1ZXN0KG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwaUtleSA9IGdldEFwaUtleShuZXR3b3JrLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9LyR7YXBpS2V5fWApO1xuICAgICAgICByZXF1ZXN0LmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIGlmIChhcGlLZXkgPT09IGdldEFwaUtleShuZXR3b3JrLm5hbWUpKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNob3dUaHJvdHRsZU1lc3NhZ2UoXCJDaGFpbnN0YWNrUHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWNoYWluc3RhY2suanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-chainstack.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-cloudflare.js":
/*!******************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-cloudflare.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloudflareProvider: function() { return /* binding */ CloudflareProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\n *  About Cloudflare\n *\n *  @_subsection: api/providers/thirdparty:Cloudflare  [providers-cloudflare]\n */\n\n\n\n/**\n *  About Cloudflare...\n */\nclass CloudflareProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider {\n    constructor(_network) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_1__.Network.from(_network);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(network.name === \"mainnet\", \"unsupported network\", \"network\", _network);\n        super(\"https:/\\/cloudflare-eth.com/\", network, { staticNetwork: network });\n    }\n}\n//# sourceMappingURL=provider-cloudflare.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItY2xvdWRmbGFyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRDtBQUNaO0FBQ2lCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyxpRUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQixRQUFRLCtEQUFjO0FBQ3RCLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci1jbG91ZGZsYXJlLmpzP2Q5MWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQWJvdXQgQ2xvdWRmbGFyZVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpDbG91ZGZsYXJlICBbcHJvdmlkZXJzLWNsb3VkZmxhcmVdXG4gKi9cbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiO1xuLyoqXG4gKiAgQWJvdXQgQ2xvdWRmbGFyZS4uLlxuICovXG5leHBvcnQgY2xhc3MgQ2xvdWRmbGFyZVByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaykge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobmV0d29yay5uYW1lID09PSBcIm1haW5uZXRcIiwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBfbmV0d29yayk7XG4gICAgICAgIHN1cGVyKFwiaHR0cHM6L1xcL2Nsb3VkZmxhcmUtZXRoLmNvbS9cIiwgbmV0d29yaywgeyBzdGF0aWNOZXR3b3JrOiBuZXR3b3JrIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWNsb3VkZmxhcmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-cloudflare.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-etherscan.js":
/*!*****************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-etherscan.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EtherscanPlugin: function() { return /* binding */ EtherscanPlugin; },\n/* harmony export */   EtherscanProvider: function() { return /* binding */ EtherscanProvider; }\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../abi/index.js */ \"../common/node_modules/ethers/lib.esm/abi/index.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../contract/index.js */ \"../common/node_modules/ethers/lib.esm/contract/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-provider.js */ \"../common/node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins-network.js */ \"../common/node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./community.js */ \"../common/node_modules/ethers/lib.esm/providers/community.js\");\n/**\n *  [[link-etherscan]] provides a third-party service for connecting to\n *  various blockchains over a combination of JSON-RPC and custom API\n *  endpoints.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Holesky Testnet (``holesky``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Base (``base``)\n *  - Base Sepolia Testnet (``base-sepolia``)\n *  - BNB Smart Chain Mainnet (``bnb``)\n *  - BNB Smart Chain Testnet (``bnbt``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *  - Polygon Amoy Testnet (``matic-amoy``)\n *\n *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]\n */\n\n\n\n\n\n\n\n\nconst THROTTLE = 2000;\nfunction isPromise(value) {\n    return (value && typeof (value.then) === \"function\");\n}\nconst EtherscanPluginId = \"org.ethers.plugins.provider.Etherscan\";\n/**\n *  A Network can include an **EtherscanPlugin** to provide\n *  a custom base URL.\n *\n *  @_docloc: api/providers/thirdparty:Etherscan\n */\nclass EtherscanPlugin extends _plugins_network_js__WEBPACK_IMPORTED_MODULE_0__.NetworkPlugin {\n    /**\n     *  The Etherscan API base URL.\n     */\n    baseUrl;\n    /**\n     *  Creates a new **EtherscanProvider** which will use\n     *  %%baseUrl%%.\n     */\n    constructor(baseUrl) {\n        super(EtherscanPluginId);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { baseUrl });\n    }\n    clone() {\n        return new EtherscanPlugin(this.baseUrl);\n    }\n}\nconst skipKeys = [\"enableCcipRead\"];\nlet nextId = 1;\n/**\n *  The **EtherscanBaseProvider** is the super-class of\n *  [[EtherscanProvider]], which should generally be used instead.\n *\n *  Since the **EtherscanProvider** includes additional code for\n *  [[Contract]] access, in //rare cases// that contracts are not\n *  used, this class can reduce code size.\n *\n *  @_docloc: api/providers/thirdparty:Etherscan\n */\nclass EtherscanProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_2__.AbstractProvider {\n    /**\n     *  The connected network.\n     */\n    network;\n    /**\n     *  The API key or null if using the community provided bandwidth.\n     */\n    apiKey;\n    #plugin;\n    /**\n     *  Creates a new **EtherscanBaseProvider**.\n     */\n    constructor(_network, _apiKey) {\n        const apiKey = (_apiKey != null) ? _apiKey : null;\n        super();\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_3__.Network.from(_network);\n        this.#plugin = network.getPlugin(EtherscanPluginId);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { apiKey, network });\n        // Test that the network is supported by Etherscan\n        this.getBaseUrl();\n    }\n    /**\n     *  Returns the base URL.\n     *\n     *  If an [[EtherscanPlugin]] is configured on the\n     *  [[EtherscanBaseProvider_network]], returns the plugin's\n     *  baseUrl.\n     */\n    getBaseUrl() {\n        if (this.#plugin) {\n            return this.#plugin.baseUrl;\n        }\n        switch (this.network.name) {\n            case \"mainnet\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"sepolia\":\n                return \"https:/\\/api-sepolia.etherscan.io\";\n            case \"holesky\":\n                return \"https:/\\/api-holesky.etherscan.io\";\n            case \"arbitrum\":\n                return \"https:/\\/api.arbiscan.io\";\n            case \"arbitrum-goerli\":\n                return \"https:/\\/api-goerli.arbiscan.io\";\n            case \"base\":\n                return \"https:/\\/api.basescan.org\";\n            case \"base-sepolia\":\n                return \"https:/\\/api-sepolia.basescan.org\";\n            case \"bnb\":\n                return \"https:/\\/api.bscscan.com\";\n            case \"bnbt\":\n                return \"https:/\\/api-testnet.bscscan.com\";\n            case \"matic\":\n                return \"https:/\\/api.polygonscan.com\";\n            case \"matic-amoy\":\n                return \"https:/\\/api-amoy.polygonscan.com\";\n            case \"matic-mumbai\":\n                return \"https:/\\/api-testnet.polygonscan.com\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            case \"optimism-goerli\":\n                return \"https:/\\/api-goerli-optimistic.etherscan.io\";\n            default:\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported network\", \"network\", this.network);\n    }\n    /**\n     *  Returns the URL for the %%module%% and %%params%%.\n     */\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \"\");\n        return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;\n    }\n    /**\n     *  Returns the URL for using POST requests.\n     */\n    getPostUrl() {\n        return `${this.getBaseUrl()}/api`;\n    }\n    /**\n     *  Returns the parameters for using POST requests.\n     */\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    async detectNetwork() {\n        return this.network;\n    }\n    /**\n     *  Resolves to the result of calling %%module%% with %%params%%.\n     *\n     *  If %%post%%, the request is made as a POST request.\n     */\n    async fetch(module, params, post) {\n        const id = nextId++;\n        const url = (post ? this.getPostUrl() : this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params) : null);\n        this.emit(\"debug\", { action: \"sendRequest\", id, url, payload: payload });\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_1__.FetchRequest(url);\n        request.setThrottleParams({ slotInterval: 1000 });\n        request.retryFunc = (req, resp, attempt) => {\n            if (this.isCommunityResource()) {\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_4__.showThrottleMessage)(\"Etherscan\");\n            }\n            return Promise.resolve(true);\n        };\n        request.processFunc = async (request, response) => {\n            const result = response.hasBody() ? JSON.parse((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(response.body)) : {};\n            const throttle = ((typeof (result.result) === \"string\") ? result.result : \"\").toLowerCase().indexOf(\"rate limit\") >= 0;\n            if (module === \"proxy\") {\n                // This JSON response indicates we are being throttled\n                if (result && result.status == 0 && result.message == \"NOTOK\" && throttle) {\n                    this.emit(\"debug\", { action: \"receiveError\", id, reason: \"proxy-NOTOK\", error: result });\n                    response.throwThrottleError(result.result, THROTTLE);\n                }\n            }\n            else {\n                if (throttle) {\n                    this.emit(\"debug\", { action: \"receiveError\", id, reason: \"null result\", error: result.result });\n                    response.throwThrottleError(result.result, THROTTLE);\n                }\n            }\n            return response;\n        };\n        if (payload) {\n            request.setHeader(\"content-type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n            request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join(\"&\");\n        }\n        const response = await request.send();\n        try {\n            response.assertOk();\n        }\n        catch (error) {\n            this.emit(\"debug\", { action: \"receiveError\", id, error, reason: \"assertOk\" });\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"response error\", \"SERVER_ERROR\", { request, response });\n        }\n        if (!response.hasBody()) {\n            this.emit(\"debug\", { action: \"receiveError\", id, error: \"missing body\", reason: \"null body\" });\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"missing response\", \"SERVER_ERROR\", { request, response });\n        }\n        const result = JSON.parse((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(response.body));\n        if (module === \"proxy\") {\n            if (result.jsonrpc != \"2.0\") {\n                this.emit(\"debug\", { action: \"receiveError\", id, result, reason: \"invalid JSON-RPC\" });\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"invalid JSON-RPC response (missing jsonrpc='2.0')\", \"SERVER_ERROR\", { request, response, info: { result } });\n            }\n            if (result.error) {\n                this.emit(\"debug\", { action: \"receiveError\", id, result, reason: \"JSON-RPC error\" });\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"error response\", \"SERVER_ERROR\", { request, response, info: { result } });\n            }\n            this.emit(\"debug\", { action: \"receiveRequest\", id, result });\n            return result.result;\n        }\n        else {\n            // getLogs, getHistory have weird success responses\n            if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n                this.emit(\"debug\", { action: \"receiveRequest\", id, result });\n                return result.result;\n            }\n            if (result.status != 1 || (typeof (result.message) === \"string\" && !result.message.match(/^OK/))) {\n                this.emit(\"debug\", { action: \"receiveError\", id, result });\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"error response\", \"SERVER_ERROR\", { request, response, info: { result } });\n            }\n            this.emit(\"debug\", { action: \"receiveRequest\", id, result });\n            return result.result;\n        }\n    }\n    /**\n     *  Returns %%transaction%% normalized for the Etherscan API.\n     */\n    _getTransactionPostData(transaction) {\n        const result = {};\n        for (let key in transaction) {\n            if (skipKeys.indexOf(key) >= 0) {\n                continue;\n            }\n            if (transaction[key] == null) {\n                continue;\n            }\n            let value = transaction[key];\n            if (key === \"type\" && value === 0) {\n                continue;\n            }\n            if (key === \"blockTag\" && value === \"latest\") {\n                continue;\n            }\n            // Quantity-types require no leading zero, unless 0\n            if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toQuantity)(value);\n            }\n            else if (key === \"accessList\") {\n                value = \"[\" + (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.accessListify)(value).map((set) => {\n                    return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n                }).join(\",\") + \"]\";\n            }\n            else if (key === \"blobVersionedHashes\") {\n                if (value.length === 0) {\n                    continue;\n                }\n                // @TODO: update this once the API supports blobs\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Etherscan API does not support blobVersionedHashes\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"_getTransactionPostData\",\n                    info: { transaction }\n                });\n            }\n            else {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(value);\n            }\n            result[key] = value;\n        }\n        return result;\n    }\n    /**\n     *  Throws the normalized Etherscan error.\n     */\n    _checkError(req, error, transaction) {\n        // Pull any message out if, possible\n        let message = \"\";\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isError)(error, \"SERVER_ERROR\")) {\n            // Check for an error emitted by a proxy call\n            try {\n                message = error.info.result.error.message;\n            }\n            catch (e) { }\n            if (!message) {\n                try {\n                    message = error.info.message;\n                }\n                catch (e) { }\n            }\n        }\n        if (req.method === \"estimateGas\") {\n            if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: req.transaction\n                });\n            }\n        }\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            if (message.match(/execution reverted/i)) {\n                let data = \"\";\n                try {\n                    data = error.info.result.error.data;\n                }\n                catch (error) { }\n                const e = _abi_index_js__WEBPACK_IMPORTED_MODULE_6__.AbiCoder.getBuiltinCallException(req.method, req.transaction, data);\n                e.info = { request: req, error };\n                throw e;\n            }\n        }\n        if (message) {\n            if (req.method === \"broadcastTransaction\") {\n                const transaction = _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.Transaction.from(req.signedTransaction);\n                if (message.match(/replacement/i) && message.match(/underpriced/i)) {\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n                        transaction\n                    });\n                }\n                if (message.match(/insufficient funds/)) {\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                        transaction\n                    });\n                }\n                if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"nonce has already been used\", \"NONCE_EXPIRED\", {\n                        transaction\n                    });\n                }\n            }\n        }\n        // Something we could not process\n        throw error;\n    }\n    async _detectNetwork() {\n        return this.network;\n    }\n    async _perform(req) {\n        switch (req.method) {\n            case \"chainId\":\n                return this.network.chainId;\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n            case \"getPriorityFee\":\n                // This is temporary until Etherscan completes support\n                if (this.network.name === \"mainnet\") {\n                    return \"1000000000\";\n                }\n                else if (this.network.name === \"optimism\") {\n                    return \"1000000\";\n                }\n                else {\n                    throw new Error(\"fallback onto the AbstractProvider default\");\n                }\n            /* Working with Etherscan to get this added:\n            try {\n                const test = await this.fetch(\"proxy\", {\n                    action: \"eth_maxPriorityFeePerGas\"\n                });\n                console.log(test);\n                return test;\n            } catch (e) {\n                console.log(\"DEBUG\", e);\n                throw e;\n            }\n            */\n            /* This might be safe; but due to rounding neither myself\n               or Etherscan are necessarily comfortable with this. :)\n            try {\n                const result = await this.fetch(\"gastracker\", { action: \"gasoracle\" });\n                console.log(result);\n                const gasPrice = parseUnits(result.SafeGasPrice, \"gwei\");\n                const baseFee = parseUnits(result.suggestBaseFee, \"gwei\");\n                const priorityFee = gasPrice - baseFee;\n                if (priorityFee < 0) { throw new Error(\"negative priority fee; defer to abstract provider default\"); }\n                return priorityFee;\n            } catch (error) {\n                console.log(\"DEBUG\", error);\n                throw error;\n            }\n            */\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getStorage\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: req.address,\n                    position: req.position,\n                    tag: req.blockTag\n                });\n            case \"broadcastTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: req.signedTransaction\n                }, true).catch((error) => {\n                    return this._checkError(req, error, req.signedTransaction);\n                });\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: req.blockTag,\n                        boolean: (req.includeTransactions ? \"true\" : \"false\")\n                    });\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"getBlock by blockHash not supported by Etherscan\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"getBlock(blockHash)\"\n                });\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: req.hash\n                });\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: req.hash\n                });\n            case \"call\": {\n                if (req.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n                const postData = this._getTransactionPostData(req.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                }\n                catch (error) {\n                    return this._checkError(req, error, req.transaction);\n                }\n            }\n            case \"estimateGas\": {\n                const postData = this._getTransactionPostData(req.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                }\n                catch (error) {\n                    return this._checkError(req, error, req.transaction);\n                }\n            }\n            /*\n                        case \"getLogs\": {\n                            // Needs to complain if more than one address is passed in\n                            const args: Record<string, any> = { action: \"getLogs\" }\n            \n                            if (params.filter.fromBlock) {\n                                args.fromBlock = checkLogTag(params.filter.fromBlock);\n                            }\n            \n                            if (params.filter.toBlock) {\n                                args.toBlock = checkLogTag(params.filter.toBlock);\n                            }\n            \n                            if (params.filter.address) {\n                                args.address = params.filter.address;\n                            }\n            \n                            // @TODO: We can handle slightly more complicated logs using the logs API\n                            if (params.filter.topics && params.filter.topics.length > 0) {\n                                if (params.filter.topics.length > 1) {\n                                    logger.throwError(\"unsupported topic count\", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                                }\n                                if (params.filter.topics.length === 1) {\n                                    const topic0 = params.filter.topics[0];\n                                    if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                                        logger.throwError(\"unsupported topic format\", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                                    }\n                                    args.topic0 = topic0;\n                                }\n                            }\n            \n                            const logs: Array<any> = await this.fetch(\"logs\", args);\n            \n                            // Cache txHash => blockHash\n                            let blocks: { [tag: string]: string } = {};\n            \n                            // Add any missing blockHash to the logs\n                            for (let i = 0; i < logs.length; i++) {\n                                const log = logs[i];\n                                if (log.blockHash != null) { continue; }\n                                if (blocks[log.blockNumber] == null) {\n                                    const block = await this.getBlock(log.blockNumber);\n                                    if (block) {\n                                        blocks[log.blockNumber] = block.hash;\n                                    }\n                                }\n            \n                                log.blockHash = blocks[log.blockNumber];\n                            }\n            \n                            return logs;\n                        }\n            */\n            default:\n                break;\n        }\n        return super._perform(req);\n    }\n    async getNetwork() {\n        return this.network;\n    }\n    /**\n     *  Resolves to the current price of ether.\n     *\n     *  This returns ``0`` on any network other than ``mainnet``.\n     */\n    async getEtherPrice() {\n        if (this.network.name !== \"mainnet\") {\n            return 0.0;\n        }\n        return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n    }\n    /**\n     *  Resolves to a [Contract]] for %%address%%, using the\n     *  Etherscan API to retreive the Contract ABI.\n     */\n    async getContract(_address) {\n        let address = this._getAddress(_address);\n        if (isPromise(address)) {\n            address = await address;\n        }\n        try {\n            const resp = await this.fetch(\"contract\", {\n                action: \"getabi\", address\n            });\n            const abi = JSON.parse(resp);\n            return new _contract_index_js__WEBPACK_IMPORTED_MODULE_7__.Contract(address, abi, this);\n        }\n        catch (error) {\n            return null;\n        }\n    }\n    isCommunityResource() {\n        return (this.apiKey == null);\n    }\n}\n//# sourceMappingURL=provider-etherscan.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItZXRoZXJzY2FuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQztBQUNLO0FBQ3FCO0FBRzdCO0FBQ2tCO0FBQ25CO0FBQ2M7QUFDQTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sOEJBQThCLDhEQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsbUVBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQjtBQUNBLFFBQVEsaUVBQWdCLFNBQVMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILDhCQUE4QjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SCxnQkFBZ0I7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3QkFBd0I7QUFDbEU7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG9CQUFvQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1Qix3REFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItZXRoZXJzY2FuLmpzPzE1YzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgW1tsaW5rLWV0aGVyc2Nhbl1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBhIGNvbWJpbmF0aW9uIG9mIEpTT04tUlBDIGFuZCBjdXN0b20gQVBJXG4gKiAgZW5kcG9pbnRzLlxuICpcbiAqICAqKlN1cHBvcnRlZCBOZXR3b3JrcyoqXG4gKlxuICogIC0gRXRoZXJldW0gTWFpbm5ldCAoYGBtYWlubmV0YGApXG4gKiAgLSBHb2VybGkgVGVzdG5ldCAoYGBnb2VybGlgYClcbiAqICAtIFNlcG9saWEgVGVzdG5ldCAoYGBzZXBvbGlhYGApXG4gKiAgLSBIb2xlc2t5IFRlc3RuZXQgKGBgaG9sZXNreWBgKVxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcbiAqICAtIEFyYml0cnVtIEdvZXJsaSBUZXN0bmV0IChgYGFyYml0cnVtLWdvZXJsaWBgKVxuICogIC0gQmFzZSAoYGBiYXNlYGApXG4gKiAgLSBCYXNlIFNlcG9saWEgVGVzdG5ldCAoYGBiYXNlLXNlcG9saWFgYClcbiAqICAtIEJOQiBTbWFydCBDaGFpbiBNYWlubmV0IChgYGJuYmBgKVxuICogIC0gQk5CIFNtYXJ0IENoYWluIFRlc3RuZXQgKGBgYm5idGBgKVxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcbiAqICAtIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0IChgYG9wdGltaXNtLWdvZXJsaWBgKVxuICogIC0gUG9seWdvbiAoYGBtYXRpY2BgKVxuICogIC0gUG9seWdvbiBNdW1iYWkgVGVzdG5ldCAoYGBtYXRpYy1tdW1iYWlgYClcbiAqICAtIFBvbHlnb24gQW1veSBUZXN0bmV0IChgYG1hdGljLWFtb3lgYClcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpFdGhlcnNjYW4gIFtwcm92aWRlcnMtZXRoZXJzY2FuXVxuICovXG5pbXBvcnQgeyBBYmlDb2RlciB9IGZyb20gXCIuLi9hYmkvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5LCBUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgaGV4bGlmeSwgdG9RdWFudGl0eSwgRmV0Y2hSZXF1ZXN0LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0Vycm9yLCBcbi8vICAgIHBhcnNlVW5pdHMsXG50b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFic3RyYWN0UHJvdmlkZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcbmltcG9ydCB7IE5ldHdvcmtQbHVnaW4gfSBmcm9tIFwiLi9wbHVnaW5zLW5ldHdvcmsuanNcIjtcbmltcG9ydCB7IHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9jb21tdW5pdHkuanNcIjtcbmNvbnN0IFRIUk9UVExFID0gMjAwMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmNvbnN0IEV0aGVyc2NhblBsdWdpbklkID0gXCJvcmcuZXRoZXJzLnBsdWdpbnMucHJvdmlkZXIuRXRoZXJzY2FuXCI7XG4vKipcbiAqICBBIE5ldHdvcmsgY2FuIGluY2x1ZGUgYW4gKipFdGhlcnNjYW5QbHVnaW4qKiB0byBwcm92aWRlXG4gKiAgYSBjdXN0b20gYmFzZSBVUkwuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6RXRoZXJzY2FuXG4gKi9cbmV4cG9ydCBjbGFzcyBFdGhlcnNjYW5QbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIEV0aGVyc2NhbiBBUEkgYmFzZSBVUkwuXG4gICAgICovXG4gICAgYmFzZVVybDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkV0aGVyc2NhblByb3ZpZGVyKiogd2hpY2ggd2lsbCB1c2VcbiAgICAgKiAgJSViYXNlVXJsJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmFzZVVybCkge1xuICAgICAgICBzdXBlcihFdGhlcnNjYW5QbHVnaW5JZCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBiYXNlVXJsIH0pO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFdGhlcnNjYW5QbHVnaW4odGhpcy5iYXNlVXJsKTtcbiAgICB9XG59XG5jb25zdCBza2lwS2V5cyA9IFtcImVuYWJsZUNjaXBSZWFkXCJdO1xubGV0IG5leHRJZCA9IDE7XG4vKipcbiAqICBUaGUgKipFdGhlcnNjYW5CYXNlUHJvdmlkZXIqKiBpcyB0aGUgc3VwZXItY2xhc3Mgb2ZcbiAqICBbW0V0aGVyc2NhblByb3ZpZGVyXV0sIHdoaWNoIHNob3VsZCBnZW5lcmFsbHkgYmUgdXNlZCBpbnN0ZWFkLlxuICpcbiAqICBTaW5jZSB0aGUgKipFdGhlcnNjYW5Qcm92aWRlcioqIGluY2x1ZGVzIGFkZGl0aW9uYWwgY29kZSBmb3JcbiAqICBbW0NvbnRyYWN0XV0gYWNjZXNzLCBpbiAvL3JhcmUgY2FzZXMvLyB0aGF0IGNvbnRyYWN0cyBhcmUgbm90XG4gKiAgdXNlZCwgdGhpcyBjbGFzcyBjYW4gcmVkdWNlIGNvZGUgc2l6ZS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpFdGhlcnNjYW5cbiAqL1xuZXhwb3J0IGNsYXNzIEV0aGVyc2NhblByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgbmV0d29yay5cbiAgICAgKi9cbiAgICBuZXR3b3JrO1xuICAgIC8qKlxuICAgICAqICBUaGUgQVBJIGtleSBvciBudWxsIGlmIHVzaW5nIHRoZSBjb21tdW5pdHkgcHJvdmlkZWQgYmFuZHdpZHRoLlxuICAgICAqL1xuICAgIGFwaUtleTtcbiAgICAjcGx1Z2luO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRXRoZXJzY2FuQmFzZVByb3ZpZGVyKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIF9hcGlLZXkpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gKF9hcGlLZXkgIT0gbnVsbCkgPyBfYXBpS2V5IDogbnVsbDtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIHRoaXMuI3BsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKEV0aGVyc2NhblBsdWdpbklkKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFwaUtleSwgbmV0d29yayB9KTtcbiAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBuZXR3b3JrIGlzIHN1cHBvcnRlZCBieSBFdGhlcnNjYW5cbiAgICAgICAgdGhpcy5nZXRCYXNlVXJsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBiYXNlIFVSTC5cbiAgICAgKlxuICAgICAqICBJZiBhbiBbW0V0aGVyc2NhblBsdWdpbl1dIGlzIGNvbmZpZ3VyZWQgb24gdGhlXG4gICAgICogIFtbRXRoZXJzY2FuQmFzZVByb3ZpZGVyX25ldHdvcmtdXSwgcmV0dXJucyB0aGUgcGx1Z2luJ3NcbiAgICAgKiAgYmFzZVVybC5cbiAgICAgKi9cbiAgICBnZXRCYXNlVXJsKCkge1xuICAgICAgICBpZiAodGhpcy4jcGx1Z2luKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcGx1Z2luLmJhc2VVcmw7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLm5ldHdvcmsubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktZ29lcmxpLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLXNlcG9saWEuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwiaG9sZXNreVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktaG9sZXNreS5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkuYXJiaXNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1nb2VybGlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWdvZXJsaS5hcmJpc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLmJhc2VzY2FuLm9yZ1wiO1xuICAgICAgICAgICAgY2FzZSBcImJhc2Utc2Vwb2xpYVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktc2Vwb2xpYS5iYXNlc2Nhbi5vcmdcIjtcbiAgICAgICAgICAgIGNhc2UgXCJibmJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLmJzY3NjYW4uY29tXCI7XG4gICAgICAgICAgICBjYXNlIFwiYm5idFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktdGVzdG5ldC5ic2NzY2FuLmNvbVwiO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5wb2x5Z29uc2Nhbi5jb21cIjtcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpYy1hbW95XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1hbW95LnBvbHlnb25zY2FuLmNvbVwiO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktdGVzdG5ldC5wb2x5Z29uc2Nhbi5jb21cIjtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWdvZXJsaS1vcHRpbWlzdGljLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCB0aGlzLm5ldHdvcmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgVVJMIGZvciB0aGUgJSVtb2R1bGUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBnZXRVcmwobW9kdWxlLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBPYmplY3Qua2V5cyhwYXJhbXMpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWNjdW0gKz0gYCYke2tleX09JHt2YWx1ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gKCh0aGlzLmFwaUtleSkgPyBgJmFwaWtleT0ke3RoaXMuYXBpS2V5fWAgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0QmFzZVVybCgpfS9hcGk/bW9kdWxlPSR7bW9kdWxlfSR7cXVlcnl9JHthcGlLZXl9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFVSTCBmb3IgdXNpbmcgUE9TVCByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBnZXRQb3N0VXJsKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRCYXNlVXJsKCl9L2FwaWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIGZvciB1c2luZyBQT1NUIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIGdldFBvc3REYXRhKG1vZHVsZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHBhcmFtcy5hcGlrZXkgPSB0aGlzLmFwaUtleTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgYXN5bmMgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXN1bHQgb2YgY2FsbGluZyAlJW1vZHVsZSUlIHdpdGggJSVwYXJhbXMlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXBvc3QlJSwgdGhlIHJlcXVlc3QgaXMgbWFkZSBhcyBhIFBPU1QgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaChtb2R1bGUsIHBhcmFtcywgcG9zdCkge1xuICAgICAgICBjb25zdCBpZCA9IG5leHRJZCsrO1xuICAgICAgICBjb25zdCB1cmwgPSAocG9zdCA/IHRoaXMuZ2V0UG9zdFVybCgpIDogdGhpcy5nZXRVcmwobW9kdWxlLCBwYXJhbXMpKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChwb3N0ID8gdGhpcy5nZXRQb3N0RGF0YShtb2R1bGUsIHBhcmFtcykgOiBudWxsKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJlcXVlc3RcIiwgaWQsIHVybCwgcGF5bG9hZDogcGF5bG9hZCB9KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QodXJsKTtcbiAgICAgICAgcmVxdWVzdC5zZXRUaHJvdHRsZVBhcmFtcyh7IHNsb3RJbnRlcnZhbDogMTAwMCB9KTtcbiAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSAocmVxLCByZXNwLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbW11bml0eVJlc291cmNlKCkpIHtcbiAgICAgICAgICAgICAgICBzaG93VGhyb3R0bGVNZXNzYWdlKFwiRXRoZXJzY2FuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5wcm9jZXNzRnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UuaGFzQm9keSgpID8gSlNPTi5wYXJzZSh0b1V0ZjhTdHJpbmcocmVzcG9uc2UuYm9keSkpIDoge307XG4gICAgICAgICAgICBjb25zdCB0aHJvdHRsZSA9ICgodHlwZW9mIChyZXN1bHQucmVzdWx0KSA9PT0gXCJzdHJpbmdcIikgPyByZXN1bHQucmVzdWx0IDogXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmF0ZSBsaW1pdFwiKSA+PSAwO1xuICAgICAgICAgICAgaWYgKG1vZHVsZSA9PT0gXCJwcm94eVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBKU09OIHJlc3BvbnNlIGluZGljYXRlcyB3ZSBhcmUgYmVpbmcgdGhyb3R0bGVkXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3RhdHVzID09IDAgJiYgcmVzdWx0Lm1lc3NhZ2UgPT0gXCJOT1RPS1wiICYmIHRocm90dGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVhc29uOiBcInByb3h5LU5PVE9LXCIsIGVycm9yOiByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcihyZXN1bHQucmVzdWx0LCBUSFJPVFRMRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRocm90dGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVhc29uOiBcIm51bGwgcmVzdWx0XCIsIGVycm9yOiByZXN1bHQucmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS50aHJvd1Rocm90dGxlRXJyb3IocmVzdWx0LnJlc3VsdCwgVEhST1RUTEUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIpO1xuICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0gT2JqZWN0LmtleXMocGF5bG9hZCkubWFwKChrKSA9PiBgJHtrfT0ke3BheWxvYWRba119YCkuam9pbihcIiZcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRXJyb3JcIiwgaWQsIGVycm9yLCByZWFzb246IFwiYXNzZXJ0T2tcIiB9KTtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBlcnJvclwiLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2UuaGFzQm9keSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRXJyb3JcIiwgaWQsIGVycm9yOiBcIm1pc3NpbmcgYm9keVwiLCByZWFzb246IFwibnVsbCBib2R5XCIgfSk7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwibWlzc2luZyByZXNwb25zZVwiLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UodG9VdGY4U3RyaW5nKHJlc3BvbnNlLmJvZHkpKTtcbiAgICAgICAgaWYgKG1vZHVsZSA9PT0gXCJwcm94eVwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmpzb25ycGMgIT0gXCIyLjBcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVzdWx0LCByZWFzb246IFwiaW52YWxpZCBKU09OLVJQQ1wiIH0pO1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJpbnZhbGlkIEpTT04tUlBDIHJlc3BvbnNlIChtaXNzaW5nIGpzb25ycGM9JzIuMCcpXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGluZm86IHsgcmVzdWx0IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVycm9yXCIsIGlkLCByZXN1bHQsIHJlYXNvbjogXCJKU09OLVJQQyBlcnJvclwiIH0pO1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJlcnJvciByZXNwb25zZVwiLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlLCBpbmZvOiB7IHJlc3VsdCB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJlcXVlc3RcIiwgaWQsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2V0TG9ncywgZ2V0SGlzdG9yeSBoYXZlIHdlaXJkIHN1Y2Nlc3MgcmVzcG9uc2VzXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PSAwICYmIChyZXN1bHQubWVzc2FnZSA9PT0gXCJObyByZWNvcmRzIGZvdW5kXCIgfHwgcmVzdWx0Lm1lc3NhZ2UgPT09IFwiTm8gdHJhbnNhY3Rpb25zIGZvdW5kXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJlcXVlc3RcIiwgaWQsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IDEgfHwgKHR5cGVvZiAocmVzdWx0Lm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmICFyZXN1bHQubWVzc2FnZS5tYXRjaCgvXk9LLykpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVycm9yXCIsIGlkLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImVycm9yIHJlc3BvbnNlXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGluZm86IHsgcmVzdWx0IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUmVxdWVzdFwiLCBpZCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgJSV0cmFuc2FjdGlvbiUlIG5vcm1hbGl6ZWQgZm9yIHRoZSBFdGhlcnNjYW4gQVBJLlxuICAgICAqL1xuICAgIF9nZXRUcmFuc2FjdGlvblBvc3REYXRhKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChza2lwS2V5cy5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdHJhbnNhY3Rpb25ba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiICYmIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImJsb2NrVGFnXCIgJiYgdmFsdWUgPT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFF1YW50aXR5LXR5cGVzIHJlcXVpcmUgbm8gbGVhZGluZyB6ZXJvLCB1bmxlc3MgMFxuICAgICAgICAgICAgaWYgKHsgdHlwZTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBtYXhGZWVQZXJHczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsIG5vbmNlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9W2tleV0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvUXVhbnRpdHkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImFjY2Vzc0xpc3RcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCJbXCIgKyBhY2Nlc3NMaXN0aWZ5KHZhbHVlKS5tYXAoKHNldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHthZGRyZXNzOlwiJHtzZXQuYWRkcmVzc31cIixzdG9yYWdlS2V5czpbXCIke3NldC5zdG9yYWdlS2V5cy5qb2luKCdcIixcIicpfVwiXX1gO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IHVwZGF0ZSB0aGlzIG9uY2UgdGhlIEFQSSBzdXBwb3J0cyBibG9ic1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJFdGhlcnNjYW4gQVBJIGRvZXMgbm90IHN1cHBvcnQgYmxvYlZlcnNpb25lZEhhc2hlc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IHRyYW5zYWN0aW9uIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaHJvd3MgdGhlIG5vcm1hbGl6ZWQgRXRoZXJzY2FuIGVycm9yLlxuICAgICAqL1xuICAgIF9jaGVja0Vycm9yKHJlcSwgZXJyb3IsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIFB1bGwgYW55IG1lc3NhZ2Ugb3V0IGlmLCBwb3NzaWJsZVxuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIlNFUlZFUl9FUlJPUlwiKSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFuIGVycm9yIGVtaXR0ZWQgYnkgYSBwcm94eSBjYWxsXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5pbmZvLnJlc3VsdC5lcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLmluZm8ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZS5tYXRjaCgvcmV2ZXJ0L2kpICYmIG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy9pKSkge1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogcmVxLnRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2V4ZWN1dGlvbiByZXZlcnRlZC9pKSkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZXJyb3IuaW5mby5yZXN1bHQuZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICBjb25zdCBlID0gQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24ocmVxLm1ldGhvZCwgcmVxLnRyYW5zYWN0aW9uLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBlLmluZm8gPSB7IHJlcXVlc3Q6IHJlcSwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbi5mcm9tKHJlcS5zaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50L2kpICYmIG1lc3NhZ2UubWF0Y2goL3VuZGVycHJpY2VkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzLykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9zYW1lIGhhc2ggd2FzIGFscmVhZHkgaW1wb3J0ZWR8dHJhbnNhY3Rpb24gbm9uY2UgaXMgdG9vIGxvd3xub25jZSB0b28gbG93LykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBcIk5PTkNFX0VYUElSRURcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWV0aGluZyB3ZSBjb3VsZCBub3QgcHJvY2Vzc1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgYXN5bmMgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcms7XG4gICAgfVxuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjaGFpbklkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV0d29yay5jaGFpbklkO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7IGFjdGlvbjogXCJldGhfYmxvY2tOdW1iZXJcIiB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwgeyBhY3Rpb246IFwiZXRoX2dhc1ByaWNlXCIgfSk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0UHJpb3JpdHlGZWVcIjpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyeSB1bnRpbCBFdGhlcnNjYW4gY29tcGxldGVzIHN1cHBvcnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrLm5hbWUgPT09IFwibWFpbm5ldFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjEwMDAwMDAwMDBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXR3b3JrLm5hbWUgPT09IFwib3B0aW1pc21cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIxMDAwMDAwXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWxsYmFjayBvbnRvIHRoZSBBYnN0cmFjdFByb3ZpZGVyIGRlZmF1bHRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogV29ya2luZyB3aXRoIEV0aGVyc2NhbiB0byBnZXQgdGhpcyBhZGRlZDpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdCA9IGF3YWl0IHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfbWF4UHJpb3JpdHlGZWVQZXJHYXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0O1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUdcIiwgZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKiBUaGlzIG1pZ2h0IGJlIHNhZmU7IGJ1dCBkdWUgdG8gcm91bmRpbmcgbmVpdGhlciBteXNlbGZcbiAgICAgICAgICAgICAgIG9yIEV0aGVyc2NhbiBhcmUgbmVjZXNzYXJpbHkgY29tZm9ydGFibGUgd2l0aCB0aGlzLiA6KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoKFwiZ2FzdHJhY2tlclwiLCB7IGFjdGlvbjogXCJnYXNvcmFjbGVcIiB9KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gcGFyc2VVbml0cyhyZXN1bHQuU2FmZUdhc1ByaWNlLCBcImd3ZWlcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUZlZSA9IHBhcnNlVW5pdHMocmVzdWx0LnN1Z2dlc3RCYXNlRmVlLCBcImd3ZWlcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlGZWUgPSBnYXNQcmljZSAtIGJhc2VGZWU7XG4gICAgICAgICAgICAgICAgaWYgKHByaW9yaXR5RmVlIDwgMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSBwcmlvcml0eSBmZWU7IGRlZmVyIHRvIGFic3RyYWN0IHByb3ZpZGVyIGRlZmF1bHRcIik7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJpb3JpdHlGZWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUdcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyBiYXNlLTEwIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwiYWNjb3VudFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJiYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlcS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0YWc6IHJlcS5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlcS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0YWc6IHJlcS5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlcS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0YWc6IHJlcS5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcmVxLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZXEucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRhZzogcmVxLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgaGV4OiByZXEuc2lnbmVkVHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICB9LCB0cnVlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrRXJyb3IocmVxLCBlcnJvciwgcmVxLnNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHJlcS5ibG9ja1RhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IChyZXEuaW5jbHVkZVRyYW5zYWN0aW9ucyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImdldEJsb2NrIGJ5IGJsb2NrSGFzaCBub3Qgc3VwcG9ydGVkIGJ5IEV0aGVyc2NhblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRCbG9jayhibG9ja0hhc2gpXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcmVxLmhhc2hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgdHhoYXNoOiByZXEuaGFzaFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjoge1xuICAgICAgICAgICAgICAgIGlmIChyZXEuYmxvY2tUYWcgIT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXRoZXJzY2FuUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBibG9ja1RhZyBmb3IgY2FsbFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zdERhdGEgPSB0aGlzLl9nZXRUcmFuc2FjdGlvblBvc3REYXRhKHJlcS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgcG9zdERhdGEubW9kdWxlID0gXCJwcm94eVwiO1xuICAgICAgICAgICAgICAgIHBvc3REYXRhLmFjdGlvbiA9IFwiZXRoX2NhbGxcIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaChcInByb3h5XCIsIHBvc3REYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0Vycm9yKHJlcSwgZXJyb3IsIHJlcS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3N0RGF0YSA9IHRoaXMuX2dldFRyYW5zYWN0aW9uUG9zdERhdGEocmVxLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBwb3N0RGF0YS5tb2R1bGUgPSBcInByb3h5XCI7XG4gICAgICAgICAgICAgICAgcG9zdERhdGEuYWN0aW9uID0gXCJldGhfZXN0aW1hdGVHYXNcIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaChcInByb3h5XCIsIHBvc3REYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0Vycm9yKHJlcSwgZXJyb3IsIHJlcS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkcyB0byBjb21wbGFpbiBpZiBtb3JlIHRoYW4gb25lIGFkZHJlc3MgaXMgcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnczogUmVjb3JkPHN0cmluZywgYW55PiA9IHsgYWN0aW9uOiBcImdldExvZ3NcIiB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci5mcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5mcm9tQmxvY2sgPSBjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLmZyb21CbG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9CbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvQmxvY2sgPSBjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLnRvQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5hZGRyZXNzID0gcGFyYW1zLmZpbHRlci5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBXZSBjYW4gaGFuZGxlIHNsaWdodGx5IG1vcmUgY29tcGxpY2F0ZWQgbG9ncyB1c2luZyB0aGUgbG9ncyBBUElcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MgJiYgcGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYyBjb3VudFwiLCBMb2dnZXIuRXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyB0b3BpY3M6IHBhcmFtcy5maWx0ZXIudG9waWNzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvcGljMCA9IHBhcmFtcy5maWx0ZXIudG9waWNzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZih0b3BpYzApICE9PSBcInN0cmluZ1wiIHx8IHRvcGljMC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYyBmb3JtYXRcIiwgTG9nZ2VyLkVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgdG9waWMwOiB0b3BpYzAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvcGljMCA9IHRvcGljMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ3M6IEFycmF5PGFueT4gPSBhd2FpdCB0aGlzLmZldGNoKFwibG9nc1wiLCBhcmdzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHR4SGFzaCA9PiBibG9ja0hhc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2tzOiB7IFt0YWc6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYW55IG1pc3NpbmcgYmxvY2tIYXNoIHRvIHRoZSBsb2dzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZyA9IGxvZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cuYmxvY2tIYXNoICE9IG51bGwpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5nZXRCbG9jayhsb2cuYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2xvZy5ibG9ja051bWJlcl0gPSBibG9jay5oYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmJsb2NrSGFzaCA9IGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wZXJmb3JtKHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgY3VycmVudCBwcmljZSBvZiBldGhlci5cbiAgICAgKlxuICAgICAqICBUaGlzIHJldHVybnMgYGAwYGAgb24gYW55IG5ldHdvcmsgb3RoZXIgdGhhbiBgYG1haW5uZXRgYC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRFdGhlclByaWNlKCkge1xuICAgICAgICBpZiAodGhpcy5uZXR3b3JrLm5hbWUgIT09IFwibWFpbm5ldFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KChhd2FpdCB0aGlzLmZldGNoKFwic3RhdHNcIiwgeyBhY3Rpb246IFwiZXRocHJpY2VcIiB9KSkuZXRodXNkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGEgW0NvbnRyYWN0XV0gZm9yICUlYWRkcmVzcyUlLCB1c2luZyB0aGVcbiAgICAgKiAgRXRoZXJzY2FuIEFQSSB0byByZXRyZWl2ZSB0aGUgQ29udHJhY3QgQUJJLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbnRyYWN0KF9hZGRyZXNzKSB7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhfYWRkcmVzcyk7XG4gICAgICAgIGlmIChpc1Byb21pc2UoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBhd2FpdCBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5mZXRjaChcImNvbnRyYWN0XCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiZ2V0YWJpXCIsIGFkZHJlc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWJpID0gSlNPTi5wYXJzZShyZXNwKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3QoYWRkcmVzcywgYWJpLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT0gbnVsbCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItZXRoZXJzY2FuLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-etherscan.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-fallback.js":
/*!****************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-fallback.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FallbackProvider: function() { return /* binding */ FallbackProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-provider.js */ \"../common/node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/**\n *  A **FallbackProvider** provides resilience, security and performance\n *  in a way that is customizable and configurable.\n *\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\n */\n\n\n\nconst BN_1 = BigInt(\"1\");\nconst BN_2 = BigInt(\"2\");\nfunction shuffle(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\nfunction getTime() { return (new Date()).getTime(); }\nfunction stringify(value) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof (value) === \"bigint\") {\n            return { type: \"bigint\", value: value.toString() };\n        }\n        return value;\n    });\n}\n;\nconst defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };\nconst defaultState = {\n    blockNumber: -2, requests: 0, lateResponses: 0, errorResponses: 0,\n    outOfSync: -1, unsupportedEvents: 0, rollingDuration: 0, score: 0,\n    _network: null, _updateNumber: null, _totalTime: 0,\n    _lastFatalError: null, _lastFatalErrorTimestamp: 0\n};\nasync function waitForSync(config, blockNumber) {\n    while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\n        if (!config._updateNumber) {\n            config._updateNumber = (async () => {\n                try {\n                    const blockNumber = await config.provider.getBlockNumber();\n                    if (blockNumber > config.blockNumber) {\n                        config.blockNumber = blockNumber;\n                    }\n                }\n                catch (error) {\n                    config.blockNumber = -2;\n                    config._lastFatalError = error;\n                    config._lastFatalErrorTimestamp = getTime();\n                }\n                config._updateNumber = null;\n            })();\n        }\n        await config._updateNumber;\n        config.outOfSync++;\n        if (config._lastFatalError) {\n            break;\n        }\n    }\n}\nfunction _normalize(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[\" + (value.map(_normalize)).join(\",\") + \"]\";\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return _normalize(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n        case \"number\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{\" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(\",\") + \"}\";\n        }\n    }\n    console.log(\"Could not serialize\", value);\n    throw new Error(\"Hmm...\");\n}\nfunction normalizeResult(method, value) {\n    if (\"error\" in value) {\n        const error = value.error;\n        let tag;\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n            tag = _normalize(Object.assign({}, error, {\n                shortMessage: undefined, reason: undefined, info: undefined\n            }));\n        }\n        else {\n            tag = _normalize(error);\n        }\n        return { tag, value: error };\n    }\n    const result = value.result;\n    return { tag: _normalize(result), value: result };\n}\n// This strategy picks the highest weight result, as long as the weight is\n// equal to or greater than quorum\nfunction checkQuorum(quorum, results) {\n    const tally = new Map();\n    for (const { value, tag, weight } of results) {\n        const t = tally.get(tag) || { value, weight: 0 };\n        t.weight += weight;\n        tally.set(tag, t);\n    }\n    let best = null;\n    for (const r of tally.values()) {\n        if (r.weight >= quorum && (!best || r.weight > best.weight)) {\n            best = r;\n        }\n    }\n    if (best) {\n        return best.value;\n    }\n    return undefined;\n}\nfunction getMedian(quorum, results) {\n    let resultWeight = 0;\n    const errorMap = new Map();\n    let bestError = null;\n    const values = [];\n    for (const { value, tag, weight } of results) {\n        if (value instanceof Error) {\n            const e = errorMap.get(tag) || { value, weight: 0 };\n            e.weight += weight;\n            errorMap.set(tag, e);\n            if (bestError == null || e.weight > bestError.weight) {\n                bestError = e;\n            }\n        }\n        else {\n            values.push(BigInt(value));\n            resultWeight += weight;\n        }\n    }\n    if (resultWeight < quorum) {\n        // We have quorum for an error\n        if (bestError && bestError.weight >= quorum) {\n            return bestError.value;\n        }\n        // We do not have quorum for a result\n        return undefined;\n    }\n    // Get the sorted values\n    values.sort((a, b) => ((a < b) ? -1 : (b > a) ? 1 : 0));\n    const mid = Math.floor(values.length / 2);\n    // Odd-length; take the middle value\n    if (values.length % 2) {\n        return values[mid];\n    }\n    // Even length; take the ceiling of the mean of the center two values\n    return (values[mid - 1] + values[mid] + BN_1) / BN_2;\n}\nfunction getAnyResult(quorum, results) {\n    // If any value or error meets quorum, that is our preferred result\n    const result = checkQuorum(quorum, results);\n    if (result !== undefined) {\n        return result;\n    }\n    // Otherwise, do we have any result?\n    for (const r of results) {\n        if (r.value) {\n            return r.value;\n        }\n    }\n    // Nope!\n    return undefined;\n}\nfunction getFuzzyMode(quorum, results) {\n    if (quorum === 1) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(getMedian(quorum, results), \"%internal\");\n    }\n    const tally = new Map();\n    const add = (result, weight) => {\n        const t = tally.get(result) || { result, weight: 0 };\n        t.weight += weight;\n        tally.set(result, t);\n    };\n    for (const { weight, value } of results) {\n        const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\n        add(r - 1, weight);\n        add(r, weight);\n        add(r + 1, weight);\n    }\n    let bestWeight = 0;\n    let bestResult = undefined;\n    for (const { weight, result } of tally.values()) {\n        // Use this result, if this result meets quorum and has either:\n        // - a better weight\n        // - or equal weight, but the result is larger\n        if (weight >= quorum && (weight > bestWeight || (bestResult != null && weight === bestWeight && result > bestResult))) {\n            bestWeight = weight;\n            bestResult = result;\n        }\n    }\n    return bestResult;\n}\n/**\n *  A **FallbackProvider** manages several [[Providers]] providing\n *  resilience by switching between slow or misbehaving nodes, security\n *  by requiring multiple backends to aggree and performance by allowing\n *  faster backends to respond earlier.\n *\n */\nclass FallbackProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_1__.AbstractProvider {\n    /**\n     *  The number of backends that must agree on a value before it is\n     *  accpeted.\n     */\n    quorum;\n    /**\n     *  @_ignore:\n     */\n    eventQuorum;\n    /**\n     *  @_ignore:\n     */\n    eventWorkers;\n    #configs;\n    #height;\n    #initialSyncPromise;\n    /**\n     *  Creates a new **FallbackProvider** with %%providers%% connected to\n     *  %%network%%.\n     *\n     *  If a [[Provider]] is included in %%providers%%, defaults are used\n     *  for the configuration.\n     */\n    constructor(providers, network, options) {\n        super(network, options);\n        this.#configs = providers.map((p) => {\n            if (p instanceof _abstract_provider_js__WEBPACK_IMPORTED_MODULE_1__.AbstractProvider) {\n                return Object.assign({ provider: p }, defaultConfig, defaultState);\n            }\n            else {\n                return Object.assign({}, defaultConfig, p, defaultState);\n            }\n        });\n        this.#height = -2;\n        this.#initialSyncPromise = null;\n        if (options && options.quorum != null) {\n            this.quorum = options.quorum;\n        }\n        else {\n            this.quorum = Math.ceil(this.#configs.reduce((accum, config) => {\n                accum += config.weight;\n                return accum;\n            }, 0) / 2);\n        }\n        this.eventQuorum = 1;\n        this.eventWorkers = 1;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.quorum <= this.#configs.reduce((a, c) => (a + c.weight), 0), \"quorum exceed provider weight\", \"quorum\", this.quorum);\n    }\n    get providerConfigs() {\n        return this.#configs.map((c) => {\n            const result = Object.assign({}, c);\n            for (const key in result) {\n                if (key[0] === \"_\") {\n                    delete result[key];\n                }\n            }\n            return result;\n        });\n    }\n    async _detectNetwork() {\n        return _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(await this._perform({ method: \"chainId\" })));\n    }\n    // @TODO: Add support to select providers to be the event subscriber\n    //_getSubscriber(sub: Subscription): Subscriber {\n    //    throw new Error(\"@TODO\");\n    //}\n    /**\n     *  Transforms a %%req%% into the correct method call on %%provider%%.\n     */\n    async _translatePerform(provider, req) {\n        switch (req.method) {\n            case \"broadcastTransaction\":\n                return await provider.broadcastTransaction(req.signedTransaction);\n            case \"call\":\n                return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));\n            case \"chainId\":\n                return (await provider.getNetwork()).chainId;\n            case \"estimateGas\":\n                return await provider.estimateGas(req.transaction);\n            case \"getBalance\":\n                return await provider.getBalance(req.address, req.blockTag);\n            case \"getBlock\": {\n                const block = (\"blockHash\" in req) ? req.blockHash : req.blockTag;\n                return await provider.getBlock(block, req.includeTransactions);\n            }\n            case \"getBlockNumber\":\n                return await provider.getBlockNumber();\n            case \"getCode\":\n                return await provider.getCode(req.address, req.blockTag);\n            case \"getGasPrice\":\n                return (await provider.getFeeData()).gasPrice;\n            case \"getPriorityFee\":\n                return (await provider.getFeeData()).maxPriorityFeePerGas;\n            case \"getLogs\":\n                return await provider.getLogs(req.filter);\n            case \"getStorage\":\n                return await provider.getStorage(req.address, req.position, req.blockTag);\n            case \"getTransaction\":\n                return await provider.getTransaction(req.hash);\n            case \"getTransactionCount\":\n                return await provider.getTransactionCount(req.address, req.blockTag);\n            case \"getTransactionReceipt\":\n                return await provider.getTransactionReceipt(req.hash);\n            case \"getTransactionResult\":\n                return await provider.getTransactionResult(req.hash);\n        }\n    }\n    // Grab the next (random) config that is not already part of\n    // the running set\n    #getNextConfig(running) {\n        // @TODO: Maybe do a check here to favour (heavily) providers that\n        //        do not require waitForSync and disfavour providers that\n        //        seem down-ish or are behaving slowly\n        const configs = Array.from(running).map((r) => r.config);\n        // Shuffle the states, sorted by priority\n        const allConfigs = this.#configs.slice();\n        shuffle(allConfigs);\n        allConfigs.sort((a, b) => (a.priority - b.priority));\n        for (const config of allConfigs) {\n            if (config._lastFatalError) {\n                continue;\n            }\n            if (configs.indexOf(config) === -1) {\n                return config;\n            }\n        }\n        return null;\n    }\n    // Adds a new runner (if available) to running.\n    #addRunner(running, req) {\n        const config = this.#getNextConfig(running);\n        // No runners available\n        if (config == null) {\n            return null;\n        }\n        // Create a new runner\n        const runner = {\n            config, result: null, didBump: false,\n            perform: null, staller: null\n        };\n        const now = getTime();\n        // Start performing this operation\n        runner.perform = (async () => {\n            try {\n                config.requests++;\n                const result = await this._translatePerform(config.provider, req);\n                runner.result = { result };\n            }\n            catch (error) {\n                config.errorResponses++;\n                runner.result = { error };\n            }\n            const dt = (getTime() - now);\n            config._totalTime += dt;\n            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\n            runner.perform = null;\n        })();\n        // Start a staller; when this times out, it's time to force\n        // kicking off another runner because we are taking too long\n        runner.staller = (async () => {\n            await stall(config.stallTimeout);\n            runner.staller = null;\n        })();\n        running.add(runner);\n        return runner;\n    }\n    // Initializes the blockNumber and network for each runner and\n    // blocks until initialized\n    async #initialSync() {\n        let initialSync = this.#initialSyncPromise;\n        if (!initialSync) {\n            const promises = [];\n            this.#configs.forEach((config) => {\n                promises.push((async () => {\n                    await waitForSync(config, 0);\n                    if (!config._lastFatalError) {\n                        config._network = await config.provider.getNetwork();\n                    }\n                })());\n            });\n            this.#initialSyncPromise = initialSync = (async () => {\n                // Wait for all providers to have a block number and network\n                await Promise.all(promises);\n                // Check all the networks match\n                let chainId = null;\n                for (const config of this.#configs) {\n                    if (config._lastFatalError) {\n                        continue;\n                    }\n                    const network = (config._network);\n                    if (chainId == null) {\n                        chainId = network.chainId;\n                    }\n                    else if (network.chainId !== chainId) {\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\n                            operation: \"new FallbackProvider\"\n                        });\n                    }\n                }\n            })();\n        }\n        await initialSync;\n    }\n    async #checkQuorum(running, req) {\n        // Get all the result objects\n        const results = [];\n        for (const runner of running) {\n            if (runner.result != null) {\n                const { tag, value } = normalizeResult(req.method, runner.result);\n                results.push({ tag, value, weight: runner.config.weight });\n            }\n        }\n        // Are there enough results to event meet quorum?\n        if (results.reduce((a, r) => (a + r.weight), 0) < this.quorum) {\n            return undefined;\n        }\n        switch (req.method) {\n            case \"getBlockNumber\": {\n                // We need to get the bootstrap block height\n                if (this.#height === -2) {\n                    this.#height = Math.ceil((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(getMedian(this.quorum, this.#configs.filter((c) => (!c._lastFatalError)).map((c) => ({\n                        value: c.blockNumber,\n                        tag: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(c.blockNumber).toString(),\n                        weight: c.weight\n                    })))));\n                }\n                // Find the mode across all the providers, allowing for\n                // a little drift between block heights\n                const mode = getFuzzyMode(this.quorum, results);\n                if (mode === undefined) {\n                    return undefined;\n                }\n                if (mode > this.#height) {\n                    this.#height = mode;\n                }\n                return this.#height;\n            }\n            case \"getGasPrice\":\n            case \"getPriorityFee\":\n            case \"estimateGas\":\n                return getMedian(this.quorum, results);\n            case \"getBlock\":\n                // Pending blocks are in the mempool and already\n                // quite untrustworthy; just grab anything\n                if (\"blockTag\" in req && req.blockTag === \"pending\") {\n                    return getAnyResult(this.quorum, results);\n                }\n                return checkQuorum(this.quorum, results);\n            case \"call\":\n            case \"chainId\":\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n            case \"getStorage\":\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n            case \"getLogs\":\n                return checkQuorum(this.quorum, results);\n            case \"broadcastTransaction\":\n                return getAnyResult(this.quorum, results);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\n            operation: `_perform(${stringify(req.method)})`\n        });\n    }\n    async #waitForQuorum(running, req) {\n        if (running.size === 0) {\n            throw new Error(\"no runners?!\");\n        }\n        // Any promises that are interesting to watch for; an expired stall\n        // or a successful perform\n        const interesting = [];\n        let newRunners = 0;\n        for (const runner of running) {\n            // No responses, yet; keep an eye on it\n            if (runner.perform) {\n                interesting.push(runner.perform);\n            }\n            // Still stalling...\n            if (runner.staller) {\n                interesting.push(runner.staller);\n                continue;\n            }\n            // This runner has already triggered another runner\n            if (runner.didBump) {\n                continue;\n            }\n            // Got a response (result or error) or stalled; kick off another runner\n            runner.didBump = true;\n            newRunners++;\n        }\n        // Check if we have reached quorum on a result (or error)\n        const value = await this.#checkQuorum(running, req);\n        if (value !== undefined) {\n            if (value instanceof Error) {\n                throw value;\n            }\n            return value;\n        }\n        // Add any new runners, because a staller timed out or a result\n        // or error response came in.\n        for (let i = 0; i < newRunners; i++) {\n            this.#addRunner(running, req);\n        }\n        // All providers have returned, and we have no result\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\n            request: \"%sub-requests\",\n            info: { request: req, results: Array.from(running).map((r) => stringify(r.result)) }\n        });\n        // Wait for someone to either complete its perform or stall out\n        await Promise.race(interesting);\n        // This is recursive, but at worst case the depth is 2x the\n        // number of providers (each has a perform and a staller)\n        return await this.#waitForQuorum(running, req);\n    }\n    async _perform(req) {\n        // Broadcasting a transaction is rare (ish) and already incurs\n        // a cost on the user, so spamming is safe-ish. Just send it to\n        // every backend.\n        if (req.method === \"broadcastTransaction\") {\n            // Once any broadcast provides a positive result, use it. No\n            // need to wait for anyone else\n            const results = this.#configs.map((c) => null);\n            const broadcasts = this.#configs.map(async ({ provider, weight }, index) => {\n                try {\n                    const result = await provider._perform(req);\n                    results[index] = Object.assign(normalizeResult(req.method, { result }), { weight });\n                }\n                catch (error) {\n                    results[index] = Object.assign(normalizeResult(req.method, { error }), { weight });\n                }\n            });\n            // As each promise finishes...\n            while (true) {\n                // Check for a valid broadcast result\n                const done = results.filter((r) => (r != null));\n                for (const { value } of done) {\n                    if (!(value instanceof Error)) {\n                        return value;\n                    }\n                }\n                // Check for a legit broadcast error (one which we cannot\n                // recover from; some nodes may return the following red\n                // herring events:\n                // - alredy seend (UNKNOWN_ERROR)\n                // - NONCE_EXPIRED\n                // - REPLACEMENT_UNDERPRICED\n                const result = checkQuorum(this.quorum, results.filter((r) => (r != null)));\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(result, \"INSUFFICIENT_FUNDS\")) {\n                    throw result;\n                }\n                // Kick off the next provider (if any)\n                const waiting = broadcasts.filter((b, i) => (results[i] == null));\n                if (waiting.length === 0) {\n                    break;\n                }\n                await Promise.race(waiting);\n            }\n            // Use standard quorum results; any result was returned above,\n            // so this will find any error that met quorum if any\n            const result = getAnyResult(this.quorum, results);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\n                request: \"%sub-requests\",\n                info: { request: req, results: results.map(stringify) }\n            });\n            if (result instanceof Error) {\n                throw result;\n            }\n            return result;\n        }\n        await this.#initialSync();\n        // Bootstrap enough runners to meet quorum\n        const running = new Set();\n        let inflightQuorum = 0;\n        while (true) {\n            const runner = this.#addRunner(running, req);\n            if (runner == null) {\n                break;\n            }\n            inflightQuorum += runner.config.weight;\n            if (inflightQuorum >= this.quorum) {\n                break;\n            }\n        }\n        const result = await this.#waitForQuorum(running, req);\n        // Track requests sent to a provider that are still\n        // outstanding after quorum has been otherwise found\n        for (const runner of running) {\n            if (runner.perform && runner.result == null) {\n                runner.config.lateResponses++;\n            }\n        }\n        return result;\n    }\n    async destroy() {\n        for (const { provider } of this.#configs) {\n            provider.destroy();\n        }\n        super.destroy();\n    }\n}\n//# sourceMappingURL=provider-fallback.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItZmFsbGJhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwRjtBQUNoQztBQUNuQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQ0FBZ0M7QUFDdEU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCLGtCQUFrQixHQUFHLHFCQUFxQixpQkFBaUI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBTztBQUNuQiw2Q0FBNkM7QUFDN0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakMsa0JBQWtCLDBEQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQixtRUFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtRUFBZ0I7QUFDN0MsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLGdEQUFPLE1BQU0sMERBQVMsdUJBQXVCLG1CQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQkFBcUIsd0JBQXdCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBTTtBQUM5QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQywrQkFBK0IsMENBQTBDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBEQUFTO0FBQ3REO0FBQ0EsNkJBQTZCLDBEQUFTO0FBQ3RDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTTtBQUNkLG1DQUFtQyxzQkFBc0I7QUFDekQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNO0FBQ2Q7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQSxpRkFBaUYsUUFBUSxLQUFLLFFBQVE7QUFDdEc7QUFDQTtBQUNBLGlGQUFpRixPQUFPLEtBQUssUUFBUTtBQUNyRztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLFlBQVksdURBQU07QUFDbEI7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItZmFsbGJhY2suanM/NWVjYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBICoqRmFsbGJhY2tQcm92aWRlcioqIHByb3ZpZGVzIHJlc2lsaWVuY2UsIHNlY3VyaXR5IGFuZCBwZXJmb3JtYW5jZVxuICogIGluIGEgd2F5IHRoYXQgaXMgY3VzdG9taXphYmxlIGFuZCBjb25maWd1cmFibGUuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9mYWxsYmFjay1wcm92aWRlcjpGYWxsYmFjayBQcm92aWRlciBbYWJvdXQtZmFsbGJhY2stcHJvdmlkZXJdXG4gKi9cbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBpc0Vycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdFByb3ZpZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5jb25zdCBCTl8xID0gQmlnSW50KFwiMVwiKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoXCIyXCIpO1xuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgY29uc3QgdG1wID0gYXJyYXlbaV07XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XG4gICAgICAgIGFycmF5W2pdID0gdG1wO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pOyB9KTtcbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaWdpbnRcIiwgdmFsdWU6IHZhbHVlLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG47XG5jb25zdCBkZWZhdWx0Q29uZmlnID0geyBzdGFsbFRpbWVvdXQ6IDQwMCwgcHJpb3JpdHk6IDEsIHdlaWdodDogMSB9O1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIGJsb2NrTnVtYmVyOiAtMiwgcmVxdWVzdHM6IDAsIGxhdGVSZXNwb25zZXM6IDAsIGVycm9yUmVzcG9uc2VzOiAwLFxuICAgIG91dE9mU3luYzogLTEsIHVuc3VwcG9ydGVkRXZlbnRzOiAwLCByb2xsaW5nRHVyYXRpb246IDAsIHNjb3JlOiAwLFxuICAgIF9uZXR3b3JrOiBudWxsLCBfdXBkYXRlTnVtYmVyOiBudWxsLCBfdG90YWxUaW1lOiAwLFxuICAgIF9sYXN0RmF0YWxFcnJvcjogbnVsbCwgX2xhc3RGYXRhbEVycm9yVGltZXN0YW1wOiAwXG59O1xuYXN5bmMgZnVuY3Rpb24gd2FpdEZvclN5bmMoY29uZmlnLCBibG9ja051bWJlcikge1xuICAgIHdoaWxlIChjb25maWcuYmxvY2tOdW1iZXIgPCAwIHx8IGNvbmZpZy5ibG9ja051bWJlciA8IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIGlmICghY29uZmlnLl91cGRhdGVOdW1iZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdXBkYXRlTnVtYmVyID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IGNvbmZpZy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiBjb25maWcuYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5ibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9sYXN0RmF0YWxFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2xhc3RGYXRhbEVycm9yVGltZXN0YW1wID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWcuX3VwZGF0ZU51bWJlciA9IG51bGw7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNvbmZpZy5fdXBkYXRlTnVtYmVyO1xuICAgICAgICBjb25maWcub3V0T2ZTeW5jKys7XG4gICAgICAgIGlmIChjb25maWcuX2xhc3RGYXRhbEVycm9yKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJbXCIgKyAodmFsdWUubWFwKF9ub3JtYWxpemUpKS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mICh2YWx1ZS50b0pTT04pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIF9ub3JtYWxpemUodmFsdWUudG9KU09OKCkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwie1wiICsga2V5cy5tYXAoKGspID0+IGAke0pTT04uc3RyaW5naWZ5KGspfToke19ub3JtYWxpemUodmFsdWVba10pfWApLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJDb3VsZCBub3Qgc2VyaWFsaXplXCIsIHZhbHVlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIbW0uLi5cIik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZXN1bHQobWV0aG9kLCB2YWx1ZSkge1xuICAgIGlmIChcImVycm9yXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgbGV0IHRhZztcbiAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgIHRhZyA9IF9ub3JtYWxpemUoT2JqZWN0LmFzc2lnbih7fSwgZXJyb3IsIHtcbiAgICAgICAgICAgICAgICBzaG9ydE1lc3NhZ2U6IHVuZGVmaW5lZCwgcmVhc29uOiB1bmRlZmluZWQsIGluZm86IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFnID0gX25vcm1hbGl6ZShlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdGFnLCB2YWx1ZTogZXJyb3IgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsdWUucmVzdWx0O1xuICAgIHJldHVybiB7IHRhZzogX25vcm1hbGl6ZShyZXN1bHQpLCB2YWx1ZTogcmVzdWx0IH07XG59XG4vLyBUaGlzIHN0cmF0ZWd5IHBpY2tzIHRoZSBoaWdoZXN0IHdlaWdodCByZXN1bHQsIGFzIGxvbmcgYXMgdGhlIHdlaWdodCBpc1xuLy8gZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIHF1b3J1bVxuZnVuY3Rpb24gY2hlY2tRdW9ydW0ocXVvcnVtLCByZXN1bHRzKSB7XG4gICAgY29uc3QgdGFsbHkgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB7IHZhbHVlLCB0YWcsIHdlaWdodCB9IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgdCA9IHRhbGx5LmdldCh0YWcpIHx8IHsgdmFsdWUsIHdlaWdodDogMCB9O1xuICAgICAgICB0LndlaWdodCArPSB3ZWlnaHQ7XG4gICAgICAgIHRhbGx5LnNldCh0YWcsIHQpO1xuICAgIH1cbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCByIG9mIHRhbGx5LnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChyLndlaWdodCA+PSBxdW9ydW0gJiYgKCFiZXN0IHx8IHIud2VpZ2h0ID4gYmVzdC53ZWlnaHQpKSB7XG4gICAgICAgICAgICBiZXN0ID0gcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVzdCkge1xuICAgICAgICByZXR1cm4gYmVzdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldE1lZGlhbihxdW9ydW0sIHJlc3VsdHMpIHtcbiAgICBsZXQgcmVzdWx0V2VpZ2h0ID0gMDtcbiAgICBjb25zdCBlcnJvck1hcCA9IG5ldyBNYXAoKTtcbiAgICBsZXQgYmVzdEVycm9yID0gbnVsbDtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgdmFsdWUsIHRhZywgd2VpZ2h0IH0gb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZSA9IGVycm9yTWFwLmdldCh0YWcpIHx8IHsgdmFsdWUsIHdlaWdodDogMCB9O1xuICAgICAgICAgICAgZS53ZWlnaHQgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgZXJyb3JNYXAuc2V0KHRhZywgZSk7XG4gICAgICAgICAgICBpZiAoYmVzdEVycm9yID09IG51bGwgfHwgZS53ZWlnaHQgPiBiZXN0RXJyb3Iud2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYmVzdEVycm9yID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKEJpZ0ludCh2YWx1ZSkpO1xuICAgICAgICAgICAgcmVzdWx0V2VpZ2h0ICs9IHdlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0V2VpZ2h0IDwgcXVvcnVtKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgcXVvcnVtIGZvciBhbiBlcnJvclxuICAgICAgICBpZiAoYmVzdEVycm9yICYmIGJlc3RFcnJvci53ZWlnaHQgPj0gcXVvcnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdEVycm9yLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvIG5vdCBoYXZlIHF1b3J1bSBmb3IgYSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBzb3J0ZWQgdmFsdWVzXG4gICAgdmFsdWVzLnNvcnQoKGEsIGIpID0+ICgoYSA8IGIpID8gLTEgOiAoYiA+IGEpID8gMSA6IDApKTtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcbiAgICAvLyBPZGQtbGVuZ3RoOyB0YWtlIHRoZSBtaWRkbGUgdmFsdWVcbiAgICBpZiAodmFsdWVzLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1ttaWRdO1xuICAgIH1cbiAgICAvLyBFdmVuIGxlbmd0aDsgdGFrZSB0aGUgY2VpbGluZyBvZiB0aGUgbWVhbiBvZiB0aGUgY2VudGVyIHR3byB2YWx1ZXNcbiAgICByZXR1cm4gKHZhbHVlc1ttaWQgLSAxXSArIHZhbHVlc1ttaWRdICsgQk5fMSkgLyBCTl8yO1xufVxuZnVuY3Rpb24gZ2V0QW55UmVzdWx0KHF1b3J1bSwgcmVzdWx0cykge1xuICAgIC8vIElmIGFueSB2YWx1ZSBvciBlcnJvciBtZWV0cyBxdW9ydW0sIHRoYXQgaXMgb3VyIHByZWZlcnJlZCByZXN1bHRcbiAgICBjb25zdCByZXN1bHQgPSBjaGVja1F1b3J1bShxdW9ydW0sIHJlc3VsdHMpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGRvIHdlIGhhdmUgYW55IHJlc3VsdD9cbiAgICBmb3IgKGNvbnN0IHIgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAoci52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHIudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm9wZSFcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0RnV6enlNb2RlKHF1b3J1bSwgcmVzdWx0cykge1xuICAgIGlmIChxdW9ydW0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGdldE51bWJlcihnZXRNZWRpYW4ocXVvcnVtLCByZXN1bHRzKSwgXCIlaW50ZXJuYWxcIik7XG4gICAgfVxuICAgIGNvbnN0IHRhbGx5ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFkZCA9IChyZXN1bHQsIHdlaWdodCkgPT4ge1xuICAgICAgICBjb25zdCB0ID0gdGFsbHkuZ2V0KHJlc3VsdCkgfHwgeyByZXN1bHQsIHdlaWdodDogMCB9O1xuICAgICAgICB0LndlaWdodCArPSB3ZWlnaHQ7XG4gICAgICAgIHRhbGx5LnNldChyZXN1bHQsIHQpO1xuICAgIH07XG4gICAgZm9yIChjb25zdCB7IHdlaWdodCwgdmFsdWUgfSBvZiByZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IHIgPSBnZXROdW1iZXIodmFsdWUpO1xuICAgICAgICBhZGQociAtIDEsIHdlaWdodCk7XG4gICAgICAgIGFkZChyLCB3ZWlnaHQpO1xuICAgICAgICBhZGQociArIDEsIHdlaWdodCk7XG4gICAgfVxuICAgIGxldCBiZXN0V2VpZ2h0ID0gMDtcbiAgICBsZXQgYmVzdFJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IHsgd2VpZ2h0LCByZXN1bHQgfSBvZiB0YWxseS52YWx1ZXMoKSkge1xuICAgICAgICAvLyBVc2UgdGhpcyByZXN1bHQsIGlmIHRoaXMgcmVzdWx0IG1lZXRzIHF1b3J1bSBhbmQgaGFzIGVpdGhlcjpcbiAgICAgICAgLy8gLSBhIGJldHRlciB3ZWlnaHRcbiAgICAgICAgLy8gLSBvciBlcXVhbCB3ZWlnaHQsIGJ1dCB0aGUgcmVzdWx0IGlzIGxhcmdlclxuICAgICAgICBpZiAod2VpZ2h0ID49IHF1b3J1bSAmJiAod2VpZ2h0ID4gYmVzdFdlaWdodCB8fCAoYmVzdFJlc3VsdCAhPSBudWxsICYmIHdlaWdodCA9PT0gYmVzdFdlaWdodCAmJiByZXN1bHQgPiBiZXN0UmVzdWx0KSkpIHtcbiAgICAgICAgICAgIGJlc3RXZWlnaHQgPSB3ZWlnaHQ7XG4gICAgICAgICAgICBiZXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZXN0UmVzdWx0O1xufVxuLyoqXG4gKiAgQSAqKkZhbGxiYWNrUHJvdmlkZXIqKiBtYW5hZ2VzIHNldmVyYWwgW1tQcm92aWRlcnNdXSBwcm92aWRpbmdcbiAqICByZXNpbGllbmNlIGJ5IHN3aXRjaGluZyBiZXR3ZWVuIHNsb3cgb3IgbWlzYmVoYXZpbmcgbm9kZXMsIHNlY3VyaXR5XG4gKiAgYnkgcmVxdWlyaW5nIG11bHRpcGxlIGJhY2tlbmRzIHRvIGFnZ3JlZSBhbmQgcGVyZm9ybWFuY2UgYnkgYWxsb3dpbmdcbiAqICBmYXN0ZXIgYmFja2VuZHMgdG8gcmVzcG9uZCBlYXJsaWVyLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEZhbGxiYWNrUHJvdmlkZXIgZXh0ZW5kcyBBYnN0cmFjdFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiBiYWNrZW5kcyB0aGF0IG11c3QgYWdyZWUgb24gYSB2YWx1ZSBiZWZvcmUgaXQgaXNcbiAgICAgKiAgYWNjcGV0ZWQuXG4gICAgICovXG4gICAgcXVvcnVtO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBldmVudFF1b3J1bTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZXZlbnRXb3JrZXJzO1xuICAgICNjb25maWdzO1xuICAgICNoZWlnaHQ7XG4gICAgI2luaXRpYWxTeW5jUHJvbWlzZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZhbGxiYWNrUHJvdmlkZXIqKiB3aXRoICUlcHJvdmlkZXJzJSUgY29ubmVjdGVkIHRvXG4gICAgICogICUlbmV0d29yayUlLlxuICAgICAqXG4gICAgICogIElmIGEgW1tQcm92aWRlcl1dIGlzIGluY2x1ZGVkIGluICUlcHJvdmlkZXJzJSUsIGRlZmF1bHRzIGFyZSB1c2VkXG4gICAgICogIGZvciB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcnMsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI2NvbmZpZ3MgPSBwcm92aWRlcnMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFic3RyYWN0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHByb3ZpZGVyOiBwIH0sIGRlZmF1bHRDb25maWcsIGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZywgcCwgZGVmYXVsdFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2hlaWdodCA9IC0yO1xuICAgICAgICB0aGlzLiNpbml0aWFsU3luY1Byb21pc2UgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnF1b3J1bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnF1b3J1bSA9IG9wdGlvbnMucXVvcnVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5xdW9ydW0gPSBNYXRoLmNlaWwodGhpcy4jY29uZmlncy5yZWR1Y2UoKGFjY3VtLCBjb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bSArPSBjb25maWcud2VpZ2h0O1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIDApIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudFF1b3J1bSA9IDE7XG4gICAgICAgIHRoaXMuZXZlbnRXb3JrZXJzID0gMTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodGhpcy5xdW9ydW0gPD0gdGhpcy4jY29uZmlncy5yZWR1Y2UoKGEsIGMpID0+IChhICsgYy53ZWlnaHQpLCAwKSwgXCJxdW9ydW0gZXhjZWVkIHByb3ZpZGVyIHdlaWdodFwiLCBcInF1b3J1bVwiLCB0aGlzLnF1b3J1bSk7XG4gICAgfVxuICAgIGdldCBwcm92aWRlckNvbmZpZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjb25maWdzLm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5WzBdID09PSBcIl9cIikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKGdldEJpZ0ludChhd2FpdCB0aGlzLl9wZXJmb3JtKHsgbWV0aG9kOiBcImNoYWluSWRcIiB9KSkpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQWRkIHN1cHBvcnQgdG8gc2VsZWN0IHByb3ZpZGVycyB0byBiZSB0aGUgZXZlbnQgc3Vic2NyaWJlclxuICAgIC8vX2dldFN1YnNjcmliZXIoc3ViOiBTdWJzY3JpcHRpb24pOiBTdWJzY3JpYmVyIHtcbiAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICAvL31cbiAgICAvKipcbiAgICAgKiAgVHJhbnNmb3JtcyBhICUlcmVxJSUgaW50byB0aGUgY29ycmVjdCBtZXRob2QgY2FsbCBvbiAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgYXN5bmMgX3RyYW5zbGF0ZVBlcmZvcm0ocHJvdmlkZXIsIHJlcSkge1xuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihyZXEuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuY2FsbChPYmplY3QuYXNzaWduKHt9LCByZXEudHJhbnNhY3Rpb24sIHsgYmxvY2tUYWc6IHJlcS5ibG9ja1RhZyB9KSk7XG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpKS5jaGFpbklkO1xuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmVzdGltYXRlR2FzKHJlcS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKHJlcS5hZGRyZXNzLCByZXEuYmxvY2tUYWcpO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IChcImJsb2NrSGFzaFwiIGluIHJlcSkgPyByZXEuYmxvY2tIYXNoIDogcmVxLmJsb2NrVGFnO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRCbG9jayhibG9jaywgcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRDb2RlKHJlcS5hZGRyZXNzLCByZXEuYmxvY2tUYWcpO1xuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCkpLmdhc1ByaWNlO1xuICAgICAgICAgICAgY2FzZSBcImdldFByaW9yaXR5RmVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCkpLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhyZXEuZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldFN0b3JhZ2UocmVxLmFkZHJlc3MsIHJlcS5wb3NpdGlvbiwgcmVxLmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvbihyZXEuaGFzaCk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHJlcS5hZGRyZXNzLCByZXEuYmxvY2tUYWcpO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQocmVxLmhhc2gpO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVzdWx0KHJlcS5oYXNoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHcmFiIHRoZSBuZXh0IChyYW5kb20pIGNvbmZpZyB0aGF0IGlzIG5vdCBhbHJlYWR5IHBhcnQgb2ZcbiAgICAvLyB0aGUgcnVubmluZyBzZXRcbiAgICAjZ2V0TmV4dENvbmZpZyhydW5uaW5nKSB7XG4gICAgICAgIC8vIEBUT0RPOiBNYXliZSBkbyBhIGNoZWNrIGhlcmUgdG8gZmF2b3VyIChoZWF2aWx5KSBwcm92aWRlcnMgdGhhdFxuICAgICAgICAvLyAgICAgICAgZG8gbm90IHJlcXVpcmUgd2FpdEZvclN5bmMgYW5kIGRpc2Zhdm91ciBwcm92aWRlcnMgdGhhdFxuICAgICAgICAvLyAgICAgICAgc2VlbSBkb3duLWlzaCBvciBhcmUgYmVoYXZpbmcgc2xvd2x5XG4gICAgICAgIGNvbnN0IGNvbmZpZ3MgPSBBcnJheS5mcm9tKHJ1bm5pbmcpLm1hcCgocikgPT4gci5jb25maWcpO1xuICAgICAgICAvLyBTaHVmZmxlIHRoZSBzdGF0ZXMsIHNvcnRlZCBieSBwcmlvcml0eVxuICAgICAgICBjb25zdCBhbGxDb25maWdzID0gdGhpcy4jY29uZmlncy5zbGljZSgpO1xuICAgICAgICBzaHVmZmxlKGFsbENvbmZpZ3MpO1xuICAgICAgICBhbGxDb25maWdzLnNvcnQoKGEsIGIpID0+IChhLnByaW9yaXR5IC0gYi5wcmlvcml0eSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBhbGxDb25maWdzKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl9sYXN0RmF0YWxFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZ3MuaW5kZXhPZihjb25maWcpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEFkZHMgYSBuZXcgcnVubmVyIChpZiBhdmFpbGFibGUpIHRvIHJ1bm5pbmcuXG4gICAgI2FkZFJ1bm5lcihydW5uaW5nLCByZXEpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy4jZ2V0TmV4dENvbmZpZyhydW5uaW5nKTtcbiAgICAgICAgLy8gTm8gcnVubmVycyBhdmFpbGFibGVcbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcnVubmVyXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IHtcbiAgICAgICAgICAgIGNvbmZpZywgcmVzdWx0OiBudWxsLCBkaWRCdW1wOiBmYWxzZSxcbiAgICAgICAgICAgIHBlcmZvcm06IG51bGwsIHN0YWxsZXI6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBTdGFydCBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uXG4gICAgICAgIHJ1bm5lci5wZXJmb3JtID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnJlcXVlc3RzKys7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fdHJhbnNsYXRlUGVyZm9ybShjb25maWcucHJvdmlkZXIsIHJlcSk7XG4gICAgICAgICAgICAgICAgcnVubmVyLnJlc3VsdCA9IHsgcmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZXJyb3JSZXNwb25zZXMrKztcbiAgICAgICAgICAgICAgICBydW5uZXIucmVzdWx0ID0geyBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZHQgPSAoZ2V0VGltZSgpIC0gbm93KTtcbiAgICAgICAgICAgIGNvbmZpZy5fdG90YWxUaW1lICs9IGR0O1xuICAgICAgICAgICAgY29uZmlnLnJvbGxpbmdEdXJhdGlvbiA9IDAuOTUgKiBjb25maWcucm9sbGluZ0R1cmF0aW9uICsgMC4wNSAqIGR0O1xuICAgICAgICAgICAgcnVubmVyLnBlcmZvcm0gPSBudWxsO1xuICAgICAgICB9KSgpO1xuICAgICAgICAvLyBTdGFydCBhIHN0YWxsZXI7IHdoZW4gdGhpcyB0aW1lcyBvdXQsIGl0J3MgdGltZSB0byBmb3JjZVxuICAgICAgICAvLyBraWNraW5nIG9mZiBhbm90aGVyIHJ1bm5lciBiZWNhdXNlIHdlIGFyZSB0YWtpbmcgdG9vIGxvbmdcbiAgICAgICAgcnVubmVyLnN0YWxsZXIgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgc3RhbGwoY29uZmlnLnN0YWxsVGltZW91dCk7XG4gICAgICAgICAgICBydW5uZXIuc3RhbGxlciA9IG51bGw7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJ1bm5pbmcuYWRkKHJ1bm5lcik7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemVzIHRoZSBibG9ja051bWJlciBhbmQgbmV0d29yayBmb3IgZWFjaCBydW5uZXIgYW5kXG4gICAgLy8gYmxvY2tzIHVudGlsIGluaXRpYWxpemVkXG4gICAgYXN5bmMgI2luaXRpYWxTeW5jKCkge1xuICAgICAgICBsZXQgaW5pdGlhbFN5bmMgPSB0aGlzLiNpbml0aWFsU3luY1Byb21pc2U7XG4gICAgICAgIGlmICghaW5pdGlhbFN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICB0aGlzLiNjb25maWdzLmZvckVhY2goKGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvclN5bmMoY29uZmlnLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuX2xhc3RGYXRhbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuX25ldHdvcmsgPSBhd2FpdCBjb25maWcucHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxTeW5jUHJvbWlzZSA9IGluaXRpYWxTeW5jID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciBhbGwgcHJvdmlkZXJzIHRvIGhhdmUgYSBibG9jayBudW1iZXIgYW5kIG5ldHdvcmtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWxsIHRoZSBuZXR3b3JrcyBtYXRjaFxuICAgICAgICAgICAgICAgIGxldCBjaGFpbklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiB0aGlzLiNjb25maWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuX2xhc3RGYXRhbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gKGNvbmZpZy5fbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV0d29yay5jaGFpbklkICE9PSBjaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IG1peCBwcm92aWRlcnMgb24gZGlmZmVyZW50IG5ldHdvcmtzXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IEZhbGxiYWNrUHJvdmlkZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGluaXRpYWxTeW5jO1xuICAgIH1cbiAgICBhc3luYyAjY2hlY2tRdW9ydW0ocnVubmluZywgcmVxKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHJlc3VsdCBvYmplY3RzXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBydW5uZXIgb2YgcnVubmluZykge1xuICAgICAgICAgICAgaWYgKHJ1bm5lci5yZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGFnLCB2YWx1ZSB9ID0gbm9ybWFsaXplUmVzdWx0KHJlcS5tZXRob2QsIHJ1bm5lci5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7IHRhZywgdmFsdWUsIHdlaWdodDogcnVubmVyLmNvbmZpZy53ZWlnaHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJlIHRoZXJlIGVub3VnaCByZXN1bHRzIHRvIGV2ZW50IG1lZXQgcXVvcnVtP1xuICAgICAgICBpZiAocmVzdWx0cy5yZWR1Y2UoKGEsIHIpID0+IChhICsgci53ZWlnaHQpLCAwKSA8IHRoaXMucXVvcnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocmVxLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCB0aGUgYm9vdHN0cmFwIGJsb2NrIGhlaWdodFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoZWlnaHQgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2hlaWdodCA9IE1hdGguY2VpbChnZXROdW1iZXIoZ2V0TWVkaWFuKHRoaXMucXVvcnVtLCB0aGlzLiNjb25maWdzLmZpbHRlcigoYykgPT4gKCFjLl9sYXN0RmF0YWxFcnJvcikpLm1hcCgoYykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBnZXROdW1iZXIoYy5ibG9ja051bWJlcikudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodDogYy53ZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSkpKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtb2RlIGFjcm9zcyBhbGwgdGhlIHByb3ZpZGVycywgYWxsb3dpbmcgZm9yXG4gICAgICAgICAgICAgICAgLy8gYSBsaXR0bGUgZHJpZnQgYmV0d2VlbiBibG9jayBoZWlnaHRzXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZSA9IGdldEZ1enp5TW9kZSh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZSA+IHRoaXMuI2hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNoZWlnaHQgPSBtb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0UHJpb3JpdHlGZWVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRNZWRpYW4odGhpcy5xdW9ydW0sIHJlc3VsdHMpO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgLy8gUGVuZGluZyBibG9ja3MgYXJlIGluIHRoZSBtZW1wb29sIGFuZCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gcXVpdGUgdW50cnVzdHdvcnRoeTsganVzdCBncmFiIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEgJiYgcmVxLmJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QW55UmVzdWx0KHRoaXMucXVvcnVtLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUXVvcnVtKHRoaXMucXVvcnVtLCByZXN1bHRzKTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tRdW9ydW0odGhpcy5xdW9ydW0sIHJlc3VsdHMpO1xuICAgICAgICAgICAgY2FzZSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFueVJlc3VsdCh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIG1ldGhvZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IGBfcGVyZm9ybSgke3N0cmluZ2lmeShyZXEubWV0aG9kKX0pYFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgI3dhaXRGb3JRdW9ydW0ocnVubmluZywgcmVxKSB7XG4gICAgICAgIGlmIChydW5uaW5nLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHJ1bm5lcnM/IVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbnkgcHJvbWlzZXMgdGhhdCBhcmUgaW50ZXJlc3RpbmcgdG8gd2F0Y2ggZm9yOyBhbiBleHBpcmVkIHN0YWxsXG4gICAgICAgIC8vIG9yIGEgc3VjY2Vzc2Z1bCBwZXJmb3JtXG4gICAgICAgIGNvbnN0IGludGVyZXN0aW5nID0gW107XG4gICAgICAgIGxldCBuZXdSdW5uZXJzID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBydW5uZXIgb2YgcnVubmluZykge1xuICAgICAgICAgICAgLy8gTm8gcmVzcG9uc2VzLCB5ZXQ7IGtlZXAgYW4gZXllIG9uIGl0XG4gICAgICAgICAgICBpZiAocnVubmVyLnBlcmZvcm0pIHtcbiAgICAgICAgICAgICAgICBpbnRlcmVzdGluZy5wdXNoKHJ1bm5lci5wZXJmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0aWxsIHN0YWxsaW5nLi4uXG4gICAgICAgICAgICBpZiAocnVubmVyLnN0YWxsZXIpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmVzdGluZy5wdXNoKHJ1bm5lci5zdGFsbGVyKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgcnVubmVyIGhhcyBhbHJlYWR5IHRyaWdnZXJlZCBhbm90aGVyIHJ1bm5lclxuICAgICAgICAgICAgaWYgKHJ1bm5lci5kaWRCdW1wKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHb3QgYSByZXNwb25zZSAocmVzdWx0IG9yIGVycm9yKSBvciBzdGFsbGVkOyBraWNrIG9mZiBhbm90aGVyIHJ1bm5lclxuICAgICAgICAgICAgcnVubmVyLmRpZEJ1bXAgPSB0cnVlO1xuICAgICAgICAgICAgbmV3UnVubmVycysrO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgcmVhY2hlZCBxdW9ydW0gb24gYSByZXN1bHQgKG9yIGVycm9yKVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuI2NoZWNrUXVvcnVtKHJ1bm5pbmcsIHJlcSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBhbnkgbmV3IHJ1bm5lcnMsIGJlY2F1c2UgYSBzdGFsbGVyIHRpbWVkIG91dCBvciBhIHJlc3VsdFxuICAgICAgICAvLyBvciBlcnJvciByZXNwb25zZSBjYW1lIGluLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1J1bm5lcnM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy4jYWRkUnVubmVyKHJ1bm5pbmcsIHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsIHByb3ZpZGVycyBoYXZlIHJldHVybmVkLCBhbmQgd2UgaGF2ZSBubyByZXN1bHRcbiAgICAgICAgYXNzZXJ0KGludGVyZXN0aW5nLmxlbmd0aCA+IDAsIFwicXVvcnVtIG5vdCBtZXRcIiwgXCJTRVJWRVJfRVJST1JcIiwge1xuICAgICAgICAgICAgcmVxdWVzdDogXCIlc3ViLXJlcXVlc3RzXCIsXG4gICAgICAgICAgICBpbmZvOiB7IHJlcXVlc3Q6IHJlcSwgcmVzdWx0czogQXJyYXkuZnJvbShydW5uaW5nKS5tYXAoKHIpID0+IHN0cmluZ2lmeShyLnJlc3VsdCkpIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHNvbWVvbmUgdG8gZWl0aGVyIGNvbXBsZXRlIGl0cyBwZXJmb3JtIG9yIHN0YWxsIG91dFxuICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoaW50ZXJlc3RpbmcpO1xuICAgICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZSwgYnV0IGF0IHdvcnN0IGNhc2UgdGhlIGRlcHRoIGlzIDJ4IHRoZVxuICAgICAgICAvLyBudW1iZXIgb2YgcHJvdmlkZXJzIChlYWNoIGhhcyBhIHBlcmZvcm0gYW5kIGEgc3RhbGxlcilcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3dhaXRGb3JRdW9ydW0ocnVubmluZywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIC8vIEJyb2FkY2FzdGluZyBhIHRyYW5zYWN0aW9uIGlzIHJhcmUgKGlzaCkgYW5kIGFscmVhZHkgaW5jdXJzXG4gICAgICAgIC8vIGEgY29zdCBvbiB0aGUgdXNlciwgc28gc3BhbW1pbmcgaXMgc2FmZS1pc2guIEp1c3Qgc2VuZCBpdCB0b1xuICAgICAgICAvLyBldmVyeSBiYWNrZW5kLlxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBPbmNlIGFueSBicm9hZGNhc3QgcHJvdmlkZXMgYSBwb3NpdGl2ZSByZXN1bHQsIHVzZSBpdC4gTm9cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gd2FpdCBmb3IgYW55b25lIGVsc2VcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLiNjb25maWdzLm1hcCgoYykgPT4gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBicm9hZGNhc3RzID0gdGhpcy4jY29uZmlncy5tYXAoYXN5bmMgKHsgcHJvdmlkZXIsIHdlaWdodCB9LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gT2JqZWN0LmFzc2lnbihub3JtYWxpemVSZXN1bHQocmVxLm1ldGhvZCwgeyByZXN1bHQgfSksIHsgd2VpZ2h0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBPYmplY3QuYXNzaWduKG5vcm1hbGl6ZVJlc3VsdChyZXEubWV0aG9kLCB7IGVycm9yIH0pLCB7IHdlaWdodCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFzIGVhY2ggcHJvbWlzZSBmaW5pc2hlcy4uLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSB2YWxpZCBicm9hZGNhc3QgcmVzdWx0XG4gICAgICAgICAgICAgICAgY29uc3QgZG9uZSA9IHJlc3VsdHMuZmlsdGVyKChyKSA9PiAociAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlIH0gb2YgZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIGxlZ2l0IGJyb2FkY2FzdCBlcnJvciAob25lIHdoaWNoIHdlIGNhbm5vdFxuICAgICAgICAgICAgICAgIC8vIHJlY292ZXIgZnJvbTsgc29tZSBub2RlcyBtYXkgcmV0dXJuIHRoZSBmb2xsb3dpbmcgcmVkXG4gICAgICAgICAgICAgICAgLy8gaGVycmluZyBldmVudHM6XG4gICAgICAgICAgICAgICAgLy8gLSBhbHJlZHkgc2VlbmQgKFVOS05PV05fRVJST1IpXG4gICAgICAgICAgICAgICAgLy8gLSBOT05DRV9FWFBJUkVEXG4gICAgICAgICAgICAgICAgLy8gLSBSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrUXVvcnVtKHRoaXMucXVvcnVtLCByZXN1bHRzLmZpbHRlcigocikgPT4gKHIgIT0gbnVsbCkpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihyZXN1bHQsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gS2ljayBvZmYgdGhlIG5leHQgcHJvdmlkZXIgKGlmIGFueSlcbiAgICAgICAgICAgICAgICBjb25zdCB3YWl0aW5nID0gYnJvYWRjYXN0cy5maWx0ZXIoKGIsIGkpID0+IChyZXN1bHRzW2ldID09IG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAod2FpdGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZSh3YWl0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZSBzdGFuZGFyZCBxdW9ydW0gcmVzdWx0czsgYW55IHJlc3VsdCB3YXMgcmV0dXJuZWQgYWJvdmUsXG4gICAgICAgICAgICAvLyBzbyB0aGlzIHdpbGwgZmluZCBhbnkgZXJyb3IgdGhhdCBtZXQgcXVvcnVtIGlmIGFueVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0QW55UmVzdWx0KHRoaXMucXVvcnVtLCByZXN1bHRzKTtcbiAgICAgICAgICAgIGFzc2VydChyZXN1bHQgIT09IHVuZGVmaW5lZCwgXCJwcm9ibGVtIG11bHRpLWJyb2FkY2FzdGluZ1wiLCBcIlNFUlZFUl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogXCIlc3ViLXJlcXVlc3RzXCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyByZXF1ZXN0OiByZXEsIHJlc3VsdHM6IHJlc3VsdHMubWFwKHN0cmluZ2lmeSkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuI2luaXRpYWxTeW5jKCk7XG4gICAgICAgIC8vIEJvb3RzdHJhcCBlbm91Z2ggcnVubmVycyB0byBtZWV0IHF1b3J1bVxuICAgICAgICBjb25zdCBydW5uaW5nID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgaW5mbGlnaHRRdW9ydW0gPSAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcnVubmVyID0gdGhpcy4jYWRkUnVubmVyKHJ1bm5pbmcsIHJlcSk7XG4gICAgICAgICAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmxpZ2h0UXVvcnVtICs9IHJ1bm5lci5jb25maWcud2VpZ2h0O1xuICAgICAgICAgICAgaWYgKGluZmxpZ2h0UXVvcnVtID49IHRoaXMucXVvcnVtKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jd2FpdEZvclF1b3J1bShydW5uaW5nLCByZXEpO1xuICAgICAgICAvLyBUcmFjayByZXF1ZXN0cyBzZW50IHRvIGEgcHJvdmlkZXIgdGhhdCBhcmUgc3RpbGxcbiAgICAgICAgLy8gb3V0c3RhbmRpbmcgYWZ0ZXIgcXVvcnVtIGhhcyBiZWVuIG90aGVyd2lzZSBmb3VuZFxuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5lciBvZiBydW5uaW5nKSB7XG4gICAgICAgICAgICBpZiAocnVubmVyLnBlcmZvcm0gJiYgcnVubmVyLnJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmNvbmZpZy5sYXRlUmVzcG9uc2VzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IHByb3ZpZGVyIH0gb2YgdGhpcy4jY29uZmlncykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1mYWxsYmFjay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-fallback.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-infura.js":
/*!**************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-infura.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfuraProvider: function() { return /* binding */ InfuraProvider; },\n/* harmony export */   InfuraWebSocketProvider: function() { return /* binding */ InfuraWebSocketProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./community.js */ \"../common/node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var _provider_websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-websocket.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-websocket.js\");\n/**\n *  [[link-infura]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)\n *  - Base (``base``)\n *  - Base Goerlia Testnet (``base-goerli``)\n *  - Base Sepolia Testnet (``base-sepolia``)\n *  - BNB Smart Chain Mainnet (``bnb``)\n *  - BNB Smart Chain Testnet (``bnbt``)\n *  - Linea (``linea``)\n *  - Linea Goerli Testnet (``linea-goerli``)\n *  - Linea Sepolia Testnet (``linea-sepolia``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\n *  - Polygon (``matic``)\n *  - Polygon Amoy Testnet (``matic-amoy``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection: api/providers/thirdparty:INFURA  [providers-infura]\n */\n\n\n\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"mainnet.infura.io\";\n        case \"goerli\":\n            return \"goerli.infura.io\";\n        case \"sepolia\":\n            return \"sepolia.infura.io\";\n        case \"arbitrum\":\n            return \"arbitrum-mainnet.infura.io\";\n        case \"arbitrum-goerli\":\n            return \"arbitrum-goerli.infura.io\";\n        case \"arbitrum-sepolia\":\n            return \"arbitrum-sepolia.infura.io\";\n        case \"base\":\n            return \"base-mainnet.infura.io\";\n        case \"base-goerlia\": // @TODO: Remove this typo in the future!\n        case \"base-goerli\":\n            return \"base-goerli.infura.io\";\n        case \"base-sepolia\":\n            return \"base-sepolia.infura.io\";\n        case \"bnb\":\n            return \"bsc-mainnet.infura.io\";\n        case \"bnbt\":\n            return \"bsc-testnet.infura.io\";\n        case \"linea\":\n            return \"linea-mainnet.infura.io\";\n        case \"linea-goerli\":\n            return \"linea-goerli.infura.io\";\n        case \"linea-sepolia\":\n            return \"linea-sepolia.infura.io\";\n        case \"matic\":\n            return \"polygon-mainnet.infura.io\";\n        case \"matic-amoy\":\n            return \"polygon-amoy.infura.io\";\n        case \"matic-mumbai\":\n            return \"polygon-mumbai.infura.io\";\n        case \"optimism\":\n            return \"optimism-mainnet.infura.io\";\n        case \"optimism-goerli\":\n            return \"optimism-goerli.infura.io\";\n        case \"optimism-sepolia\":\n            return \"optimism-sepolia.infura.io\";\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **InfuraWebSocketProvider** connects to the [[link-infura]]\n *  WebSocket end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-infura-signup).\n */\nclass InfuraWebSocketProvider extends _provider_websocket_js__WEBPACK_IMPORTED_MODULE_1__.WebSocketProvider {\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    projectId;\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This should not\n     *  be used outside of private contexts.\n     */\n    projectSecret;\n    /**\n     *  Creates a new **InfuraWebSocketProvider**.\n     */\n    constructor(network, projectId) {\n        const provider = new InfuraProvider(network, projectId);\n        const req = provider._getConnection();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!req.credentials, \"INFURA WebSocket project secrets unsupported\", \"UNSUPPORTED_OPERATION\", { operation: \"InfuraProvider.getWebSocketProvider()\" });\n        const url = req.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, provider._network);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            projectId: provider.projectId,\n            projectSecret: provider.projectSecret\n        });\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\n/**\n *  The **InfuraProvider** connects to the [[link-infura]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-infura-signup).\n */\nclass InfuraProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\n    /**\n     *  The Project ID for the INFURA connection.\n     */\n    projectId;\n    /**\n     *  The Project Secret.\n     *\n     *  If null, no authenticated requests are made. This should not\n     *  be used outside of private contexts.\n     */\n    projectSecret;\n    /**\n     *  Creates a new **InfuraProvider**.\n     */\n    constructor(_network, projectId, projectSecret) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_3__.Network.from(_network);\n        if (projectId == null) {\n            projectId = defaultProjectId;\n        }\n        if (projectSecret == null) {\n            projectSecret = null;\n        }\n        const request = InfuraProvider.getRequest(network, projectId, projectSecret);\n        super(request, network, { staticNetwork: network });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { projectId, projectSecret });\n    }\n    _getProvider(chainId) {\n        try {\n            return new InfuraProvider(chainId, this.projectId, this.projectSecret);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n    /**\n     *  Creates a new **InfuraWebSocketProvider**.\n     */\n    static getWebSocketProvider(network, projectId) {\n        return new InfuraWebSocketProvider(network, projectId);\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%%\n     *  with %%projectId%% and %%projectSecret%%.\n     */\n    static getRequest(network, projectId, projectSecret) {\n        if (projectId == null) {\n            projectId = defaultProjectId;\n        }\n        if (projectSecret == null) {\n            projectSecret = null;\n        }\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/v3/${projectId}`);\n        request.allowGzip = true;\n        if (projectSecret) {\n            request.setCredentials(\"\", projectSecret);\n        }\n        if (projectId === defaultProjectId) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_4__.showThrottleMessage)(\"InfuraProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n}\n//# sourceMappingURL=provider-infura.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItaW5mdXJhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJGO0FBQ3RDO0FBQ2Q7QUFDaUI7QUFDSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0NBQXNDLHFFQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSw4RkFBOEYsb0RBQW9EO0FBQ2hLO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQjtBQUN4QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsaUVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRCxRQUFRLGlFQUFnQixTQUFTLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBWSxhQUFhLHNCQUFzQixNQUFNLFVBQVU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItaW5mdXJhLmpzP2Y5NjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgW1tsaW5rLWluZnVyYV1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXG4gKiAgLSBTZXBvbGlhIFRlc3RuZXQgKGBgc2Vwb2xpYWBgKVxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcbiAqICAtIEFyYml0cnVtIEdvZXJsaSBUZXN0bmV0IChgYGFyYml0cnVtLWdvZXJsaWBgKVxuICogIC0gQXJiaXRydW0gU2Vwb2xpYSBUZXN0bmV0IChgYGFyYml0cnVtLXNlcG9saWFgYClcbiAqICAtIEJhc2UgKGBgYmFzZWBgKVxuICogIC0gQmFzZSBHb2VybGlhIFRlc3RuZXQgKGBgYmFzZS1nb2VybGlgYClcbiAqICAtIEJhc2UgU2Vwb2xpYSBUZXN0bmV0IChgYGJhc2Utc2Vwb2xpYWBgKVxuICogIC0gQk5CIFNtYXJ0IENoYWluIE1haW5uZXQgKGBgYm5iYGApXG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gVGVzdG5ldCAoYGBibmJ0YGApXG4gKiAgLSBMaW5lYSAoYGBsaW5lYWBgKVxuICogIC0gTGluZWEgR29lcmxpIFRlc3RuZXQgKGBgbGluZWEtZ29lcmxpYGApXG4gKiAgLSBMaW5lYSBTZXBvbGlhIFRlc3RuZXQgKGBgbGluZWEtc2Vwb2xpYWBgKVxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcbiAqICAtIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0IChgYG9wdGltaXNtLWdvZXJsaWBgKVxuICogIC0gT3B0aW1pc20gU2Vwb2xpYSBUZXN0bmV0IChgYG9wdGltaXNtLXNlcG9saWFgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqICAtIFBvbHlnb24gQW1veSBUZXN0bmV0IChgYG1hdGljLWFtb3lgYClcbiAqICAtIFBvbHlnb24gTXVtYmFpIFRlc3RuZXQgKGBgbWF0aWMtbXVtYmFpYGApXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OklORlVSQSAgW3Byb3ZpZGVycy1pbmZ1cmFdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEZldGNoUmVxdWVzdCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgc2hvd1Rocm90dGxlTWVzc2FnZSB9IGZyb20gXCIuL2NvbW11bml0eS5qc1wiO1xuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcbmltcG9ydCB7IFdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItd2Vic29ja2V0LmpzXCI7XG5jb25zdCBkZWZhdWx0UHJvamVjdElkID0gXCI4NDg0MjA3OGIwOTk0NjYzOGMwMzE1N2Y4MzQwNTIxM1wiO1xuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJnb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJzZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJzZXBvbGlhLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYml0cnVtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYml0cnVtLWdvZXJsaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLXNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYml0cnVtLXNlcG9saWEuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlLWdvZXJsaWFcIjogLy8gQFRPRE86IFJlbW92ZSB0aGlzIHR5cG8gaW4gdGhlIGZ1dHVyZSFcbiAgICAgICAgY2FzZSBcImJhc2UtZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiYXNlLWdvZXJsaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImJhc2Utc2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYmFzZS1zZXBvbGlhLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiYm5iXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJic2MtbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImJuYnRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImJzYy10ZXN0bmV0LmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwibGluZWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImxpbmVhLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJsaW5lYS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImxpbmVhLWdvZXJsaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImxpbmVhLXNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImxpbmVhLXNlcG9saWEuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1tYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwibWF0aWMtYW1veVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1hbW95LmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwibWF0aWMtbXVtYmFpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5Z29uLW11bWJhaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJvcHRpbWlzbS1tYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwib3B0aW1pc20tZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJvcHRpbWlzbS1nb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJvcHRpbWlzbS1zZXBvbGlhLmluZnVyYS5pb1wiO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuYW1lKTtcbn1cbi8qKlxuICogIFRoZSAqKkluZnVyYVdlYlNvY2tldFByb3ZpZGVyKiogY29ubmVjdHMgdG8gdGhlIFtbbGluay1pbmZ1cmFdXVxuICogIFdlYlNvY2tldCBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1pbmZ1cmEtc2lnbnVwKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZnVyYVdlYlNvY2tldFByb3ZpZGVyIGV4dGVuZHMgV2ViU29ja2V0UHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgUHJvamVjdCBJRCBmb3IgdGhlIElORlVSQSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIHByb2plY3RJZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFByb2plY3QgU2VjcmV0LlxuICAgICAqXG4gICAgICogIElmIG51bGwsIG5vIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdHMgYXJlIG1hZGUuIFRoaXMgc2hvdWxkIG5vdFxuICAgICAqICBiZSB1c2VkIG91dHNpZGUgb2YgcHJpdmF0ZSBjb250ZXh0cy5cbiAgICAgKi9cbiAgICBwcm9qZWN0U2VjcmV0O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIqKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBwcm9qZWN0SWQpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgSW5mdXJhUHJvdmlkZXIobmV0d29yaywgcHJvamVjdElkKTtcbiAgICAgICAgY29uc3QgcmVxID0gcHJvdmlkZXIuX2dldENvbm5lY3Rpb24oKTtcbiAgICAgICAgYXNzZXJ0KCFyZXEuY3JlZGVudGlhbHMsIFwiSU5GVVJBIFdlYlNvY2tldCBwcm9qZWN0IHNlY3JldHMgdW5zdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiSW5mdXJhUHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKVwiIH0pO1xuICAgICAgICBjb25zdCB1cmwgPSByZXEudXJsLnJlcGxhY2UoL15odHRwL2ksIFwid3NcIikucmVwbGFjZShcIi92My9cIiwgXCIvd3MvdjMvXCIpO1xuICAgICAgICBzdXBlcih1cmwsIHByb3ZpZGVyLl9uZXR3b3JrKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHByb3ZpZGVyLnByb2plY3RJZCxcbiAgICAgICAgICAgIHByb2plY3RTZWNyZXQ6IHByb3ZpZGVyLnByb2plY3RTZWNyZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpO1xuICAgIH1cbn1cbi8qKlxuICogIFRoZSAqKkluZnVyYVByb3ZpZGVyKiogY29ubmVjdHMgdG8gdGhlIFtbbGluay1pbmZ1cmFdXVxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXG4gKlxuICogIEJ5IGRlZmF1bHQsIGEgaGlnaGx5LXRocm90dGxlZCBBUEkga2V5IGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLWluZnVyYS1zaWdudXApLlxuICovXG5leHBvcnQgY2xhc3MgSW5mdXJhUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgUHJvamVjdCBJRCBmb3IgdGhlIElORlVSQSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIHByb2plY3RJZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFByb2plY3QgU2VjcmV0LlxuICAgICAqXG4gICAgICogIElmIG51bGwsIG5vIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdHMgYXJlIG1hZGUuIFRoaXMgc2hvdWxkIG5vdFxuICAgICAqICBiZSB1c2VkIG91dHNpZGUgb2YgcHJpdmF0ZSBjb250ZXh0cy5cbiAgICAgKi9cbiAgICBwcm9qZWN0U2VjcmV0O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqSW5mdXJhUHJvdmlkZXIqKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0KSB7XG4gICAgICAgIGlmIChfbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICBfbmV0d29yayA9IFwibWFpbm5ldFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBOZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICBpZiAocHJvamVjdElkID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2plY3RJZCA9IGRlZmF1bHRQcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2plY3RTZWNyZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvamVjdFNlY3JldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IEluZnVyYVByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0KTtcbiAgICAgICAgc3VwZXIocmVxdWVzdCwgbmV0d29yaywgeyBzdGF0aWNOZXR3b3JrOiBuZXR3b3JrIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0IH0pO1xuICAgIH1cbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmZ1cmFQcm92aWRlcihjaGFpbklkLCB0aGlzLnByb2plY3RJZCwgdGhpcy5wcm9qZWN0U2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcioqLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBwcm9qZWN0SWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBwcm9qZWN0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHByZXBhcmVkIHJlcXVlc3QgZm9yIGNvbm5lY3RpbmcgdG8gJSVuZXR3b3JrJSVcbiAgICAgKiAgd2l0aCAlJXByb2plY3RJZCUlIGFuZCAlJXByb2plY3RTZWNyZXQlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmVxdWVzdChuZXR3b3JrLCBwcm9qZWN0SWQsIHByb2plY3RTZWNyZXQpIHtcbiAgICAgICAgaWYgKHByb2plY3RJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9qZWN0SWQgPSBkZWZhdWx0UHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0U2VjcmV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2plY3RTZWNyZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9L3YzLyR7cHJvamVjdElkfWApO1xuICAgICAgICByZXF1ZXN0LmFsbG93R3ppcCA9IHRydWU7XG4gICAgICAgIGlmIChwcm9qZWN0U2VjcmV0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNldENyZWRlbnRpYWxzKFwiXCIsIHByb2plY3RTZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2hvd1Rocm90dGxlTWVzc2FnZShcIkluZnVyYVByb3ZpZGVyXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1pbmZ1cmEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-infura.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js":
/*!*************************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IpcSocketProvider: function() { return /* binding */ IpcSocketProvider; }\n/* harmony export */ });\nconst IpcSocketProvider = undefined;\n\n//# sourceMappingURL=provider-ipcsocket-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItaXBjc29ja2V0LWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQzZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci1pcGNzb2NrZXQtYnJvd3Nlci5qcz83Zjc3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IElwY1NvY2tldFByb3ZpZGVyID0gdW5kZWZpbmVkO1xuZXhwb3J0IHsgSXBjU29ja2V0UHJvdmlkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWlwY3NvY2tldC1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js":
/*!***************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcApiPollingProvider: function() { return /* binding */ JsonRpcApiPollingProvider; },\n/* harmony export */   JsonRpcApiProvider: function() { return /* binding */ JsonRpcApiProvider; },\n/* harmony export */   JsonRpcProvider: function() { return /* binding */ JsonRpcProvider; },\n/* harmony export */   JsonRpcSigner: function() { return /* binding */ JsonRpcSigner; }\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../abi/index.js */ \"../common/node_modules/ethers/lib.esm/abi/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"../common/node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract-provider.js */ \"../common/node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-signer.js */ \"../common/node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./subscriber-filterid.js */ \"../common/node_modules/ethers/lib.esm/providers/subscriber-filterid.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./subscriber-polling.js */ \"../common/node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */\n// @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\n\n\n\n\n\n\n\n\n\n\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n    if (value == null || Primitive.indexOf(typeof (value)) >= 0) {\n        return value;\n    }\n    // Keep any Addressable\n    if (typeof (value.getAddress) === \"function\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return (value.map(deepCopy));\n    }\n    if (typeof (value) === \"object\") {\n        return Object.keys(value).reduce((accum, key) => {\n            accum[key] = value[key];\n            return accum;\n        }, {});\n    }\n    throw new Error(`should not happen: ${value} (${typeof (value)})`);\n}\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nfunction isPollable(value) {\n    return (value && typeof (value.pollingInterval) === \"number\");\n}\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n    batchStallTime: 10,\n    batchMaxSize: (1 << 20),\n    batchMaxCount: 100,\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nclass JsonRpcSigner extends _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    address;\n    constructor(provider, address) {\n        super(provider);\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { address });\n    }\n    connect(provider) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx) {\n        return await this.populateCall(tx);\n    }\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        const promises = [];\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async () => {\n                const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(_from, this.provider);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        }\n        else {\n            tx.from = this.address;\n        }\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async () => {\n                tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });\n            })());\n        }\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async () => {\n                tx.to = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(_to, this.provider);\n            })());\n        }\n        // Wait until all of our properties are filled in\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return this.provider.send(\"eth_sendTransaction\", [hexTx]);\n    }\n    async sendTransaction(tx) {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await (new Promise((resolve, reject) => {\n            const timeouts = [1000, 100];\n            let invalids = 0;\n            const checkTx = async () => {\n                try {\n                    // Try getting the transaction\n                    const tx = await this.provider.getTransaction(hash);\n                    if (tx != null) {\n                        resolve(tx.replaceableTransaction(blockNumber));\n                        return;\n                    }\n                }\n                catch (error) {\n                    // If we were cancelled: stop polling.\n                    // If the data is bad: the node returns bad transactions\n                    // If the network changed: calling again will also fail\n                    // If unsupported: likely destroyed\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isError)(error, \"CANCELLED\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isError)(error, \"BAD_DATA\") ||\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isError)(error, \"NETWORK_ERROR\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isError)(error, \"UNSUPPORTED_OPERATION\")) {\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        reject(error);\n                        return;\n                    }\n                    // Stop-gap for misbehaving backends; see #4513\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isError)(error, \"INVALID_ARGUMENT\")) {\n                        invalids++;\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        if (invalids > 10) {\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Notify anyone that cares; but we will try again, since\n                    // it is likely an intermittent service error\n                    this.provider.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"failed to fetch transation after sending (will try again)\", \"UNKNOWN_ERROR\", { error }));\n                }\n                // Wait another 4 seconds\n                this.provider._setTimeout(() => { checkTx(); }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        }));\n    }\n    async signTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(tx.from, this.provider);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        }\n        else {\n            tx.from = this.address;\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [hexTx]);\n    }\n    async signMessage(_message) {\n        const message = ((typeof (_message) === \"string\") ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)(_message) : _message);\n        return await this.provider.send(\"personal_sign\", [\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(message), this.address.toLowerCase()\n        ]);\n    }\n    async signTypedData(domain, types, _value) {\n        const value = deepCopy(_value);\n        // Populate any ENS names (in-place)\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_3__.TypedDataEncoder.resolveNames(domain, types, value, async (value) => {\n            const address = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n    async unlock(password) {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(), password, null\n        ]);\n    }\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message) {\n        const message = ((typeof (_message) === \"string\") ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)(_message) : _message);\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(message)\n        ]);\n    }\n}\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */\nclass JsonRpcApiProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_4__.AbstractProvider {\n    #options;\n    // The next ID to use for the JSON-RPC ID field\n    #nextId;\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads;\n    #drainTimer;\n    #notReady;\n    #network;\n    #pendingDetectNetwork;\n    #scheduleDrain() {\n        if (this.#drainTimer) {\n            return;\n        }\n        // If we aren't using batching, no harm in sending it immediately\n        const stallTime = (this._getOption(\"batchMaxCount\") === 1) ? 0 : this._getOption(\"batchStallTime\");\n        this.#drainTimer = setTimeout(() => {\n            this.#drainTimer = null;\n            const payloads = this.#payloads;\n            this.#payloads = [];\n            while (payloads.length) {\n                // Create payload batches that satisfy our batch constraints\n                const batch = [(payloads.shift())];\n                while (payloads.length) {\n                    if (batch.length === this.#options.batchMaxCount) {\n                        break;\n                    }\n                    batch.push((payloads.shift()));\n                    const bytes = JSON.stringify(batch.map((p) => p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift((batch.pop()));\n                        break;\n                    }\n                }\n                // Process the result to each payload\n                (async () => {\n                    const payload = ((batch.length === 1) ? batch[0].payload : batch.map((p) => p.payload));\n                    this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch) {\n                            if (this.destroyed) {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n                                continue;\n                            }\n                            // Find the matching result\n                            const resp = result.filter((r) => (r.id === payload.id))[0];\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result, info: { payload }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n                    }\n                    catch (error) {\n                        this.emit(\"debug\", { action: \"receiveRpcError\", error });\n                        for (const { reject } of batch) {\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n    constructor(network, options) {\n        super(network, options);\n        this.#nextId = 1;\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        this.#payloads = [];\n        this.#drainTimer = null;\n        this.#network = null;\n        this.#pendingDetectNetwork = null;\n        {\n            let resolve = null;\n            const promise = new Promise((_resolve) => {\n                resolve = _resolve;\n            });\n            this.#notReady = { promise, resolve };\n        }\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (typeof (staticNetwork) === \"boolean\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n            if (staticNetwork && network != null) {\n                this.#network = _network_js__WEBPACK_IMPORTED_MODULE_5__.Network.from(network);\n            }\n        }\n        else if (staticNetwork) {\n            // Make sure any static network is compatbile with the provided netwrok\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */\n    _getOption(key) {\n        return this.#options[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */\n    get _network() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */\n    async _perform(req) {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(tx.type)) {\n                // If there are no EIP-1559 or newer properties, it might be pre-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({}, req, {\n                            transaction: Object.assign({}, tx, { type: undefined })\n                        });\n                    }\n                }\n            }\n        }\n        const request = this.getRpcRequest(req);\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n        return super._perform(req);\n    }\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */\n    async _detectNetwork() {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            if (network === true) {\n                if (this.#network) {\n                    return this.#network;\n                }\n            }\n            else {\n                return network;\n            }\n        }\n        if (this.#pendingDetectNetwork) {\n            return await this.#pendingDetectNetwork;\n        }\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            this.#pendingDetectNetwork = (async () => {\n                try {\n                    const result = _network_js__WEBPACK_IMPORTED_MODULE_5__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(await this.send(\"eth_chainId\", [])));\n                    this.#pendingDetectNetwork = null;\n                    return result;\n                }\n                catch (error) {\n                    this.#pendingDetectNetwork = null;\n                    throw error;\n                }\n            })();\n            return await this.#pendingDetectNetwork;\n        }\n        // We are not ready yet; use the primitive _send\n        this.#pendingDetectNetwork = (async () => {\n            const payload = {\n                id: this.#nextId++, method: \"eth_chainId\", params: [], jsonrpc: \"2.0\"\n            };\n            this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n            let result;\n            try {\n                result = (await this._send(payload))[0];\n                this.#pendingDetectNetwork = null;\n            }\n            catch (error) {\n                this.#pendingDetectNetwork = null;\n                this.emit(\"debug\", { action: \"receiveRpcError\", error });\n                throw error;\n            }\n            this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n            if (\"result\" in result) {\n                return _network_js__WEBPACK_IMPORTED_MODULE_5__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(result.result));\n            }\n            throw this.getRpcError(payload, result);\n        })();\n        return await this.#pendingDetectNetwork;\n    }\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */\n    _start() {\n        if (this.#notReady == null || this.#notReady.resolve == null) {\n            return;\n        }\n        this.#notReady.resolve();\n        this.#notReady = null;\n        (async () => {\n            // Bootstrap the network\n            while (this.#network == null && !this.destroyed) {\n                try {\n                    this.#network = await this._detectNetwork();\n                }\n                catch (error) {\n                    if (this.destroyed) {\n                        break;\n                    }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", { event: \"initial-network-discovery\", info: { error } }));\n                    await stall(1000);\n                }\n            }\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */\n    async _waitUntilReady() {\n        if (this.#notReady == null) {\n            return;\n        }\n        return await this.#notReady.promise;\n    }\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */\n    _getSubscriber(sub) {\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") {\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_6__.FilterIdPendingSubscriber(this);\n        }\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_7__.PollingEventSubscriber(this, sub.filter);\n            }\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_6__.FilterIdEventSubscriber(this, sub.filter);\n        }\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_4__.UnmanagedSubscriber(\"orphan\");\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */\n    get ready() { return this.#notReady == null; }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */\n    getRpcTransaction(tx) {\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            let dstKey = key;\n            if (key === \"gasLimit\") {\n                dstKey = \"gas\";\n            }\n            result[dstKey] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toQuantity)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(tx[key], `tx.${key}`));\n        });\n        // Make sure addresses and data are lowercase\n        [\"from\", \"to\", \"data\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(tx[key]);\n        });\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.accessListify)(tx.accessList);\n        }\n        if (tx.blobVersionedHashes) {\n            // @TODO: Remove this <any> case once EIP-4844 added to prepared tx\n            result[\"blobVersionedHashes\"] = tx.blobVersionedHashes.map(h => h.toLowerCase());\n        }\n        if (tx.authorizationList) {\n            result[\"authorizationList\"] = tx.authorizationList.map((_a) => {\n                const a = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_8__.authorizationify)(_a);\n                return {\n                    address: a.address,\n                    nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toQuantity)(a.nonce),\n                    chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toQuantity)(a.chainId),\n                    yParity: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toQuantity)(a.signature.yParity),\n                    r: a.signature.r,\n                    s: a.signature.s,\n                };\n            });\n        }\n        // @TODO: blobs should probably also be copied over, optionally\n        // accounting for the kzg property to backfill blobVersionedHashes\n        // using the commitment. Or should that be left as an exercise to\n        // the caller?\n        return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */\n    getRpcRequest(req) {\n        switch (req.method) {\n            case \"chainId\":\n                return { method: \"eth_chainId\", args: [] };\n            case \"getBlockNumber\":\n                return { method: \"eth_blockNumber\", args: [] };\n            case \"getGasPrice\":\n                return { method: \"eth_gasPrice\", args: [] };\n            case \"getPriorityFee\":\n                return { method: \"eth_maxPriorityFeePerGas\", args: [] };\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        (\"0x\" + req.position.toString(16)),\n                        req.blockTag\n                    ]\n                };\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [req.signedTransaction]\n                };\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [req.blockTag, !!req.includeTransactions]\n                    };\n                }\n                else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [req.blockHash, !!req.includeTransactions]\n                    };\n                }\n                break;\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [req.hash]\n                };\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [req.hash]\n                };\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [this.getRpcTransaction(req.transaction), req.blockTag]\n                };\n            case \"estimateGas\": {\n                return {\n                    method: \"eth_estimateGas\",\n                    args: [this.getRpcTransaction(req.transaction)]\n                };\n            }\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    }\n                    else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return { method: \"eth_getLogs\", args: [req.filter] };\n        }\n        return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */\n    getRpcError(payload, _error) {\n        const { method } = payload;\n        const { error } = _error;\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: (payload.params[0]),\n                    info: { payload, error }\n                });\n            }\n            else if (msg.match(/nonce/i) && msg.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction: (payload.params[0]),\n                    info: { payload, error }\n                });\n            }\n        }\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n            const e = _abi_index_js__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.getBuiltinCallException((method === \"eth_call\") ? \"call\" : \"estimateGas\", (payload.params[0]), (result ? result.data : null));\n            e.info = { error, payload };\n            return e;\n        }\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n        const message = JSON.stringify(spelunkMessage(error));\n        if (typeof (error.message) === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\",\n            };\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(`user rejected action`, \"ACTION_REJECTED\", {\n                action: (actionMap[method] || \"unknown\"),\n                reason: \"rejected\",\n                info: { payload, error }\n            });\n        }\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = (payload.params[0]);\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction, info: { error }\n                });\n            }\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", { transaction, info: { error } });\n            }\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", { transaction, info: { error } });\n            }\n            if (message.match(/only replay-protected/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method, info: { transaction, info: { error } }\n                });\n            }\n        }\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n        if (unsupported) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method, info: { error, payload }\n            });\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", { error, payload });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */\n    send(method, params) {\n        // @TODO: cache chainId?? purge on switch_networks\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: method }));\n        }\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject) => {\n            this.#payloads.push({\n                resolve, reject,\n                payload: { method, params, id, jsonrpc: \"2.0\" }\n            });\n        });\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n        return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accountsPromise = this.send(\"eth_accounts\", []);\n        // Account index\n        if (typeof (address) === \"number\") {\n            const accounts = (await accountsPromise);\n            if (address >= accounts.length) {\n                throw new Error(\"no such account\");\n            }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n        const { accounts } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n        // Account address\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        for (const account of accounts) {\n            if ((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n        throw new Error(\"invalid account\");\n    }\n    async listAccounts() {\n        const accounts = await this.send(\"eth_accounts\", []);\n        return accounts.map((a) => new JsonRpcSigner(this, a));\n    }\n    destroy() {\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads) {\n            reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n        }\n        this.#payloads = [];\n        // Parent clean-up\n        super.destroy();\n    }\n}\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */\nclass JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval;\n    constructor(network, options) {\n        super(network, options);\n        let pollingInterval = this._getOption(\"pollingInterval\");\n        if (pollingInterval == null) {\n            pollingInterval = defaultOptions.pollingInterval;\n        }\n        this.#pollingInterval = pollingInterval;\n    }\n    _getSubscriber(sub) {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */\n    get pollingInterval() { return this.#pollingInterval; }\n    set pollingInterval(value) {\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(\"invalid interval\");\n        }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub) => {\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */\nclass JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect;\n    constructor(url, network, options) {\n        if (url == null) {\n            url = \"http:/\\/localhost:8545\";\n        }\n        super(network, options);\n        if (typeof (url) === \"string\") {\n            this.#connect = new _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.FetchRequest(url);\n        }\n        else {\n            this.#connect = url.clone();\n        }\n    }\n    _getConnection() {\n        return this.#connect.clone();\n    }\n    async send(method, params) {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) {\n            resp = [resp];\n        }\n        return resp;\n    }\n}\nfunction spelunkData(value) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(/revert/i) && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isHexString)(value.data)) {\n        return { message: value.message, data: value.data };\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            const result = spelunkData(value[key]);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction _spelunkMessage(value, result) {\n    if (value == null) {\n        return;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\") {\n        result.push(value.message);\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            _spelunkMessage(value[key], result);\n        }\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        }\n        catch (error) { }\n    }\n}\nfunction spelunkMessage(value) {\n    const result = [];\n    _spelunkMessage(value, result);\n    return result;\n}\n//# sourceMappingURL=provider-jsonrpc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkM7QUFDc0I7QUFDYjtBQUNzQjtBQUNrSDtBQUM3RztBQUN6QjtBQUNmO0FBQ3VEO0FBQzdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBLDBDQUEwQyxPQUFPLEdBQUcsZUFBZTtBQUNuRTtBQUNBO0FBQ0Esc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLCtEQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2REFBVTtBQUM1QixRQUFRLGlFQUFnQixTQUFTLFNBQVM7QUFDMUM7QUFDQTtBQUNBLFFBQVEsdURBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFjO0FBQ2pELGdCQUFnQiwrREFBYztBQUM5QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwyQkFBMkI7QUFDM0YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUVBQWM7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDREQUFXO0FBQzVGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWpzb25ycGMuanM/ZTA4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBPbmUgb2YgdGhlIG1vc3QgY29tbW9uIHdheXMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgYmxvY2tjaGFpbiBpc1xuICogIGJ5IGEgbm9kZSBydW5uaW5nIGEgSlNPTi1SUEMgaW50ZXJmYWNlIHdoaWNoIGNhbiBiZSBjb25uZWN0ZWQgdG8sXG4gKiAgYmFzZWQgb24gdGhlIHRyYW5zcG9ydCwgdXNpbmc6XG4gKlxuICogIC0gSFRUUCBvciBIVFRQUyAtIFtbSnNvblJwY1Byb3ZpZGVyXV1cbiAqICAtIFdlYlNvY2tldCAtIFtbV2ViU29ja2V0UHJvdmlkZXJdXVxuICogIC0gSVBDIC0gW1tJcGNTb2NrZXRQcm92aWRlcl1dXG4gKlxuICogQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2pzb25ycGM6SlNPTi1SUEMgUHJvdmlkZXIgIFthYm91dC1qc29ucnBjUHJvdmlkZXJdXG4gKi9cbi8vIEBUT0RPOlxuLy8gLSBBZGQgdGhlIGJhdGNoaW5nIEFQSVxuLy8gaHR0cHM6Ly9wbGF5Z3JvdW5kLm9wZW4tcnBjLm9yZy8/c2NoZW1hVXJsPWh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ldGhlcmV1bS9ldGgxLjAtYXBpcy9hc3NlbWJsZWQtc3BlYy9vcGVucnBjLmpzb24mdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpzcGxpdFZpZXclNUQ9dHJ1ZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmlucHV0JTVEPWZhbHNlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6ZXhhbXBsZXNEcm9wZG93biU1RD1mYWxzZVxuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnksIGF1dGhvcml6YXRpb25pZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvUXVhbnRpdHksIHRvVXRmOEJ5dGVzLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFic3RyYWN0UHJvdmlkZXIsIFVubWFuYWdlZFN1YnNjcmliZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1zaWduZXIuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciwgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItZmlsdGVyaWQuanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmNvbnN0IFByaW1pdGl2ZSA9IFwiYmlnaW50LGJvb2xlYW4sZnVuY3Rpb24sbnVtYmVyLHN0cmluZyxzeW1ib2xcIi5zcGxpdCgvLC9nKTtcbi8vY29uc3QgTWV0aG9kcyA9IFwiZ2V0QWRkcmVzcyx0aGVuXCIuc3BsaXQoLywvZyk7XG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IFByaW1pdGl2ZS5pbmRleE9mKHR5cGVvZiAodmFsdWUpKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gS2VlcCBhbnkgQWRkcmVzc2FibGVcbiAgICBpZiAodHlwZW9mICh2YWx1ZS5nZXRBZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUubWFwKGRlZXBDb3B5KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzaG91bGQgbm90IGhhcHBlbjogJHt2YWx1ZX0gKCR7dHlwZW9mICh2YWx1ZSl9KWApO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7IH0pO1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc1BvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnBvbGxpbmdJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpO1xufVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcG9sbGluZzogZmFsc2UsXG4gICAgc3RhdGljTmV0d29yazogbnVsbCxcbiAgICBiYXRjaFN0YWxsVGltZTogMTAsXG4gICAgYmF0Y2hNYXhTaXplOiAoMSA8PCAyMCksXG4gICAgYmF0Y2hNYXhDb3VudDogMTAwLFxuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8vIEBUT0RPOiBVbmNoZWNrZWQgU2lnbmVyc1xuZXhwb3J0IGNsYXNzIEpzb25ScGNTaWduZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgYWRkcmVzcztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcykge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHJlY29ubmVjdCBKc29uUnBjU2lnbmVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICAgIH1cbiAgICAvLyBKU09OLVJQQyB3aWxsIGF1dG9tYXRpYWxseSBmaWxsIGluIG5vbmNlLCBldGMuIHNvIHdlIGp1c3QgY2hlY2sgZnJvbVxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBqdXN0IHRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBhZnRlciBzZW50LCB3aGljaCBpcyB3aGF0XG4gICAgLy8gdGhlIGJhcmUgSlNPTi1SUEMgQVBJIGRvZXM7XG4gICAgYXN5bmMgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IF9mcm9tID0gdHguZnJvbTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3MoX2Zyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoeyAuLi50eCwgZnJvbTogdGhpcy5hZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGFkZHJlc3MgbWF5IGJlIGFuIEVOUyBuYW1lIG9yIEFkZHJlc3NhYmxlXG4gICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBfdG8gPSB0eC50bztcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC50byA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF90bywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IHVudGlsIGFsbCBvZiBvdXIgcHJvcGVydGllcyBhcmUgZmlsbGVkIGluXG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgLy8gU2VuZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgLy8gZm9yIGEgcmVzcG9uc2UsIGFuZCB3ZSBuZWVkIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb24sIHNvIHdlIHBvbGxcbiAgICAgICAgLy8gZm9yIGl0OyBpdCBzaG91bGQgc2hvdyB1cCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0cyA9IFsxMDAwLCAxMDBdO1xuICAgICAgICAgICAgbGV0IGludmFsaWRzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrVHggPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGNhbmNlbGxlZDogc3RvcCBwb2xsaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YSBpcyBiYWQ6IHRoZSBub2RlIHJldHVybnMgYmFkIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBjaGFuZ2VkOiBjYWxsaW5nIGFnYWluIHdpbGwgYWxzbyBmYWlsXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHVuc3VwcG9ydGVkOiBsaWtlbHkgZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTkNFTExFRFwiKSB8fCBpc0Vycm9yKGVycm9yLCBcIkJBRF9EQVRBXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Vycm9yKGVycm9yLCBcIk5FVFdPUktfRVJST1JcIikgfHwgaXNFcnJvcihlcnJvciwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5pbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvLnNlbmRUcmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wLWdhcCBmb3IgbWlzYmVoYXZpbmcgYmFja2VuZHM7IHNlZSAjNDUxM1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8uc2VuZFRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZHMgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbnlvbmUgdGhhdCBjYXJlczsgYnV0IHdlIHdpbGwgdHJ5IGFnYWluLCBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBsaWtlbHkgYW4gaW50ZXJtaXR0ZW50IHNlcnZpY2UgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5lbWl0KFwiZXJyb3JcIiwgbWFrZUVycm9yKFwiZmFpbGVkIHRvIGZldGNoIHRyYW5zYXRpb24gYWZ0ZXIgc2VuZGluZyAod2lsbCB0cnkgYWdhaW4pXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IGVycm9yIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBhbm90aGVyIDQgc2Vjb25kc1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuX3NldFRpbWVvdXQoKCkgPT4geyBjaGVja1R4KCk7IH0sIHRpbWVvdXRzLnBvcCgpIHx8IDQwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoZWNrVHgoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24oX3R4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gZGVlcENvcHkoX3R4KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbXG4gICAgICAgICAgICBoZXhsaWZ5KG1lc3NhZ2UpLCB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ29weShfdmFsdWUpO1xuICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3MgIT0gbnVsbCwgXCJUeXBlZERhdGEgZG9lcyBub3Qgc3VwcG9ydCBudWxsIGFkZHJlc3NcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFR5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cbiAgICBhc3luYyBfbGVnYWN5U2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIGhleGxpZnkobWVzc2FnZSlcbiAgICAgICAgXSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNBcGlQcm92aWRlciBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgKipNVVNUKiogYmVcbiAqICBzdWItY2xhc3NlZC5cbiAqXG4gKiAgSXQgcHJvdmlkZXMgdGhlIGJhc2UgZm9yIGFsbCBKU09OLVJQQy1iYXNlZCBQcm92aWRlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiAgU3ViLWNsYXNzaW5nIE5vdGVzOlxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBvdmVycmlkZSBfc2VuZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIHRoZSBgX3N0YXJ0KClgIG1ldGhvZCBvbmNlIGNvbm5lY3RlZFxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI29wdGlvbnM7XG4gICAgLy8gVGhlIG5leHQgSUQgdG8gdXNlIGZvciB0aGUgSlNPTi1SUEMgSUQgZmllbGRcbiAgICAjbmV4dElkO1xuICAgIC8vIFBheWxvYWRzIGFyZSBxdWV1ZWQgYW5kIHRyaWdnZXJlZCBpbiBiYXRjaGVzIHVzaW5nIHRoZSBkcmFpblRpbWVyXG4gICAgI3BheWxvYWRzO1xuICAgICNkcmFpblRpbWVyO1xuICAgICNub3RSZWFkeTtcbiAgICAjbmV0d29yaztcbiAgICAjcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgI3NjaGVkdWxlRHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIGJhdGNoaW5nLCBubyBoYXJtIGluIHNlbmRpbmcgaXQgaW1tZWRpYXRlbHlcbiAgICAgICAgY29uc3Qgc3RhbGxUaW1lID0gKHRoaXMuX2dldE9wdGlvbihcImJhdGNoTWF4Q291bnRcIikgPT09IDEpID8gMCA6IHRoaXMuX2dldE9wdGlvbihcImJhdGNoU3RhbGxUaW1lXCIpO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdGhpcy4jcGF5bG9hZHM7XG4gICAgICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXlsb2FkIGJhdGNoZXMgdGhhdCBzYXRpc2Z5IG91ciBiYXRjaCBjb25zdHJhaW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gWyhwYXlsb2Fkcy5zaGlmdCgpKV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID09PSB0aGlzLiNvcHRpb25zLmJhdGNoTWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goKHBheWxvYWRzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBKU09OLnN0cmluZ2lmeShiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gdGhpcy4jb3B0aW9ucy5iYXRjaE1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzLnVuc2hpZnQoKGJhdGNoLnBvcCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSByZXN1bHQgdG8gZWFjaCBwYXlsb2FkXG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICgoYmF0Y2gubGVuZ3RoID09PSAxKSA/IGJhdGNoWzBdLnBheWxvYWQgOiBiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyByZXN1bHRzIGluIGJhdGNoIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0LCBwYXlsb2FkIH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZXN1bHQuZmlsdGVyKChyKSA9PiAoci5pZCA9PT0gcGF5bG9hZC5pZCkpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdDsgdGhlIG5vZGUgZmFpbGVkIHVzIGluIHVuZXhwZWN0ZWQgd2F5c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBtYWtlRXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlIGZvciByZXF1ZXN0XCIsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCwgaW5mbzogeyBwYXlsb2FkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCByZXNwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZ29vZDsgc2VuZCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVqZWN0IH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogYXVnbWVudCB0aGUgZXJyb3Igd2l0aCB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFsbFRpbWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNuZXh0SWQgPSAxO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jbm90UmVhZHkgPSB7IHByb21pc2UsIHJlc29sdmUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0aWNOZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc3RhdGljTmV0d29yaykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghc3RhdGljTmV0d29yayB8fCBuZXR3b3JrICE9PSBcImFueVwiLCBcInN0YXRpY05ldHdvcmsgY2Fubm90IGJlIHVzZWQgb24gc3BlY2lhbCBuZXR3b3JrICdhbnknXCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNOZXR3b3JrICYmIG5ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBOZXR3b3JrLmZyb20obmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGljTmV0d29yaykge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBzdGF0aWMgbmV0d29yayBpcyBjb21wYXRiaWxlIHdpdGggdGhlIHByb3ZpZGVkIG5ldHdyb2tcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG5ldHdvcmsgPT0gbnVsbCB8fCBzdGF0aWNOZXR3b3JrLm1hdGNoZXMobmV0d29yayksIFwic3RhdGljTmV0d29yayBNVVNUIG1hdGNoIG5ldHdvcmsgb2JqZWN0XCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBzdGF0aWNOZXR3b3JrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG9wdGlvbiAlJWtleSUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIGNhbiB1c2UgdGhpcyB0byBpbnF1aXJlIGFib3V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0T3B0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyB0aGUgW1tOZXR3b3JrXV0gdGhpcyBwcm92aWRlciBoYXMgY29tbWl0dGVkIHRvLiBPbiBlYWNoIGNhbGwsIHRoZSBuZXR3b3JrXG4gICAgICogIGlzIGRldGVjdGVkLCBhbmQgaWYgaXQgaGFzIGNoYW5nZWQsIHRoZSBjYWxsIHdpbGwgcmVqZWN0LlxuICAgICAqL1xuICAgIGdldCBfbmV0d29yaygpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI25ldHdvcmssIFwibmV0d29yayBpcyBub3QgYXZhaWxhYmxlIHlldFwiLCBcIk5FVFdPUktfRVJST1JcIik7XG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG5vbi1ub3JtYWxpemVkIHZhbHVlIGJ5IHBlcmZvcm1pbmcgJSVyZXElJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgYmVoYXZpb3Igb2YgYWN0aW9ucyxcbiAgICAgKiAgYW5kIHNob3VsZCBnZW5lcmFsbHkgY2FsbCBgYHN1cGVyLl9wZXJmb3JtYGAgYXMgYSBmYWxsYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgLy8gTGVnYWN5IG5ldHdvcmtzIGRvIG5vdCBsaWtlIHRoZSB0eXBlIGZpZWxkIGJlaW5nIHBhc3NlZCBhbG9uZyAod2hpY2hcbiAgICAgICAgLy8gaXMgZmFpciksIHNvIHdlIGRlbGV0ZSB0eXBlIGlmIGl0IGlzIDAgYW5kIGEgbm9uLUVJUC0xNTU5IG5ldHdvcmtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgbGV0IHR4ID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgaWYgKHR4ICYmIHR4LnR5cGUgIT0gbnVsbCAmJiBnZXRCaWdJbnQodHgudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gRUlQLTE1NTkgb3IgbmV3ZXIgcHJvcGVydGllcywgaXQgbWlnaHQgYmUgcHJlLUVJUC0xNTU5XG4gICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IE9iamVjdC5hc3NpZ24oe30sIHJlcSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyB0eXBlOiB1bmRlZmluZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmdldFJwY1JlcXVlc3QocmVxKTtcbiAgICAgICAgaWYgKHJlcXVlc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX3BlcmZvcm0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzOyBpdCBkZXRlY3RzIHRoZSAqYWN0dWFsKiBuZXR3b3JrIHRoYXRcbiAgICAgKiAgd2UgYXJlICoqY3VycmVudGx5KiogY29ubmVjdGVkIHRvLlxuICAgICAqXG4gICAgICogIEtlZXAgaW4gbWluZCB0aGF0IFtbc2VuZF1dIG1heSBvbmx5IGJlIHVzZWQgb25jZSBbW3JlYWR5XV0sIG90aGVyd2lzZSB0aGVcbiAgICAgKiAgX3NlbmQgcHJpbWl0aXZlIG11c3QgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKG5ldHdvcmspIHtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI25ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlIHJlYWR5LCB1c2UgYGBzZW5kYGAsIHdoaWNoIGVuYWJsZWQgcmVxdWVzdHMgdG8gYmUgYmF0Y2hlZFxuICAgICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IE5ldHdvcmsuZnJvbShnZXRCaWdJbnQoYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgbm90IHJlYWR5IHlldDsgdXNlIHRoZSBwcmltaXRpdmUgX3NlbmRcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy4jbmV4dElkKyssIG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBwYXJhbXM6IFtdLCBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpKVswXTtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICBpZiAoXCJyZXN1bHRcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKGdldEJpZ0ludChyZXN1bHQucmVzdWx0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3VsdCk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqTVVTVCoqIGNhbGwgdGhpcy4gVW50aWwgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNhbGxzXG4gICAgICogIHdpbGwgYmUgcGFzc2VkIHRvIFtbX3NlbmRdXSBmcm9tIFtbc2VuZF1dLiBJZiBpdCBpcyBvdmVycmlkZGVuLCB0aGVuXG4gICAgICogIGBgc3VwZXIuX3N0YXJ0KClgYCAqKk1VU1QqKiBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAgQ2FsbGluZyBpdCBtdWx0aXBsZSB0aW1lcyBpcyBzYWZlIGFuZCBoYXMgbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIF9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwgfHwgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLiNub3RSZWFkeSA9IG51bGw7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgdGhlIG5ldHdvcmtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNuZXR3b3JrID09IG51bGwgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJKc29uUnBjUHJvdmlkZXIgZmFpbGVkIHRvIGRldGVjdCBuZXR3b3JrIGFuZCBjYW5ub3Qgc3RhcnQgdXA7IHJldHJ5IGluIDFzIChwZXJoYXBzIHRoZSBVUkwgaXMgd3Jvbmcgb3IgdGhlIG5vZGUgaXMgbm90IHN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJmYWlsZWQgdG8gYm9vdHN0cmFwIG5ldHdvcmsgZGV0ZWN0aW9uXCIsIFwiTkVUV09SS19FUlJPUlwiLCB7IGV2ZW50OiBcImluaXRpYWwtbmV0d29yay1kaXNjb3ZlcnlcIiwgaW5mbzogeyBlcnJvciB9IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgZGlzcGF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLiBUaGlzIGNhbiBiZSB1c2VkIGluXG4gICAgICogIHN1Yi1jbGFzc2VzIHRvIGRlZmVyIHNlbmRpbmcgZGF0YSB1bnRpbCB0aGUgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgICAqICBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdFVudGlsUmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLiNub3RSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI25vdFJlYWR5LnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBTdWJzY3JpYmVyIHRoYXQgd2lsbCBtYW5hZ2UgdGhlICUlc3ViJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZlxuICAgICAqICBzdWJzY3JpcHRpb24gbWFuYWdlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgLy8gUGVuZGluZyBGaWx0ZXJzIGFyZW4ndCBhdmFpbGJsZSB2aWEgcG9sbGluZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPcHRpb24oXCJwb2xsaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcnBoYW5lZCBMb2dzIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHksIGJ5IHRoZSBmaWx0ZXIsIHNpbmNlXG4gICAgICAgIC8vIGxvZ3Mgd2l0aCByZW1vdmVkIGFyZSBlbWl0dGVkIGJ5IGl0XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJvcnBoYW5cIiAmJiBzdWIuZmlsdGVyLm9ycGhhbiA9PT0gXCJkcm9wLWxvZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoXCJvcnBoYW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICovXG4gICAgZ2V0IHJlYWR5KCkgeyByZXR1cm4gdGhpcy4jbm90UmVhZHkgPT0gbnVsbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zICUldHglJSBhcyBhIG5vcm1hbGl6ZWQgSlNPTi1SUEMgdHJhbnNhY3Rpb24gcmVxdWVzdCxcbiAgICAgKiAgd2hpY2ggaGFzIGFsbCB2YWx1ZXMgaGV4bGlmaWVkIGFuZCBhbnkgbnVtZXJpYyB2YWx1ZXMgY29udmVydGVkXG4gICAgICogIHRvIFF1YW50aXR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXRScGNUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gSlNPTi1SUEMgbm93IHJlcXVpcmVzIG51bWVyaWMgdmFsdWVzIHRvIGJlIFwicXVhbnRpdHlcIiB2YWx1ZXNcbiAgICAgICAgW1wiY2hhaW5JZFwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ0eXBlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJub25jZVwiLCBcInZhbHVlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcbiAgICAgICAgICAgICAgICBkc3RLZXkgPSBcImdhc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2RzdEtleV0gPSB0b1F1YW50aXR5KGdldEJpZ0ludCh0eFtrZXldLCBgdHguJHtrZXl9YCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFkZHJlc3NlcyBhbmQgZGF0YSBhcmUgbG93ZXJjYXNlXG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiLCBcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZXhsaWZ5KHR4W2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBhY2Nlc3MgbGlzdCBvYmplY3RcbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtcImFjY2Vzc0xpc3RcIl0gPSBhY2Nlc3NMaXN0aWZ5KHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgPGFueT4gY2FzZSBvbmNlIEVJUC00ODQ0IGFkZGVkIHRvIHByZXBhcmVkIHR4XG4gICAgICAgICAgICByZXN1bHRbXCJibG9iVmVyc2lvbmVkSGFzaGVzXCJdID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcy5tYXAoaCA9PiBoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYXV0aG9yaXphdGlvbkxpc3RcIl0gPSB0eC5hdXRob3JpemF0aW9uTGlzdC5tYXAoKF9hKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGF1dGhvcml6YXRpb25pZnkoX2EpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHRvUXVhbnRpdHkoYS5ub25jZSksXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRvUXVhbnRpdHkoYS5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eTogdG9RdWFudGl0eShhLnNpZ25hdHVyZS55UGFyaXR5KSxcbiAgICAgICAgICAgICAgICAgICAgcjogYS5zaWduYXR1cmUucixcbiAgICAgICAgICAgICAgICAgICAgczogYS5zaWduYXR1cmUucyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IGJsb2JzIHNob3VsZCBwcm9iYWJseSBhbHNvIGJlIGNvcGllZCBvdmVyLCBvcHRpb25hbGx5XG4gICAgICAgIC8vIGFjY291bnRpbmcgZm9yIHRoZSBremcgcHJvcGVydHkgdG8gYmFja2ZpbGwgYmxvYlZlcnNpb25lZEhhc2hlc1xuICAgICAgICAvLyB1c2luZyB0aGUgY29tbWl0bWVudC4gT3Igc2hvdWxkIHRoYXQgYmUgbGVmdCBhcyBhbiBleGVyY2lzZSB0b1xuICAgICAgICAvLyB0aGUgY2FsbGVyP1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcmVxdWVzdCBtZXRob2QgYW5kIGFyZ3VtZW50cyByZXF1aXJlZCB0byBwZXJmb3JtXG4gICAgICogICUlcmVxJSUuXG4gICAgICovXG4gICAgZ2V0UnBjUmVxdWVzdChyZXEpIHtcbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9ibG9ja051bWJlclwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nYXNQcmljZVwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFByaW9yaXR5RmVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJhbGFuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiMHhcIiArIHJlcS5wb3NpdGlvbi50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5zaWduZWRUcmFuc2FjdGlvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja1RhZywgISFyZXEuaW5jbHVkZVRyYW5zYWN0aW9uc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJibG9ja0hhc2hcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuYmxvY2tIYXNoLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9lc3RpbWF0ZUdhc1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgICAgIGlmIChyZXEuZmlsdGVyICYmIHJlcS5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcS5maWx0ZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IHJlcS5maWx0ZXIuYWRkcmVzcy5tYXAoZ2V0TG93ZXJDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShyZXEuZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfZ2V0TG9nc1wiLCBhcmdzOiBbcmVxLmZpbHRlcl0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYW4gZXRoZXJzLXN0eWxlIEVycm9yIGZvciB0aGUgZ2l2ZW4gSlNPTi1SUEMgZXJyb3JcbiAgICAgKiAgJSVwYXlsb2FkJSUsIGNvYWxlc2NpbmcgdGhlIHZhcmlvdXMgc3RyaW5ncyBhbmQgZXJyb3Igc2hhcGVzXG4gICAgICogIHRoYXQgZGlmZmVyZW50IG5vZGVzIHJldHVybiwgY29lcmNpbmcgdGhlbSBpbnRvIGEgbWFjaGluZS1yZWFkYWJsZVxuICAgICAqICBzdGFuZGFyZGl6ZWQgZXJyb3IuXG4gICAgICovXG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgX2Vycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0aG9kIH0gPSBwYXlsb2FkO1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBfZXJyb3I7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIgJiYgZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghbXNnLm1hdGNoKC9yZXZlcnQvaSkgJiYgbXNnLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IChwYXlsb2FkLnBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobXNnLm1hdGNoKC9ub25jZS9pKSAmJiBtc2cubWF0Y2goL3RvbyBsb3cvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIFwiTk9OQ0VfRVhQSVJFRFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAocGF5bG9hZC5wYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9jYWxsXCIgfHwgbWV0aG9kID09PSBcImV0aF9lc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rRGF0YShlcnJvcik7XG4gICAgICAgICAgICBjb25zdCBlID0gQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiKSA/IFwiY2FsbFwiIDogXCJlc3RpbWF0ZUdhc1wiLCAocGF5bG9hZC5wYXJhbXNbMF0pLCAocmVzdWx0ID8gcmVzdWx0LmRhdGEgOiBudWxsKSk7XG4gICAgICAgICAgICBlLmluZm8gPSB7IGVycm9yLCBwYXlsb2FkIH07XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGVzdGltYXRlR2FzIGFuZCBjYWxsIGNhbiByZXR1cm4gYXJiaXRyYXJ5IGNvbnRyYWN0LWRlZmluZWQgdGV4dCwgc28gbm93IHdlXG4gICAgICAgIC8vIHdlIGNhbiBwcm9jZXNzIHRleHQgc2FmZWx5LlxuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoc3BlbHVua01lc3NhZ2UoZXJyb3IpKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWR8ZXRoZXJzLXVzZXItZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25NYXAgPSB7XG4gICAgICAgICAgICAgICAgZXRoX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBwZXJzb25hbF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjQ6IFwic2lnblR5cGVkRGF0YVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHJhbnNhY3Rpb246IFwic2lnblRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NlbmRUcmFuc2FjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBldGhfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgICAgICB3YWxsZXRfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKGB1c2VyIHJlamVjdGVkIGFjdGlvbmAsIFwiQUNUSU9OX1JFSkVDVEVEXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IChhY3Rpb25NYXBbbWV0aG9kXSB8fCBcInVua25vd25cIiksXG4gICAgICAgICAgICAgICAgcmVhc29uOiBcInJlamVjdGVkXCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiB8fCBtZXRob2QgPT09IFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IChwYXlsb2FkLnBhcmFtc1swXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzfGJhc2UgZmVlIGV4Y2VlZHMgZ2FzIGxpbWl0L2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UvaSkgJiYgbWVzc2FnZS5tYXRjaCgvdG9vIGxvdy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uL2kpICYmIG1lc3NhZ2UubWF0Y2goL3VuZGVycHJpY2VkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIiwgeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL29ubHkgcmVwbGF5LXByb3RlY3RlZC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG1ldGhvZCwgaW5mbzogeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5zdXBwb3J0ZWQgPSAhIW1lc3NhZ2UubWF0Y2goL3RoZSBtZXRob2QgLiogZG9lcyBub3QgZXhpc3QvaSk7XG4gICAgICAgIGlmICghdW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5kZXRhaWxzICYmIGVycm9yLmRldGFpbHMuc3RhcnRzV2l0aChcIlVuYXV0aG9yaXplZCBtZXRob2Q6XCIpKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcInVuc3VwcG9ydGVkIG9wZXJhdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCwgaW5mbzogeyBlcnJvciwgcGF5bG9hZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiY291bGQgbm90IGNvYWxlc2NlIGVycm9yXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IGVycm9yLCBwYXlsb2FkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVxdWVzdHMgdGhlICUlbWV0aG9kJSUgd2l0aCAlJXBhcmFtcyUlIHZpYSB0aGUgSlNPTi1SUEMgcHJvdG9jb2xcbiAgICAgKiAgb3ZlciB0aGUgdW5kZXJseWluZyBjaGFubmVsLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhbGwgbWV0aG9kc1xuICAgICAqICBvbiB0aGUgYmFja2VuZCB0aGF0IGRvIG5vdCBoYXZlIGEgaGlnaC1sZXZlbCBBUEkgd2l0aGluIHRoZSBQcm92aWRlclxuICAgICAqICBBUEkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgcXVldWVzIHJlcXVlc3RzIGFjY29yZGluZyB0byB0aGUgYmF0Y2ggY29uc3RyYWludHNcbiAgICAgKiAgaW4gdGhlIG9wdGlvbnMsIGFzc2lnbnMgdGhlIHJlcXVlc3QgYSB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiAgKipEbyBOT1Qgb3ZlcnJpZGUqKiB0aGlzIG1ldGhvZCBpbiBzdWItY2xhc3NlczsgaW5zdGVhZFxuICAgICAqICBvdmVycmlkZSBbW19zZW5kXV0gb3IgZm9yY2UgdGhlIG9wdGlvbnMgdmFsdWVzIGluIHRoZVxuICAgICAqICBjYWxsIHRvIHRoZSBjb25zdHJ1Y3RvciB0byBtb2RpZnkgdGhpcyBtZXRob2QncyBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBjYWNoZSBjaGFpbklkPz8gcHVyZ2Ugb24gc3dpdGNoX25ldHdvcmtzXG4gICAgICAgIC8vIFdlIGhhdmUgYmVlbiBkZXN0cm95ZWQ7IG5vIG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZCBhbnltb3JlXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IG1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLiNuZXh0SWQrKztcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsIHJlamVjdCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IG1ldGhvZCwgcGFyYW1zLCBpZCwganNvbnJwYzogXCIyLjBcIiB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBhIHBlbmRpbmcgZHJhaW5UaW1lciwgc2V0IG9uZVxuICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIFtbU2lnbmVyXV0gYWNjb3VudCBmb3IgICUlYWRkcmVzcyUlIG1hbmFnZWQgYnlcbiAgICAgKiAgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVhZGRyZXNzJSUgaXMgYSBudW1iZXIsIGl0IGlzIHVzZWQgYXMgYW4gaW5kZXggaW4gdGhlXG4gICAgICogIHRoZSBhY2NvdW50cyBmcm9tIFtbbGlzdEFjY291bnRzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBiZSB1c2VkIG9uIGNsaWVudHMgd2hpY2ggbWFuYWdlIGFjY291bnRzIChzdWNoIGFzXG4gICAgICogIEdldGggd2l0aCBpbXBvcnRlZCBhY2NvdW50IG9yIE1ldGFNYXNrKS5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIGFjY291bnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50c1Byb21pc2UgPSB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICAvLyBBY2NvdW50IGluZGV4XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBhY2NvdW50c1Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPj0gYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCBhY2NvdW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFjY291bnRzW2FkZHJlc3NdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50c1Byb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFjY291bnQgYWRkcmVzc1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgZm9yIChjb25zdCBhY2NvdW50IG9mIGFjY291bnRzKSB7XG4gICAgICAgICAgICBpZiAoZ2V0QWRkcmVzcyhhY2NvdW50KSA9PT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFjY291bnRcIik7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RBY2NvdW50cygpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgcHJvY2Vzc2luZyByZXF1ZXN0c1xuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RyYWluVGltZXIpO1xuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgIGZvciAoY29uc3QgeyBwYXlsb2FkLCByZWplY3QgfSBvZiB0aGlzLiNwYXlsb2Fkcykge1xuICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAvLyBQYXJlbnQgY2xlYW4tdXBcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbi8vIEBUT0RPOiByZW1vdmUgdGhpcyBpbiB2NywgaXQgaXMgbm90IGV4cG9ydGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbmFsaXR5XG4vLyBpcyBleHBvc2VkIGluIHRoZSBKc29uUnBjQXBpUHJvdmlkZXIgYnkgc2V0dGluZyBwb2xsaW5nIHRvIHRydWUuIEl0IHNob3VsZFxuLy8gYmUgc2FmZSB0byByZW1vdmUgcmVnYXJkbGVzcywgYmVjYXVzZSBpdCBpc24ndCByZWFjaGFibGUsIGJ1dCBqdXN0IGluIGNhc2UuXG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUHJvdmlkZXIge1xuICAgICNwb2xsaW5nSW50ZXJ2YWw7XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IHBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdJbnRlcnZhbFwiKTtcbiAgICAgICAgaWYgKHBvbGxpbmdJbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb2xsaW5nSW50ZXJ2YWwgPSBkZWZhdWx0T3B0aW9ucy5wb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gcG9sbGluZ0ludGVydmFsO1xuICAgIH1cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwb2xsaW5nIGludGVydmFsIChkZWZhdWx0OiA0MDAwIG1zKVxuICAgICAqL1xuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludGVydmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigoc3ViKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNQb2xsYWJsZShzdWIpKSB7XG4gICAgICAgICAgICAgICAgc3ViLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNQcm92aWRlciBpcyBvbmUgb2YgdGhlIG1vc3QgY29tbW9uIFByb3ZpZGVycyxcbiAqICB3aGljaCBwZXJmb3JtcyBhbGwgb3BlcmF0aW9ucyBvdmVyIEhUVFAgKG9yIEhUVFBTKSByZXF1ZXN0cy5cbiAqXG4gKiAgRXZlbnRzIGFyZSBwcm9jZXNzZWQgYnkgcG9sbGluZyB0aGUgYmFja2VuZCBmb3IgdGhlIGN1cnJlbnQgYmxvY2tcbiAqICBudW1iZXI7IHdoZW4gaXQgYWR2YW5jZXMsIGFsbCBibG9jay1iYXNlIGV2ZW50cyBhcmUgdGhlbiBjaGVja2VkXG4gKiAgZm9yIHVwZGF0ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIHtcbiAgICAjY29ubmVjdDtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICB1cmwgPSBcImh0dHA6L1xcL2xvY2FsaG9zdDo4NTQ1XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gdXJsLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjb25uZWN0LmNsb25lKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQWxsIHJlcXVlc3RzIGFyZSBvdmVyIEhUVFAsIHNvIHdlIGNhbiBqdXN0IHN0YXJ0IGhhbmRsaW5nIHJlcXVlc3RzXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgaGVyZSByYXRoZXIgdGhhbiB0aGUgY29uc3RydWN0b3Igc28gdGhhdCB3ZSBkb24ndCBzZW5kIGFueVxuICAgICAgICAvLyByZXF1ZXN0cyB0byB0aGUgbmV0d29yayAoaS5lLiBldGhfY2hhaW5JZCkgdW50aWwgd2UgYWJzb2x1dGVseSBoYXZlIHRvLlxuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kKHBheWxvYWQpIHtcbiAgICAgICAgLy8gQ29uZmlndXJlIGEgUE9TVCBjb25uZWN0aW9uIGZvciB0aGUgcmVxdWVzdGVkIG1ldGhvZFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICByZXF1ZXN0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xuICAgICAgICBsZXQgcmVzcCA9IHJlc3BvbnNlLmJvZHlKc29uO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcCkpIHtcbiAgICAgICAgICAgIHJlc3AgPSBbcmVzcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfVxufVxuZnVuY3Rpb24gc3BlbHVua0RhdGEodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnQvaSkgJiYgaXNIZXhTdHJpbmcodmFsdWUuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogdmFsdWUubWVzc2FnZSwgZGF0YTogdmFsdWUuZGF0YSB9O1xuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWx1bmtEYXRhKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZVtrZXldLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIF9zcGVsdW5rTWVzc2FnZShKU09OLnBhcnNlKHZhbHVlKSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNwZWx1bmtNZXNzYWdlKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1qc29ucnBjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-pocket.js":
/*!**************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-pocket.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PocketProvider: function() { return /* binding */ PocketProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./community.js */ \"../common/node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\n *  [[link-pocket]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Polygon (``matic``)\n *  - Arbitrum (``arbitrum``)\n *\n *  @_subsection: api/providers/thirdparty:Pocket  [providers-pocket]\n */\n\n\n\n\nconst defaultApplicationId = \"62e1ad51b37b8e00394bda3b\";\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"eth-mainnet.gateway.pokt.network\";\n        case \"goerli\":\n            return \"eth-goerli.gateway.pokt.network\";\n        case \"matic\":\n            return \"poly-mainnet.gateway.pokt.network\";\n        case \"matic-mumbai\":\n            return \"polygon-mumbai-rpc.gateway.pokt.network\";\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **PocketProvider** connects to the [[link-pocket]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-pocket-signup).\n */\nclass PocketProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\n    /**\n     *  The Application ID for the Pocket connection.\n     */\n    applicationId;\n    /**\n     *  The Application Secret for making authenticated requests\n     *  to the Pocket connection.\n     */\n    applicationSecret;\n    /**\n     *  Create a new **PocketProvider**.\n     *\n     *  By default connecting to ``mainnet`` with a highly throttled\n     *  API key.\n     */\n    constructor(_network, applicationId, applicationSecret) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\n        if (applicationId == null) {\n            applicationId = defaultApplicationId;\n        }\n        if (applicationSecret == null) {\n            applicationSecret = null;\n        }\n        const options = { staticNetwork: network };\n        const request = PocketProvider.getRequest(network, applicationId, applicationSecret);\n        super(request, network, options);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { applicationId, applicationSecret });\n    }\n    _getProvider(chainId) {\n        try {\n            return new PocketProvider(chainId, this.applicationId, this.applicationSecret);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%% with\n     *  %%applicationId%%.\n     */\n    static getRequest(network, applicationId, applicationSecret) {\n        if (applicationId == null) {\n            applicationId = defaultApplicationId;\n        }\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/v1/lb/${applicationId}`);\n        request.allowGzip = true;\n        if (applicationSecret) {\n            request.setCredentials(\"\", applicationSecret);\n        }\n        if (applicationId === defaultApplicationId) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)(\"PocketProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n    isCommunityResource() {\n        return (this.applicationId === defaultApplicationId);\n    }\n}\n//# sourceMappingURL=provider-pocket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItcG9ja2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUY7QUFDOUI7QUFDZDtBQUNpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLGlFQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxrQ0FBa0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQVksYUFBYSxzQkFBc0IsU0FBUyxjQUFjO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLXBvY2tldC5qcz80OGI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFtbbGluay1wb2NrZXRdXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXG4gKlxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcbiAqXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcbiAqICAtIEdvZXJsaSBUZXN0bmV0IChgYGdvZXJsaWBgKVxuICogIC0gUG9seWdvbiAoYGBtYXRpY2BgKVxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6UG9ja2V0ICBbcHJvdmlkZXJzLXBvY2tldF1cbiAqL1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgRmV0Y2hSZXF1ZXN0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgc2hvd1Rocm90dGxlTWVzc2FnZSB9IGZyb20gXCIuL2NvbW11bml0eS5qc1wiO1xuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcbmNvbnN0IGRlZmF1bHRBcHBsaWNhdGlvbklkID0gXCI2MmUxYWQ1MWIzN2I4ZTAwMzk0YmRhM2JcIjtcbmZ1bmN0aW9uIGdldEhvc3QobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoLW1haW5uZXQuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoLWdvZXJsaS5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHktbWFpbm5ldC5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICBjYXNlIFwibWF0aWMtbXVtYmFpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5Z29uLW11bWJhaS1ycGMuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG59XG4vKipcbiAqICBUaGUgKipQb2NrZXRQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstcG9ja2V0XV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1wb2NrZXQtc2lnbnVwKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBvY2tldFByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIEFwcGxpY2F0aW9uIElEIGZvciB0aGUgUG9ja2V0IGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYXBwbGljYXRpb25JZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIEFwcGxpY2F0aW9uIFNlY3JldCBmb3IgbWFraW5nIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdHNcbiAgICAgKiAgdG8gdGhlIFBvY2tldCBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFwcGxpY2F0aW9uU2VjcmV0O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2NrZXRQcm92aWRlcioqLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQgY29ubmVjdGluZyB0byBgYG1haW5uZXRgYCB3aXRoIGEgaGlnaGx5IHRocm90dGxlZFxuICAgICAqICBBUEkga2V5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCkge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgaWYgKGFwcGxpY2F0aW9uSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBwbGljYXRpb25JZCA9IGRlZmF1bHRBcHBsaWNhdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHBsaWNhdGlvblNlY3JldCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcHBsaWNhdGlvblNlY3JldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgc3RhdGljTmV0d29yazogbmV0d29yayB9O1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gUG9ja2V0UHJvdmlkZXIuZ2V0UmVxdWVzdChuZXR3b3JrLCBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCk7XG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXBwbGljYXRpb25JZCwgYXBwbGljYXRpb25TZWNyZXQgfSk7XG4gICAgfVxuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvY2tldFByb3ZpZGVyKGNoYWluSWQsIHRoaXMuYXBwbGljYXRpb25JZCwgdGhpcy5hcHBsaWNhdGlvblNlY3JldCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRQcm92aWRlcihjaGFpbklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBwcmVwYXJlZCByZXF1ZXN0IGZvciBjb25uZWN0aW5nIHRvICUlbmV0d29yayUlIHdpdGhcbiAgICAgKiAgJSVhcHBsaWNhdGlvbklkJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgYXBwbGljYXRpb25JZCwgYXBwbGljYXRpb25TZWNyZXQpIHtcbiAgICAgICAgaWYgKGFwcGxpY2F0aW9uSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBwbGljYXRpb25JZCA9IGRlZmF1bHRBcHBsaWNhdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9L3YxL2xiLyR7YXBwbGljYXRpb25JZH1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICBpZiAoYXBwbGljYXRpb25TZWNyZXQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0Q3JlZGVudGlhbHMoXCJcIiwgYXBwbGljYXRpb25TZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHBsaWNhdGlvbklkID09PSBkZWZhdWx0QXBwbGljYXRpb25JZCkge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSBhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIGF0dGVtcHQpID0+IHtcbiAgICAgICAgICAgICAgICBzaG93VGhyb3R0bGVNZXNzYWdlKFwiUG9ja2V0UHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBwbGljYXRpb25JZCA9PT0gZGVmYXVsdEFwcGxpY2F0aW9uSWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLXBvY2tldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-pocket.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-quicknode.js":
/*!*****************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-quicknode.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuickNodeProvider: function() { return /* binding */ QuickNodeProvider; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _community_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./community.js */ \"../common/node_modules/ethers/lib.esm/providers/community.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network.js */ \"../common/node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\n *  [[link-quicknode]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Holesky Testnet (``holesky``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)\n *  - Base Mainnet (``base``);\n *  - Base Goerli Testnet (``base-goerli``);\n *  - Base Sepolia Testnet (``base-sepolia``);\n *  - BNB Smart Chain Mainnet (``bnb``)\n *  - BNB Smart Chain Testnet (``bnbt``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Optimism Sepolia Testnet (``optimism-sepolia``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection: api/providers/thirdparty:QuickNode  [providers-quicknode]\n */\n\n\n\n\nconst defaultToken = \"919b412a057b5e9c9b6dce193c5a60242d6efadb\";\nfunction getHost(name) {\n    switch (name) {\n        case \"mainnet\":\n            return \"ethers.quiknode.pro\";\n        case \"goerli\":\n            return \"ethers.ethereum-goerli.quiknode.pro\";\n        case \"sepolia\":\n            return \"ethers.ethereum-sepolia.quiknode.pro\";\n        case \"holesky\":\n            return \"ethers.ethereum-holesky.quiknode.pro\";\n        case \"arbitrum\":\n            return \"ethers.arbitrum-mainnet.quiknode.pro\";\n        case \"arbitrum-goerli\":\n            return \"ethers.arbitrum-goerli.quiknode.pro\";\n        case \"arbitrum-sepolia\":\n            return \"ethers.arbitrum-sepolia.quiknode.pro\";\n        case \"base\":\n            return \"ethers.base-mainnet.quiknode.pro\";\n        case \"base-goerli\":\n            return \"ethers.base-goerli.quiknode.pro\";\n        case \"base-spolia\":\n            return \"ethers.base-sepolia.quiknode.pro\";\n        case \"bnb\":\n            return \"ethers.bsc.quiknode.pro\";\n        case \"bnbt\":\n            return \"ethers.bsc-testnet.quiknode.pro\";\n        case \"matic\":\n            return \"ethers.matic.quiknode.pro\";\n        case \"matic-mumbai\":\n            return \"ethers.matic-testnet.quiknode.pro\";\n        case \"optimism\":\n            return \"ethers.optimism.quiknode.pro\";\n        case \"optimism-goerli\":\n            return \"ethers.optimism-goerli.quiknode.pro\";\n        case \"optimism-sepolia\":\n            return \"ethers.optimism-sepolia.quiknode.pro\";\n        case \"xdai\":\n            return \"ethers.xdai.quiknode.pro\";\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/*\n@TODO:\n  These networks are not currently present in the Network\n  default included networks. Research them and ensure they\n  are EVM compatible and work with ethers\n\n  http://ethers.matic-amoy.quiknode.pro\n\n  http://ethers.avalanche-mainnet.quiknode.pro\n  http://ethers.avalanche-testnet.quiknode.pro\n  http://ethers.blast-sepolia.quiknode.pro\n  http://ethers.celo-mainnet.quiknode.pro\n  http://ethers.fantom.quiknode.pro\n  http://ethers.imx-demo.quiknode.pro\n  http://ethers.imx-mainnet.quiknode.pro\n  http://ethers.imx-testnet.quiknode.pro\n  http://ethers.near-mainnet.quiknode.pro\n  http://ethers.near-testnet.quiknode.pro\n  http://ethers.nova-mainnet.quiknode.pro\n  http://ethers.scroll-mainnet.quiknode.pro\n  http://ethers.scroll-testnet.quiknode.pro\n  http://ethers.tron-mainnet.quiknode.pro\n  http://ethers.zkevm-mainnet.quiknode.pro\n  http://ethers.zkevm-testnet.quiknode.pro\n  http://ethers.zksync-mainnet.quiknode.pro\n  http://ethers.zksync-testnet.quiknode.pro\n*/\n/**\n *  The **QuickNodeProvider** connects to the [[link-quicknode]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API token is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-quicknode).\n */\nclass QuickNodeProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\n    /**\n     *  The API token.\n     */\n    token;\n    /**\n     *  Creates a new **QuickNodeProvider**.\n     */\n    constructor(_network, token) {\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = _network_js__WEBPACK_IMPORTED_MODULE_2__.Network.from(_network);\n        if (token == null) {\n            token = defaultToken;\n        }\n        const request = QuickNodeProvider.getRequest(network, token);\n        super(request, network, { staticNetwork: network });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { token });\n    }\n    _getProvider(chainId) {\n        try {\n            return new QuickNodeProvider(chainId, this.token);\n        }\n        catch (error) { }\n        return super._getProvider(chainId);\n    }\n    isCommunityResource() {\n        return (this.token === defaultToken);\n    }\n    /**\n     *  Returns a new request prepared for %%network%% and the\n     *  %%token%%.\n     */\n    static getRequest(network, token) {\n        if (token == null) {\n            token = defaultToken;\n        }\n        const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(`https:/\\/${getHost(network.name)}/${token}`);\n        request.allowGzip = true;\n        //if (projectSecret) { request.setCredentials(\"\", projectSecret); }\n        if (token === defaultToken) {\n            request.retryFunc = async (request, response, attempt) => {\n                (0,_community_js__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)(\"QuickNodeProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n}\n//# sourceMappingURL=provider-quicknode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItcXVpY2tub2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRjtBQUM5QjtBQUNkO0FBQ2lCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsaUVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsUUFBUSxpRUFBZ0IsU0FBUyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFZLGFBQWEsc0JBQXNCLEdBQUcsTUFBTTtBQUNwRjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItcXVpY2tub2RlLmpzPzIxMGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgW1tsaW5rLXF1aWNrbm9kZV1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXG4gKiAgLSBTZXBvbGlhIFRlc3RuZXQgKGBgc2Vwb2xpYWBgKVxuICogIC0gSG9sZXNreSBUZXN0bmV0IChgYGhvbGVza3lgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBBcmJpdHJ1bSBHb2VybGkgVGVzdG5ldCAoYGBhcmJpdHJ1bS1nb2VybGlgYClcbiAqICAtIEFyYml0cnVtIFNlcG9saWEgVGVzdG5ldCAoYGBhcmJpdHJ1bS1zZXBvbGlhYGApXG4gKiAgLSBCYXNlIE1haW5uZXQgKGBgYmFzZWBgKTtcbiAqICAtIEJhc2UgR29lcmxpIFRlc3RuZXQgKGBgYmFzZS1nb2VybGlgYCk7XG4gKiAgLSBCYXNlIFNlcG9saWEgVGVzdG5ldCAoYGBiYXNlLXNlcG9saWFgYCk7XG4gKiAgLSBCTkIgU21hcnQgQ2hhaW4gTWFpbm5ldCAoYGBibmJgYClcbiAqICAtIEJOQiBTbWFydCBDaGFpbiBUZXN0bmV0IChgYGJuYnRgYClcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXG4gKiAgLSBPcHRpbWlzbSBHb2VybGkgVGVzdG5ldCAoYGBvcHRpbWlzbS1nb2VybGlgYClcbiAqICAtIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoYGBvcHRpbWlzbS1zZXBvbGlhYGApXG4gKiAgLSBQb2x5Z29uIChgYG1hdGljYGApXG4gKiAgLSBQb2x5Z29uIE11bWJhaSBUZXN0bmV0IChgYG1hdGljLW11bWJhaWBgKVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpRdWlja05vZGUgIFtwcm92aWRlcnMtcXVpY2tub2RlXVxuICovXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBGZXRjaFJlcXVlc3QsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vY29tbXVuaXR5LmpzXCI7XG5pbXBvcnQgeyBOZXR3b3JrIH0gZnJvbSBcIi4vbmV0d29yay5qc1wiO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiO1xuY29uc3QgZGVmYXVsdFRva2VuID0gXCI5MTliNDEyYTA1N2I1ZTljOWI2ZGNlMTkzYzVhNjAyNDJkNmVmYWRiXCI7XG5mdW5jdGlvbiBnZXRIb3N0KG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmV0aGVyZXVtLWdvZXJsaS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5ldGhlcmV1bS1zZXBvbGlhLnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwiaG9sZXNreVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmV0aGVyZXVtLWhvbGVza3kucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmFyYml0cnVtLW1haW5uZXQucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5hcmJpdHJ1bS1nb2VybGkucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYXJiaXRydW0tc2Vwb2xpYS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5iYXNlLW1haW5uZXQucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmJhc2UtZ29lcmxpLnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwiYmFzZS1zcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5iYXNlLXNlcG9saWEucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJibmJcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5ic2MucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJibmJ0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYnNjLXRlc3RuZXQucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLm1hdGljLnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwibWF0aWMtbXVtYmFpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMubWF0aWMtdGVzdG5ldC5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMub3B0aW1pc20ucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5vcHRpbWlzbS1nb2VybGkucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1zZXBvbGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMub3B0aW1pc20tc2Vwb2xpYS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcInhkYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy54ZGFpLnF1aWtub2RlLnByb1wiO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuYW1lKTtcbn1cbi8qXG5AVE9ETzpcbiAgVGhlc2UgbmV0d29ya3MgYXJlIG5vdCBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgTmV0d29ya1xuICBkZWZhdWx0IGluY2x1ZGVkIG5ldHdvcmtzLiBSZXNlYXJjaCB0aGVtIGFuZCBlbnN1cmUgdGhleVxuICBhcmUgRVZNIGNvbXBhdGlibGUgYW5kIHdvcmsgd2l0aCBldGhlcnNcblxuICBodHRwOi8vZXRoZXJzLm1hdGljLWFtb3kucXVpa25vZGUucHJvXG5cbiAgaHR0cDovL2V0aGVycy5hdmFsYW5jaGUtbWFpbm5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy5hdmFsYW5jaGUtdGVzdG5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy5ibGFzdC1zZXBvbGlhLnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLmNlbG8tbWFpbm5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy5mYW50b20ucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuaW14LWRlbW8ucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuaW14LW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuaW14LXRlc3RuZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMubmVhci1tYWlubmV0LnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLm5lYXItdGVzdG5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy5ub3ZhLW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuc2Nyb2xsLW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuc2Nyb2xsLXRlc3RuZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMudHJvbi1tYWlubmV0LnF1aWtub2RlLnByb1xuICBodHRwOi8vZXRoZXJzLnprZXZtLW1haW5uZXQucXVpa25vZGUucHJvXG4gIGh0dHA6Ly9ldGhlcnMuemtldm0tdGVzdG5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy56a3N5bmMtbWFpbm5ldC5xdWlrbm9kZS5wcm9cbiAgaHR0cDovL2V0aGVycy56a3N5bmMtdGVzdG5ldC5xdWlrbm9kZS5wcm9cbiovXG4vKipcbiAqICBUaGUgKipRdWlja05vZGVQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstcXVpY2tub2RlXV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIHRva2VuIGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLXF1aWNrbm9kZSkuXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWlja05vZGVQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBBUEkgdG9rZW4uXG4gICAgICovXG4gICAgdG9rZW47XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipRdWlja05vZGVQcm92aWRlcioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCB0b2tlbikge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgIHRva2VuID0gZGVmYXVsdFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBRdWlja05vZGVQcm92aWRlci5nZXRSZXF1ZXN0KG5ldHdvcmssIHRva2VuKTtcbiAgICAgICAgc3VwZXIocmVxdWVzdCwgbmV0d29yaywgeyBzdGF0aWNOZXR3b3JrOiBuZXR3b3JrIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdG9rZW4gfSk7XG4gICAgfVxuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFF1aWNrTm9kZVByb3ZpZGVyKGNoYWluSWQsIHRoaXMudG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50b2tlbiA9PT0gZGVmYXVsdFRva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgcmVxdWVzdCBwcmVwYXJlZCBmb3IgJSVuZXR3b3JrJSUgYW5kIHRoZVxuICAgICAqICAlJXRva2VuJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgIHRva2VuID0gZGVmYXVsdFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9LyR7dG9rZW59YCk7XG4gICAgICAgIHJlcXVlc3QuYWxsb3dHemlwID0gdHJ1ZTtcbiAgICAgICAgLy9pZiAocHJvamVjdFNlY3JldCkgeyByZXF1ZXN0LnNldENyZWRlbnRpYWxzKFwiXCIsIHByb2plY3RTZWNyZXQpOyB9XG4gICAgICAgIGlmICh0b2tlbiA9PT0gZGVmYXVsdFRva2VuKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNob3dUaHJvdHRsZU1lc3NhZ2UoXCJRdWlja05vZGVQcm92aWRlclwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItcXVpY2tub2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-quicknode.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-socket.js":
/*!**************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-socket.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SocketBlockSubscriber: function() { return /* binding */ SocketBlockSubscriber; },\n/* harmony export */   SocketEventSubscriber: function() { return /* binding */ SocketEventSubscriber; },\n/* harmony export */   SocketPendingSubscriber: function() { return /* binding */ SocketPendingSubscriber; },\n/* harmony export */   SocketProvider: function() { return /* binding */ SocketProvider; },\n/* harmony export */   SocketSubscriber: function() { return /* binding */ SocketSubscriber; }\n/* harmony export */ });\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-provider.js */ \"../common/node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider:Socket Providers  [about-socketProvider]\n */\n\n\n\n/**\n *  A **SocketSubscriber** uses a socket transport to handle events and\n *  should use [[_emit]] to manage the events.\n */\nclass SocketSubscriber {\n    #provider;\n    #filter;\n    /**\n     *  The filter.\n     */\n    get filter() { return JSON.parse(this.#filter); }\n    #filterId;\n    #paused;\n    #emitPromise;\n    /**\n     *  Creates a new **SocketSubscriber** attached to %%provider%% listening\n     *  to %%filter%%.\n     */\n    constructor(provider, filter) {\n        this.#provider = provider;\n        this.#filter = JSON.stringify(filter);\n        this.#filterId = null;\n        this.#paused = null;\n        this.#emitPromise = null;\n    }\n    start() {\n        this.#filterId = this.#provider.send(\"eth_subscribe\", this.filter).then((filterId) => {\n            ;\n            this.#provider._register(filterId, this);\n            return filterId;\n        });\n    }\n    stop() {\n        (this.#filterId).then((filterId) => {\n            if (this.#provider.destroyed) {\n                return;\n            }\n            this.#provider.send(\"eth_unsubscribe\", [filterId]);\n        });\n        this.#filterId = null;\n    }\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n    //        and resume\n    pause(dropWhilePaused) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\", \"UNSUPPORTED_OPERATION\", { operation: \"pause(false)\" });\n        this.#paused = !!dropWhilePaused;\n    }\n    resume() {\n        this.#paused = null;\n    }\n    /**\n     *  @_ignore:\n     */\n    _handleMessage(message) {\n        if (this.#filterId == null) {\n            return;\n        }\n        if (this.#paused === null) {\n            let emitPromise = this.#emitPromise;\n            if (emitPromise == null) {\n                emitPromise = this._emit(this.#provider, message);\n            }\n            else {\n                emitPromise = emitPromise.then(async () => {\n                    await this._emit(this.#provider, message);\n                });\n            }\n            this.#emitPromise = emitPromise.then(() => {\n                if (this.#emitPromise === emitPromise) {\n                    this.#emitPromise = null;\n                }\n            });\n        }\n    }\n    /**\n     *  Sub-classes **must** override this to emit the events on the\n     *  provider.\n     */\n    async _emit(provider, message) {\n        throw new Error(\"sub-classes must implemente this; _emit\");\n    }\n}\n/**\n *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n *  ``\"block\"`` events.\n */\nclass SocketBlockSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */\n    constructor(provider) {\n        super(provider, [\"newHeads\"]);\n    }\n    async _emit(provider, message) {\n        provider.emit(\"block\", parseInt(message.number));\n    }\n}\n/**\n *  A **SocketPendingSubscriber** listens for pending transacitons and emits\n *  ``\"pending\"`` events.\n */\nclass SocketPendingSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */\n    constructor(provider) {\n        super(provider, [\"newPendingTransactions\"]);\n    }\n    async _emit(provider, message) {\n        provider.emit(\"pending\", message);\n    }\n}\n/**\n *  A **SocketEventSubscriber** listens for event logs.\n */\nclass SocketEventSubscriber extends SocketSubscriber {\n    #logFilter;\n    /**\n     *  The filter.\n     */\n    get logFilter() { return JSON.parse(this.#logFilter); }\n    /**\n     *  @_ignore:\n     */\n    constructor(provider, filter) {\n        super(provider, [\"logs\", filter]);\n        this.#logFilter = JSON.stringify(filter);\n    }\n    async _emit(provider, message) {\n        provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\n    }\n}\n/**\n *  A **SocketProvider** is backed by a long-lived connection over a\n *  socket, which can subscribe and receive real-time messages over\n *  its communication channel.\n */\nclass SocketProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcApiProvider {\n    #callbacks;\n    // Maps each filterId to its subscriber\n    #subs;\n    // If any events come in before a subscriber has finished\n    // registering, queue them\n    #pending;\n    /**\n     *  Creates a new **SocketProvider** connected to %%network%%.\n     *\n     *  If unspecified, the network will be discovered.\n     */\n    constructor(network, _options) {\n        // Copy the options\n        const options = Object.assign({}, (_options != null) ? _options : {});\n        // Support for batches is generally not supported for\n        // connection-base providers; if this changes in the future\n        // the _send should be updated to reflect this\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(options.batchMaxCount == null || options.batchMaxCount === 1, \"sockets-based providers do not support batches\", \"options.batchMaxCount\", _options);\n        options.batchMaxCount = 1;\n        // Socket-based Providers (generally) cannot change their network,\n        // since they have a long-lived connection; but let people override\n        // this if they have just cause.\n        if (options.staticNetwork == null) {\n            options.staticNetwork = true;\n        }\n        super(network, options);\n        this.#callbacks = new Map();\n        this.#subs = new Map();\n        this.#pending = new Map();\n    }\n    // This value is only valid after _start has been called\n    /*\n    get _network(): Network {\n        if (this.#network == null) {\n            throw new Error(\"this shouldn't happen\");\n        }\n        return this.#network.clone();\n    }\n    */\n    _getSubscriber(sub) {\n        switch (sub.type) {\n            case \"close\":\n                return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_2__.UnmanagedSubscriber(\"close\");\n            case \"block\":\n                return new SocketBlockSubscriber(this);\n            case \"pending\":\n                return new SocketPendingSubscriber(this);\n            case \"event\":\n                return new SocketEventSubscriber(this, sub.filter);\n            case \"orphan\":\n                // Handled auto-matically within AbstractProvider\n                // when the log.removed = true\n                if (sub.filter.orphan === \"drop-log\") {\n                    return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_2__.UnmanagedSubscriber(\"drop-log\");\n                }\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Register a new subscriber. This is used internalled by Subscribers\n     *  and generally is unecessary unless extending capabilities.\n     */\n    _register(filterId, subscriber) {\n        this.#subs.set(filterId, subscriber);\n        const pending = this.#pending.get(filterId);\n        if (pending) {\n            for (const message of pending) {\n                subscriber._handleMessage(message);\n            }\n            this.#pending.delete(filterId);\n        }\n    }\n    async _send(payload) {\n        // WebSocket provider doesn't accept batches\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\n        // @TODO: stringify payloads here and store to prevent mutations\n        // Prepare a promise to respond to\n        const promise = new Promise((resolve, reject) => {\n            this.#callbacks.set(payload.id, { payload, resolve, reject });\n        });\n        // Wait until the socket is connected before writing to it\n        await this._waitUntilReady();\n        // Write the request to the socket\n        await this._write(JSON.stringify(payload));\n        return [await promise];\n    }\n    // Sub-classes must call this once they are connected\n    /*\n    async _start(): Promise<void> {\n        if (this.#ready) { return; }\n\n        for (const { payload } of this.#callbacks.values()) {\n            await this._write(JSON.stringify(payload));\n        }\n\n        this.#ready = (async function() {\n            await super._start();\n        })();\n    }\n    */\n    /**\n     *  Sub-classes **must** call this with messages received over their\n     *  transport to be processed and dispatched.\n     */\n    async _processMessage(message) {\n        const result = (JSON.parse(message));\n        if (result && typeof (result) === \"object\" && \"id\" in result) {\n            const callback = this.#callbacks.get(result.id);\n            if (callback == null) {\n                this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"received result for unknown id\", \"UNKNOWN_ERROR\", {\n                    reasonCode: \"UNKNOWN_ID\",\n                    result\n                }));\n                return;\n            }\n            this.#callbacks.delete(result.id);\n            callback.resolve(result);\n        }\n        else if (result && result.method === \"eth_subscription\") {\n            const filterId = result.params.subscription;\n            const subscriber = this.#subs.get(filterId);\n            if (subscriber) {\n                subscriber._handleMessage(result.params.result);\n            }\n            else {\n                let pending = this.#pending.get(filterId);\n                if (pending == null) {\n                    pending = [];\n                    this.#pending.set(filterId, pending);\n                }\n                pending.push(result.params.result);\n            }\n        }\n        else {\n            this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"received unexpected message\", \"UNKNOWN_ERROR\", {\n                reasonCode: \"UNEXPECTED_MESSAGE\",\n                result\n            }));\n            return;\n        }\n    }\n    /**\n     *  Sub-classes **must** override this to send %%message%% over their\n     *  transport.\n     */\n    async _write(message) {\n        throw new Error(\"sub-classes must override this\");\n    }\n}\n//# sourceMappingURL=provider-socket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItc29ja2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7QUFDUztBQUNYO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLGlIQUFpSCwyQkFBMkI7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLG9FQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQ0FBb0M7QUFDNUU7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNFQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzRUFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBCQUEwQjtBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQixxQkFBcUIsVUFBVTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwREFBUztBQUM1QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwREFBUztBQUN4QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItc29ja2V0LmpzP2UyZTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgR2VuZXJpYyBsb25nLWxpdmVkIHNvY2tldCBwcm92aWRlci5cbiAqXG4gKiAgU3ViLWNsYXNzaW5nIG5vdGVzXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIGNhbGwgdGhlIGBfc3RhcnQoKWAgbWV0aG9kIG9uY2UgY29ubmVjdGVkXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIG92ZXJyaWRlIHRoZSBgX3dyaXRlKHN0cmluZylgIG1ldGhvZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIGBfcHJvY2Vzc01lc3NhZ2Uoc3RyaW5nKWAgZm9yIGVhY2ggbWVzc2FnZVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXI6U29ja2V0IFByb3ZpZGVycyAgW2Fib3V0LXNvY2tldFByb3ZpZGVyXVxuICovXG5pbXBvcnQgeyBVbm1hbmFnZWRTdWJzY3JpYmVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSnNvblJwY0FwaVByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiO1xuLyoqXG4gKiAgQSAqKlNvY2tldFN1YnNjcmliZXIqKiB1c2VzIGEgc29ja2V0IHRyYW5zcG9ydCB0byBoYW5kbGUgZXZlbnRzIGFuZFxuICogIHNob3VsZCB1c2UgW1tfZW1pdF1dIHRvIG1hbmFnZSB0aGUgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgU29ja2V0U3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBmaWx0ZXIuXG4gICAgICovXG4gICAgZ2V0IGZpbHRlcigpIHsgcmV0dXJuIEpTT04ucGFyc2UodGhpcy4jZmlsdGVyKTsgfVxuICAgICNmaWx0ZXJJZDtcbiAgICAjcGF1c2VkO1xuICAgICNlbWl0UHJvbWlzZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNvY2tldFN1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUgbGlzdGVuaW5nXG4gICAgICogIHRvICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBKU09OLnN0cmluZ2lmeShmaWx0ZXIpO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BhdXNlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuI2VtaXRQcm9taXNlID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuI2ZpbHRlcklkID0gdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF9zdWJzY3JpYmVcIiwgdGhpcy5maWx0ZXIpLnRoZW4oKGZpbHRlcklkKSA9PiB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5fcmVnaXN0ZXIoZmlsdGVySWQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgKHRoaXMuI2ZpbHRlcklkKS50aGVuKChmaWx0ZXJJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3Byb3ZpZGVyLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfdW5zdWJzY3JpYmVcIiwgW2ZpbHRlcklkXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZCA9IG51bGw7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBwYXVzZSBzaG91bGQgdHJhcCB0aGUgY3VycmVudCBibG9ja051bWJlciwgdW5zdWIsIGFuZCBvbiByZXN1bWUgdXNlIGdldExvZ3NcbiAgICAvLyAgICAgICAgYW5kIHJlc3VtZVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBhc3NlcnQoZHJvcFdoaWxlUGF1c2VkLCBcInByZXNlcnZlIGxvZ3Mgd2hpbGUgcGF1c2VkIG5vdCBzdXBwb3J0ZWQgYnkgU29ja2V0U3Vic2NyaWJlciB5ZXRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicGF1c2UoZmFsc2UpXCIgfSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZCA9ICEhZHJvcFdoaWxlUGF1c2VkO1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuI3BhdXNlZCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLiNmaWx0ZXJJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGVtaXRQcm9taXNlID0gdGhpcy4jZW1pdFByb21pc2U7XG4gICAgICAgICAgICBpZiAoZW1pdFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVtaXRQcm9taXNlID0gdGhpcy5fZW1pdCh0aGlzLiNwcm92aWRlciwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0UHJvbWlzZSA9IGVtaXRQcm9taXNlLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9lbWl0KHRoaXMuI3Byb3ZpZGVyLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2VtaXRQcm9taXNlID0gZW1pdFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2VtaXRQcm9taXNlID09PSBlbWl0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNlbWl0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gZW1pdCB0aGUgZXZlbnRzIG9uIHRoZVxuICAgICAqICBwcm92aWRlci5cbiAgICAgKi9cbiAgICBhc3luYyBfZW1pdChwcm92aWRlciwgbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudGUgdGhpczsgX2VtaXRcIik7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlNvY2tldEJsb2NrU3Vic2NyaWJlcioqIGxpc3RlbnMgZm9yIGBgbmV3SGVhZHNgYCBldmVudHMgYW5kIGVtaXRzXG4gKiAgYGBcImJsb2NrXCJgYCBldmVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2NrZXRCbG9ja1N1YnNjcmliZXIgZXh0ZW5kcyBTb2NrZXRTdWJzY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIsIFtcIm5ld0hlYWRzXCJdKTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXQocHJvdmlkZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvdmlkZXIuZW1pdChcImJsb2NrXCIsIHBhcnNlSW50KG1lc3NhZ2UubnVtYmVyKSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlNvY2tldFBlbmRpbmdTdWJzY3JpYmVyKiogbGlzdGVucyBmb3IgcGVuZGluZyB0cmFuc2FjaXRvbnMgYW5kIGVtaXRzXG4gKiAgYGBcInBlbmRpbmdcImBgIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNvY2tldFBlbmRpbmdTdWJzY3JpYmVyIGV4dGVuZHMgU29ja2V0U3Vic2NyaWJlciB7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyLCBbXCJuZXdQZW5kaW5nVHJhbnNhY3Rpb25zXCJdKTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXQocHJvdmlkZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvdmlkZXIuZW1pdChcInBlbmRpbmdcIiwgbWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlNvY2tldEV2ZW50U3Vic2NyaWJlcioqIGxpc3RlbnMgZm9yIGV2ZW50IGxvZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2NrZXRFdmVudFN1YnNjcmliZXIgZXh0ZW5kcyBTb2NrZXRTdWJzY3JpYmVyIHtcbiAgICAjbG9nRmlsdGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmlsdGVyLlxuICAgICAqL1xuICAgIGdldCBsb2dGaWx0ZXIoKSB7IHJldHVybiBKU09OLnBhcnNlKHRoaXMuI2xvZ0ZpbHRlcik7IH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlciwgW1wibG9nc1wiLCBmaWx0ZXJdKTtcbiAgICAgICAgdGhpcy4jbG9nRmlsdGVyID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyKTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXQocHJvdmlkZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLmxvZ0ZpbHRlciwgcHJvdmlkZXIuX3dyYXBMb2cobWVzc2FnZSwgcHJvdmlkZXIuX25ldHdvcmspKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqU29ja2V0UHJvdmlkZXIqKiBpcyBiYWNrZWQgYnkgYSBsb25nLWxpdmVkIGNvbm5lY3Rpb24gb3ZlciBhXG4gKiAgc29ja2V0LCB3aGljaCBjYW4gc3Vic2NyaWJlIGFuZCByZWNlaXZlIHJlYWwtdGltZSBtZXNzYWdlcyBvdmVyXG4gKiAgaXRzIGNvbW11bmljYXRpb24gY2hhbm5lbC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNvY2tldFByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVByb3ZpZGVyIHtcbiAgICAjY2FsbGJhY2tzO1xuICAgIC8vIE1hcHMgZWFjaCBmaWx0ZXJJZCB0byBpdHMgc3Vic2NyaWJlclxuICAgICNzdWJzO1xuICAgIC8vIElmIGFueSBldmVudHMgY29tZSBpbiBiZWZvcmUgYSBzdWJzY3JpYmVyIGhhcyBmaW5pc2hlZFxuICAgIC8vIHJlZ2lzdGVyaW5nLCBxdWV1ZSB0aGVtXG4gICAgI3BlbmRpbmc7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipTb2NrZXRQcm92aWRlcioqIGNvbm5lY3RlZCB0byAlJW5ldHdvcmslJS5cbiAgICAgKlxuICAgICAqICBJZiB1bnNwZWNpZmllZCwgdGhlIG5ldHdvcmsgd2lsbCBiZSBkaXNjb3ZlcmVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIF9vcHRpb25zKSB7XG4gICAgICAgIC8vIENvcHkgdGhlIG9wdGlvbnNcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIChfb3B0aW9ucyAhPSBudWxsKSA/IF9vcHRpb25zIDoge30pO1xuICAgICAgICAvLyBTdXBwb3J0IGZvciBiYXRjaGVzIGlzIGdlbmVyYWxseSBub3Qgc3VwcG9ydGVkIGZvclxuICAgICAgICAvLyBjb25uZWN0aW9uLWJhc2UgcHJvdmlkZXJzOyBpZiB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAvLyB0aGUgX3NlbmQgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGlzXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KG9wdGlvbnMuYmF0Y2hNYXhDb3VudCA9PSBudWxsIHx8IG9wdGlvbnMuYmF0Y2hNYXhDb3VudCA9PT0gMSwgXCJzb2NrZXRzLWJhc2VkIHByb3ZpZGVycyBkbyBub3Qgc3VwcG9ydCBiYXRjaGVzXCIsIFwib3B0aW9ucy5iYXRjaE1heENvdW50XCIsIF9vcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5iYXRjaE1heENvdW50ID0gMTtcbiAgICAgICAgLy8gU29ja2V0LWJhc2VkIFByb3ZpZGVycyAoZ2VuZXJhbGx5KSBjYW5ub3QgY2hhbmdlIHRoZWlyIG5ldHdvcmssXG4gICAgICAgIC8vIHNpbmNlIHRoZXkgaGF2ZSBhIGxvbmctbGl2ZWQgY29ubmVjdGlvbjsgYnV0IGxldCBwZW9wbGUgb3ZlcnJpZGVcbiAgICAgICAgLy8gdGhpcyBpZiB0aGV5IGhhdmUganVzdCBjYXVzZS5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhdGljTmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN0YXRpY05ldHdvcmsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNjYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3N1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI3BlbmRpbmcgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8vIFRoaXMgdmFsdWUgaXMgb25seSB2YWxpZCBhZnRlciBfc3RhcnQgaGFzIGJlZW4gY2FsbGVkXG4gICAgLypcbiAgICBnZXQgX25ldHdvcmsoKTogTmV0d29yayB7XG4gICAgICAgIGlmICh0aGlzLiNuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRoaXMgc2hvdWxkbid0IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yay5jbG9uZSgpO1xuICAgIH1cbiAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBzd2l0Y2ggKHN1Yi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU29ja2V0QmxvY2tTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNvY2tldFBlbmRpbmdTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTb2NrZXRFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICBjYXNlIFwib3JwaGFuXCI6XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlZCBhdXRvLW1hdGljYWxseSB3aXRoaW4gQWJzdHJhY3RQcm92aWRlclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGxvZy5yZW1vdmVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGlmIChzdWIuZmlsdGVyLm9ycGhhbiA9PT0gXCJkcm9wLWxvZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlcihcImRyb3AtbG9nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlZ2lzdGVyIGEgbmV3IHN1YnNjcmliZXIuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGxlZCBieSBTdWJzY3JpYmVyc1xuICAgICAqICBhbmQgZ2VuZXJhbGx5IGlzIHVuZWNlc3NhcnkgdW5sZXNzIGV4dGVuZGluZyBjYXBhYmlsaXRpZXMuXG4gICAgICovXG4gICAgX3JlZ2lzdGVyKGZpbHRlcklkLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIHRoaXMuI3N1YnMuc2V0KGZpbHRlcklkLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgY29uc3QgcGVuZGluZyA9IHRoaXMuI3BlbmRpbmcuZ2V0KGZpbHRlcklkKTtcbiAgICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5faGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3BlbmRpbmcuZGVsZXRlKGZpbHRlcklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIC8vIFdlYlNvY2tldCBwcm92aWRlciBkb2Vzbid0IGFjY2VwdCBiYXRjaGVzXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFBcnJheS5pc0FycmF5KHBheWxvYWQpLCBcIldlYlNvY2tldCBkb2VzIG5vdCBzdXBwb3J0IGJhdGNoIHNlbmRcIiwgXCJwYXlsb2FkXCIsIHBheWxvYWQpO1xuICAgICAgICAvLyBAVE9ETzogc3RyaW5naWZ5IHBheWxvYWRzIGhlcmUgYW5kIHN0b3JlIHRvIHByZXZlbnQgbXV0YXRpb25zXG4gICAgICAgIC8vIFByZXBhcmUgYSBwcm9taXNlIHRvIHJlc3BvbmQgdG9cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2NhbGxiYWNrcy5zZXQocGF5bG9hZC5pZCwgeyBwYXlsb2FkLCByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXYWl0IHVudGlsIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkIGJlZm9yZSB3cml0aW5nIHRvIGl0XG4gICAgICAgIGF3YWl0IHRoaXMuX3dhaXRVbnRpbFJlYWR5KCk7XG4gICAgICAgIC8vIFdyaXRlIHRoZSByZXF1ZXN0IHRvIHRoZSBzb2NrZXRcbiAgICAgICAgYXdhaXQgdGhpcy5fd3JpdGUoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICByZXR1cm4gW2F3YWl0IHByb21pc2VdO1xuICAgIH1cbiAgICAvLyBTdWItY2xhc3NlcyBtdXN0IGNhbGwgdGhpcyBvbmNlIHRoZXkgYXJlIGNvbm5lY3RlZFxuICAgIC8qXG4gICAgYXN5bmMgX3N0YXJ0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAodGhpcy4jcmVhZHkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgZm9yIChjb25zdCB7IHBheWxvYWQgfSBvZiB0aGlzLiNjYWxsYmFja3MudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3dyaXRlKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI3JlYWR5ID0gKGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXdhaXQgc3VwZXIuX3N0YXJ0KCk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgICovXG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIGNhbGwgdGhpcyB3aXRoIG1lc3NhZ2VzIHJlY2VpdmVkIG92ZXIgdGhlaXJcbiAgICAgKiAgdHJhbnNwb3J0IHRvIGJlIHByb2Nlc3NlZCBhbmQgZGlzcGF0Y2hlZC5cbiAgICAgKi9cbiAgICBhc3luYyBfcHJvY2Vzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoSlNPTi5wYXJzZShtZXNzYWdlKSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIChyZXN1bHQpID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy4jY2FsbGJhY2tzLmdldChyZXN1bHQuaWQpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJyZWNlaXZlZCByZXN1bHQgZm9yIHVua25vd24gaWRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uQ29kZTogXCJVTktOT1dOX0lEXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYWxsYmFja3MuZGVsZXRlKHJlc3VsdC5pZCk7XG4gICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ICYmIHJlc3VsdC5tZXRob2QgPT09IFwiZXRoX3N1YnNjcmlwdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJJZCA9IHJlc3VsdC5wYXJhbXMuc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMuI3N1YnMuZ2V0KGZpbHRlcklkKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5faGFuZGxlTWVzc2FnZShyZXN1bHQucGFyYW1zLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcGVuZGluZyA9IHRoaXMuI3BlbmRpbmcuZ2V0KGZpbHRlcklkKTtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZy5zZXQoZmlsdGVySWQsIHBlbmRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwZW5kaW5nLnB1c2gocmVzdWx0LnBhcmFtcy5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbWFrZUVycm9yKFwicmVjZWl2ZWQgdW5leHBlY3RlZCBtZXNzYWdlXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgcmVhc29uQ29kZTogXCJVTkVYUEVDVEVEX01FU1NBR0VcIixcbiAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyB0byBzZW5kICUlbWVzc2FnZSUlIG92ZXIgdGhlaXJcbiAgICAgKiAgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIGFzeW5jIF93cml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1zb2NrZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-socket.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider-websocket.js":
/*!*****************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider-websocket.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketProvider: function() { return /* binding */ WebSocketProvider; }\n/* harmony export */ });\n/* harmony import */ var _ws_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ws.js */ \"../common/node_modules/ethers/lib.esm/providers/ws-browser.js\");\n/* harmony import */ var _provider_socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-socket.js */ \"../common/node_modules/ethers/lib.esm/providers/provider-socket.js\");\n /*-browser*/\n\n/**\n *  A JSON-RPC provider which is backed by a WebSocket.\n *\n *  WebSockets are often preferred because they retain a live connection\n *  to a server, which permits more instant access to events.\n *\n *  However, this incurs higher server infrasturture costs, so additional\n *  resources may be required to host your own WebSocket nodes and many\n *  third-party services charge additional fees for WebSocket endpoints.\n */\nclass WebSocketProvider extends _provider_socket_js__WEBPACK_IMPORTED_MODULE_0__.SocketProvider {\n    #connect;\n    #websocket;\n    get websocket() {\n        if (this.#websocket == null) {\n            throw new Error(\"websocket closed\");\n        }\n        return this.#websocket;\n    }\n    constructor(url, network, options) {\n        super(network, options);\n        if (typeof (url) === \"string\") {\n            this.#connect = () => { return new _ws_js__WEBPACK_IMPORTED_MODULE_1__.WebSocket(url); };\n            this.#websocket = this.#connect();\n        }\n        else if (typeof (url) === \"function\") {\n            this.#connect = url;\n            this.#websocket = url();\n        }\n        else {\n            this.#connect = null;\n            this.#websocket = url;\n        }\n        this.websocket.onopen = async () => {\n            try {\n                await this._start();\n                this.resume();\n            }\n            catch (error) {\n                console.log(\"failed to start WebsocketProvider\", error);\n                // @TODO: now what? Attempt reconnect?\n            }\n        };\n        this.websocket.onmessage = (message) => {\n            this._processMessage(message.data);\n        };\n        /*\n                this.websocket.onclose = (event) => {\n                    // @TODO: What event.code should we reconnect on?\n                    const reconnect = false;\n                    if (reconnect) {\n                        this.pause(true);\n                        if (this.#connect) {\n                            this.#websocket = this.#connect();\n                            this.#websocket.onopen = ...\n                            // @TODO: this requires the super class to rebroadcast; move it there\n                        }\n                        this._reconnect();\n                    }\n                };\n        */\n    }\n    async _write(message) {\n        this.websocket.send(message);\n    }\n    async destroy() {\n        if (this.#websocket != null) {\n            this.#websocket.close();\n            this.#websocket = null;\n        }\n        super.destroy();\n    }\n}\n//# sourceMappingURL=provider-websocket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrRCxDQUFDO0FBQ0c7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsK0RBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXLDZDQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci13ZWJzb2NrZXQuanM/MWExZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXZWJTb2NrZXQgYXMgX1dlYlNvY2tldCB9IGZyb20gXCIuL3dzLmpzXCI7IC8qLWJyb3dzZXIqL1xuaW1wb3J0IHsgU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1zb2NrZXQuanNcIjtcbi8qKlxuICogIEEgSlNPTi1SUEMgcHJvdmlkZXIgd2hpY2ggaXMgYmFja2VkIGJ5IGEgV2ViU29ja2V0LlxuICpcbiAqICBXZWJTb2NrZXRzIGFyZSBvZnRlbiBwcmVmZXJyZWQgYmVjYXVzZSB0aGV5IHJldGFpbiBhIGxpdmUgY29ubmVjdGlvblxuICogIHRvIGEgc2VydmVyLCB3aGljaCBwZXJtaXRzIG1vcmUgaW5zdGFudCBhY2Nlc3MgdG8gZXZlbnRzLlxuICpcbiAqICBIb3dldmVyLCB0aGlzIGluY3VycyBoaWdoZXIgc2VydmVyIGluZnJhc3R1cnR1cmUgY29zdHMsIHNvIGFkZGl0aW9uYWxcbiAqICByZXNvdXJjZXMgbWF5IGJlIHJlcXVpcmVkIHRvIGhvc3QgeW91ciBvd24gV2ViU29ja2V0IG5vZGVzIGFuZCBtYW55XG4gKiAgdGhpcmQtcGFydHkgc2VydmljZXMgY2hhcmdlIGFkZGl0aW9uYWwgZmVlcyBmb3IgV2ViU29ja2V0IGVuZHBvaW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlNvY2tldFByb3ZpZGVyIGV4dGVuZHMgU29ja2V0UHJvdmlkZXIge1xuICAgICNjb25uZWN0O1xuICAgICN3ZWJzb2NrZXQ7XG4gICAgZ2V0IHdlYnNvY2tldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3dlYnNvY2tldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWJzb2NrZXQgY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN3ZWJzb2NrZXQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9ICgpID0+IHsgcmV0dXJuIG5ldyBfV2ViU29ja2V0KHVybCk7IH07XG4gICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQgPSB0aGlzLiNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mICh1cmwpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSB1cmw7XG4gICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQgPSB1cmwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4jd2Vic29ja2V0ID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9ub3BlbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmYWlsZWQgdG8gc3RhcnQgV2Vic29ja2V0UHJvdmlkZXJcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBub3cgd2hhdD8gQXR0ZW1wdCByZWNvbm5lY3Q/XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzTWVzc2FnZShtZXNzYWdlLmRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICAvKlxuICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0Lm9uY2xvc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFdoYXQgZXZlbnQuY29kZSBzaG91bGQgd2UgcmVjb25uZWN0IG9uP1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXVzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jd2Vic29ja2V0ID0gdGhpcy4jY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldC5vbm9wZW4gPSAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogdGhpcyByZXF1aXJlcyB0aGUgc3VwZXIgY2xhc3MgdG8gcmVicm9hZGNhc3Q7IG1vdmUgaXQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgKi9cbiAgICB9XG4gICAgYXN5bmMgX3dyaXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChtZXNzYWdlKTtcbiAgICB9XG4gICAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3dlYnNvY2tldCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLXdlYnNvY2tldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider-websocket.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/provider.js":
/*!*******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/provider.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: function() { return /* binding */ Block; },\n/* harmony export */   FeeData: function() { return /* binding */ FeeData; },\n/* harmony export */   Log: function() { return /* binding */ Log; },\n/* harmony export */   TransactionReceipt: function() { return /* binding */ TransactionReceipt; },\n/* harmony export */   TransactionResponse: function() { return /* binding */ TransactionResponse; },\n/* harmony export */   copyRequest: function() { return /* binding */ copyRequest; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n//import { resolveAddress } from \"@ethersproject/address\";\n\n\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */\nclass FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    gasPrice;\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of heavy load\n     *  and lowering when less busy.\n     *\n     *  The actual fee per gas will be the base fee for the block\n     *  and the priority fee, up to the max fee per gas.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxFeePerGas;\n    /**\n     *  The additional amout to pay per gas to encourage a validator\n     *  to include the transaction.\n     *\n     *  The purpose of this is to compensate the validator for the\n     *  adjusted risk for including a given transaction.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */\n    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\n        };\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */\nfunction copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_1__.accessListify)(req.accessList);\n    }\n    if (req.authorizationList) {\n        result.authorizationList = req.authorizationList.slice();\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    if (\"blobVersionedHashes\" in req && req.blobVersionedHashes) {\n        result.blobVersionedHashes = req.blobVersionedHashes.slice();\n    }\n    if (\"kzg\" in req) {\n        result.kzg = req.kzg;\n    }\n    if (\"blobs\" in req && req.blobs) {\n        result.blobs = req.blobs.map((b) => {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(b)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(b);\n            }\n            return Object.assign({}, b);\n        });\n    }\n    return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */\nclass Block {\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  sequential number that is one higher than the parent block.\n     */\n    number;\n    /**\n     *  The block hash.\n     *\n     *  This hash includes all properties, so can be safely used to identify\n     *  an exact set of block properties.\n     */\n    hash;\n    /**\n     *  The timestamp for this block, which is the number of seconds since\n     *  epoch that this block was included.\n     */\n    timestamp;\n    /**\n     *  The block hash of the parent block.\n     */\n    parentHash;\n    /**\n     *  The hash tree root of the parent beacon block for the given\n     *  execution block. See [[link-eip-4788]].\n     */\n    parentBeaconBlockRoot;\n    /**\n     *  The nonce.\n     *\n     *  On legacy networks, this is the random number inserted which\n     *  permitted the difficulty target to be reached.\n     */\n    nonce;\n    /**\n     *  The difficulty target.\n     *\n     *  On legacy networks, this is the proof-of-work target required\n     *  for a block to meet the protocol rules to be included.\n     *\n     *  On modern networks, this is a random number arrived at using\n     *  randao.  @TODO: Find links?\n     */\n    difficulty;\n    /**\n     *  The total gas limit for this block.\n     */\n    gasLimit;\n    /**\n     *  The total gas used in this block.\n     */\n    gasUsed;\n    /**\n     *  The root hash for the global state after applying changes\n     *  in this block.\n     */\n    stateRoot;\n    /**\n     *  The hash of the transaction receipts trie.\n     */\n    receiptsRoot;\n    /**\n     *  The total amount of blob gas consumed by the transactions\n     *  within the block. See [[link-eip-4844]].\n     */\n    blobGasUsed;\n    /**\n     *  The running total of blob gas consumed in excess of the\n     *  target, prior to the block. See [[link-eip-4844]].\n     */\n    excessBlobGas;\n    /**\n     *  The miner coinbase address, wihch receives any subsidies for\n     *  including this block.\n     */\n    miner;\n    /**\n     *  The latest RANDAO mix of the post beacon state of\n     *  the previous block.\n     */\n    prevRandao;\n    /**\n     *  Any extra data the validator wished to include.\n     */\n    extraData;\n    /**\n     *  The base fee per gas that all transactions in this block were\n     *  charged.\n     *\n     *  This adjusts after each block, depending on how congested the network\n     *  is.\n     */\n    baseFeePerGas;\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */\n    constructor(block, provider) {\n        this.#transactions = block.transactions.map((tx) => {\n            if (typeof (tx) !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            blobGasUsed: block.blobGasUsed,\n            excessBlobGas: block.excessBlobGas,\n            miner: block.miner,\n            prevRandao: getValue(block.prevRandao),\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas),\n            stateRoot: block.stateRoot,\n            receiptsRoot: block.receiptsRoot,\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */\n    get transactions() {\n        return this.#transactions.map((tx) => {\n            if (typeof (tx) === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */\n    get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof (txs[0]) === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            blobGasUsed: toJson(this.blobGasUsed),\n            excessBlobGas: toJson(this.excessBlobGas),\n            hash, miner, prevRandao, nonce, number, parentHash, timestamp,\n            parentBeaconBlockRoot, stateRoot, receiptsRoot,\n            transactions,\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return {\n                        value: txs[index++], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */\n    get length() { return this.#transactions.length; }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */\n    get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */\n    async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof (indexOrHash) === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        }\n        else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions) {\n                if (typeof (v) === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n                else {\n                    if (v.hash !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof (tx) === \"string\") {\n            return (await this.provider.getTransaction(tx));\n        }\n        else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */\n    getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof (indexOrHash) === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs) {\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */\n    isMined() { return !!this.hash; }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */\n    isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */\n    orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */\nclass Log {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransaction]] to get the [[TransactionResponse]].\n     */\n    transactionHash;\n    /**\n     *  The block hash of the block this log occurred in. Use the\n     *  [[Log-getBlock]] to get the [[Block]].\n     */\n    blockHash;\n    /**\n     *  The block number of the block this log occurred in. It is preferred\n     *  to use the [[Block-hash]] when fetching the related [[Block]],\n     *  since in the case of an orphaned block, the block at that height may\n     *  have changed.\n     */\n    blockNumber;\n    /**\n     *  If the **Log** represents a block that was removed due to an orphaned\n     *  block, this will be true.\n     *\n     *  This can only happen within an orphan event listener.\n     */\n    removed;\n    /**\n     *  The address of the contract that emitted this log.\n     */\n    address;\n    /**\n     *  The data included in this log when it was emitted.\n     */\n    data;\n    /**\n     *  The indexed topics included in this log when it was emitted.\n     *\n     *  All topics are included in the bloom filters, so they can be\n     *  efficiently filtered using the [[Provider-getLogs]] method.\n     */\n    topics;\n    /**\n     *  The index within the block this log occurred at. This is generally\n     *  not useful to developers, but can be used with the various roots\n     *  to proof inclusion within a block.\n     */\n    index;\n    /**\n     *  The index within the transaction of this log.\n     */\n    transactionIndex;\n    /**\n     *  @_ignore:\n     */\n    constructor(log, provider) {\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex,\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */\n    toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address, blockHash, blockNumber, data, index,\n            removed, topics, transactionHash, transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */\n    async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/\n/**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */\nclass TransactionReceipt {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The address the transaction was sent to.\n     */\n    to;\n    /**\n     *  The sender of the transaction.\n     */\n    from;\n    /**\n     *  The address of the contract if the transaction was directly\n     *  responsible for deploying one.\n     *\n     *  This is non-null **only** if the ``to`` is empty and the ``data``\n     *  was successfully executed as initcode.\n     */\n    contractAddress;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The index of this transaction within the block transactions.\n     */\n    index;\n    /**\n     *  The block hash of the [[Block]] this transaction was included in.\n     */\n    blockHash;\n    /**\n     *  The block number of the [[Block]] this transaction was included in.\n     */\n    blockNumber;\n    /**\n     *  The bloom filter bytes that represent all logs that occurred within\n     *  this transaction. This is generally not useful for most developers,\n     *  but can be used to validate the included logs.\n     */\n    logsBloom;\n    /**\n     *  The actual amount of gas used by this transaction.\n     *\n     *  When creating a transaction, the amount of gas that will be used can\n     *  only be approximated, but the sender must pay the gas fee for the\n     *  entire gas limit. After the transaction, the difference is refunded.\n     */\n    gasUsed;\n    /**\n     *  The gas used for BLObs. See [[link-eip-4844]].\n     */\n    blobGasUsed;\n    /**\n     *  The amount of gas used by all transactions within the block for this\n     *  and all transactions with a lower ``index``.\n     *\n     *  This is generally not useful for developers but can be used to\n     *  validate certain aspects of execution.\n     */\n    cumulativeGasUsed;\n    /**\n     *  The actual gas price used during execution.\n     *\n     *  Due to the complexity of [[link-eip-1559]] this value can only\n     *  be caluclated after the transaction has been mined, snce the base\n     *  fee is protocol-enforced.\n     */\n    gasPrice;\n    /**\n     *  The price paid per BLOB in gas. See [[link-eip-4844]].\n     */\n    blobGasPrice;\n    /**\n     *  The [[link-eip-2718]] transaction type.\n     */\n    type;\n    //readonly byzantium!: boolean;\n    /**\n     *  The status of this transaction, indicating success (i.e. ``1``) or\n     *  a revert (i.e. ``0``).\n     *\n     *  This is available in post-byzantium blocks, but some backends may\n     *  backfill this value.\n     */\n    status;\n    /**\n     *  The root hash of this transaction.\n     *\n     *  This is no present and was only included in pre-byzantium blocks, but\n     *  could be used to validate certain parts of the receipt.\n     */\n    root;\n    #logs;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.#logs = Object.freeze(tx.logs.map((log) => {\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        }\n        else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            blobGasUsed: tx.blobGasUsed,\n            gasPrice,\n            blobGasPrice: tx.blobGasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */\n    get logs() { return this.#logs; }\n    /**\n     *  Returns a JSON-compatible representation.\n     */\n    toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium, \n        status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash, blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            blobGasUsed: toJson(this.blobGasUsed),\n            blobGasPrice: toJson(this.blobGasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash, index, logs, logsBloom, root, status, to\n        };\n    }\n    /**\n     *  @_ignore:\n     */\n    get length() { return this.logs.length; }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return { value: this.logs[index++], done: false };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */\n    get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */\n    async getResult() {\n        return (await this.provider.getTransactionResult(this.hash));\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */\n    reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"reorderedEvent(other)\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */\nclass TransactionResponse {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    provider;\n    /**\n     *  The block number of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockNumber;\n    /**\n     *  The blockHash of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockHash;\n    /**\n     *  The index within the block that this transaction resides at.\n     */\n    index;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The [[link-eip-2718]] transaction envelope type. This is\n     *  ``0`` for legacy transactions types.\n     */\n    type;\n    /**\n     *  The receiver of this transaction.\n     *\n     *  If ``null``, then the transaction is an initcode transaction.\n     *  This means the result of executing the [[data]] will be deployed\n     *  as a new contract on chain (assuming it does not revert) and the\n     *  address may be computed using [[getCreateAddress]].\n     */\n    to;\n    /**\n     *  The sender of this transaction. It is implicitly computed\n     *  from the transaction pre-image hash (as the digest) and the\n     *  [[signature]] using ecrecover.\n     */\n    from;\n    /**\n     *  The nonce, which is used to prevent replay attacks and offer\n     *  a method to ensure transactions from a given sender are explicitly\n     *  ordered.\n     *\n     *  When sending a transaction, this must be equal to the number of\n     *  transactions ever sent by [[from]].\n     */\n    nonce;\n    /**\n     *  The maximum units of gas this transaction can consume. If execution\n     *  exceeds this, the entries transaction is reverted and the sender\n     *  is charged for the full amount, despite not state changes being made.\n     */\n    gasLimit;\n    /**\n     *  The gas price can have various values, depending on the network.\n     *\n     *  In modern networks, for transactions that are included this is\n     *  the //effective gas price// (the fee per gas that was actually\n     *  charged), while for transactions that have not been included yet\n     *  is the [[maxFeePerGas]].\n     *\n     *  For legacy transactions, or transactions on legacy networks, this\n     *  is the fee that will be charged per unit of gas the transaction\n     *  consumes.\n     */\n    gasPrice;\n    /**\n     *  The maximum priority fee (per unit of gas) to allow a\n     *  validator to charge the sender. This is inclusive of the\n     *  [[maxFeeFeePerGas]].\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  The maximum fee (per unit of gas) to allow this transaction\n     *  to charge the sender.\n     */\n    maxFeePerGas;\n    /**\n     *  The [[link-eip-4844]] max fee per BLOb gas.\n     */\n    maxFeePerBlobGas;\n    /**\n     *  The data.\n     */\n    data;\n    /**\n     *  The value, in wei. Use [[formatEther]] to format this value\n     *  as ether.\n     */\n    value;\n    /**\n     *  The chain ID.\n     */\n    chainId;\n    /**\n     *  The signature.\n     */\n    signature;\n    /**\n     *  The [[link-eip-2930]] access list for transaction types that\n     *  support it, otherwise ``null``.\n     */\n    accessList;\n    /**\n     *  The [[link-eip-4844]] BLOb versioned hashes.\n     */\n    blobVersionedHashes;\n    /**\n     *  The [[link-eip-7702]] authorizations (if any).\n     */\n    authorizationList;\n    #startBlock;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.provider = provider;\n        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;\n        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;\n        this.maxFeePerBlobGas = (tx.maxFeePerBlobGas != null) ? tx.maxFeePerBlobGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = (tx.accessList != null) ? tx.accessList : null;\n        this.blobVersionedHashes = (tx.blobVersionedHashes != null) ? tx.blobVersionedHashes : null;\n        this.authorizationList = (tx.authorizationList != null) ? tx.authorizationList : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */\n    toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;\n        return {\n            _type: \"TransactionResponse\",\n            accessList, blockNumber, blockHash,\n            blobVersionedHashes,\n            chainId: toJson(this.chainId),\n            data, from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),\n            nonce, signature, to, index, type,\n            value: toJson(this.value),\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */\n    async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */\n    async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(_confirms, _timeout) {\n        const confirms = (_confirms == null) ? 1 : _confirms;\n        const timeout = (_timeout == null) ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = (startBlock === -1) ? true : false;\n        const checkReplacement = async () => {\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while (nextScan <= blockNumber) {\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block) {\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for (let i = 0; i < block.length; i++) {\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if ((blockNumber - receipt.blockNumber + 1) < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        }\n                        else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt) => {\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null, reason: null, invocation: null, revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                }, receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if ((await receipt.confirmations()) >= confirms) {\n                return checkReceipt(receipt);\n            }\n        }\n        else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject) => {\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = () => { cancellers.forEach((c) => c()); };\n            // On cancel, stop scanning for replacements\n            cancellers.push(() => { stopScanning = true; });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(() => {\n                    cancel();\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(() => { clearTimeout(timer); });\n            }\n            const txListener = async (receipt) => {\n                // Done; return it!\n                if ((await receipt.confirmations()) >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(() => { this.provider.off(this.hash, txListener); });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async () => {\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    }\n                    catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(() => { this.provider.off(\"block\", replaceListener); });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */\n    isMined() {\n        return (this.blockHash != null);\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)\n     *  transaction. See [[link-eip-4844]].\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */\n    removedEvent() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */\n    reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */\n    replaceableTransaction(startBlock) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return { orphan: \"drop-block\", hash: block.hash, number: block.number };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return { orphan: \"reorder-transaction\", tx, other };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return { orphan: \"drop-transaction\", tx };\n}\nfunction createRemovedLogFilter(log) {\n    return { orphan: \"drop-log\", log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        } };\n}\n//# sourceMappingURL=provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxXQUFXLGlCQUFpQjtBQUNvSTtBQUN4RztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUFTLHNCQUFzQixJQUFJO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBUyxzQkFBc0IsSUFBSTtBQUN6RDtBQUNBO0FBQ0EsNEJBQTRCLG9FQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBVztBQUMzQix1QkFBdUIsd0RBQU87QUFDOUI7QUFDQSxtQ0FBbUM7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsaUVBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1TEFBdUw7QUFDdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtR0FBbUc7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU0sMkRBQTJEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSx3REFBd0Q7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU0scUVBQXFFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU0sd0dBQXdHLG9DQUFvQztBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrR0FBK0c7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLHFGQUFxRiw0QkFBNEI7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLHFGQUFxRiw0QkFBNEI7QUFDL0gsUUFBUSx1REFBTSx3R0FBd0csNEJBQTRCO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9wcm92aWRlci5qcz9kOGMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGlzQnl0ZXNMaWtlLCByZXNvbHZlUHJvcGVydGllcywgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNFcnJvciwgbWFrZUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvSnNvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn1cbi8vIEBUT0RPPyA8VCBleHRlbmRzIEZlZURhdGEgPSB7IH0+IGltcGxlbWVudHMgUmVxdWlyZWQ8VD5cbi8qKlxuICogIEEgKipGZWVEYXRhKiogd3JhcHMgYWxsIHRoZSBmZWUtcmVsYXRlZCB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoXG4gKiAgdGhlIG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVEYXRhIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBmb3IgbGVnYWN5IG5ldHdvcmtzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgdG8gcGF5IHBlciBnYXMuXG4gICAgICpcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgaXMgZGVmaW5lZCBieSB0aGUgbmV0d29yayBhbmQgYmFzZWQgb25cbiAgICAgKiAgY29uZ2VzdGlvbiwgaW5jcmVhc2luZyB0aGUgY29zdCBkdXJpbmcgdGltZXMgb2YgaGVhdnkgbG9hZFxuICAgICAqICBhbmQgbG93ZXJpbmcgd2hlbiBsZXNzIGJ1c3kuXG4gICAgICpcbiAgICAgKiAgVGhlIGFjdHVhbCBmZWUgcGVyIGdhcyB3aWxsIGJlIHRoZSBiYXNlIGZlZSBmb3IgdGhlIGJsb2NrXG4gICAgICogIGFuZCB0aGUgcHJpb3JpdHkgZmVlLCB1cCB0byB0aGUgbWF4IGZlZSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBiZSBgYG51bGxgYCBvbiBsZWdhY3kgbmV0d29ya3MgKGkuZS4gW3ByZS1FSVAtMTU1OV0obGluay1laXAtMTU1OSkpXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkaXRpb25hbCBhbW91dCB0byBwYXkgcGVyIGdhcyB0byBlbmNvdXJhZ2UgYSB2YWxpZGF0b3JcbiAgICAgKiAgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhlIHB1cnBvc2Ugb2YgdGhpcyBpcyB0byBjb21wZW5zYXRlIHRoZSB2YWxpZGF0b3IgZm9yIHRoZVxuICAgICAqICBhZGp1c3RlZCByaXNrIGZvciBpbmNsdWRpbmcgYSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEZlZURhdGEgZm9yICUlZ2FzUHJpY2UlJSwgJSVtYXhGZWVQZXJHYXMlJSBhbmRcbiAgICAgKiAgJSVtYXhQcmlvcml0eUZlZVBlckdhcyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZ2FzUHJpY2U6IGdldFZhbHVlKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2V0VmFsdWUobWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJGZWVEYXRhXCIsXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKG1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdG9Kc29uKG1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG47XG4vKipcbiAqICBSZXR1cm5zIGEgY29weSBvZiAlJXJlcSUlIHdpdGggYWxsIHByb3BlcnRpZXMgY29lcmNlZCB0byB0aGVpciBzdHJpY3RcbiAqICB0eXBlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSZXF1ZXN0KHJlcSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8vIFRoZXNlIGNvdWxkIGJlIGFkZHJlc3NlcywgRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlc1xuICAgIGlmIChyZXEudG8pIHtcbiAgICAgICAgcmVzdWx0LnRvID0gcmVxLnRvO1xuICAgIH1cbiAgICBpZiAocmVxLmZyb20pIHtcbiAgICAgICAgcmVzdWx0LmZyb20gPSByZXEuZnJvbTtcbiAgICB9XG4gICAgaWYgKHJlcS5kYXRhKSB7XG4gICAgICAgIHJlc3VsdC5kYXRhID0gaGV4bGlmeShyZXEuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGJpZ0ludEtleXMgPSBcImNoYWluSWQsZ2FzTGltaXQsZ2FzUHJpY2UsbWF4RmVlUGVyQmxvYkdhcyxtYXhGZWVQZXJHYXMsbWF4UHJpb3JpdHlGZWVQZXJHYXMsdmFsdWVcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGJpZ0ludEtleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXRCaWdJbnQocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xuICAgIH1cbiAgICBjb25zdCBudW1iZXJLZXlzID0gXCJ0eXBlLG5vbmNlXCIuc3BsaXQoLywvKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBudW1iZXJLZXlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiByZXEpIHx8IHJlcVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gZ2V0TnVtYmVyKHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgaWYgKHJlcS5hY2Nlc3NMaXN0KSB7XG4gICAgICAgIHJlc3VsdC5hY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeShyZXEuYWNjZXNzTGlzdCk7XG4gICAgfVxuICAgIGlmIChyZXEuYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGhvcml6YXRpb25MaXN0ID0gcmVxLmF1dGhvcml6YXRpb25MaXN0LnNsaWNlKCk7XG4gICAgfVxuICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja1RhZyA9IHJlcS5ibG9ja1RhZztcbiAgICB9XG4gICAgaWYgKFwiZW5hYmxlQ2NpcFJlYWRcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmVuYWJsZUNjaXBSZWFkID0gISFyZXEuZW5hYmxlQ2NpcFJlYWQ7XG4gICAgfVxuICAgIGlmIChcImN1c3RvbURhdGFcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmN1c3RvbURhdGEgPSByZXEuY3VzdG9tRGF0YTtcbiAgICB9XG4gICAgaWYgKFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiIGluIHJlcSAmJiByZXEuYmxvYlZlcnNpb25lZEhhc2hlcykge1xuICAgICAgICByZXN1bHQuYmxvYlZlcnNpb25lZEhhc2hlcyA9IHJlcS5ibG9iVmVyc2lvbmVkSGFzaGVzLnNsaWNlKCk7XG4gICAgfVxuICAgIGlmIChcImt6Z1wiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQua3pnID0gcmVxLmt6ZztcbiAgICB9XG4gICAgaWYgKFwiYmxvYnNcIiBpbiByZXEgJiYgcmVxLmJsb2JzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9icyA9IHJlcS5ibG9icy5tYXAoKGIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0J5dGVzTGlrZShiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIEEgKipCbG9jayoqIHJlcHJlc2VudHMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgZnVsbCBibG9jayBvblxuICogIEV0aGVyZXVtLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2sge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBibG9jayB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIsIHNvbWV0aW1lcyBjYWxsZWQgdGhlIGJsb2NrIGhlaWdodC4gVGhpcyBpcyBhXG4gICAgICogIHNlcXVlbnRpYWwgbnVtYmVyIHRoYXQgaXMgb25lIGhpZ2hlciB0aGFuIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgbnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaC5cbiAgICAgKlxuICAgICAqICBUaGlzIGhhc2ggaW5jbHVkZXMgYWxsIHByb3BlcnRpZXMsIHNvIGNhbiBiZSBzYWZlbHkgdXNlZCB0byBpZGVudGlmeVxuICAgICAqICBhbiBleGFjdCBzZXQgb2YgYmxvY2sgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgdGltZXN0YW1wIGZvciB0aGlzIGJsb2NrLCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcbiAgICAgKiAgZXBvY2ggdGhhdCB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZC5cbiAgICAgKi9cbiAgICB0aW1lc3RhbXA7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgcGFyZW50SGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGhhc2ggdHJlZSByb290IG9mIHRoZSBwYXJlbnQgYmVhY29uIGJsb2NrIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgZXhlY3V0aW9uIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00Nzg4XV0uXG4gICAgICovXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSByYW5kb20gbnVtYmVyIGluc2VydGVkIHdoaWNoXG4gICAgICogIHBlcm1pdHRlZCB0aGUgZGlmZmljdWx0eSB0YXJnZXQgdG8gYmUgcmVhY2hlZC5cbiAgICAgKi9cbiAgICBub25jZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRpZmZpY3VsdHkgdGFyZ2V0LlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpcyBpcyB0aGUgcHJvb2Ytb2Ytd29yayB0YXJnZXQgcmVxdWlyZWRcbiAgICAgKiAgZm9yIGEgYmxvY2sgdG8gbWVldCB0aGUgcHJvdG9jb2wgcnVsZXMgdG8gYmUgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgT24gbW9kZXJuIG5ldHdvcmtzLCB0aGlzIGlzIGEgcmFuZG9tIG51bWJlciBhcnJpdmVkIGF0IHVzaW5nXG4gICAgICogIHJhbmRhby4gIEBUT0RPOiBGaW5kIGxpbmtzP1xuICAgICAqL1xuICAgIGRpZmZpY3VsdHk7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgbGltaXQgZm9yIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgdXNlZCBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggZm9yIHRoZSBnbG9iYWwgc3RhdGUgYWZ0ZXIgYXBwbHlpbmcgY2hhbmdlc1xuICAgICAqICBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIHN0YXRlUm9vdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRzIHRyaWUuXG4gICAgICovXG4gICAgcmVjZWlwdHNSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgYW1vdW50IG9mIGJsb2IgZ2FzIGNvbnN1bWVkIGJ5IHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgKiAgd2l0aGluIHRoZSBibG9jay4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgcnVubmluZyB0b3RhbCBvZiBibG9iIGdhcyBjb25zdW1lZCBpbiBleGNlc3Mgb2YgdGhlXG4gICAgICogIHRhcmdldCwgcHJpb3IgdG8gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgZXhjZXNzQmxvYkdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1pbmVyIGNvaW5iYXNlIGFkZHJlc3MsIHdpaGNoIHJlY2VpdmVzIGFueSBzdWJzaWRpZXMgZm9yXG4gICAgICogIGluY2x1ZGluZyB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIG1pbmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgbGF0ZXN0IFJBTkRBTyBtaXggb2YgdGhlIHBvc3QgYmVhY29uIHN0YXRlIG9mXG4gICAgICogIHRoZSBwcmV2aW91cyBibG9jay5cbiAgICAgKi9cbiAgICBwcmV2UmFuZGFvO1xuICAgIC8qKlxuICAgICAqICBBbnkgZXh0cmEgZGF0YSB0aGUgdmFsaWRhdG9yIHdpc2hlZCB0byBpbmNsdWRlLlxuICAgICAqL1xuICAgIGV4dHJhRGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgdGhhdCBhbGwgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2sgd2VyZVxuICAgICAqICBjaGFyZ2VkLlxuICAgICAqXG4gICAgICogIFRoaXMgYWRqdXN0cyBhZnRlciBlYWNoIGJsb2NrLCBkZXBlbmRpbmcgb24gaG93IGNvbmdlc3RlZCB0aGUgbmV0d29ya1xuICAgICAqICBpcy5cbiAgICAgKi9cbiAgICBiYXNlRmVlUGVyR2FzO1xuICAgICN0cmFuc2FjdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkJsb2NrKiogb2JqZWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgbmVjZXNzYXJ5IGFzIHRoZSB1bmxlc3MgaW1wbGVtZW50aW5nIGFcbiAgICAgKiAgbG93LWxldmVsIGxpYnJhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmxvY2ssIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3RyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICBoYXNoOiBnZXRWYWx1ZShibG9jay5oYXNoKSxcbiAgICAgICAgICAgIG51bWJlcjogYmxvY2subnVtYmVyLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBibG9jay50aW1lc3RhbXAsXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBibG9jay5wYXJlbnRIYXNoLFxuICAgICAgICAgICAgcGFyZW50QmVhY29uQmxvY2tSb290OiBibG9jay5wYXJlbnRCZWFjb25CbG9ja1Jvb3QsXG4gICAgICAgICAgICBub25jZTogYmxvY2subm9uY2UsXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiBibG9jay5kaWZmaWN1bHR5LFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0LFxuICAgICAgICAgICAgZ2FzVXNlZDogYmxvY2suZ2FzVXNlZCxcbiAgICAgICAgICAgIGJsb2JHYXNVc2VkOiBibG9jay5ibG9iR2FzVXNlZCxcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IGJsb2NrLmV4Y2Vzc0Jsb2JHYXMsXG4gICAgICAgICAgICBtaW5lcjogYmxvY2subWluZXIsXG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBnZXRWYWx1ZShibG9jay5wcmV2UmFuZGFvKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogYmxvY2suZXh0cmFEYXRhLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogZ2V0VmFsdWUoYmxvY2suYmFzZUZlZVBlckdhcyksXG4gICAgICAgICAgICBzdGF0ZVJvb3Q6IGJsb2NrLnN0YXRlUm9vdCxcbiAgICAgICAgICAgIHJlY2VpcHRzUm9vdDogYmxvY2sucmVjZWlwdHNSb290LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb24gaGFzaGVzLCBpbiB0aGUgb3JkZXJcbiAgICAgKiAgdGhleSB3ZXJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgYmxvY2suXG4gICAgICovXG4gICAgZ2V0IHRyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHguaGFzaDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBjb21wbGV0ZSB0cmFuc2FjdGlvbnMsIGluIHRoZSBvcmRlciB0aGV5XG4gICAgICogIHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBibG9ja3Mgd2hpY2ggcHJlZmV0Y2hlZFxuICAgICAqICB0cmFuc2FjdGlvbnMsIGJ5IHBhc3NpbmcgYGB0cnVlYGAgdG8gJSVwcmVmZXRjaFR4cyUlXG4gICAgICogIGludG8gW1tQcm92aWRlci1nZXRCbG9ja11dLlxuICAgICAqL1xuICAgIGdldCBwcmVmZXRjaGVkVHJhbnNhY3Rpb25zKCkge1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLiN0cmFuc2FjdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgLy8gRG9lc24ndCBtYXR0ZXIuLi5cbiAgICAgICAgaWYgKHR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcHJlZmV0Y2hlZCB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHR4c1swXSkgPT09IFwib2JqZWN0XCIsIFwidHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQgd2l0aCBibG9jayByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0cmFuc2FjdGlvblJlc3BvbnNlcygpXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmFzZUZlZVBlckdhcywgZGlmZmljdWx0eSwgZXh0cmFEYXRhLCBnYXNMaW1pdCwgZ2FzVXNlZCwgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsIHRpbWVzdGFtcCwgdHJhbnNhY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiQmxvY2tcIixcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IHRvSnNvbihiYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRvSnNvbihkaWZmaWN1bHR5KSxcbiAgICAgICAgICAgIGV4dHJhRGF0YSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24oZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzVXNlZDogdG9Kc29uKGdhc1VzZWQpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IHRvSnNvbih0aGlzLmV4Y2Vzc0Jsb2JHYXMpLFxuICAgICAgICAgICAgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLnRyYW5zYWN0aW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4c1tpbmRleCsrXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWpzLWRhdGVdXSB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZCBhdC5cbiAgICAgKi9cbiAgICBnZXQgZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXN0YW1wID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRpbWVzdGFtcCAqIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSB0cmFuc2FjdGlvbiBhdCAlJWluZGV4ZSUlIHdpdGhpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGludGVybmFsIHZhbHVlIGJ5IGl0cyBpbmRleCBvciBoYXNoXG4gICAgICAgIGxldCB0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0eCA9IHRoaXMuI3RyYW5zYWN0aW9uc1tpbmRleE9ySGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLiN0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHggPSB2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIHR4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHR4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGEgKipCbG9jayoqIHdhcyBmZXRjaGVkIHdpdGggYSByZXF1ZXN0IHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAqICB0aGlzIHdpbGwgYWxsb3cgc3luY2hyb25vdXMgYWNjZXNzIHRvIHRob3NlIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgdHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQsIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRQcmVmZXRjaGVkVHJhbnNhY3Rpb24oaW5kZXhPckhhc2gpIHtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy5wcmVmZXRjaGVkVHJhbnNhY3Rpb25zO1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleE9ySGFzaCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eHNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4T3JIYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB0eCBvZiB0eHMpIHtcbiAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSBpbmRleE9ySGFzaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJubyBtYXRjaGluZyB0cmFuc2FjdGlvblwiLCBcImluZGV4T3JIYXNoXCIsIGluZGV4T3JIYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGJsb2NrIGJlZW4gbWluZWQuIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGd1YXJkXG4gICAgICogIGZvciBhbGwgcHJvcGVydGllcyBvbiBhIFtbTWluZWRCbG9ja11dLlxuICAgICAqL1xuICAgIGlzTWluZWQoKSB7IHJldHVybiAhIXRoaXMuaGFzaDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBpcyBhbiBbW2xpbmstZWlwLTI5MzBdXSBibG9jay5cbiAgICAgKi9cbiAgICBpc0xvbmRvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5iYXNlRmVlUGVyR2FzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgb3JwaGFuZWRFdmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTWluZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyKHRoaXMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIExvZ1xuLyoqXG4gKiAgQSAqKkxvZyoqIGluIEV0aGVyZXVtIHJlcHJlc2VudHMgYW4gZXZlbnQgdGhhdCBoYXMgYmVlbiBpbmNsdWRlZCBpbiBhXG4gKiAgdHJhbnNhY3Rpb24gdXNpbmcgdGhlIGBgTE9HKmBgIG9wY29kZXMsIHdoaWNoIGFyZSBtb3N0IGNvbW1vbmx5IHVzZWQgYnlcbiAqICBTb2xpZGl0eSdzIGVtaXQgZm9yIGFubm91bmNpbmcgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXG4gICAgICogIFtbTG9nLWdldFRyYW5zYWN0aW9uXV0gdG8gZ2V0IHRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRCbG9ja11dIHRvIGdldCB0aGUgW1tCbG9ja11dLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIEl0IGlzIHByZWZlcnJlZFxuICAgICAqICB0byB1c2UgdGhlIFtbQmxvY2staGFzaF1dIHdoZW4gZmV0Y2hpbmcgdGhlIHJlbGF0ZWQgW1tCbG9ja11dLFxuICAgICAqICBzaW5jZSBpbiB0aGUgY2FzZSBvZiBhbiBvcnBoYW5lZCBibG9jaywgdGhlIGJsb2NrIGF0IHRoYXQgaGVpZ2h0IG1heVxuICAgICAqICBoYXZlIGNoYW5nZWQuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSAqKkxvZyoqIHJlcHJlc2VudHMgYSBibG9jayB0aGF0IHdhcyByZW1vdmVkIGR1ZSB0byBhbiBvcnBoYW5lZFxuICAgICAqICBibG9jaywgdGhpcyB3aWxsIGJlIHRydWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBoYXBwZW4gd2l0aGluIGFuIG9ycGhhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICByZW1vdmVkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgdGhhdCBlbWl0dGVkIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4ZWQgdG9waWNzIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiAgQWxsIHRvcGljcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGJsb29tIGZpbHRlcnMsIHNvIHRoZXkgY2FuIGJlXG4gICAgICogIGVmZmljaWVudGx5IGZpbHRlcmVkIHVzaW5nIHRoZSBbW1Byb3ZpZGVyLWdldExvZ3NdXSBtZXRob2QuXG4gICAgICovXG4gICAgdG9waWNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBhdC4gVGhpcyBpcyBnZW5lcmFsbHlcbiAgICAgKiAgbm90IHVzZWZ1bCB0byBkZXZlbG9wZXJzLCBidXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgdmFyaW91cyByb290c1xuICAgICAqICB0byBwcm9vZiBpbmNsdXNpb24gd2l0aGluIGEgYmxvY2suXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIG9mIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSW5kZXg7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGxvZy5ibG9ja051bWJlcixcbiAgICAgICAgICAgIHJlbW92ZWQ6IGxvZy5yZW1vdmVkLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljcyxcbiAgICAgICAgICAgIGluZGV4OiBsb2cuaW5kZXgsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBsb2cudHJhbnNhY3Rpb25JbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsIHJlbW92ZWQsIHRvcGljcywgdHJhbnNhY3Rpb25IYXNoLCB0cmFuc2FjdGlvbkluZGV4IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwibG9nXCIsXG4gICAgICAgICAgICBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCxcbiAgICAgICAgICAgIHJlbW92ZWQsIHRvcGljcywgdHJhbnNhY3Rpb25IYXNoLCB0cmFuc2FjdGlvbkluZGV4XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBibG9jayB0aGF0IHRoaXMgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sodGhpcy5ibG9ja0hhc2gpO1xuICAgICAgICBhc3NlcnQoISFibG9jaywgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoaXMgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odGhpcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBhc3NlcnQoISF0eCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvdCB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzXG4gICAgICogIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGFzc2VydCghIXJlY2VpcHQsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb24gcmVjZWlwdFwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIodGhpcyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVHJhbnNhY3Rpb24gUmVjZWlwdFxuLypcbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5VHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IGZhbHNlO1xuICAgIHN0YXR1czogbnVsbDtcbiAgICByb290OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnl6YW50aXVtVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IHRydWU7XG4gICAgc3RhdHVzOiBudW1iZXI7XG4gICAgcm9vdDogbnVsbDtcbn1cbiovXG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCBhXG4gKiAgdHJhbnNhY3Rpb24gdGhhdCBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciBpdCBoYXMgYmVlbiBtaW5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIHRoZSB0cmFuc2FjdGlvbiB3YXMgc2VudCB0by5cbiAgICAgKi9cbiAgICB0bztcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRlciBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgZGlyZWN0bHlcbiAgICAgKiAgcmVzcG9uc2libGUgZm9yIGRlcGxveWluZyBvbmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub24tbnVsbCAqKm9ubHkqKiBpZiB0aGUgYGB0b2BgIGlzIGVtcHR5IGFuZCB0aGUgYGBkYXRhYGBcbiAgICAgKiAgd2FzIHN1Y2Nlc3NmdWxseSBleGVjdXRlZCBhcyBpbml0Y29kZS5cbiAgICAgKi9cbiAgICBjb250cmFjdEFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCBvZiB0aGlzIHRyYW5zYWN0aW9uIHdpdGhpbiB0aGUgYmxvY2sgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvb20gZmlsdGVyIGJ5dGVzIHRoYXQgcmVwcmVzZW50IGFsbCBsb2dzIHRoYXQgb2NjdXJyZWQgd2l0aGluXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIG1vc3QgZGV2ZWxvcGVycyxcbiAgICAgKiAgYnV0IGNhbiBiZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBpbmNsdWRlZCBsb2dzLlxuICAgICAqL1xuICAgIGxvZ3NCbG9vbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCBhbW91bnQgb2YgZ2FzIHVzZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBXaGVuIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb24sIHRoZSBhbW91bnQgb2YgZ2FzIHRoYXQgd2lsbCBiZSB1c2VkIGNhblxuICAgICAqICBvbmx5IGJlIGFwcHJveGltYXRlZCwgYnV0IHRoZSBzZW5kZXIgbXVzdCBwYXkgdGhlIGdhcyBmZWUgZm9yIHRoZVxuICAgICAqICBlbnRpcmUgZ2FzIGxpbWl0LiBBZnRlciB0aGUgdHJhbnNhY3Rpb24sIHRoZSBkaWZmZXJlbmNlIGlzIHJlZnVuZGVkLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgdXNlZCBmb3IgQkxPYnMuIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBibG9iR2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFtb3VudCBvZiBnYXMgdXNlZCBieSBhbGwgdHJhbnNhY3Rpb25zIHdpdGhpbiB0aGUgYmxvY2sgZm9yIHRoaXNcbiAgICAgKiAgYW5kIGFsbCB0cmFuc2FjdGlvbnMgd2l0aCBhIGxvd2VyIGBgaW5kZXhgYC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBkZXZlbG9wZXJzIGJ1dCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICB2YWxpZGF0ZSBjZXJ0YWluIGFzcGVjdHMgb2YgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGN1bXVsYXRpdmVHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGdhcyBwcmljZSB1c2VkIGR1cmluZyBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIHRoZSBjb21wbGV4aXR5IG9mIFtbbGluay1laXAtMTU1OV1dIHRoaXMgdmFsdWUgY2FuIG9ubHlcbiAgICAgKiAgYmUgY2FsdWNsYXRlZCBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQsIHNuY2UgdGhlIGJhc2VcbiAgICAgKiAgZmVlIGlzIHByb3RvY29sLWVuZm9yY2VkLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJpY2UgcGFpZCBwZXIgQkxPQiBpbiBnYXMuIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBibG9iR2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLy9yZWFkb25seSBieXphbnRpdW0hOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdHVzIG9mIHRoaXMgdHJhbnNhY3Rpb24sIGluZGljYXRpbmcgc3VjY2VzcyAoaS5lLiBgYDFgYCkgb3JcbiAgICAgKiAgYSByZXZlcnQgKGkuZS4gYGAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYXZhaWxhYmxlIGluIHBvc3QtYnl6YW50aXVtIGJsb2NrcywgYnV0IHNvbWUgYmFja2VuZHMgbWF5XG4gICAgICogIGJhY2tmaWxsIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdHVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgcm9vdCBoYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBubyBwcmVzZW50IGFuZCB3YXMgb25seSBpbmNsdWRlZCBpbiBwcmUtYnl6YW50aXVtIGJsb2NrcywgYnV0XG4gICAgICogIGNvdWxkIGJlIHVzZWQgdG8gdmFsaWRhdGUgY2VydGFpbiBwYXJ0cyBvZiB0aGUgcmVjZWlwdC5cbiAgICAgKi9cbiAgICByb290O1xuICAgICNsb2dzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jbG9ncyA9IE9iamVjdC5mcmVlemUodHgubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IGdhc1ByaWNlID0gQk5fMDtcbiAgICAgICAgaWYgKHR4LmVmZmVjdGl2ZUdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZWZmZWN0aXZlR2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHguY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgIGluZGV4OiB0eC5pbmRleCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogdHguYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiB0eC5sb2dzQmxvb20sXG4gICAgICAgICAgICBnYXNVc2VkOiB0eC5nYXNVc2VkLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHR4LmJsb2JHYXNVc2VkLFxuICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHR4LmJsb2JHYXNQcmljZSxcbiAgICAgICAgICAgIHR5cGU6IHR4LnR5cGUsXG4gICAgICAgICAgICAvL2J5emFudGl1bTogdHguYnl6YW50aXVtLFxuICAgICAgICAgICAgc3RhdHVzOiB0eC5zdGF0dXMsXG4gICAgICAgICAgICByb290OiB0eC5yb290XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZ3MgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7IHJldHVybiB0aGlzLiNsb2dzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IHRvLCBmcm9tLCBjb250cmFjdEFkZHJlc3MsIGhhc2gsIGluZGV4LCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBsb2dzQmxvb20sIGxvZ3MsIC8vYnl6YW50aXVtLCBcbiAgICAgICAgc3RhdHVzLCByb290IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgLy9ieXphbnRpdW0sIFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHRvSnNvbih0aGlzLmN1bXVsYXRpdmVHYXNVc2VkKSxcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGJsb2JHYXNQcmljZTogdG9Kc29uKHRoaXMuYmxvYkdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgaW5kZXgsIGxvZ3MsIGxvZ3NCbG9vbSwgcm9vdCwgc3RhdHVzLCB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMubG9ncy5sZW5ndGg7IH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5sb2dzW2luZGV4KytdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLCBpbiB3ZWkuXG4gICAgICovXG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzVXNlZCAqIHRoaXMuZ2FzUHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXG4gICAgICogIHdpdGggdGhlIGBgZGVidWdfYGAgb3IgYGB0cmFjZV9gYCBBUEkgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdCh0aGlzLmhhc2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSkgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2N0aW9uIGNhbm5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW9yZGVyZWRFdmVudChvdGhlcilcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cbiAqICB0aGF0IHdhcyBzZW50IHRvIHRoZSBuZXR3b3JrLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiBhXG4gKiAgYmxvY2suXG4gKlxuICogIFRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2UtaXNNaW5lZF1dIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZVxuICogIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFzIHdlbGwgYXMgdHlwZSBndWFyZCB0aGF0IHRoZSBvdGhlcndpc2VcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciB0aGlzIGlzIGNvbm5lY3RlZCB0bywgd2hpY2ggd2lsbCBpbmZsdWVuY2UgaG93IGl0c1xuICAgICAqICBtZXRob2RzIHdpbGwgcmVzb2x2ZSBpdHMgYXN5bmMgaW5zcGVjdGlvbiBtZXRob2RzLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2tIYXNoIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHJlc2lkZXMgYXQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0eXBlLiBUaGlzIGlzXG4gICAgICogIGBgMGBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zIHR5cGVzLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNlaXZlciBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIElmIGBgbnVsbGBgLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbml0Y29kZSB0cmFuc2FjdGlvbi5cbiAgICAgKiAgVGhpcyBtZWFucyB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyB0aGUgW1tkYXRhXV0gd2lsbCBiZSBkZXBsb3llZFxuICAgICAqICBhcyBhIG5ldyBjb250cmFjdCBvbiBjaGFpbiAoYXNzdW1pbmcgaXQgZG9lcyBub3QgcmV2ZXJ0KSBhbmQgdGhlXG4gICAgICogIGFkZHJlc3MgbWF5IGJlIGNvbXB1dGVkIHVzaW5nIFtbZ2V0Q3JlYXRlQWRkcmVzc11dLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uIEl0IGlzIGltcGxpY2l0bHkgY29tcHV0ZWRcbiAgICAgKiAgZnJvbSB0aGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlIGhhc2ggKGFzIHRoZSBkaWdlc3QpIGFuZCB0aGVcbiAgICAgKiAgW1tzaWduYXR1cmVdXSB1c2luZyBlY3JlY292ZXIuXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5vbmNlLCB3aGljaCBpcyB1c2VkIHRvIHByZXZlbnQgcmVwbGF5IGF0dGFja3MgYW5kIG9mZmVyXG4gICAgICogIGEgbWV0aG9kIHRvIGVuc3VyZSB0cmFuc2FjdGlvbnMgZnJvbSBhIGdpdmVuIHNlbmRlciBhcmUgZXhwbGljaXRseVxuICAgICAqICBvcmRlcmVkLlxuICAgICAqXG4gICAgICogIFdoZW4gc2VuZGluZyBhIHRyYW5zYWN0aW9uLCB0aGlzIG11c3QgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAqICB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGJ5IFtbZnJvbV1dLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB1bml0cyBvZiBnYXMgdGhpcyB0cmFuc2FjdGlvbiBjYW4gY29uc3VtZS4gSWYgZXhlY3V0aW9uXG4gICAgICogIGV4Y2VlZHMgdGhpcywgdGhlIGVudHJpZXMgdHJhbnNhY3Rpb24gaXMgcmV2ZXJ0ZWQgYW5kIHRoZSBzZW5kZXJcbiAgICAgKiAgaXMgY2hhcmdlZCBmb3IgdGhlIGZ1bGwgYW1vdW50LCBkZXNwaXRlIG5vdCBzdGF0ZSBjaGFuZ2VzIGJlaW5nIG1hZGUuXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgY2FuIGhhdmUgdmFyaW91cyB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqICBJbiBtb2Rlcm4gbmV0d29ya3MsIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgaW5jbHVkZWQgdGhpcyBpc1xuICAgICAqICB0aGUgLy9lZmZlY3RpdmUgZ2FzIHByaWNlLy8gKHRoZSBmZWUgcGVyIGdhcyB0aGF0IHdhcyBhY3R1YWxseVxuICAgICAqICBjaGFyZ2VkKSwgd2hpbGUgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGhhdmUgbm90IGJlZW4gaW5jbHVkZWQgeWV0XG4gICAgICogIGlzIHRoZSBbW21heEZlZVBlckdhc11dLlxuICAgICAqXG4gICAgICogIEZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLCBvciB0cmFuc2FjdGlvbnMgb24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzXG4gICAgICogIGlzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIGNoYXJnZWQgcGVyIHVuaXQgb2YgZ2FzIHRoZSB0cmFuc2FjdGlvblxuICAgICAqICBjb25zdW1lcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IGFcbiAgICAgKiAgdmFsaWRhdG9yIHRvIGNoYXJnZSB0aGUgc2VuZGVyLiBUaGlzIGlzIGluY2x1c2l2ZSBvZiB0aGVcbiAgICAgKiAgW1ttYXhGZWVGZWVQZXJHYXNdXS5cbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiAgdG8gY2hhcmdlIHRoZSBzZW5kZXIuXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC00ODQ0XV0gbWF4IGZlZSBwZXIgQkxPYiBnYXMuXG4gICAgICovXG4gICAgbWF4RmVlUGVyQmxvYkdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlLCBpbiB3ZWkuIFVzZSBbW2Zvcm1hdEV0aGVyXV0gdG8gZm9ybWF0IHRoaXMgdmFsdWVcbiAgICAgKiAgYXMgZXRoZXIuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBjaGFpbklkO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0IGZvciB0cmFuc2FjdGlvbiB0eXBlcyB0aGF0XG4gICAgICogIHN1cHBvcnQgaXQsIG90aGVyd2lzZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhY2Nlc3NMaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC00ODQ0XV0gQkxPYiB2ZXJzaW9uZWQgaGFzaGVzLlxuICAgICAqL1xuICAgIGJsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTc3MDJdXSBhdXRob3JpemF0aW9ucyAoaWYgYW55KS5cbiAgICAgKi9cbiAgICBhdXRob3JpemF0aW9uTGlzdDtcbiAgICAjc3RhcnRCbG9jaztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5ibG9ja051bWJlciA9ICh0eC5ibG9ja051bWJlciAhPSBudWxsKSA/IHR4LmJsb2NrTnVtYmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9ja0hhc2ggPSAodHguYmxvY2tIYXNoICE9IG51bGwpID8gdHguYmxvY2tIYXNoIDogbnVsbDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHguaGFzaDtcbiAgICAgICAgdGhpcy5pbmRleCA9IHR4LmluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eC50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSB0eC5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gdHgudG8gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5nYXNMaW1pdCA9IHR4Lmdhc0xpbWl0O1xuICAgICAgICB0aGlzLm5vbmNlID0gdHgubm9uY2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzID0gKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckdhcyA9ICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckJsb2JHYXMgPSAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckJsb2JHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHR4LnNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5hY2Nlc3NMaXN0ID0gKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkgPyB0eC5hY2Nlc3NMaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9iVmVyc2lvbmVkSGFzaGVzID0gKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT0gbnVsbCkgPyB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzIDogbnVsbDtcbiAgICAgICAgdGhpcy5hdXRob3JpemF0aW9uTGlzdCA9ICh0eC5hdXRob3JpemF0aW9uTGlzdCAhPSBudWxsKSA/IHR4LmF1dGhvcml6YXRpb25MaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy4jc3RhcnRCbG9jayA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tIYXNoLCBpbmRleCwgaGFzaCwgdHlwZSwgdG8sIGZyb20sIG5vbmNlLCBkYXRhLCBzaWduYXR1cmUsIGFjY2Vzc0xpc3QsIGJsb2JWZXJzaW9uZWRIYXNoZXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlc3BvbnNlXCIsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IHRvSnNvbih0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgZGF0YSwgZnJvbSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24odGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJCbG9iR2FzKSxcbiAgICAgICAgICAgIG5vbmNlLCBzaWduYXR1cmUsIHRvLCBpbmRleCwgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0pzb24odGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCB5ZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGxldCBibG9ja051bWJlciA9IHRoaXMuYmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoaXMgdHJhbnNhY3Rpb24gYmVpbmcgcmUtcmVxdWVzdGVkIGZyb20gdGhlXG4gICAgICogIHByb3ZpZGVyLiBUaGlzIGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlIGFuIHVubWluZWQgdHJhbnNhY3Rpb25cbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tOdW1iZXIgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0eDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm90IG1pbmVkIHlldC4uLlxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwgfHwgdHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChfY29uZmlybXMsIF90aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyA9PSBudWxsKSA/IDEgOiBfY29uZmlybXM7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoX3RpbWVvdXQgPT0gbnVsbCkgPyAwIDogX3RpbWVvdXQ7XG4gICAgICAgIGxldCBzdGFydEJsb2NrID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgbGV0IG5leHRTY2FuID0gLTE7XG4gICAgICAgIGxldCBzdG9wU2Nhbm5pbmcgPSAoc3RhcnRCbG9jayA9PT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGVja1JlcGxhY2VtZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIHNlbmRlclxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgbm9uY2UgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5mcm9tKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBObyB0cmFuc2FjdGlvbiBvciBvdXIgbm9uY2UgaGFzIG5vdCBiZWVuIG1pbmVkIHlldDsgYnV0IHdlXG4gICAgICAgICAgICAvLyBjYW4gc3RhcnQgc2Nhbm5pbmcgbGF0ZXIgd2hlbiB3ZSBkbyBzdGFydFxuICAgICAgICAgICAgaWYgKG5vbmNlIDwgdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3ZXJlIG1pbmVkOyBubyByZXBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWluZWQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQ7IHN0YXJ0IHNjYW5uaW5nIGZvciB0aGF0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBTdGFydGluZyB0byBzY2FuOyBsb29rIGJhY2sgYSBmZXcgZXh0cmEgYmxvY2tzIGZvciBzYWZldHlcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHN0YXJ0QmxvY2sgLSAzO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2NhbiA8IHRoaXMuI3N0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNjYW4gPSB0aGlzLiNzdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2NhbiA8PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBibG9jayB0byBzY2FuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKG5leHRTY2FuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID09PSB0aGlzLmhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHJlcGxhY2VkIHVzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGJsb2NrLmdldFRyYW5zYWN0aW9uKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gdGhpcy5mcm9tICYmIHR4Lm5vbmNlID09PSB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eC5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgcmV0cnkgdGhpcyBvbiB0aGUgbmV4dCBibG9jayAodGhpcyBjYXNlIGNvdWxkIGJlIG9wdGltaXplZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSkgPCBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhID09PSB0aGlzLmRhdGEgJiYgdHgudG8gPT09IHRoaXMudG8gJiYgdHgudmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5kYXRhID09PSBcIjB4XCIgJiYgdHguZnJvbSA9PT0gdHgudG8gJiYgdHgudmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTY2FuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsIHx8IHJlY2VpcHQuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidHJhbnNhY3Rpb24gZXhlY3V0aW9uIHJldmVydGVkXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLCByZWFzb246IG51bGwsIGludm9jYXRpb246IG51bGwsIHJldmVydDogbnVsbCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0bzogcmVjZWlwdC50byxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmVjZWlwdC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIlwiIC8vIEBUT0RPOiBpbiB2Nywgc3BsaXQgb3V0IHNlbmRUcmFuc2FjdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSwgcmVjZWlwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmhhc2gpO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgIGlmICgoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aHJvd3MgaWYgYSByZXBsYWNlbWVudCB3YXMgZm91bmRcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgIC8vIEFsbG93IG51bGwgb25seSB3aGVuIHRoZSBjb25maXJtcyBpcyAwXG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWl0ZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBMaXN0IG9mIHRoaW5ncyB0byBjYW5jZWwgd2hlbiB3ZSBoYXZlIGEgcmVzdWx0IChvbmUgd2F5IG9yIHRoZSBvdGhlcilcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHsgY2FuY2VsbGVycy5mb3JFYWNoKChjKSA9PiBjKCkpOyB9O1xuICAgICAgICAgICAgLy8gT24gY2FuY2VsLCBzdG9wIHNjYW5uaW5nIGZvciByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHN0b3BTY2FubmluZyA9IHRydWU7IH0pO1xuICAgICAgICAgICAgLy8gU2V0IHVwIGFueSB0aW1lb3V0IHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ3YWl0IGZvciB0cmFuc2FjdGlvbiB0aW1lb3V0XCIsIFwiVElNRU9VVFwiKSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eExpc3RlbmVyID0gYXN5bmMgKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb25lOyByZXR1cm4gaXQhXG4gICAgICAgICAgICAgICAgaWYgKChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNoZWNrUmVjZWlwdChyZWNlaXB0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7IH0pO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbih0aGlzLmhhc2gsIHR4TGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gV2Ugc3VwcG9ydCByZXBsYWNlbWVudCBkZXRlY3Rpb247IHN0YXJ0IGNoZWNraW5nXG4gICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUxpc3RlbmVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRoaXMgdGhyb3dzIG9ubHkgaWYgb25lIGlzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHJlcGxhY2VkICh3aXRoIGVub3VnaCBjb25maXJtcyk7IHJlLXRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNjaGV1ZGxlIGEgY2hlY2sgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB3YWl0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBlZmZlY3RpdmUgb25seSBhcyBvZiB0aGUgdGltZSB0aGUgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgICAqICB3YXMgaW5zdGFudGlhdGVkLiBUbyBnZXQgdXAtdG8tZGF0ZSBpbmZvcm1hdGlvbiwgdXNlXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxuICAgICAqICB1bm1pbmVkIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmxvY2tIYXNoICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSAoaS5lLiBgYHR5cGUgPT0gMGBgKVxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBCZXJsaW4gKGkuZS4gYGB0eXBlID09IDFgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTE1NTldXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBodGUgdHJhbnNhY3Rpb24gaXMgYSBDYW5jdW4gKGkuZS4gYGB0eXBlID09IDNgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBpc0NhbmN1bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCBldmljdCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCByZS1vcmRlciB0aGlzIGV2ZW50IGFnYWluc3QgJSVvdGhlciUlLlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSBpbnN0YW5jZSB3aGljaCBoYXMgdGhlIGFiaWxpdHkgdG9cbiAgICAgKiAgZGV0ZWN0IChhbmQgdGhyb3cgYW4gZXJyb3IpIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyByZXBsYWNlZCwgd2hpY2hcbiAgICAgKiAgd2lsbCBiZWdpbiBzY2FubmluZyBhdCAlJXN0YXJ0QmxvY2slJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYnkgZGV2ZWxvcGVycyBhbmQgaXMgaW50ZW5kZWRcbiAgICAgKiAgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIFNldHRpbmcgYW4gaW5jb3JyZWN0ICUlc3RhcnRCbG9jayUlIGNhblxuICAgICAqICBoYXZlIGRldmFzdGF0aW5nIHBlcmZvcm1hbmNlIGNvbnNlcXVlbmNlcyBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAqL1xuICAgIHJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jaykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YXJ0QmxvY2spICYmIHN0YXJ0QmxvY2sgPj0gMCwgXCJpbnZhbGlkIHN0YXJ0QmxvY2tcIiwgXCJzdGFydEJsb2NrXCIsIHN0YXJ0QmxvY2spO1xuICAgICAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKHRoaXMsIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICB0eC4jc3RhcnRCbG9jayA9IHN0YXJ0QmxvY2s7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyKGJsb2NrKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtYmxvY2tcIiwgaGFzaDogYmxvY2suaGFzaCwgbnVtYmVyOiBibG9jay5udW1iZXIgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHR4LCBvdGhlcikge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJyZW9yZGVyLXRyYW5zYWN0aW9uXCIsIHR4LCBvdGhlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHR4KSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtdHJhbnNhY3Rpb25cIiwgdHggfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIobG9nKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtbG9nXCIsIGxvZzoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGxvZy5ibG9ja051bWJlcixcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICB0b3BpY3M6IE9iamVjdC5mcmVlemUobG9nLnRvcGljcy5zbGljZSgpKSxcbiAgICAgICAgICAgIGluZGV4OiBsb2cuaW5kZXhcbiAgICAgICAgfSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/provider.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/signer-noncemanager.js":
/*!******************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/signer-noncemanager.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NonceManager: function() { return /* binding */ NonceManager; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-signer.js */ \"../common/node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n\n\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nclass NonceManager extends _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    /**\n     *  The Signer being managed.\n     */\n    signer;\n    #noncePromise;\n    #delta;\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */\n    constructor(signer) {\n        super(signer.provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { signer });\n        this.#noncePromise = null;\n        this.#delta = 0;\n    }\n    async getAddress() {\n        return this.signer.getAddress();\n    }\n    connect(provider) {\n        return new NonceManager(this.signer.connect(provider));\n    }\n    async getNonce(blockTag) {\n        if (blockTag === \"pending\") {\n            if (this.#noncePromise == null) {\n                this.#noncePromise = super.getNonce(\"pending\");\n            }\n            const delta = this.#delta;\n            return (await this.#noncePromise) + delta;\n        }\n        return super.getNonce(blockTag);\n    }\n    /**\n     *  Manually increment the nonce. This may be useful when managng\n     *  offline transactions.\n     */\n    increment() {\n        this.#delta++;\n    }\n    /**\n     *  Resets the nonce, causing the **NonceManager** to reload the current\n     *  nonce from the blockchain on the next transaction.\n     */\n    reset() {\n        this.#delta = 0;\n        this.#noncePromise = null;\n    }\n    async sendTransaction(tx) {\n        const noncePromise = this.getNonce(\"pending\");\n        this.increment();\n        tx = await this.signer.populateTransaction(tx);\n        tx.nonce = await noncePromise;\n        // @TODO: Maybe handle interesting/recoverable errors?\n        // Like don't increment if the tx was certainly not sent\n        return await this.signer.sendTransaction(tx);\n    }\n    signTransaction(tx) {\n        return this.signer.signTransaction(tx);\n    }\n    signMessage(message) {\n        return this.signer.signMessage(message);\n    }\n    signTypedData(domain, types, value) {\n        return this.signer.signTypedData(domain, types, value);\n    }\n}\n//# sourceMappingURL=signer-noncemanager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc2lnbmVyLW5vbmNlbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFDQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLCtEQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQixTQUFTLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9zaWduZXItbm9uY2VtYW5hZ2VyLmpzP2U3MjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1zaWduZXIuanNcIjtcbi8qKlxuICogIEEgKipOb25jZU1hbmFnZXIqKiB3cmFwcyBhbm90aGVyIFtbU2lnbmVyXV0gYW5kIGF1dG9tYXRpY2FsbHkgbWFuYWdlc1xuICogIHRoZSBub25jZSwgZW5zdXJpbmcgc2VyaWFsaXplZCBhbmQgc2VxdWVudGlhbCBub25jZXMgYXJlIHVzZWQgZHVyaW5nXG4gKiAgdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBOb25jZU1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBTaWduZXIgYmVpbmcgbWFuYWdlZC5cbiAgICAgKi9cbiAgICBzaWduZXI7XG4gICAgI25vbmNlUHJvbWlzZTtcbiAgICAjZGVsdGE7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOb25jZU1hbmFnZXIqKiB0byBtYW5hZ2UgJSVzaWduZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzaWduZXIpIHtcbiAgICAgICAgc3VwZXIoc2lnbmVyLnByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpZ25lciB9KTtcbiAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGVsdGEgPSAwO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9uY2VNYW5hZ2VyKHRoaXMuc2lnbmVyLmNvbm5lY3QocHJvdmlkZXIpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI25vbmNlUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gc3VwZXIuZ2V0Tm9uY2UoXCJwZW5kaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLiNkZWx0YTtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy4jbm9uY2VQcm9taXNlKSArIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXROb25jZShibG9ja1RhZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBNYW51YWxseSBpbmNyZW1lbnQgdGhlIG5vbmNlLiBUaGlzIG1heSBiZSB1c2VmdWwgd2hlbiBtYW5hZ25nXG4gICAgICogIG9mZmxpbmUgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGluY3JlbWVudCgpIHtcbiAgICAgICAgdGhpcy4jZGVsdGErKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc2V0cyB0aGUgbm9uY2UsIGNhdXNpbmcgdGhlICoqTm9uY2VNYW5hZ2VyKiogdG8gcmVsb2FkIHRoZSBjdXJyZW50XG4gICAgICogIG5vbmNlIGZyb20gdGhlIGJsb2NrY2hhaW4gb24gdGhlIG5leHQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuI2RlbHRhID0gMDtcbiAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IG5vbmNlUHJvbWlzZSA9IHRoaXMuZ2V0Tm9uY2UoXCJwZW5kaW5nXCIpO1xuICAgICAgICB0aGlzLmluY3JlbWVudCgpO1xuICAgICAgICB0eCA9IGF3YWl0IHRoaXMuc2lnbmVyLnBvcHVsYXRlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICB0eC5ub25jZSA9IGF3YWl0IG5vbmNlUHJvbWlzZTtcbiAgICAgICAgLy8gQFRPRE86IE1heWJlIGhhbmRsZSBpbnRlcmVzdGluZy9yZWNvdmVyYWJsZSBlcnJvcnM/XG4gICAgICAgIC8vIExpa2UgZG9uJ3QgaW5jcmVtZW50IGlmIHRoZSB0eCB3YXMgY2VydGFpbmx5IG5vdCBzZW50XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHgpO1xuICAgIH1cbiAgICBzaWduVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbih0eCk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduZXItbm9uY2VtYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/signer-noncemanager.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/subscriber-filterid.js":
/*!******************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/subscriber-filterid.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilterIdEventSubscriber: function() { return /* binding */ FilterIdEventSubscriber; },\n/* harmony export */   FilterIdPendingSubscriber: function() { return /* binding */ FilterIdPendingSubscriber; },\n/* harmony export */   FilterIdSubscriber: function() { return /* binding */ FilterIdSubscriber; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-polling.js */ \"../common/node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass FilterIdSubscriber {\n    #provider;\n    #filterIdPromise;\n    #poller;\n    #running;\n    #network;\n    #hault;\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#network = null;\n        this.#hault = false;\n    }\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */\n    _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */\n    _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */\n    _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    async #poll(blockNumber) {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n            // Get the Filter ID\n            let filterId = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            }\n            catch (error) {\n                if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) {\n                this.#network = network;\n            }\n            if (this.#network.chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n            if (this.#hault) {\n                return;\n            }\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [filterId]);\n            await this._emitResults(this.#provider, result);\n        }\n        catch (error) {\n            console.log(\"@TODO\", error);\n        }\n        this.#provider.once(\"block\", this.#poller);\n    }\n    #teardown() {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId) => {\n                if (this.#provider.destroyed) {\n                    return;\n                }\n                this.#provider.send(\"eth_uninstallFilter\", [filterId]);\n            });\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#teardown();\n        }\n        this.#provider.off(\"block\", this.#poller);\n    }\n    resume() { this.start(); }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event;\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        super(provider);\n        this.#event = copy(filter);\n    }\n    _recover(provider) {\n        return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__.PollingEventSubscriber(provider, this.#event);\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [this.#event]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results) {\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results) {\n            provider.emit(\"pending\", result);\n        }\n    }\n}\n//# sourceMappingURL=subscriber-filterid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0QztBQUNxQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwRUFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9zdWJzY3JpYmVyLWZpbHRlcmlkLmpzPzNlNDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiO1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8qKlxuICogIFNvbWUgYmFja2VuZHMgc3VwcG9ydCBzdWJzY3JpYmluZyB0byBldmVudHMgdXNpbmcgYSBGaWx0ZXIgSUQuXG4gKlxuICogIFdoZW4gc3Vic2NyaWJpbmcgd2l0aCB0aGlzIHRlY2huaXF1ZSwgdGhlIG5vZGUgaXNzdWVzIGEgdW5pcXVlXG4gKiAgLy9GaWx0ZXIgSUQvLy4gQXQgdGhpcyBwb2ludCB0aGUgbm9kZSBkZWRpY2F0ZXMgcmVzb3VyY2VzIHRvXG4gKiAgdGhlIGZpbHRlciwgc28gdGhhdCBwZXJpb2RpYyBjYWxscyB0byBmb2xsb3cgdXAgb24gdGhlIC8vRmlsdGVyIElELy9cbiAqICB3aWxsIHJlY2VpdmUgYW55IGV2ZW50cyBzaW5jZSB0aGUgbGFzdCBjYWxsLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAjcG9sbGVyO1xuICAgICNydW5uaW5nO1xuICAgICNuZXR3b3JrO1xuICAgICNoYXVsdDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkU3Vic2NyaWJlcioqIHdoaWNoIHdpbGwgdXNlZCBbW19zdWJzY3JpYmVdXVxuICAgICAqICBhbmQgW1tfZW1pdFJlc3VsdHNdXSB0byBzZXR1cCB0aGUgc3Vic2NyaXB0aW9uIGFuZCBwcm92aWRlIHRoZSBldmVudFxuICAgICAqICB0byB0aGUgJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy4jaGF1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gYmVnaW4gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyBoYW5kbGUgdGhlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHJlY292ZXJ5IG9uIGVycm9ycy5cbiAgICAgKi9cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgYXN5bmMgI3BvbGwoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGlmICh0aGlzLiNmaWx0ZXJJZFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IHRoaXMuX3N1YnNjcmliZSh0aGlzLiNwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIEZpbHRlciBJRFxuICAgICAgICAgICAgbGV0IGZpbHRlcklkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmlsdGVySWQgPSBhd2FpdCB0aGlzLiNmaWx0ZXJJZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIpIHx8IGVycm9yLm9wZXJhdGlvbiAhPT0gXCJldGhfbmV3RmlsdGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBGaWx0ZXIgSUQ7IGRvd25ncmFkZSB0b1xuICAgICAgICAgICAgLy8gcG9sbGluZ1xuICAgICAgICAgICAgaWYgKGZpbHRlcklkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9yZWNvdmVyU3Vic2NyaWJlcih0aGlzLCB0aGlzLl9yZWNvdmVyKHRoaXMuI3Byb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy4jbmV0d29yaykge1xuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmsuY2hhaW5JZCAhPT0gbmV0d29yay5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhaWQgY2hhbmdlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2VtaXRSZXN1bHRzKHRoaXMuI3Byb3ZpZGVyLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJAVE9ET1wiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub25jZShcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgICN0ZWFyZG93bigpIHtcbiAgICAgICAgY29uc3QgZmlsdGVySWRQcm9taXNlID0gdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICBpZiAoZmlsdGVySWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgZmlsdGVySWRQcm9taXNlLnRoZW4oKGZpbHRlcklkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3Byb3ZpZGVyLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jdGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjZXZlbnQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJVxuICAgICAqICBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2V2ZW50ID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIocHJvdmlkZXIsIHRoaXMuI2V2ZW50KTtcbiAgICB9XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZCA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfbmV3RmlsdGVyXCIsIFt0aGlzLiNldmVudF0pO1xuICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2V2ZW50LCBwcm92aWRlci5fd3JhcExvZyhyZXN1bHQsIHByb3ZpZGVyLl9uZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1maWx0ZXJpZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/subscriber-filterid.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/subscriber-polling.js":
/*!*****************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/subscriber-polling.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnBlockSubscriber: function() { return /* binding */ OnBlockSubscriber; },\n/* harmony export */   PollingBlockSubscriber: function() { return /* binding */ PollingBlockSubscriber; },\n/* harmony export */   PollingBlockTagSubscriber: function() { return /* binding */ PollingBlockTagSubscriber; },\n/* harmony export */   PollingEventSubscriber: function() { return /* binding */ PollingEventSubscriber; },\n/* harmony export */   PollingOrphanSubscriber: function() { return /* binding */ PollingOrphanSubscriber; },\n/* harmony export */   PollingTransactionSubscriber: function() { return /* binding */ PollingTransactionSubscriber; },\n/* harmony export */   getPollingSubscriber: function() { return /* binding */ getPollingSubscriber; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nfunction getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval() { return this.#interval; }\n    set pollingInterval(value) { this.#interval = value; }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        }\n        catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber) => {\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) { this.stop(); }\n    resume() { this.start(); }\n}\nclass PollingBlockTagSubscriber extends OnBlockSubscriber {\n    #tag;\n    #lastBlock;\n    constructor(provider, tag) {\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#lastBlock = -2;\n        }\n        super.pause(dropWhilePaused);\n    }\n    async _poll(blockNumber, provider) {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) {\n            return;\n        }\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        }\n        else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider, hash) {\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n//# sourceMappingURL=subscriber-polling.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1wb2xsaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQVc7QUFDbkI7QUFDQTtBQUNBLElBQUksdURBQU07QUFDVixtREFBbUQ7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGVBQWU7QUFDZjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1wb2xsaW5nLmpzP2ZlYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0LCBpc0hleFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgcG9sbGluZyBzdWJzY3JpYmVyIGZvciBjb21tb24gZXZlbnRzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9sbGluZ1N1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKHByb3ZpZGVyLCBldmVudCk7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBwb2xsaW5nIGV2ZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImdldFBvbGxpbmdTdWJzY3JpYmVyXCIsIGluZm86IHsgZXZlbnQgfVxuICAgIH0pO1xufVxuLy8gQFRPRE86IHJlZmFjdG9yIHRoaXNcbi8qKlxuICogIEEgKipQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKiogcG9sbHMgYXQgYSByZWd1bGFyIGludGVydmFsIGZvciBhIGNoYW5nZVxuICogIGluIHRoZSBibG9jayBudW1iZXIuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjaW50ZXJ2YWw7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICNibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNpbnRlcnZhbCA9IDQwMDA7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKi9cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jaW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7IHRoaXMuI2ludGVydmFsID0gdmFsdWU7IH1cbiAgICBhc3luYyAjcG9sbCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCBwb2xsIHRvIHNldHVwIG91ciBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQFRPRE86IFB1dCBhIGNhcCBvbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHBlciBsb29wP1xuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyICE9PSB0aGlzLiNibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgPSB0aGlzLiNibG9ja051bWJlciArIDE7IGIgPD0gYmxvY2tOdW1iZXI7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNwcm92aWRlci5lbWl0KFwiYmxvY2tcIiwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogTWlub3IgYnVtcCwgYWRkIGFuIFwiZXJyb3JcIiBldmVudCB0byBsZXQgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIC8vICAgICAgICBrbm93IHRoaW5ncyB3ZW50IGF3cnkuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gc3RvcHBlZFxuICAgICAgICBpZiAodGhpcy4jcG9sbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwcm92aWRlci5fc2V0VGltZW91dCh0aGlzLiNwb2xsLmJpbmQodGhpcyksIHRoaXMuI2ludGVydmFsKTtcbiAgICAgICAgdGhpcy4jcG9sbCgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3BvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9jbGVhclRpbWVvdXQodGhpcy4jcG9sbGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gbnVsbDtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqT25CbG9ja1N1YnNjcmliZXIqKiBjYW4gYmUgc3ViLWNsYXNzZWQsIHdpdGggYSBbW19wb2xsXV1cbiAqICBpbXBsbWVudGF0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI3BvbGw7XG4gICAgI3J1bm5pbmc7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKk9uQmxvY2tTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcG9sbCA9IChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcG9sbChibG9ja051bWJlciwgdGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbGVkIG9uIGV2ZXJ5IG5ldyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViLWNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcG9sbCgtMik7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbCk7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB0aGlzLnN0b3AoKTsgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG5leHBvcnQgY2xhc3MgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjdGFnO1xuICAgICNsYXN0QmxvY2s7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIHRhZykge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI3RhZyA9IHRhZztcbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gLTI7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXVzZShkcm9wV2hpbGVQYXVzZWQpO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCBwcm92aWRlci5nZXRCbG9jayh0aGlzLiN0YWcpO1xuICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2sgPT09IC0yKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSBibG9jay5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2subnVtYmVyID4gdGhpcy4jbGFzdEJsb2NrKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI3RhZywgYmxvY2subnVtYmVyKTtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IGJsb2NrLm51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ09ycGhhblN1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI2ZpbHRlcjtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuI2ZpbHRlcik7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiB3aWxsIHBvbGwgZm9yIGEgZ2l2ZW4gdHJhbnNhY3Rpb25cbiAqICBoYXNoIGZvciBpdHMgcmVjZWlwdC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI2hhc2g7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVoYXNoJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGhhc2gpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNoYXNoID0gaGFzaDtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuI2hhc2gpO1xuICAgICAgICBpZiAodHgpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jaGFzaCwgdHgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKlBvbGxpbmdFdmVudFN1YnNjcmliZXIqKiB3aWxsIHBvbGwgZm9yIGEgZ2l2ZW4gZmlsdGVyIGZvciBpdHMgbG9ncy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdFdmVudFN1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjZmlsdGVyO1xuICAgICNwb2xsZXI7XG4gICAgI3J1bm5pbmc7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICNibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gY29weShmaWx0ZXIpO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICB9XG4gICAgYXN5bmMgI3BvbGwoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgLy8gVGhlIGluaXRpYWwgYmxvY2sgaGFzbid0IGJlZW4gZGV0ZXJtaW5lZCB5ZXRcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGNvcHkodGhpcy4jZmlsdGVyKTtcbiAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IHRoaXMuI2Jsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgY29uc3QgbG9ncyA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldExvZ3MoZmlsdGVyKTtcbiAgICAgICAgLy8gTm8gbG9ncyBjb3VsZCBqdXN0IG1lYW4gdGhlIG5vZGUgaGFzIG5vdCBpbmRleGVkIHRoZW0geWV0LFxuICAgICAgICAvLyBzbyB3ZSBrZWVwIGEgc2xpZGluZyB3aW5kb3cgb2YgNjAgYmxvY2tzIHRvIGtlZXAgc2Nhbm5pbmdcbiAgICAgICAgaWYgKGxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPCBibG9ja051bWJlciAtIDYwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLmVtaXQodGhpcy4jZmlsdGVyLCBsb2cpO1xuICAgICAgICAgICAgLy8gT25seSBhZHZhbmNlIHRoZSBibG9jayBudW1iZXIgd2hlbiBsb2dzIHdlcmUgZm91bmQgdG9cbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIG5ldHdvcmtzIChsaWtlIEJOQiBhbmQgUG9seWdvbikgd2hpY2ggbWF5XG4gICAgICAgICAgICAvLyBzYWNyaWZpY2UgZXZlbnQgY29uc2lzdGVuY3kgZm9yIGJsb2NrIGV2ZW50IHNwZWVkXG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5vbihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZXItcG9sbGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/subscriber-polling.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/providers/ws-browser.js":
/*!*********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/providers/ws-browser.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocket: function() { return /* binding */ _WebSocket; }\n/* harmony export */ });\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n}\n;\nconst _WebSocket = getGlobal().WebSocket;\n\n//# sourceMappingURL=ws-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvd3MtYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvd3MtYnJvd3Nlci5qcz84ZDQ1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG47XG5jb25zdCBfV2ViU29ja2V0ID0gZ2V0R2xvYmFsKCkuV2ViU29ja2V0O1xuZXhwb3J0IHsgX1dlYlNvY2tldCBhcyBXZWJTb2NrZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdzLWJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/providers/ws-browser.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/transaction/accesslist.js":
/*!***********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/transaction/accesslist.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accessListify: function() { return /* binding */ accessListify; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(addr),\n        storageKeys: storageKeys.map((storageKey, index) => {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */\nfunction accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set != null && typeof (set) === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value != null && typeof (value) === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n//# sourceMappingURL=accesslist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hY2Nlc3NsaXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRDtBQUNlO0FBQ2hFO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQVU7QUFDM0I7QUFDQSxZQUFZLCtEQUFjLENBQUMsNERBQVcsaURBQWlELE1BQU07QUFDN0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFjLGdEQUFnRCxNQUFNO0FBQ3BGO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FjY2Vzc2xpc3QuanM/N2MwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBpc0hleFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gYWNjZXNzU2V0aWZ5KGFkZHIsIHN0b3JhZ2VLZXlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyhhZGRyKSxcbiAgICAgICAgc3RvcmFnZUtleXM6IHN0b3JhZ2VLZXlzLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHN0b3JhZ2VLZXksIDMyKSwgXCJpbnZhbGlkIHNsb3RcIiwgYHN0b3JhZ2VLZXlzWyR7aW5kZXh9XWAsIHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbQWNjZXNzTGlzdF1dIGZyb20gYW55IGV0aGVycy1zdXBwb3J0ZWQgYWNjZXNzLWxpc3Qgc3RydWN0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWNjZXNzTGlzdGlmeSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChzZXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXQpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0Lmxlbmd0aCA9PT0gMiwgXCJpbnZhbGlkIHNsb3Qgc2V0XCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0WzBdLCBzZXRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0ICE9IG51bGwgJiYgdHlwZW9mIChzZXQpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWRkcmVzcy1zbG90IHNldFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWNjZXNzIGxpc3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoYWRkcikgPT4ge1xuICAgICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHZhbHVlW2FkZHJdLnJlZHVjZSgoYWNjdW0sIHN0b3JhZ2VLZXkpID0+IHtcbiAgICAgICAgICAgIGFjY3VtW3N0b3JhZ2VLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KGFkZHIsIE9iamVjdC5rZXlzKHN0b3JhZ2VLZXlzKS5zb3J0KCkpO1xuICAgIH0pO1xuICAgIHJlc3VsdC5zb3J0KChhLCBiKSA9PiAoYS5hZGRyZXNzLmxvY2FsZUNvbXBhcmUoYi5hZGRyZXNzKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3NsaXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/transaction/accesslist.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/transaction/address.js":
/*!********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/transaction/address.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeAddress: function() { return /* binding */ computeAddress; },\n/* harmony export */   recoverAddress: function() { return /* binding */ recoverAddress; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n\n\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */\nfunction computeAddress(key) {\n    let pubkey;\n    if (typeof (key) === \"string\") {\n        pubkey = _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.computePublicKey(key, false);\n    }\n    else {\n        pubkey = key.publicKey;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */\nfunction recoverAddress(digest, signature) {\n    return computeAddress(_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.recoverPublicKey(digest, signature));\n}\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFDVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBVSxDQUFDLDJEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDBCQUEwQix3REFBVTtBQUNwQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FkZHJlc3MuanM/ZWViMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiwgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSAlJWtleSUlLlxuICpcbiAqICBUaGUga2V5IG1heSBiZSBhbnkgc3RhbmRhcmQgZm9ybSBvZiBwdWJsaWMga2V5IG9yIGEgcHJpdmF0ZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcbiAgICBsZXQgcHVia2V5O1xuICAgIGlmICh0eXBlb2YgKGtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHVia2V5ID0gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KGtleSwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHVia2V5ID0ga2V5LnB1YmxpY0tleTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3Moa2VjY2FrMjU2KFwiMHhcIiArIHB1YmtleS5zdWJzdHJpbmcoNCkpLnN1YnN0cmluZygyNikpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgcmVjb3ZlcmVkIGFkZHJlc3MgZm9yIHRoZSBwcml2YXRlIGtleSB0aGF0IHdhc1xuICogIHVzZWQgdG8gc2lnbiAlJWRpZ2VzdCUlIHRoYXQgcmVzdWx0ZWQgaW4gJSVzaWduYXR1cmUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVBZGRyZXNzKFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/transaction/address.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/transaction/authorization.js":
/*!**************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/transaction/authorization.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authorizationify: function() { return /* binding */ authorizationify; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\n\nfunction authorizationify(auth) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(auth.address),\n        nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)((auth.nonce != null) ? auth.nonce : 0),\n        chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)((auth.chainId != null) ? auth.chainId : 0),\n        signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.Signature.from(auth.signature)\n    };\n}\n//# sourceMappingURL=authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hdXRob3JpemF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFDRjtBQUNEO0FBQ3ZDO0FBQ1A7QUFDQSxpQkFBaUIsNkRBQVU7QUFDM0IsZUFBZSwwREFBUztBQUN4QixpQkFBaUIsMERBQVM7QUFDMUIsbUJBQW1CLHVEQUFTO0FBQzVCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hdXRob3JpemF0aW9uLmpzPzQ4NzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBhdXRob3JpemF0aW9uaWZ5KGF1dGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGF1dGguYWRkcmVzcyksXG4gICAgICAgIG5vbmNlOiBnZXRCaWdJbnQoKGF1dGgubm9uY2UgIT0gbnVsbCkgPyBhdXRoLm5vbmNlIDogMCksXG4gICAgICAgIGNoYWluSWQ6IGdldEJpZ0ludCgoYXV0aC5jaGFpbklkICE9IG51bGwpID8gYXV0aC5jaGFpbklkIDogMCksXG4gICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oYXV0aC5zaWduYXR1cmUpXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/transaction/authorization.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/transaction/index.js":
/*!******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/transaction/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transaction: function() { return /* reexport safe */ _transaction_js__WEBPACK_IMPORTED_MODULE_3__.Transaction; },\n/* harmony export */   accessListify: function() { return /* reexport safe */ _accesslist_js__WEBPACK_IMPORTED_MODULE_0__.accessListify; },\n/* harmony export */   authorizationify: function() { return /* reexport safe */ _authorization_js__WEBPACK_IMPORTED_MODULE_1__.authorizationify; },\n/* harmony export */   computeAddress: function() { return /* reexport safe */ _address_js__WEBPACK_IMPORTED_MODULE_2__.computeAddress; },\n/* harmony export */   recoverAddress: function() { return /* reexport safe */ _address_js__WEBPACK_IMPORTED_MODULE_2__.recoverAddress; }\n/* harmony export */ });\n/* harmony import */ var _accesslist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accesslist.js */ \"../common/node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _authorization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./authorization.js */ \"../common/node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./address.js */ \"../common/node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transaction.js */ \"../common/node_modules/ethers/lib.esm/transaction/transaction.js\");\n/**\n *  Each state-changing operation on Ethereum requires a transaction.\n *\n *  @_section api/transaction:Transactions  [about-transactions]\n */\nnull;\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDTTtBQUNRO0FBQ2Y7QUFDL0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vaW5kZXguanM/Njk3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBFYWNoIHN0YXRlLWNoYW5naW5nIG9wZXJhdGlvbiBvbiBFdGhlcmV1bSByZXF1aXJlcyBhIHRyYW5zYWN0aW9uLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3RyYW5zYWN0aW9uOlRyYW5zYWN0aW9ucyAgW2Fib3V0LXRyYW5zYWN0aW9uc11cbiAqL1xubnVsbDtcbmV4cG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi9hY2Nlc3NsaXN0LmpzXCI7XG5leHBvcnQgeyBhdXRob3JpemF0aW9uaWZ5IH0gZnJvbSBcIi4vYXV0aG9yaXphdGlvbi5qc1wiO1xuZXhwb3J0IHsgY29tcHV0ZUFkZHJlc3MsIHJlY292ZXJBZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzcy5qc1wiO1xuZXhwb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi90cmFuc2FjdGlvbi5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/transaction/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/transaction/transaction.js":
/*!************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/transaction/transaction.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transaction: function() { return /* binding */ Transaction; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _constants_addresses_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/addresses.js */ \"../common/node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _accesslist_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./accesslist.js */ \"../common/node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _authorization_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./authorization.js */ \"../common/node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./address.js */ \"../common/node_modules/ethers/lib.esm/transaction/address.js\");\n\n\n\n\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst BLOB_SIZE = 4096 * 32;\nfunction getKzgLibrary(kzg) {\n    const blobToKzgCommitment = (blob) => {\n        if (\"computeBlobProof\" in kzg) {\n            // micro-ecc-signer; check for computeBlobProof since this API\n            // expects a string while the kzg-wasm below expects a Unit8Array\n            if (\"blobToKzgCommitment\" in kzg && typeof (kzg.blobToKzgCommitment) === \"function\") {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\n            }\n        }\n        else if (\"blobToKzgCommitment\" in kzg && typeof (kzg.blobToKzgCommitment) === \"function\") {\n            // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment(blob));\n        }\n        // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\n        if (\"blobToKZGCommitment\" in kzg && typeof (kzg.blobToKZGCommitment) === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKZGCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    const computeBlobKzgProof = (blob, commitment) => {\n        // micro-ecc-signer\n        if (\"computeBlobProof\" in kzg && typeof (kzg.computeBlobProof) === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\n        }\n        // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\n        if (\"computeBlobKzgProof\" in kzg && typeof (kzg.computeBlobKzgProof) === \"function\") {\n            return kzg.computeBlobKzgProof(blob, commitment);\n        }\n        // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\n        if (\"computeBlobKZGProof\" in kzg && typeof (kzg.computeBlobKZGProof) === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobKZGProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    return { blobToKzgCommitment, computeBlobKzgProof };\n}\nfunction getVersionedHash(version, hash) {\n    let versioned = version.toString(16);\n    while (versioned.length < 2) {\n        versioned = \"0\" + versioned;\n    }\n    versioned += (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(hash).substring(4);\n    return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(value);\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleAuthorizationList(value, param) {\n    try {\n        if (!Array.isArray(value)) {\n            throw new Error(\"authorizationList: invalid array\");\n        }\n        const result = [];\n        for (let i = 0; i < value.length; i++) {\n            const auth = value[i];\n            if (!Array.isArray(auth)) {\n                throw new Error(`authorization[${i}]: invalid array`);\n            }\n            if (auth.length !== 6) {\n                throw new Error(`authorization[${i}]: wrong length`);\n            }\n            if (!auth[1]) {\n                throw new Error(`authorization[${i}]: null address`);\n            }\n            result.push({\n                address: handleAddress(auth[1]),\n                nonce: handleUint(auth[2], \"nonce\"),\n                chainId: handleUint(auth[0], \"chainId\"),\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.from({\n                    yParity: handleNumber(auth[3], \"yParity\"),\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[4], 32),\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[5], 32)\n                })\n            });\n        }\n        return result;\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_value, param);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(_value, \"value\");\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction formatAuthorizationList(value) {\n    return value.map((a) => {\n        return [\n            formatNumber(a.chainId, \"chainId\"),\n            a.address,\n            formatNumber(a.nonce, \"nonce\"),\n            formatNumber(a.signature.yParity, \"yParity\"),\n            a.signature.r,\n            a.signature.s\n        ];\n    });\n}\nfunction formatHashes(value, param) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(value), `invalid ${param}`, \"value\", value);\n    for (let i = 0; i < value.length; i++) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n    }\n    return value;\n}\nfunction _parseLegacy(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeRlp)(data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    }\n    else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[7], 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[8], 32),\n            v\n        });\n        //tx.hash = keccak256(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.getChainIdV(chainId, sig.v);\n    }\n    else if (BigInt(sig.v) !== v) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(v));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.r));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.s));\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    }\n    catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[1], 32);\n    const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[2], 32);\n    const signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.from({ r, s, yParity });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x02\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields)]);\n}\nfunction _parseEip2930(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x01\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields)]);\n}\nfunction _parseEip4844(data) {\n    let fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    let typeName = \"3\";\n    let blobs = null;\n    // Parse the network format\n    if (fields.length === 4 && Array.isArray(fields[0])) {\n        typeName = \"3 (network format)\";\n        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n        blobs = [];\n        for (let i = 0; i < fields[1].length; i++) {\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: fProofs[i],\n            });\n        }\n        fields = fields[0];\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 3,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes: fields[10]\n    };\n    if (blobs) {\n        tx.blobs = blobs;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(tx.to != null, `invalid address for transaction type: ${typeName}`, \"data\", data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n    }\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) {\n        return tx;\n    }\n    // @TODO: Do we need to do this? This is only called internally\n    // and used to verify hashes; it might save time to not do this\n    //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n    _parseEipSignature(tx, fields.slice(11));\n    return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || _constants_addresses_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.s));\n        // We have blobs; return the network wrapped format\n        if (blobs) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n                \"0x03\",\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)([\n                    fields,\n                    blobs.map((b) => b.data),\n                    blobs.map((b) => b.commitment),\n                    blobs.map((b) => b.proof),\n                ])\n            ]);\n        }\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x03\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields)]);\n}\nfunction _parseEip7702(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), \"invalid field count for transaction type: 4\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 4,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        authorizationList: handleAuthorizationList(fields[9], \"authorizationList\"),\n    };\n    // Unsigned EIP-7702 Transaction\n    if (fields.length === 10) {\n        return tx;\n    }\n    _parseEipSignature(tx, fields.slice(10));\n    return tx;\n}\nfunction _serializeEip7702(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatAuthorizationList(tx.authorizationList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x04\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeRlp)(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nclass Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    #maxFeePerBlobGas;\n    #blobVersionedHashes;\n    #kzg;\n    #blobs;\n    #auths;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get type() { return this.#type; }\n    set type(value) {\n        switch (value) {\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            case 3:\n            case \"cancun\":\n            case \"eip-4844\":\n                this.#type = 3;\n                break;\n            case 4:\n            case \"pectra\":\n            case \"eip-7702\":\n                this.#type = 4;\n                break;\n            default:\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */\n    get typeName() {\n        switch (this.type) {\n            case 0: return \"legacy\";\n            case 1: return \"eip-2930\";\n            case 2: return \"eip-1559\";\n            case 3: return \"eip-4844\";\n            case 4: return \"eip-7702\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n    get to() {\n        const value = this.#to;\n        if (value == null && this.type === 3) {\n            return _constants_addresses_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress;\n        }\n        return value;\n    }\n    set to(value) {\n        this.#to = (value == null) ? null : (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n    }\n    /**\n     *  The transaction nonce.\n     */\n    get nonce() { return this.#nonce; }\n    set nonce(value) { this.#nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value, \"value\"); }\n    /**\n     *  The gas limit.\n     */\n    get gasLimit() { return this.#gasLimit; }\n    set gasLimit(value) { this.#gasLimit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value); }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n    get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n    get data() { return this.#data; }\n    set data(value) { this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value); }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */\n    get value() { return this.#value; }\n    set value(value) {\n        this.#value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n    get chainId() { return this.#chainId; }\n    set chainId(value) { this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value); }\n    /**\n     *  If signed, the signature for this transaction.\n     */\n    get signature() { return this.#sig || null; }\n    set signature(value) {\n        this.#sig = (value == null) ? null : _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n    get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = (value == null) ? null : (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(value);\n    }\n    get authorizationList() {\n        const value = this.#auths || null;\n        if (value == null) {\n            if (this.type === 4) {\n                // @TODO: in v7, this should become a live object itself,\n                // otherwise mutation is inconsistent\n                return [];\n            }\n        }\n        return value;\n    }\n    set authorizationList(auths) {\n        this.#auths = (auths == null) ? null : auths.map((a) => (0,_authorization_js__WEBPACK_IMPORTED_MODULE_5__.authorizationify)(a));\n    }\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */\n    get maxFeePerBlobGas() {\n        const value = this.#maxFeePerBlobGas;\n        if (value == null && this.type === 3) {\n            return BN_0;\n        }\n        return value;\n    }\n    set maxFeePerBlobGas(value) {\n        this.#maxFeePerBlobGas = (value == null) ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"maxFeePerBlobGas\");\n    }\n    /**\n     *  The BLOb versioned hashes for Cancun transactions.\n     */\n    get blobVersionedHashes() {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = this.#blobVersionedHashes;\n        if (value == null && this.type === 3) {\n            return [];\n        }\n        return value;\n    }\n    set blobVersionedHashes(value) {\n        if (value != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for (let i = 0; i < value.length; i++) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n            }\n        }\n        this.#blobVersionedHashes = value;\n    }\n    /**\n     *  The BLObs for the Transaction, if any.\n     *\n     *  If ``blobs`` is non-``null``, then the [[seriailized]]\n     *  will return the network formatted sidecar, otherwise it\n     *  will return the standard [[link-eip-2718]] payload. The\n     *  [[unsignedSerialized]] is unaffected regardless.\n     *\n     *  When setting ``blobs``, either fully valid [[Blob]] objects\n     *  may be specified (i.e. correctly padded, with correct\n     *  committments and proofs) or a raw [[BytesLike]] may\n     *  be provided.\n     *\n     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n     *  be already set. The blob will be correctly padded and the\n     *  [[KzgLibrary]] will be used to compute the committment and\n     *  proof for the blob.\n     *\n     *  A BLOb is a sequence of field elements, each of which must\n     *  be within the BLS field modulo, so some additional processing\n     *  may be required to encode arbitrary data to ensure each 32 byte\n     *  field is within the valid range.\n     *\n     *  Setting this automatically populates [[blobVersionedHashes]],\n     *  overwriting any existing values. Setting this to ``null``\n     *  does **not** remove the [[blobVersionedHashes]], leaving them\n     *  present.\n     */\n    get blobs() {\n        if (this.#blobs == null) {\n            return null;\n        }\n        return this.#blobs.map((b) => Object.assign({}, b));\n    }\n    set blobs(_blobs) {\n        if (_blobs == null) {\n            this.#blobs = null;\n            return;\n        }\n        const blobs = [];\n        const versionedHashes = [];\n        for (let i = 0; i < _blobs.length; i++) {\n            const blob = _blobs[i];\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(blob)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"set blobs()\"\n                });\n                let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(blob);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${i}]`, blob);\n                // Pad blob if necessary\n                if (data.length !== BLOB_SIZE) {\n                    const padded = new Uint8Array(BLOB_SIZE);\n                    padded.set(data);\n                    data = padded;\n                }\n                const commit = this.#kzg.blobToKzgCommitment(data);\n                const proof = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(this.#kzg.computeBlobKzgProof(data, commit));\n                blobs.push({\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data),\n                    commitment: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commit),\n                    proof\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n            else {\n                const commit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.commitment);\n                blobs.push({\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.data),\n                    commitment: commit,\n                    proof: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.proof)\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            }\n        }\n        this.#blobs = blobs;\n        this.#blobVersionedHashes = versionedHashes;\n    }\n    get kzg() { return this.#kzg; }\n    set kzg(kzg) {\n        if (kzg == null) {\n            this.#kzg = null;\n        }\n        else {\n            this.#kzg = getKzgLibrary(kzg);\n        }\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */\n    constructor() {\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BN_0;\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BN_0;\n        this.#chainId = BN_0;\n        this.#sig = null;\n        this.#accessList = null;\n        this.#maxFeePerBlobGas = null;\n        this.#blobVersionedHashes = null;\n        this.#kzg = null;\n        this.#blobs = null;\n        this.#auths = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */\n    get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(this.#getSerialized(true, false));\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n    get unsignedHash() {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n    get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_address_js__WEBPACK_IMPORTED_MODULE_6__.recoverAddress)(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n    get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    isSigned() {\n        return this.signature != null;\n    }\n    #getSerialized(signed, sidecar) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n        const sig = signed ? this.signature : null;\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this, sig);\n            case 1:\n                return _serializeEip2930(this, sig);\n            case 2:\n                return _serializeEip1559(this, sig);\n            case 3:\n                return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n            case 4:\n                return _serializeEip7702(this, sig);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n    get serialized() {\n        return this.#getSerialized(true, true);\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n    get unsignedSerialized() {\n        return this.#getSerialized(false, false);\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    inferType() {\n        const types = this.inferTypes();\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) {\n            return 2;\n        }\n        // Return the highest inferred type\n        return (types.pop());\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n    inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\n        const hasAccessList = (this.accessList != null);\n        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        }\n        else {\n            if (this.authorizationList && this.authorizationList.length) {\n                types.push(4);\n            }\n            else if (hasFee) {\n                types.push(2);\n            }\n            else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            }\n            else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            }\n            else if (hasBlob && this.to) {\n                types.push(3);\n            }\n            else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */\n    clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */\n    toJSON() {\n        const s = (v) => {\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n    static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof (tx) === \"string\") {\n            const payload = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(tx);\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch (payload[0]) {\n                case 1: return Transaction.from(_parseEip2930(payload));\n                case 2: return Transaction.from(_parseEip1559(payload));\n                case 3: return Transaction.from(_parseEip4844(payload));\n                case 4: return Transaction.from(_parseEip7702(payload));\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.maxFeePerBlobGas != null) {\n            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.authorizationList != null) {\n            result.authorizationList = tx.authorizationList;\n        }\n        // This will get overwritten by blobs, if present\n        if (tx.blobVersionedHashes != null) {\n            result.blobVersionedHashes = tx.blobVersionedHashes;\n        }\n        // Make sure we assign the kzg before assigning blobs, which\n        // require the library in the event raw blob data is provided.\n        if (tx.kzg != null) {\n            result.kzg = tx.kzg;\n        }\n        if (tx.blobs != null) {\n            result.blobs = tx.blobs;\n        }\n        if (tx.hash != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFpRDtBQUNPO0FBQ3NCO0FBQ3VHO0FBQ3JJO0FBQ007QUFDUjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLHlEQUFRLHlCQUF5Qix3REFBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsbUJBQW1CLHlEQUFRO0FBQzNCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsbUJBQW1CLHlEQUFRLHlCQUF5Qix3REFBTztBQUMzRDtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQVEsc0JBQXNCLHdEQUFPLFFBQVEsd0RBQU87QUFDdkU7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsbUJBQW1CLHlEQUFRLHlCQUF5Qix3REFBTyxRQUFRLHdEQUFPO0FBQzFFO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZEQUFhO0FBQzVCO0FBQ0E7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkRBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkRBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkRBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU0sNEVBQTRFLGlFQUFpRSwwQkFBMEI7QUFDckw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLG1FQUFtRSwwQkFBMEI7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQU0seUdBQXlHLGFBQWE7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLHFJQUFxSSxhQUFhO0FBQ2hLLFFBQVEsdURBQU0sK0ZBQStGLGFBQWE7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBUTtBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQU0sbUVBQW1FLG1CQUFtQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdURBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWM7QUFDMUIsWUFBWSwrREFBYztBQUMxQjtBQUNBO0FBQ0EsWUFBWSwrREFBYztBQUMxQixZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanM/ODc3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9hZGRyZXNzZXMuanNcIjtcbmltcG9ydCB7IGtlY2NhazI1Niwgc2hhMjU2LCBTaWduYXR1cmUsIFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRlY29kZVJscCwgZW5jb2RlUmxwLCBnZXRCeXRlcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzQnl0ZXNMaWtlLCBpc0hleFN0cmluZywgdG9CZUFycmF5LCB6ZXJvUGFkVmFsdWUgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi9hY2Nlc3NsaXN0LmpzXCI7XG5pbXBvcnQgeyBhdXRob3JpemF0aW9uaWZ5IH0gZnJvbSBcIi4vYXV0aG9yaXphdGlvbi5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IEJOX01BWF9VSU5UID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuY29uc3QgQkxPQl9TSVpFID0gNDA5NiAqIDMyO1xuZnVuY3Rpb24gZ2V0S3pnTGlicmFyeShremcpIHtcbiAgICBjb25zdCBibG9iVG9LemdDb21taXRtZW50ID0gKGJsb2IpID0+IHtcbiAgICAgICAgaWYgKFwiY29tcHV0ZUJsb2JQcm9vZlwiIGluIGt6Zykge1xuICAgICAgICAgICAgLy8gbWljcm8tZWNjLXNpZ25lcjsgY2hlY2sgZm9yIGNvbXB1dGVCbG9iUHJvb2Ygc2luY2UgdGhpcyBBUElcbiAgICAgICAgICAgIC8vIGV4cGVjdHMgYSBzdHJpbmcgd2hpbGUgdGhlIGt6Zy13YXNtIGJlbG93IGV4cGVjdHMgYSBVbml0OEFycmF5XG4gICAgICAgICAgICBpZiAoXCJibG9iVG9LemdDb21taXRtZW50XCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQoaGV4bGlmeShibG9iKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiYmxvYlRvS3pnQ29tbWl0bWVudFwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBremctd2FzbSA8MC41LjA7IGJsb2JUb0t6Z0NvbW1pdG1lbnQoVWludDhBcnJheSkgPT4gVWludDhBcnJheVxuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KGJsb2IpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBremctd2FzbSA+PSAwLjUuMDsgYmxvYlRvS1pHQ29tbWl0bWVudChzdHJpbmcpID0+IHN0cmluZ1xuICAgICAgICBpZiAoXCJibG9iVG9LWkdDb21taXRtZW50XCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmJsb2JUb0taR0NvbW1pdG1lbnQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuYmxvYlRvS1pHQ29tbWl0bWVudChoZXhsaWZ5KGJsb2IpKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgS1pHIGxpYnJhcnlcIiwgXCJremdcIiwga3pnKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbXB1dGVCbG9iS3pnUHJvb2YgPSAoYmxvYiwgY29tbWl0bWVudCkgPT4ge1xuICAgICAgICAvLyBtaWNyby1lY2Mtc2lnbmVyXG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iUHJvb2ZcIiBpbiBremcgJiYgdHlwZW9mIChremcuY29tcHV0ZUJsb2JQcm9vZikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5jb21wdXRlQmxvYlByb29mKGhleGxpZnkoYmxvYiksIGhleGxpZnkoY29tbWl0bWVudCkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBremctd2FzbSA8MC41LjA7IGNvbXB1dGVCbG9iS3pnUHJvb2YoVWludDhBcnJheSwgVWludDhBcnJheSkgPT4gVWludDhBcnJheVxuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYkt6Z1Byb29mXCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmNvbXB1dGVCbG9iS3pnUHJvb2YpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBremcuY29tcHV0ZUJsb2JLemdQcm9vZihibG9iLCBjb21taXRtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBremctd2FzbSA+PSAwLjUuMDsgY29tcHV0ZUJsb2JLWkdQcm9vZihzdHJpbmcsIHN0cmluZykgPT4gc3RyaW5nXG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iS1pHUHJvb2ZcIiBpbiBremcgJiYgdHlwZW9mIChremcuY29tcHV0ZUJsb2JLWkdQcm9vZikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5jb21wdXRlQmxvYktaR1Byb29mKGhleGxpZnkoYmxvYiksIGhleGxpZnkoY29tbWl0bWVudCkpKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBLWkcgbGlicmFyeVwiLCBcImt6Z1wiLCBremcpO1xuICAgIH07XG4gICAgcmV0dXJuIHsgYmxvYlRvS3pnQ29tbWl0bWVudCwgY29tcHV0ZUJsb2JLemdQcm9vZiB9O1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbmVkSGFzaCh2ZXJzaW9uLCBoYXNoKSB7XG4gICAgbGV0IHZlcnNpb25lZCA9IHZlcnNpb24udG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlICh2ZXJzaW9uZWQubGVuZ3RoIDwgMikge1xuICAgICAgICB2ZXJzaW9uZWQgPSBcIjBcIiArIHZlcnNpb25lZDtcbiAgICB9XG4gICAgdmVyc2lvbmVkICs9IHNoYTI1NihoYXNoKS5zdWJzdHJpbmcoNCk7XG4gICAgcmV0dXJuIFwiMHhcIiArIHZlcnNpb25lZDtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFkZHJlc3ModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzTGlzdCh2YWx1ZSwgcGFyYW0pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgZXJyb3IubWVzc2FnZSwgcGFyYW0sIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVBdXRob3JpemF0aW9uTGlzdCh2YWx1ZSwgcGFyYW0pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRob3JpemF0aW9uTGlzdDogaW52YWxpZCBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYXV0aCA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGF1dGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdXRob3JpemF0aW9uWyR7aX1dOiBpbnZhbGlkIGFycmF5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXV0aC5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF1dGhvcml6YXRpb25bJHtpfV06IHdyb25nIGxlbmd0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdXRoWzFdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdXRob3JpemF0aW9uWyR7aX1dOiBudWxsIGFkZHJlc3NgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBoYW5kbGVBZGRyZXNzKGF1dGhbMV0pLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBoYW5kbGVVaW50KGF1dGhbMl0sIFwibm9uY2VcIiksXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChhdXRoWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHk6IGhhbmRsZU51bWJlcihhdXRoWzNdLCBcInlQYXJpdHlcIiksXG4gICAgICAgICAgICAgICAgICAgIHI6IHplcm9QYWRWYWx1ZShhdXRoWzRdLCAzMiksXG4gICAgICAgICAgICAgICAgICAgIHM6IHplcm9QYWRWYWx1ZShhdXRoWzVdLCAzMilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBwYXJhbSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZU51bWJlcihfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TnVtYmVyKF92YWx1ZSwgcGFyYW0pO1xufVxuZnVuY3Rpb24gaGFuZGxlVWludChfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBCTl8wO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIHBhcmFtKTtcbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA8PSBCTl9NQVhfVUlOVCwgXCJ2YWx1ZSBleGNlZWRzIHVpbnQgc2l6ZVwiLCBwYXJhbSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihfdmFsdWUsIG5hbWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQubGVuZ3RoIDw9IDMyLCBgdmFsdWUgdG9vIGxhcmdlYCwgYHR4LiR7bmFtZX1gLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKChzZXQpID0+IFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXSk7XG59XG5mdW5jdGlvbiBmb3JtYXRBdXRob3JpemF0aW9uTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoKGEpID0+IHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihhLmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgICAgIGEuYWRkcmVzcyxcbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihhLm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICAgICAgZm9ybWF0TnVtYmVyKGEuc2lnbmF0dXJlLnlQYXJpdHksIFwieVBhcml0eVwiKSxcbiAgICAgICAgICAgIGEuc2lnbmF0dXJlLnIsXG4gICAgICAgICAgICBhLnNpZ25hdHVyZS5zXG4gICAgICAgIF07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRIYXNoZXModmFsdWUsIHBhcmFtKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSksIGBpbnZhbGlkICR7cGFyYW19YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZVtpXSwgMzIpLCBcImludmFsaWQgJHsgcGFyYW0gfSBoYXNoXCIsIGB2YWx1ZVske2l9XWAsIHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3BhcnNlTGVnYWN5KGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZGF0YSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA5IHx8IGZpZWxkcy5sZW5ndGggPT09IDYpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvblwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDAsXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzBdLCBcIm5vbmNlXCIpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlVWludChmaWVsZHNbMV0sIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzNdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s1XSksXG4gICAgICAgIGNoYWluSWQ6IEJOXzBcbiAgICB9O1xuICAgIC8vIExlZ2FjeSB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgY29uc3QgdiA9IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZcIik7XG4gICAgY29uc3QgciA9IGhhbmRsZVVpbnQoZmllbGRzWzddLCBcInJcIik7XG4gICAgY29uc3QgcyA9IGhhbmRsZVVpbnQoZmllbGRzWzhdLCBcInNcIik7XG4gICAgaWYgKHIgPT09IEJOXzAgJiYgcyA9PT0gQk5fMCkge1xuICAgICAgICAvLyBFSVAtMTU1IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNoYWluSWQgPSB2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgRUlQLTE1NSBjaGFpbiBJRCAob3IgMCBmb3IgbGVnYWN5KVxuICAgICAgICBsZXQgY2hhaW5JZCA9ICh2IC0gQk5fMzUpIC8gQk5fMjtcbiAgICAgICAgaWYgKGNoYWluSWQgPCBCTl8wKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICB0eC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgLy8gU2lnbmVkIExlZ2FjeSBUcmFuc2FjdGlvblxuICAgICAgICBhc3NlcnRBcmd1bWVudChjaGFpbklkICE9PSBCTl8wIHx8ICh2ID09PSBCTl8yNyB8fCB2ID09PSBCTl8yOCksIFwibm9uLWNhbm9uaWNhbCBsZWdhY3kgdlwiLCBcInZcIiwgZmllbGRzWzZdKTtcbiAgICAgICAgdHguc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICAgICAgICAgICAgcjogemVyb1BhZFZhbHVlKGZpZWxkc1s3XSwgMzIpLFxuICAgICAgICAgICAgczogemVyb1BhZFZhbHVlKGZpZWxkc1s4XSwgMzIpLFxuICAgICAgICAgICAgdlxuICAgICAgICB9KTtcbiAgICAgICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplTGVnYWN5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKHR4LnRvIHx8IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICBdO1xuICAgIGxldCBjaGFpbklkID0gQk5fMDtcbiAgICBpZiAodHguY2hhaW5JZCAhPSBCTl8wKSB7XG4gICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XG4gICAgICAgIGNoYWluSWQgPSBnZXRCaWdJbnQodHguY2hhaW5JZCwgXCJ0eC5jaGFpbklkXCIpO1xuICAgICAgICAvLyBXZSBoYXZlIGEgY2hhaW5JZCBpbiB0aGUgdHggYW5kIGFuIEVJUC0xNTUgdiBpbiB0aGUgc2lnbmF0dXJlLFxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhleSBhZ3JlZSB3aXRoIGVhY2ggb3RoZXJcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXNpZyB8fCBzaWcubmV0d29ya1YgPT0gbnVsbCB8fCBzaWcubGVnYWN5Q2hhaW5JZCA9PT0gY2hhaW5JZCwgXCJ0eC5jaGFpbklkL3NpZy52IG1pc21hdGNoXCIsIFwic2lnXCIsIHNpZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR4LnNpZ25hdHVyZSkge1xuICAgICAgICAvLyBObyBleHBsaWNpdCBjaGFpbklkLCBidXQgRUlQLTE1NSBoYXZlIGEgZGVyaXZlZCBpbXBsaWNpdCBjaGFpbklkXG4gICAgICAgIGNvbnN0IGxlZ2FjeSA9IHR4LnNpZ25hdHVyZS5sZWdhY3lDaGFpbklkO1xuICAgICAgICBpZiAobGVnYWN5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBsZWdhY3k7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVxdWVzdGluZyBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgIGlmICghc2lnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcbiAgICAgICAgaWYgKGNoYWluSWQgIT09IEJOXzApIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShjaGFpbklkKSk7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlUmxwKGZpZWxkcyk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgY2hlY2sgdGhhdCB0eC5zaWduYXR1cmUsIGNoYWluSWQsIGFuZCBzaWdcbiAgICAvLyAgICAgICAgbWF0Y2ggYnV0IHRoYXQgbG9naWMgY291bGQgYnJlYWsgZXhpc3RpbmcgY29kZSwgc28gc2NoZWR1bGVcbiAgICAvLyAgICAgICAgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgYnVtcC5cbiAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IHZcbiAgICBsZXQgdiA9IEJpZ0ludCgyNyArIHNpZy55UGFyaXR5KTtcbiAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xuICAgICAgICB2ID0gU2lnbmF0dXJlLmdldENoYWluSWRWKGNoYWluSWQsIHNpZy52KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQmlnSW50KHNpZy52KSAhPT0gdikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ0eC5jaGFpbklkL3NpZy52IG1pc21hdGNoXCIsIFwic2lnXCIsIHNpZyk7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgc2lnbmF0dXJlXG4gICAgZmllbGRzLnB1c2godG9CZUFycmF5KHYpKTtcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICByZXR1cm4gZW5jb2RlUmxwKGZpZWxkcyk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcykge1xuICAgIGxldCB5UGFyaXR5O1xuICAgIHRyeSB7XG4gICAgICAgIHlQYXJpdHkgPSBoYW5kbGVOdW1iZXIoZmllbGRzWzBdLCBcInlQYXJpdHlcIik7XG4gICAgICAgIGlmICh5UGFyaXR5ICE9PSAwICYmIHlQYXJpdHkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCB5UGFyaXR5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHlQYXJpdHlcIiwgXCJ5UGFyaXR5XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSB6ZXJvUGFkVmFsdWUoZmllbGRzWzFdLCAzMik7XG4gICAgY29uc3QgcyA9IHplcm9QYWRWYWx1ZShmaWVsZHNbMl0sIDMyKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7IHIsIHMsIHlQYXJpdHkgfSk7XG4gICAgdHguc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMTU1OShkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDkgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTIpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAyLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s3XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMTU1OSBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDkpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMTU1OSh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMlwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDggfHwgZmllbGRzLmxlbmd0aCA9PT0gMTEpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbM10sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s1XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbNl0pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s3XSwgXCJhY2Nlc3NMaXN0XCIpXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMjkzMCBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDgpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNQcmljZSB8fCAwLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMVwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwNDg0NChkYXRhKSB7XG4gICAgbGV0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgbGV0IHR5cGVOYW1lID0gXCIzXCI7XG4gICAgbGV0IGJsb2JzID0gbnVsbDtcbiAgICAvLyBQYXJzZSB0aGUgbmV0d29yayBmb3JtYXRcbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNCAmJiBBcnJheS5pc0FycmF5KGZpZWxkc1swXSkpIHtcbiAgICAgICAgdHlwZU5hbWUgPSBcIjMgKG5ldHdvcmsgZm9ybWF0KVwiO1xuICAgICAgICBjb25zdCBmQmxvYnMgPSBmaWVsZHNbMV0sIGZDb21taXRzID0gZmllbGRzWzJdLCBmUHJvb2ZzID0gZmllbGRzWzNdO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZCbG9icyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogYmxvYnMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzFdXCIsIGZCbG9icyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZkNvbW1pdHMpLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGNvbW1pdG1lbnRzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1syXVwiLCBmQ29tbWl0cyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZlByb29mcyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogcHJvb2ZzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1szXVwiLCBmUHJvb2ZzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZkJsb2JzLmxlbmd0aCA9PT0gZkNvbW1pdHMubGVuZ3RoLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzL2NvbW1pdG1lbnRzIGxlbmd0aCBtaXNtYXRjaFwiLCBcImZpZWxkc1wiLCBmaWVsZHMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmQmxvYnMubGVuZ3RoID09PSBmUHJvb2ZzLmxlbmd0aCwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icy9wcm9vZnMgbGVuZ3RoIG1pc21hdGNoXCIsIFwiZmllbGRzXCIsIGZpZWxkcyk7XG4gICAgICAgIGJsb2JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzWzFdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBibG9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBmQmxvYnNbaV0sXG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogZkNvbW1pdHNbaV0sXG4gICAgICAgICAgICAgICAgcHJvb2Y6IGZQcm9vZnNbaV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMgPSBmaWVsZHNbMF07XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gMTEgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTQpLCBgaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogJHt0eXBlTmFtZX1gLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDMsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbMl0sIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICAgICAgbWF4RmVlUGVyQmxvYkdhczogaGFuZGxlVWludChmaWVsZHNbOV0sIFwibWF4RmVlUGVyQmxvYkdhc1wiKSxcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlczogZmllbGRzWzEwXVxuICAgIH07XG4gICAgaWYgKGJsb2JzKSB7XG4gICAgICAgIHR4LmJsb2JzID0gYmxvYnM7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KHR4LnRvICE9IG51bGwsIGBpbnZhbGlkIGFkZHJlc3MgZm9yIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHlwZU5hbWV9YCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkodHguYmxvYlZlcnNpb25lZEhhc2hlcyksIFwiaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaGVzOiBtdXN0IGJlIGFuIGFycmF5XCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodHguYmxvYlZlcnNpb25lZEhhc2hlc1tpXSwgMzIpLCBgaW52YWxpZCBibG9iVmVyc2lvbmVkSGFzaCBhdCBpbmRleCAke2l9OiBtdXN0IGJlIGxlbmd0aCAzMmAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICB9XG4gICAgLy8gVW5zaWduZWQgRUlQLTQ4NDQgVHJhbnNhY3Rpb25cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMTEpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvLyBAVE9ETzogRG8gd2UgbmVlZCB0byBkbyB0aGlzPyBUaGlzIGlzIG9ubHkgY2FsbGVkIGludGVybmFsbHlcbiAgICAvLyBhbmQgdXNlZCB0byB2ZXJpZnkgaGFzaGVzOyBpdCBtaWdodCBzYXZlIHRpbWUgdG8gbm90IGRvIHRoaXNcbiAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoY29uY2F0KFsgXCIweDAzXCIsIGVuY29kZVJscChmaWVsZHMpIF0pKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSgxMSkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXA0ODQ0KHR4LCBzaWcsIGJsb2JzKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBaZXJvQWRkcmVzcyksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgdHguZGF0YSxcbiAgICAgICAgZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckJsb2JHYXMgfHwgMCwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpLFxuICAgICAgICBmb3JtYXRIYXNoZXModHguYmxvYlZlcnNpb25lZEhhc2hlcyB8fCBbXSwgXCJibG9iVmVyc2lvbmVkSGFzaGVzXCIpXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJ5UGFyaXR5XCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgICAgICAvLyBXZSBoYXZlIGJsb2JzOyByZXR1cm4gdGhlIG5ldHdvcmsgd3JhcHBlZCBmb3JtYXRcbiAgICAgICAgaWYgKGJsb2JzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgICAgICBcIjB4MDNcIixcbiAgICAgICAgICAgICAgICBlbmNvZGVSbHAoW1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzLm1hcCgoYikgPT4gYi5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgYmxvYnMubWFwKChiKSA9PiBiLmNvbW1pdG1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIucHJvb2YpLFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDNcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDc3MDIoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSAxMCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMyksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogNFwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDQsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbMl0sIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3Q6IGhhbmRsZUF1dGhvcml6YXRpb25MaXN0KGZpZWxkc1s5XSwgXCJhdXRob3JpemF0aW9uTGlzdFwiKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC03NzAyIFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoMTApKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwNzcwMih0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSksXG4gICAgICAgIGZvcm1hdEF1dGhvcml6YXRpb25MaXN0KHR4LmF1dGhvcml6YXRpb25MaXN0IHx8IFtdKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDA0XCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb24qKiBkZXNjcmliZXMgYW4gb3BlcmF0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uXG4gKiAgRXRoZXJldW0gYnkgYW4gRXh0ZXJuYWxseSBPd25lZCBBY2NvdW50IChFT0EpLiBJdCBpbmNsdWRlc1xuICogIHdobyAodGhlIFtbdG9dXSBhZGRyZXNzKSwgd2hhdCAodGhlIFtbZGF0YV1dKSBhbmQgaG93IG11Y2ggKHRoZVxuICogIFtbdmFsdWVdXSBpbiBldGhlcikgdGhlIG9wZXJhdGlvbiBzaG91bGQgZW50YWlsLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHR4ID0gbmV3IFRyYW5zYWN0aW9uKClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICB0eC5kYXRhID0gXCIweDEyMzRcIjtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICAjdHlwZTtcbiAgICAjdG87XG4gICAgI2RhdGE7XG4gICAgI25vbmNlO1xuICAgICNnYXNMaW1pdDtcbiAgICAjZ2FzUHJpY2U7XG4gICAgI21heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICNtYXhGZWVQZXJHYXM7XG4gICAgI3ZhbHVlO1xuICAgICNjaGFpbklkO1xuICAgICNzaWc7XG4gICAgI2FjY2Vzc0xpc3Q7XG4gICAgI21heEZlZVBlckJsb2JHYXM7XG4gICAgI2Jsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgI2t6ZztcbiAgICAjYmxvYnM7XG4gICAgI2F1dGhzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKlxuICAgICAqICBJZiBudWxsLCB0aGUgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgYmFzZWQgb25cbiAgICAgKiAgZXhwbGljaXQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuI3R5cGU7IH1cbiAgICBzZXQgdHlwZSh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIFwibGVnYWN5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiYmVybGluXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTI5MzBcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJsb25kb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMTU1OVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FzZSBcImNhbmN1blwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC00ODQ0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBjYXNlIFwicGVjdHJhXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTc3MDJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcInR5cGVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBcImxlZ2FjeVwiO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gXCJlaXAtMjkzMFwiO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJlaXAtMTU1OVwiO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gXCJlaXAtNDg0NFwiO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gXCJlaXAtNzcwMlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdG9gYCBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb24gb3IgYGBudWxsYGAgaWYgdGhlXG4gICAgICogIHRyYW5zYWN0aW9uIGlzIGFuIGBgaW5pdGBgIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB0bygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN0bztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gWmVyb0FkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgdG8odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jdG8gPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gbm9uY2UuXG4gICAgICovXG4gICAgZ2V0IG5vbmNlKCkgeyByZXR1cm4gdGhpcy4jbm9uY2U7IH1cbiAgICBzZXQgbm9uY2UodmFsdWUpIHsgdGhpcy4jbm9uY2UgPSBnZXROdW1iZXIodmFsdWUsIFwidmFsdWVcIik7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBsaW1pdC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzTGltaXQoKSB7IHJldHVybiB0aGlzLiNnYXNMaW1pdDsgfVxuICAgIHNldCBnYXNMaW1pdCh2YWx1ZSkgeyB0aGlzLiNnYXNMaW1pdCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MgdGhpcyBkZWZpbmVzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIHBhaWQuIE9uXG4gICAgICogIEVJUC0xNTU5IG5ldHdvcmtzLCB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzUHJpY2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZ2FzUHJpY2U7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICh0aGlzLnR5cGUgPT09IDAgfHwgdGhpcy50eXBlID09PSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgZ2FzUHJpY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcImdhc1ByaWNlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAyIHx8IHRoaXMudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gdG90YWwgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbWF4RmVlUGVyR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heEZlZVBlckdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhGZWVQZXJHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEJpZ0ludCh2YWx1ZSwgXCJtYXhGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gZGF0YS4gRm9yIGBgaW5pdGBgIHRyYW5zYWN0aW9ucyB0aGlzIGlzIHRoZVxuICAgICAqICBkZXBsb3ltZW50IGNvZGUuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiB0aGlzLiNkYXRhOyB9XG4gICAgc2V0IGRhdGEodmFsdWUpIHsgdGhpcy4jZGF0YSA9IGhleGxpZnkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhbW91bnQgb2YgZXRoZXIgKGluIHdlaSkgdG8gc2VuZCBpbiB0aGlzIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLiN2YWx1ZTsgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IGdldEJpZ0ludCh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCB0aGlzIHRyYW5zYWN0aW9uIGlzIHZhbGlkIG9uLlxuICAgICAqL1xuICAgIGdldCBjaGFpbklkKCkgeyByZXR1cm4gdGhpcy4jY2hhaW5JZDsgfVxuICAgIHNldCBjaGFpbklkKHZhbHVlKSB7IHRoaXMuI2NoYWluSWQgPSBnZXRCaWdJbnQodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIElmIHNpZ25lZCwgdGhlIHNpZ25hdHVyZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmF0dXJlKCkgeyByZXR1cm4gdGhpcy4jc2lnIHx8IG51bGw7IH1cbiAgICBzZXQgc2lnbmF0dXJlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3NpZyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBTaWduYXR1cmUuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYWNjZXNzIGxpc3QuXG4gICAgICpcbiAgICAgKiAgQW4gYWNjZXNzIGxpc3QgcGVybWl0cyBkaXNjb3VudGVkIChidXQgcHJlLXBhaWQpIGFjY2VzcyB0b1xuICAgICAqICBieXRlY29kZSBhbmQgc3RhdGUgdmFyaWFibGUgYWNjZXNzIHdpdGhpbiBjb250cmFjdCBleGVjdXRpb24uXG4gICAgICovXG4gICAgZ2V0IGFjY2Vzc0xpc3QoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jYWNjZXNzTGlzdCB8fCBudWxsO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMSB8fCB0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IGluIHY3LCB0aGlzIHNob3VsZCBhc3NpZ24gdGhlIHZhbHVlIG9yIGJlY29tZVxuICAgICAgICAgICAgICAgIC8vIGEgbGl2ZSBvYmplY3QgaXRzZWxmLCBvdGhlcndpc2UgbXV0YXRpb24gaXMgaW5jb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGFjY2Vzc0xpc3RpZnkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgYXV0aG9yaXphdGlvbkxpc3QoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jYXV0aHMgfHwgbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaW4gdjcsIHRoaXMgc2hvdWxkIGJlY29tZSBhIGxpdmUgb2JqZWN0IGl0c2VsZixcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgbXV0YXRpb24gaXMgaW5jb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGF1dGhvcml6YXRpb25MaXN0KGF1dGhzKSB7XG4gICAgICAgIHRoaXMuI2F1dGhzID0gKGF1dGhzID09IG51bGwpID8gbnVsbCA6IGF1dGhzLm1hcCgoYSkgPT4gYXV0aG9yaXphdGlvbmlmeShhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4IGZlZSBwZXIgYmxvYiBnYXMgZm9yIENhbmN1biB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IG1heEZlZVBlckJsb2JHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyQmxvYkdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhGZWVQZXJCbG9iR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heEZlZVBlckJsb2JHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQkxPYiB2ZXJzaW9uZWQgaGFzaGVzIGZvciBDYW5jdW4gdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCBibG9iVmVyc2lvbmVkSGFzaGVzKCkge1xuICAgICAgICAvLyBAVE9ETzogTXV0YXRpb24gaXMgaW5jb25zaXN0ZW50OyBpZiB1bnNldCwgdGhlIHJldHVybmVkIHZhbHVlXG4gICAgICAgIC8vIGNhbm5vdCBtdXRhdGUgdGhlIG9iamVjdCwgaWYgc2V0IGl0IGNhblxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBibG9iVmVyc2lvbmVkSGFzaGVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KHZhbHVlKSwgXCJibG9iVmVyc2lvbmVkSGFzaGVzIG11c3QgYmUgYW4gQXJyYXlcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWVbaV0sIDMyKSwgXCJpbnZhbGlkIGJsb2JWZXJzaW9uZWRIYXNoXCIsIGB2YWx1ZVske2l9XWAsIHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQkxPYnMgZm9yIHRoZSBUcmFuc2FjdGlvbiwgaWYgYW55LlxuICAgICAqXG4gICAgICogIElmIGBgYmxvYnNgYCBpcyBub24tYGBudWxsYGAsIHRoZW4gdGhlIFtbc2VyaWFpbGl6ZWRdXVxuICAgICAqICB3aWxsIHJldHVybiB0aGUgbmV0d29yayBmb3JtYXR0ZWQgc2lkZWNhciwgb3RoZXJ3aXNlIGl0XG4gICAgICogIHdpbGwgcmV0dXJuIHRoZSBzdGFuZGFyZCBbW2xpbmstZWlwLTI3MThdXSBwYXlsb2FkLiBUaGVcbiAgICAgKiAgW1t1bnNpZ25lZFNlcmlhbGl6ZWRdXSBpcyB1bmFmZmVjdGVkIHJlZ2FyZGxlc3MuXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGBgYmxvYnNgYCwgZWl0aGVyIGZ1bGx5IHZhbGlkIFtbQmxvYl1dIG9iamVjdHNcbiAgICAgKiAgbWF5IGJlIHNwZWNpZmllZCAoaS5lLiBjb3JyZWN0bHkgcGFkZGVkLCB3aXRoIGNvcnJlY3RcbiAgICAgKiAgY29tbWl0dG1lbnRzIGFuZCBwcm9vZnMpIG9yIGEgcmF3IFtbQnl0ZXNMaWtlXV0gbWF5XG4gICAgICogIGJlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogIElmIHJhdyBbW0J5dGVzTGlrZV1dIGFyZSBwcm92aWRlZCwgdGhlIFtba3pnXV0gcHJvcGVydHkgKiptdXN0KipcbiAgICAgKiAgYmUgYWxyZWFkeSBzZXQuIFRoZSBibG9iIHdpbGwgYmUgY29ycmVjdGx5IHBhZGRlZCBhbmQgdGhlXG4gICAgICogIFtbS3pnTGlicmFyeV1dIHdpbGwgYmUgdXNlZCB0byBjb21wdXRlIHRoZSBjb21taXR0bWVudCBhbmRcbiAgICAgKiAgcHJvb2YgZm9yIHRoZSBibG9iLlxuICAgICAqXG4gICAgICogIEEgQkxPYiBpcyBhIHNlcXVlbmNlIG9mIGZpZWxkIGVsZW1lbnRzLCBlYWNoIG9mIHdoaWNoIG11c3RcbiAgICAgKiAgYmUgd2l0aGluIHRoZSBCTFMgZmllbGQgbW9kdWxvLCBzbyBzb21lIGFkZGl0aW9uYWwgcHJvY2Vzc2luZ1xuICAgICAqICBtYXkgYmUgcmVxdWlyZWQgdG8gZW5jb2RlIGFyYml0cmFyeSBkYXRhIHRvIGVuc3VyZSBlYWNoIDMyIGJ5dGVcbiAgICAgKiAgZmllbGQgaXMgd2l0aGluIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIHRoaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZXMgW1tibG9iVmVyc2lvbmVkSGFzaGVzXV0sXG4gICAgICogIG92ZXJ3cml0aW5nIGFueSBleGlzdGluZyB2YWx1ZXMuIFNldHRpbmcgdGhpcyB0byBgYG51bGxgYFxuICAgICAqICBkb2VzICoqbm90KiogcmVtb3ZlIHRoZSBbW2Jsb2JWZXJzaW9uZWRIYXNoZXNdXSwgbGVhdmluZyB0aGVtXG4gICAgICogIHByZXNlbnQuXG4gICAgICovXG4gICAgZ2V0IGJsb2JzKCkge1xuICAgICAgICBpZiAodGhpcy4jYmxvYnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jsb2JzLm1hcCgoYikgPT4gT2JqZWN0LmFzc2lnbih7fSwgYikpO1xuICAgIH1cbiAgICBzZXQgYmxvYnMoX2Jsb2JzKSB7XG4gICAgICAgIGlmIChfYmxvYnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvYnMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2JzID0gW107XG4gICAgICAgIGNvbnN0IHZlcnNpb25lZEhhc2hlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9ibG9icy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IF9ibG9ic1tpXTtcbiAgICAgICAgICAgIGlmIChpc0J5dGVzTGlrZShibG9iKSkge1xuICAgICAgICAgICAgICAgIGFzc2VydCh0aGlzLiNremcsIFwiYWRkaW5nIGEgcmF3IGJsb2IgcmVxdWlyZXMgYSBLWkcgbGlicmFyeVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXQgYmxvYnMoKVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBnZXRCeXRlcyhibG9iKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhLmxlbmd0aCA8PSBCTE9CX1NJWkUsIFwiYmxvYiBpcyB0b28gbGFyZ2VcIiwgYGJsb2JzWyR7aX1dYCwgYmxvYik7XG4gICAgICAgICAgICAgICAgLy8gUGFkIGJsb2IgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBCTE9CX1NJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoQkxPQl9TSVpFKTtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGVkLnNldChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBhZGRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWl0ID0gdGhpcy4ja3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvb2YgPSBoZXhsaWZ5KHRoaXMuI2t6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKGRhdGEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgICAgIGJsb2JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhsaWZ5KGRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBoZXhsaWZ5KGNvbW1pdCksXG4gICAgICAgICAgICAgICAgICAgIHByb29mXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzLnB1c2goZ2V0VmVyc2lvbmVkSGFzaCgxLCBjb21taXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1pdCA9IGhleGxpZnkoYmxvYi5jb21taXRtZW50KTtcbiAgICAgICAgICAgICAgICBibG9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4bGlmeShibG9iLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBjb21taXQsXG4gICAgICAgICAgICAgICAgICAgIHByb29mOiBoZXhsaWZ5KGJsb2IucHJvb2YpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzLnB1c2goZ2V0VmVyc2lvbmVkSGFzaCgxLCBjb21taXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNibG9icyA9IGJsb2JzO1xuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gdmVyc2lvbmVkSGFzaGVzO1xuICAgIH1cbiAgICBnZXQga3pnKCkgeyByZXR1cm4gdGhpcy4ja3pnOyB9XG4gICAgc2V0IGt6ZyhremcpIHtcbiAgICAgICAgaWYgKGt6ZyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNremcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4ja3pnID0gZ2V0S3pnTGlicmFyeShremcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFRyYW5zYWN0aW9uIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLiN0byA9IG51bGw7XG4gICAgICAgIHRoaXMuI25vbmNlID0gMDtcbiAgICAgICAgdGhpcy4jZ2FzTGltaXQgPSBCTl8wO1xuICAgICAgICB0aGlzLiNnYXNQcmljZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGF0YSA9IFwiMHhcIjtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBCTl8wO1xuICAgICAgICB0aGlzLiNjaGFpbklkID0gQk5fMDtcbiAgICAgICAgdGhpcy4jc2lnID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYWNjZXNzTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckJsb2JHYXMgPSBudWxsO1xuICAgICAgICB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy4ja3pnID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYmxvYnMgPSBudWxsO1xuICAgICAgICB0aGlzLiNhdXRocyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaCwgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBoYXNoKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLiNnZXRTZXJpYWxpemVkKHRydWUsIGZhbHNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJlLWltYWdlIGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBkaWdlc3QgdGhhdCBhIFtbU2lnbmVyXV0gbXVzdCBzaWduIHRvIGF1dGhvcml6ZVxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB1bnNpZ25lZEhhc2goKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy51bnNpZ25lZFNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRpbmcgYWRkcmVzcywgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBmcm9tKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb21QdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgc2lnbmVkLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgcHJvcGVydGllcyByZXF1aXJpbmcgYSBzaWduZWRcbiAgICAgKiAgdHJhbnNhY3Rpb24gYXJlIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzU2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmUgIT0gbnVsbDtcbiAgICB9XG4gICAgI2dldFNlcmlhbGl6ZWQoc2lnbmVkLCBzaWRlY2FyKSB7XG4gICAgICAgIGFzc2VydCghc2lnbmVkIHx8IHRoaXMuc2lnbmF0dXJlICE9IG51bGwsIFwiY2Fubm90IHNlcmlhbGl6ZSB1bnNpZ25lZCB0cmFuc2FjdGlvbjsgbWF5YmUgeW91IG1lYW50IC51bnNpZ25lZFNlcmlhbGl6ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2lnbmVkID8gdGhpcy5zaWduYXR1cmUgOiBudWxsO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0aGlzLCBzaWcpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwNDg0NCh0aGlzLCBzaWcsIHNpZGVjYXIgPyB0aGlzLmJsb2JzIDogbnVsbCk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXA3NzAyKHRoaXMsIHNpZyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgdGhyb3dzIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyB1bnNpZ25lZC4gRm9yIHRoZSBwcmUtaW1hZ2UsXG4gICAgICogIHVzZSBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0U2VyaWFsaXplZCh0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UuXG4gICAgICpcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhpcyBpcyB0aGUgZGlnZXN0IHdoaWNoIG5lZWRzIHRvIGJlIHNpZ25lZCB0b1xuICAgICAqICBhdXRob3JpemUgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgdW5zaWduZWRTZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0U2VyaWFsaXplZChmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBtb3N0IFwibGlrZWx5XCIgdHlwZTsgY3VycmVudGx5IHRoZSBoaWdoZXN0XG4gICAgICogIHN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIGluZmVyVHlwZSgpIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB0aGlzLmluZmVyVHlwZXMoKTtcbiAgICAgICAgLy8gUHJlZmVyIExvbmRvbiAoRUlQLTE1NTkpIG92ZXIgQ2FuY3VuIChCTE9iKVxuICAgICAgICBpZiAodHlwZXMuaW5kZXhPZigyKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIGhpZ2hlc3QgaW5mZXJyZWQgdHlwZVxuICAgICAgICByZXR1cm4gKHR5cGVzLnBvcCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFZhbGlkYXRlcyB0aGUgZXhwbGljaXQgcHJvcGVydGllcyBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgY29tcGF0aWJsZVxuICAgICAqICB0cmFuc2FjdGlvbiB0eXBlcy5cbiAgICAgKi9cbiAgICBpbmZlclR5cGVzKCkge1xuICAgICAgICAvLyBDaGVja3MgdGhhdCB0aGVyZSBhcmUgbm8gY29uZmxpY3RpbmcgcHJvcGVydGllcyBzZXRcbiAgICAgICAgY29uc3QgaGFzR2FzUHJpY2UgPSB0aGlzLmdhc1ByaWNlICE9IG51bGw7XG4gICAgICAgIGNvbnN0IGhhc0ZlZSA9ICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IGhhc0FjY2Vzc0xpc3QgPSAodGhpcy5hY2Nlc3NMaXN0ICE9IG51bGwpO1xuICAgICAgICBjb25zdCBoYXNCbG9iID0gKHRoaXMuI21heEZlZVBlckJsb2JHYXMgIT0gbnVsbCB8fCB0aGlzLiNibG9iVmVyc2lvbmVkSGFzaGVzKTtcbiAgICAgICAgLy9pZiAoaGFzR2FzUHJpY2UgJiYgaGFzRmVlKSB7XG4gICAgICAgIC8vICAgIHRocm93IG5ldyBFcnJvcihcInRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGdhc1ByaWNlIGFuZCBtYXhGZWVQZXJHYXNcIik7XG4gICAgICAgIC8vfVxuICAgICAgICBpZiAodGhpcy5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLm1heEZlZVBlckdhcyA+PSB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzLCBcInByaW9yaXR5RmVlIGNhbm5vdCBiZSBtb3JlIHRoYW4gbWF4RmVlXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL2lmICh0aGlzLnR5cGUgPT09IDIgJiYgaGFzR2FzUHJpY2UpIHtcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgZ2FzUHJpY2VcIik7XG4gICAgICAgIC8vfVxuICAgICAgICBhc3NlcnQoIWhhc0ZlZSB8fCAodGhpcy50eXBlICE9PSAwICYmIHRoaXMudHlwZSAhPT0gMSksIFwidHJhbnNhY3Rpb24gdHlwZSBjYW5ub3QgaGF2ZSBtYXhGZWVQZXJHYXMgb3IgbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICBhc3NlcnQodGhpcy50eXBlICE9PSAwIHx8ICFoYXNBY2Nlc3NMaXN0LCBcImxlZ2FjeSB0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBhY2Nlc3NMaXN0XCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgLy8gRXhwbGljaXQgdHlwZVxuICAgICAgICBpZiAodGhpcy50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR5cGVzLnB1c2godGhpcy50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dGhvcml6YXRpb25MaXN0ICYmIHRoaXMuYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCg0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0ZlZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNHYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0Jsb2IgJiYgdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDApO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHR5cGVzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYSBsZWdhY3kgdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGJlcmxpbiBoYXJkZm9ybSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDFgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0JlcmxpbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgbG9uZG9uIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMmBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhbiBbW2xpbmstZWlwLTQ4NDRdXSBCTE9CXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNDYW5jdW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyB0cmFuc2FjaXRvbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20odGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBKU09OLWZyaWVuZGx5IG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHMgPSAodikgPT4ge1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBzKHRoaXMuZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHModGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcyh0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogcyh0aGlzLm1heEZlZVBlckdhcyksXG4gICAgICAgICAgICB2YWx1ZTogcyh0aGlzLnZhbHVlKSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHModGhpcy5jaGFpbklkKSxcbiAgICAgICAgICAgIHNpZzogdGhpcy5zaWduYXR1cmUgPyB0aGlzLnNpZ25hdHVyZS50b0pTT04oKSA6IG51bGwsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiB0aGlzLmFjY2Vzc0xpc3RcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhICoqVHJhbnNhY3Rpb24qKiBmcm9tIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvciBhXG4gICAgICogIFRyYW5zYWN0aW9uLWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR4KSB7XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZ2V0Qnl0ZXModHgpO1xuICAgICAgICAgICAgaWYgKHBheWxvYWRbMF0gPj0gMHg3ZikgeyAvLyBAVE9ETzogPiB2cyA+PSA/P1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUxlZ2FjeShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDI5MzAocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMTU1OShwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXA0ODQ0KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDc3MDIocGF5bG9hZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZnJvbVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAodHgudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IHR4LnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50byA9IHR4LnRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ub25jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubm9uY2UgPSB0eC5ub25jZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzTGltaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc0xpbWl0ID0gdHguZ2FzTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eC5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhGZWVQZXJHYXMgPSB0eC5tYXhGZWVQZXJHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heEZlZVBlckJsb2JHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckJsb2JHYXMgPSB0eC5tYXhGZWVQZXJCbG9iR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gdHguZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gdHgudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5zaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHR4LnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSB0eC5hY2Nlc3NMaXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hdXRob3JpemF0aW9uTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYXV0aG9yaXphdGlvbkxpc3QgPSB0eC5hdXRob3JpemF0aW9uTGlzdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHdpbGwgZ2V0IG92ZXJ3cml0dGVuIGJ5IGJsb2JzLCBpZiBwcmVzZW50XG4gICAgICAgIGlmICh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXNzaWduIHRoZSBremcgYmVmb3JlIGFzc2lnbmluZyBibG9icywgd2hpY2hcbiAgICAgICAgLy8gcmVxdWlyZSB0aGUgbGlicmFyeSBpbiB0aGUgZXZlbnQgcmF3IGJsb2IgZGF0YSBpcyBwcm92aWRlZC5cbiAgICAgICAgaWYgKHR4Lmt6ZyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQua3pnID0gdHgua3pnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ibG9icyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvYnMgPSB0eC5ibG9icztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguaGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lICcuaGFzaCdcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaGFzaCA9PT0gdHguaGFzaCwgXCJoYXNoIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgJy5mcm9tJ1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5mcm9tLnRvTG93ZXJDYXNlKCkgPT09ICh0eC5mcm9tIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/transaction/transaction.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/base58.js":
/*!*************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/base58.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase58: function() { return /* binding */ decodeBase58; },\n/* harmony export */   encodeBase58: function() { return /* binding */ encodeBase58; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"../common/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"../common/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maths.js */ \"../common/node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */\n\n\n\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n    if (Lookup == null) {\n        Lookup = {};\n        for (let i = 0; i < Alphabet.length; i++) {\n            Lookup[Alphabet[i]] = BigInt(i);\n        }\n    }\n    const result = Lookup[letter];\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\n    return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */\nfunction encodeBase58(_value) {\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_value);\n    let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt)(bytes);\n    let result = \"\";\n    while (value) {\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n    // Account for leading padding zeros\n    for (let i = 0; i < bytes.length; i++) {\n        if (bytes[i]) {\n            break;\n        }\n        result = Alphabet[0] + result;\n    }\n    return result;\n}\n/**\n *  Decode the Base58-encoded %%value%%.\n */\nfunction decodeBase58(value) {\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n}\n//# sourceMappingURL=base58.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNRO0FBQ1A7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQkFBa0Isa0RBQVE7QUFDMUIsZ0JBQWdCLG1EQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzP2U1ODkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIFtCYXNlNTggRW5jb2RpbmddKGxpbmstYmFzZTU4KSBzY2hlbWUgYWxsb3dzIGEgKipudW1lcmljKiogdmFsdWVcbiAqICB0byBiZSBlbmNvZGVkIGFzIGEgY29tcGFjdCBzdHJpbmcgdXNpbmcgYSByYWRpeCBvZiA1OCB1c2luZyBvbmx5XG4gKiAgYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLiBDb25mdXNpbmdseSBzaW1pbGFyIGNoYXJhY3RlcnMgYXJlIG9taXR0ZWRcbiAqICAoaS5lLiBgYFwibDBPXCJgYCkuXG4gKlxuICogIE5vdGUgdGhhdCBCYXNlNTggZW5jb2RlcyBhICoqbnVtZXJpYyoqIHZhbHVlLCBub3QgYXJiaXRyYXJ5IGJ5dGVzLFxuICogIHNpbmNlIGFueSB6ZXJvLWJ5dGVzIG9uIHRoZSBsZWZ0IHdvdWxkIGdldCByZW1vdmVkLiBUbyBtaXRpZ2F0ZSB0aGlzXG4gKiAgaXNzdWUgbW9zdCBzY2hlbWVzIHRoYXQgdXNlIEJhc2U1OCBjaG9vc2Ugc3BlY2lmaWMgaGlnaC1vcmRlciB2YWx1ZXNcbiAqICB0byBlbnN1cmUgbm9uLXplcm8gcHJlZml4ZXMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOkJhc2U1OCBFbmNvZGluZyBbYWJvdXQtYmFzZTU4XVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyB0b0JpZ0ludCB9IGZyb20gXCIuL21hdGhzLmpzXCI7XG5jb25zdCBBbHBoYWJldCA9IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO1xubGV0IExvb2t1cCA9IG51bGw7XG5mdW5jdGlvbiBnZXRBbHBoYShsZXR0ZXIpIHtcbiAgICBpZiAoTG9va3VwID09IG51bGwpIHtcbiAgICAgICAgTG9va3VwID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIExvb2t1cFtBbHBoYWJldFtpXV0gPSBCaWdJbnQoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gTG9va3VwW2xldHRlcl07XG4gICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0ICE9IG51bGwsIGBpbnZhbGlkIGJhc2U1OCB2YWx1ZWAsIFwibGV0dGVyXCIsIGxldHRlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl81OCA9IEJpZ0ludCg1OCk7XG4vKipcbiAqICBFbmNvZGUgJSV2YWx1ZSUlIGFzIGEgQmFzZTU4LWVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTU4KF92YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoX3ZhbHVlKTtcbiAgICBsZXQgdmFsdWUgPSB0b0JpZ0ludChieXRlcyk7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdCA9IEFscGhhYmV0W051bWJlcih2YWx1ZSAlIEJOXzU4KV0gKyByZXN1bHQ7XG4gICAgICAgIHZhbHVlIC89IEJOXzU4O1xuICAgIH1cbiAgICAvLyBBY2NvdW50IGZvciBsZWFkaW5nIHBhZGRpbmcgemVyb3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChieXRlc1tpXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gQWxwaGFiZXRbMF0gKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBEZWNvZGUgdGhlIEJhc2U1OC1lbmNvZGVkICUldmFsdWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJhc2U1OCh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICo9IEJOXzU4O1xuICAgICAgICByZXN1bHQgKz0gZ2V0QWxwaGEodmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTU4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/base58.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/base64-browser.js":
/*!*********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/base64-browser.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase64: function() { return /* binding */ decodeBase64; },\n/* harmony export */   encodeBase64: function() { return /* binding */ encodeBase64; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"../common/node_modules/ethers/lib.esm/utils/data.js\");\n// utils/base64-browser\n\nfunction decodeBase64(textData) {\n    textData = atob(textData);\n    const data = new Uint8Array(textData.length);\n    for (let i = 0; i < textData.length; i++) {\n        data[i] = textData.charCodeAt(i);\n    }\n    return (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n}\nfunction encodeBase64(_data) {\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n//# sourceMappingURL=base64-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNjQtYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNxQztBQUM5QjtBQUNQO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXLGtEQUFRO0FBQ25CO0FBQ087QUFDUCxpQkFBaUIsa0RBQVE7QUFDekI7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTY0LWJyb3dzZXIuanM/NTk5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1dGlscy9iYXNlNjQtYnJvd3NlclxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0KHRleHREYXRhKSB7XG4gICAgdGV4dERhdGEgPSBhdG9iKHRleHREYXRhKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dERhdGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSB0ZXh0RGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTY0KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhKTtcbiAgICBsZXQgdGV4dERhdGEgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZXh0RGF0YSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQtYnJvd3Nlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/base64-browser.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/data.js":
/*!***********************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/data.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: function() { return /* binding */ concat; },\n/* harmony export */   dataLength: function() { return /* binding */ dataLength; },\n/* harmony export */   dataSlice: function() { return /* binding */ dataSlice; },\n/* harmony export */   getBytes: function() { return /* binding */ getBytes; },\n/* harmony export */   getBytesCopy: function() { return /* binding */ getBytesCopy; },\n/* harmony export */   hexlify: function() { return /* binding */ hexlify; },\n/* harmony export */   isBytesLike: function() { return /* binding */ isBytesLike; },\n/* harmony export */   isHexString: function() { return /* binding */ isHexString; },\n/* harmony export */   stripZerosLeft: function() { return /* binding */ stripZerosLeft; },\n/* harmony export */   zeroPadBytes: function() { return /* binding */ zeroPadBytes; },\n/* harmony export */   zeroPadValue: function() { return /* binding */ zeroPadValue; }\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"../common/node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\n\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof (value) === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nfunction getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nfunction getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && (value.length % 2) !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nfunction isBytesLike(value) {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nfunction hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nfunction concat(datas) {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nfunction dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nfunction dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nfunction stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) {\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    }\n    else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nfunction zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nfunction zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\n//# sourceMappingURL=data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcz9iMmQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFNvbWUgZGF0YSBoZWxwZXJzLlxuICpcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpEYXRhIEhlbHBlcnMgIFthYm91dC1kYXRhXVxuICovXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5mdW5jdGlvbiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGNvcHkpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1hdGNoKC9eMHgoPzpbMC05YS1mXVswLTlhLWZdKSokL2kpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEJ5dGVzTGlrZSB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLyoqXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLiBJZiBhbHJlYWR5IGEgVWludDhBcnJheVxuICogIHRoZSBvcmlnaW5hbCAlJXZhbHVlJSUgaXMgcmV0dXJuZWQ7IGlmIGEgY29weSBpcyByZXF1aXJlZCB1c2VcbiAqICBbW2dldEJ5dGVzQ29weV1dLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc0NvcHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVzKHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgZmFsc2UpO1xufVxuLyoqXG4gKiAgR2V0IGEgdHlwZWQgVWludDhBcnJheSBmb3IgJSV2YWx1ZSUlLCBjcmVhdGluZyBhIGNvcHkgaWYgbmVjZXNzYXJ5XG4gKiAgdG8gcHJldmVudCBhbnkgbW9kaWZpY2F0aW9ucyBvZiB0aGUgcmV0dXJuZWQgdmFsdWUgZnJvbSBiZWluZ1xuICogIHJlZmxlY3RlZCBlbHNld2hlcmUuXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlc0NvcHkodmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0hleFN0cmluZ11dLlxuICpcbiAqICBJZiAlJWxlbmd0aCUlIGlzIGBgdHJ1ZWBgIG9yIGEgLy9udW1iZXIvLywgaXQgYWxzbyBjaGVja3MgdGhhdFxuICogICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9mICUlbGVuZ3RoJSUgKGlmIGEgLy9udW1iZXIvLylcbiAqICBieXRlcyBvZiBkYXRhIChlLmcuIGBgMHgxMjM0YGAgaXMgMiBieXRlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobGVuZ3RoKSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA9PT0gdHJ1ZSAmJiAodmFsdWUubGVuZ3RoICUgMikgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhcmJpdHJhcnlcbiAqICBkYXRhIChpLmUuIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb3IgYSBVaW50OEFycmF5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSkgfHwgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpO1xufVxuY29uc3QgSGV4Q2hhcmFjdGVycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIHJlcHJlc2VudGF0aW9uIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4bGlmeShkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IGJ5dGVzW2ldO1xuICAgICAgICByZXN1bHQgKz0gSGV4Q2hhcmFjdGVyc1sodiAmIDB4ZjApID4+IDRdICsgSGV4Q2hhcmFjdGVyc1t2ICYgMHgwZl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgY29uY2F0ZW5hdGluZyBhbGwgdmFsdWVzXG4gKiAgd2l0aGluICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGRhdGFzKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIGRhdGFzLm1hcCgoZCkgPT4gaGV4bGlmeShkKS5zdWJzdHJpbmcoMikpLmpvaW4oXCJcIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUsIGluIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEsIHRydWUpKSB7XG4gICAgICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlcyhkYXRhKS5sZW5ndGg7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgc2xpY2luZyAlJWRhdGElJSBmcm9tIHRoZSAlJXN0YXJ0JSVcbiAqICBvZmZzZXQgdG8gdGhlICUlZW5kJSUgb2Zmc2V0LlxuICpcbiAqICBCeSBkZWZhdWx0ICUlc3RhcnQlJSBpcyAwIGFuZCAlJWVuZCUlIGlzIHRoZSBsZW5ndGggb2YgJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhU2xpY2UoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgaWYgKGVuZCAhPSBudWxsICYmIGVuZCA+IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHNsaWNlIGJleW9uZCBkYXRhIGJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogYnl0ZXMsIGxlbmd0aDogYnl0ZXMubGVuZ3RoLCBvZmZzZXQ6IGVuZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMuc2xpY2UoKHN0YXJ0ID09IG51bGwpID8gMCA6IHN0YXJ0LCAoZW5kID09IG51bGwpID8gYnl0ZXMubGVuZ3RoIDogZW5kKSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIHJlc3VsdCBieSBzdHJpcHBpbmcgYWxsICoqbGVhZGluZyoqXG4gKiogemVybyBieXRlcyBmcm9tICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBaZXJvc0xlZnQoZGF0YSkge1xuICAgIGxldCBieXRlcyA9IGhleGxpZnkoZGF0YSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChieXRlcy5zdGFydHNXaXRoKFwiMDBcIikpIHtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBieXRlcztcbn1cbmZ1bmN0aW9uIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBsZWZ0KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBhc3NlcnQobGVuZ3RoID49IGJ5dGVzLmxlbmd0aCwgXCJwYWRkaW5nIGV4Y2VlZHMgZGF0YSBsZW5ndGhcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgb2Zmc2V0OiBsZW5ndGggKyAxXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICByZXN1bHQuZmlsbCgwKTtcbiAgICBpZiAobGVmdCkge1xuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCBsZW5ndGggLSBieXRlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgMCk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipsZWZ0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKnZhbHVlcyoqIGFyZSBpbiBTb2xpZGl0eVxuICogIChlLmcuIGBgdWludDEyOGBgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWRWYWx1ZShkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIHRydWUpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqcmlnaHQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqYnl0ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYGJ5dGVzMTZgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkQnl0ZXMoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBmYWxzZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/data.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/errors.js":
/*!*************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/errors.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   assertArgument: function() { return /* binding */ assertArgument; },\n/* harmony export */   assertArgumentCount: function() { return /* binding */ assertArgumentCount; },\n/* harmony export */   assertNormalize: function() { return /* binding */ assertNormalize; },\n/* harmony export */   assertPrivate: function() { return /* binding */ assertPrivate; },\n/* harmony export */   isCallException: function() { return /* binding */ isCallException; },\n/* harmony export */   isError: function() { return /* binding */ isError; },\n/* harmony export */   makeError: function() { return /* binding */ makeError; }\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"../common/node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"../common/node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\n\n\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n        }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nfunction isError(error, code) {\n    return (error && error.code === code);\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nfunction isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nfunction makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = (info[key]);\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n                //                } catch (error: any) {\n                //                console.log(\"MMM\", error.message);\n                //                    details.push(key + \"=[could not serialize object]\");\n                //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, { code });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, { shortMessage });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nfunction assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nfunction assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */\n            if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n            /* c8 ignore stop */\n        }\n        accum.push(form);\n    }\n    catch (error) { }\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nfunction assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nfunction assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5QztBQUNVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCLGFBQWEsSUFBSSxvQkFBb0IsbUJBQW1CO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGdCQUFnQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSztBQUNsQyxnQ0FBZ0MsZ0RBQU8sQ0FBQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQWdCLFVBQVUsTUFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0VBQWdCLFVBQVUsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlEQUFpRCw4QkFBOEI7QUFDL0U7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EseURBQXlEO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU0sT0FBTztBQUN6RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzP2UxYmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQWxsIGVycm9ycyBpbiBldGhlcnMgaW5jbHVkZSBwcm9wZXJ0aWVzIHRvIGVuc3VyZSB0aGV5IGFyZSBib3RoXG4gKiAgaHVtYW4tcmVhZGFibGUgKGkuZS4gYGAubWVzc2FnZWBgKSBhbmQgbWFjaGluZS1yZWFkYWJsZSAoaS5lLiBgYC5jb2RlYGApLlxuICpcbiAqICBUaGUgW1tpc0Vycm9yXV0gZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhlIGVycm9yIGBgY29kZWBgIGFuZFxuICogIHByb3ZpZGUgYSB0eXBlIGd1YXJkIGZvciB0aGUgcHJvcGVydGllcyBwcmVzZW50IG9uIHRoYXQgZXJyb3IgaW50ZXJmYWNlLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9lcnJvcnM6RXJyb3JzICBbYWJvdXQtZXJyb3JzXVxuICovXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiWyBcIiArICh2YWx1ZS5tYXAoc3RyaW5naWZ5KSkuam9pbihcIiwgXCIpICsgXCIgXVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSAmIDB4Zl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAodmFsdWUudG9KU09OKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUudG9KU09OKCkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBcInsgXCIgKyBrZXlzLm1hcCgoaykgPT4gYCR7c3RyaW5naWZ5KGspfTogJHtzdHJpbmdpZnkodmFsdWVba10pfWApLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYFsgQ09VTEQgTk9UIFNFUklBTElaRSBdYDtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgJSVlcnJvciUlIG1hdGNoZXMgYW4gZXJyb3IgdGhyb3duIGJ5IGV0aGVyc1xuICogIHRoYXQgbWF0Y2hlcyB0aGUgZXJyb3IgJSVjb2RlJSUuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoYXQgJSVlcnJvciUlXG4gKiAgbWF0Y2hlcyBhbiBFdGhlcnNFcnJvciB0eXBlLCB3aGljaCBtZWFucyB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcyB3aWxsXG4gKiAgYmUgc2V0LlxuICpcbiAqICBAU2VlIFtFcnJvckNvZGVzXShhcGk6RXJyb3JDb2RlKVxuICogIEBleGFtcGxlXG4gKiAgICB0cnkge1xuICogICAgICAvLyBjb2RlLi4uLlxuICogICAgfSBjYXRjaCAoZSkge1xuICogICAgICBpZiAoaXNFcnJvcihlLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gKiAgICAgICAgICAvLyBUaGUgVHlwZSBHdWFyZCBoYXMgdmFsaWRhdGVkIHRoaXMgb2JqZWN0XG4gKiAgICAgICAgICBjb25zb2xlLmxvZyhlLmRhdGEpO1xuICogICAgICB9XG4gKiAgICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKGVycm9yLCBjb2RlKSB7XG4gICAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBjb2RlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWVycm9yJSUgaXMgYSBbW0NhbGxFeGNlcHRpb25FcnJvcl0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBuZXcgRXJyb3IgY29uZmlndXJlZCB0byB0aGUgZm9ybWF0IGV0aGVycyBlbWl0cyBlcnJvcnMsIHdpdGhcbiAqICB0aGUgJSVtZXNzYWdlJSUsIFtbYXBpOkVycm9yQ29kZV1dICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqICBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgRXRoZXJzRXJyb3IuXG4gKlxuICogIEVhY2ggZXJyb3IgaW4gZXRoZXJzIGluY2x1ZGVzIHRoZSB2ZXJzaW9uIG9mIGV0aGVycywgYVxuICogIG1hY2hpbmUtcmVhZGFibGUgW1tFcnJvckNvZGVdXSwgYW5kIGRlcGVuZGluZyBvbiAlJWNvZGUlJSwgYWRkaXRpb25hbFxuICogIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYWxzbyBpbmNsdWRlIHRoZSAlJW1lc3NhZ2UlJSxcbiAqICBldGhlcnMgdmVyc2lvbiwgJSVjb2RlJSUgYW5kIGFsbCBhZGRpdGlvbmFsIHByb3BlcnRpZXMsIHNlcmlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGxldCBzaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IFtdO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKFwibWVzc2FnZVwiIGluIGluZm8gfHwgXCJjb2RlXCIgaW4gaW5mbyB8fCBcIm5hbWVcIiBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSB3aWxsIG92ZXJ3cml0ZSBwb3B1bGF0ZWQgdmFsdWVzOiAke3N0cmluZ2lmeShpbmZvKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcInNob3J0TWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChpbmZvW2tleV0pO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTU1NXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9W2NvdWxkIG5vdCBzZXJpYWxpemUgb2JqZWN0XVwiKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgZGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7dmVyc2lvbn1gKTtcbiAgICAgICAgaWYgKGRldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIGRldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVycm9yO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFwiSU5WQUxJRF9BUkdVTUVOVFwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOVU1FUklDX0ZBVUxUXCI6XG4gICAgICAgIGNhc2UgXCJCVUZGRVJfT1ZFUlJVTlwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgUmFuZ2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgY29kZSB9KTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVycm9yLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLnNob3J0TWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgc2hvcnRNZXNzYWdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqICBUaHJvd3MgYW4gRXRoZXJzRXJyb3Igd2l0aCAlJW1lc3NhZ2UlJSwgJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgZXJyb3JcbiAqICAlJWluZm8lJSB3aGVuICUlY2hlY2slJSBpcyBmYWxzaXNoLi5cbiAqXG4gKiAgQHNlZSBbW2FwaTptYWtlRXJyb3JdXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgICB0aHJvdyBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbyk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBzaW1wbGUgaGVscGVyIHRvIHNpbXBseSBlbnN1cmluZyBwcm92aWRlZCBhcmd1bWVudHMgbWF0Y2ggZXhwZWN0ZWRcbiAqICBjb25zdHJhaW50cywgdGhyb3dpbmcgaWYgbm90LlxuICpcbiAqICBJbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cywgdGhlICUlY2hlY2slJSBoYXMgYmVlbiBhc3NlcnRlZCB0cnVlLCBzb1xuICogIGFueSBmdXJ0aGVyIGNvZGUgZG9lcyBub3QgbmVlZCBhZGRpdGlvbmFsIGNvbXBpbGUtdGltZSBjaGVja3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgIH1cbiAgICBhc3NlcnQoY291bnQgPj0gZXhwZWN0ZWRDb3VudCwgXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBcIk1JU1NJTkdfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbiAgICBhc3NlcnQoY291bnQgPD0gZXhwZWN0ZWRDb3VudCwgXCJ0b28gbWFueSBhcmd1bWVudHNcIiArIG1lc3NhZ2UsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xufVxuY29uc3QgX25vcm1hbGl6ZUZvcm1zID0gW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0ucmVkdWNlKChhY2N1bSwgZm9ybSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEdlbmVyYWwgdGVzdCBmb3Igbm9ybWFsaXplXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKGZvcm0gPT09IFwiTkZEXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIik7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIH1cbiAgICAgICAgYWNjdW0ucHVzaChmb3JtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gYWNjdW07XG59LCBbXSk7XG4vKipcbiAqICBUaHJvd3MgaWYgdGhlIG5vcm1hbGl6YXRpb24gJSVmb3JtJSUgaXMgbm90IHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5vcm1hbGl6ZShmb3JtKSB7XG4gICAgYXNzZXJ0KF9ub3JtYWxpemVGb3Jtcy5pbmRleE9mKGZvcm0pID49IDAsIFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBpbmZvOiB7IGZvcm0gfVxuICAgIH0pO1xufVxuLyoqXG4gKiAgTWFueSBjbGFzc2VzIHVzZSBmaWxlLXNjb3BlZCB2YWx1ZXMgdG8gZ3VhcmQgdGhlIGNvbnN0cnVjdG9yLFxuICogIG1ha2luZyBpdCBlZmZlY3RpdmVseSBwcml2YXRlLiBUaGlzIGZhY2lsaXRhdGVzIHRoYXQgcGF0dGVyblxuICogIGJ5IGVuc3VyaW5nIHRoZSAlJWdpdmVuR2F1cmQlJSBtYXRjaGVzIHRoZSBmaWxlLXNjb3BlZCAlJWd1YXJkJSUsXG4gKiAgdGhyb3dpbmcgaWYgbm90LCBpbmRpY2F0aW5nIHRoZSAlJWNsYXNzTmFtZSUlIGlmIHByb3ZpZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZShnaXZlbkd1YXJkLCBndWFyZCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChnaXZlbkd1YXJkICE9PSBndWFyZCkge1xuICAgICAgICBsZXQgbWV0aG9kID0gY2xhc3NOYW1lLCBvcGVyYXRpb24gPSBcIm5ld1wiO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gXCIuXCI7XG4gICAgICAgICAgICBvcGVyYXRpb24gKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgcHJpdmF0ZSBjb25zdHJ1Y3RvcjsgdXNlICR7bWV0aG9kfWZyb20qIG1ldGhvZHNgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/errors.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/events.js":
/*!*************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/events.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: function() { return /* binding */ EventPayload; }\n/* harmony export */ });\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./properties.js */ \"../common/node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */\n\n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */\nclass EventPayload {\n    /**\n     *  The event filter.\n     */\n    filter;\n    /**\n     *  The **EventEmitterable**.\n     */\n    emitter;\n    #listener;\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */\n    constructor(emitter, listener, filter) {\n        this.#listener = listener;\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { emitter, filter });\n    }\n    /**\n     *  Unregister the triggered listener for future events.\n     */\n    async removeListener() {\n        if (this.#listener == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n}\n//# sourceMappingURL=events.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ldmVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFnQixTQUFTLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzPzAzYjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRXZlbnRzIGFsbG93IGZvciBhcHBsaWNhdGlvbnMgdG8gdXNlIHRoZSBvYnNlcnZlciBwYXR0ZXJuLCB3aGljaFxuICogIGFsbG93cyBzdWJzY3JpYmluZyBhbmQgcHVibGlzaGluZyBldmVudHMsIG91dHNpZGUgdGhlIG5vcm1hbFxuICogIGV4ZWN1dGlvbiBwYXRocy5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9ldmVudHM6RXZlbnRzICBbYWJvdXQtZXZlbnRzXVxuICovXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuLyoqXG4gKiAgV2hlbiBhbiBbW0V2ZW50RW1pdHRlcmFibGVdXSB0cmlnZ2VycyBhIFtbTGlzdGVuZXJdXSwgdGhlXG4gKiAgY2FsbGJhY2sgYWx3YXlzIGFoYXMgb25lIGFkZGl0aW9uYWwgYXJndW1lbnQgcGFzc2VkLCB3aGljaCBpc1xuICogIGFuICoqRXZlbnRQYXlsb2FkKiouXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgZmlsdGVyLlxuICAgICAqL1xuICAgIGZpbHRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlICoqRXZlbnRFbWl0dGVyYWJsZSoqLlxuICAgICAqL1xuICAgIGVtaXR0ZXI7XG4gICAgI2xpc3RlbmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipFdmVudFBheWxvYWQqKiBmb3IgJSVlbWl0dGVyJSUgd2l0aFxuICAgICAqICB0aGUgJSVsaXN0ZW5lciUlIGFuZCBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyLCBsaXN0ZW5lciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlbWl0dGVyLCBmaWx0ZXIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVbnJlZ2lzdGVyIHRoZSB0cmlnZ2VyZWQgbGlzdGVuZXIgZm9yIGZ1dHVyZSBldmVudHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiNsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5lbWl0dGVyLm9mZih0aGlzLmZpbHRlciwgdGhpcy4jbGlzdGVuZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/events.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/fetch.js":
/*!************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/fetch.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchCancelSignal: function() { return /* binding */ FetchCancelSignal; },\n/* harmony export */   FetchRequest: function() { return /* binding */ FetchRequest; },\n/* harmony export */   FetchResponse: function() { return /* binding */ FetchResponse; }\n/* harmony export */ });\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ \"../common/node_modules/ethers/lib.esm/utils/base64-browser.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"../common/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"../common/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./properties.js */ \"../common/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utf8.js */ \"../common/node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _geturl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geturl.js */ \"../common/node_modules/ethers/lib.esm/utils/geturl-browser.js\");\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\n\n\n\n\n\n\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n    try {\n        const match = url.match(reData);\n        if (!match) {\n            throw new Error(\"invalid data\");\n        }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": (match[1] || \"text/plain\"),\n        }, (match[2] ? (0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.decodeBase64)(match[3]) : unpercent(match[3])));\n    }\n    catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n    }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction getIpfsGatewayFunc(baseUrl) {\n    async function gatewayIpfs(url, signal) {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) {\n                throw new Error(\"invalid link\");\n            }\n            return new FetchRequest(`${baseUrl}${match[2]}`);\n        }\n        catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n        }\n    }\n    return gatewayIpfs;\n}\nconst Gateways = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */\nclass FetchCancelSignal {\n    #listeners;\n    #cancelled;\n    constructor(request) {\n        this.#listeners = [];\n        this.#cancelled = false;\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) {\n                return;\n            }\n            this.#cancelled = true;\n            for (const listener of this.#listeners) {\n                setTimeout(() => { listener(); }, 0);\n            }\n            this.#listeners = [];\n        });\n    }\n    addListener(listener) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n    get cancelled() { return this.#cancelled; }\n    checkSignal() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n    if (signal == null) {\n        throw new Error(\"missing signal; should not happen\");\n    }\n    signal.checkSignal();\n    return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nclass FetchRequest {\n    #allowInsecure;\n    #gzip;\n    #headers;\n    #method;\n    #timeout;\n    #url;\n    #body;\n    #bodyType;\n    #creds;\n    // Hooks\n    #preflight;\n    #process;\n    #retry;\n    #signal;\n    #throttle;\n    #getUrlFunc;\n    /**\n     *  The fetch URL to request.\n     */\n    get url() { return this.#url; }\n    set url(url) {\n        this.#url = String(url);\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``).\n     *\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n     *  set to ``application/json``.\n     */\n    get body() {\n        if (this.#body == null) {\n            return null;\n        }\n        return new Uint8Array(this.#body);\n    }\n    set body(body) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        }\n        else if (typeof (body) === \"string\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(body);\n            this.#bodyType = \"text/plain\";\n        }\n        else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        }\n        else if (typeof (body) === \"object\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        }\n        else {\n            throw new Error(\"invalid body\");\n        }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */\n    hasBody() {\n        return (this.#body != null);\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */\n    get method() {\n        if (this.#method) {\n            return this.#method;\n        }\n        if (this.hasBody()) {\n            return \"POST\";\n        }\n        return \"GET\";\n    }\n    set method(method) {\n        if (method == null) {\n            method = \"\";\n        }\n        this.#method = String(method).toUpperCase();\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any changes will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */\n    get headers() {\n        const headers = Object.assign({}, this.#headers);\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${(0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.encodeBase64)((0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(this.#creds))}`;\n        }\n        ;\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) {\n            headers[\"content-length\"] = String(this.body.length);\n        }\n        return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */\n    getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */\n    setHeader(key, value) {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */\n    clearHeaders() {\n        this.#headers = {};\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [key, headers[key]], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */\n    get credentials() {\n        return this.#creds || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */\n    setCredentials(username, password) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${username}:${password}`;\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */\n    get allowGzip() {\n        return this.#gzip;\n    }\n    set allowGzip(value) {\n        this.#gzip = !!value;\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */\n    get allowInsecureAuthentication() {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value) {\n        this.#allowInsecure = !!value;\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complete response.\n     *  //(default: 5 minutes)//\n     */\n    get timeout() { return this.#timeout; }\n    set timeout(timeout) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */\n    get preflightFunc() {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight) {\n        this.#preflight = preflight;\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */\n    get processFunc() {\n        return this.#process || null;\n    }\n    set processFunc(process) {\n        this.#process = process;\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */\n    get retryFunc() {\n        return this.#retry || null;\n    }\n    set retryFunc(retry) {\n        this.#retry = retry;\n    }\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */\n    get getUrlFunc() {\n        return this.#getUrlFunc || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value) {\n        this.#getUrlFunc = value;\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */\n    constructor(url) {\n        this.#url = String(url);\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = {};\n        this.#method = \"\";\n        this.#timeout = 300000;\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n        this.#getUrlFunc = null;\n    }\n    toString() {\n        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */\n    setThrottleParams(params) {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n    async #send(attempt, expires, delay, _request, _response) {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\", reason: \"timeout\", request: _request\n        });\n        if (delay > 0) {\n            await wait(delay);\n        }\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    }\n                    catch (error) {\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof (error.stall) !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n                        // Ignore throttling\n                    }\n                }\n                return response;\n            }\n            req = result;\n        }\n        // We have a preflight function; update the request\n        if (this.preflightFunc) {\n            req = await this.preflightFunc(req);\n        }\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n        if (response.statusCode === 301 || response.statusCode === 302) {\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            }\n            catch (error) { }\n            // Things won't get any better on another attempt; abort\n            return response;\n        }\n        else if (response.statusCode === 429) {\n            // Throttle\n            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            }\n            catch (error) {\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof (error.stall) !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                ;\n                if (error.stall >= 0) {\n                    delay = error.stall;\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        return response;\n    }\n    /**\n     *  Resolves to the response by sending the request.\n     */\n    send() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.send\" });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */\n    cancel() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.cancel\" });\n        const signal = fetchSignals.get(this);\n        if (!signal) {\n            throw new Error(\"missing signal; should not happen\");\n        }\n        signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */\n    redirect(location) {\n        // Redirection; for now we only support absolute locations\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\n        });\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({}, this.#headers);\n        if (this.#body) {\n            req.#body = new Uint8Array(this.#body);\n        }\n        req.#bodyType = this.#bodyType;\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n        return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */\n    clone() {\n        const clone = new FetchRequest(this.url);\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) {\n            clone.#body = this.#body;\n        }\n        clone.#bodyType = this.#bodyType;\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({}, this.#headers);\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n        if (this.allowGzip) {\n            clone.allowGzip = true;\n        }\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) {\n            clone.allowInsecureAuthentication = true;\n        }\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n        clone.#throttle = Object.assign({}, this.#throttle);\n        clone.#getUrlFunc = this.#getUrlFunc;\n        return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */\n    static lockConfig() {\n        locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */\n    static getGateway(scheme) {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGateway(scheme, func) {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\n        }\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGetUrl(getUrl) {\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        defaultGetUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */\n    static createGetUrlFunc(options) {\n        return (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)(options);\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */\n    static createDataGateway() {\n        return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */\n    static createIpfsGatewayFunc(baseUrl) {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\n;\n/**\n *  The response for a FetchRequest.\n */\nclass FetchResponse {\n    #statusCode;\n    #statusMessage;\n    #headers;\n    #body;\n    #request;\n    #error;\n    toString() {\n        return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  The response status code.\n     */\n    get statusCode() { return this.#statusCode; }\n    /**\n     *  The response status message.\n     */\n    get statusMessage() { return this.#statusMessage; }\n    /**\n     *  The response headers. All keys are lower-case.\n     */\n    get headers() { return Object.assign({}, this.#headers); }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */\n    get body() {\n        return (this.#body == null) ? null : new Uint8Array(this.#body);\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */\n    get bodyText() {\n        try {\n            return (this.#body == null) ? \"\" : (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\n        }\n        catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\", info: { response: this }\n            });\n        }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */\n    get bodyJson() {\n        try {\n            return JSON.parse(this.bodyText);\n        }\n        catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\", info: { response: this }\n            });\n        }\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [key, headers[key]], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    constructor(statusCode, statusMessage, headers, body, request) {\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k) => {\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, {});\n        this.#body = ((body == null) ? null : new Uint8Array(body));\n        this.#request = (request || null);\n        this.#error = { message: \"\" };\n    }\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */\n    makeServerError(message, error) {\n        let statusMessage;\n        if (!message) {\n            message = `${this.statusCode} ${this.statusMessage}`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\n        }\n        else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\n        response.#error = { message, error };\n        return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */\n    throwThrottleError(message, stall) {\n        if (stall == null) {\n            stall = -1;\n        }\n        else {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n        const error = new Error(message || \"throttling requests\");\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_5__.defineProperties)(error, { stall, throttle: true });\n        throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */\n    getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true if the response has a body.\n     */\n    hasBody() {\n        return (this.#body != null);\n    }\n    /**\n     *  The request made for this response.\n     */\n    get request() { return this.#request; }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */\n    ok() {\n        return (this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300);\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */\n    assertOk() {\n        if (this.ok()) {\n            return;\n        }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\n        }\n        let requestUrl = null;\n        if (this.request) {\n            requestUrl = this.request.url;\n        }\n        let responseBody = null;\n        try {\n            if (this.#body) {\n                responseBody = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\n            }\n        }\n        catch (e) { }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, message, \"SERVER_ERROR\", {\n            request: (this.request || \"unknown request\"), response: this, error,\n            info: {\n                requestUrl, responseBody,\n                responseStatus: `${this.statusCode} ${this.statusMessage}`\n            }\n        });\n    }\n}\nfunction getTime() { return (new Date()).getTime(); }\nfunction unpercent(value) {\n    return (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\nfunction wait(delay) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RDtBQUNyQjtBQUNpQjtBQUNGO0FBQ0c7QUFDWDtBQUMzQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQVk7QUFDcEMscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjLHdEQUFZO0FBQ25DO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUSxFQUFFLFNBQVM7QUFDMUQ7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFFBQVEsa0RBQU0sOENBQThDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxnREFBZ0Qsd0RBQVksQ0FBQyxxREFBVyxlQUFlO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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bW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZmV0Y2guanM/ZmVhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBGZXRjaGluZyBjb250ZW50IGZyb20gdGhlIHdlYiBpcyBlbnZpcm9ubWVudC1zcGVjaWZpYywgc28gRXRoZXJzXG4gKiAgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gdGhhdCBlYWNoIGVudmlyb25tZW50IGNhbiBpbXBsZW1lbnQgdG8gcHJvdmlkZVxuICogIHRoaXMgc2VydmljZS5cbiAqXG4gKiAgT24gW05vZGUuanNdKGxpbmstbm9kZSksIHRoZSBgYGh0dHBgYCBhbmQgYGBodHRwc2BgIGxpYnMgYXJlIHVzZWQgdG9cbiAqICBjcmVhdGUgYSByZXF1ZXN0IG9iamVjdCwgcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGFuZCBwcm9jZXNzIGRhdGFcbiAqICBhbmQgcG9wdWxhdGUgdGhlIFtbRmV0Y2hSZXNwb25zZV1dLlxuICpcbiAqICBJbiBhIGJyb3dzZXIsIHRoZSBbRE9NIGZldGNoXShsaW5rLWpzLWZldGNoKSBpcyB1c2VkLCBhbmQgdGhlIHJlc3VsdGluZ1xuICogIGBgUHJvbWlzZWBgIGlzIHdhaXRlZCBvbiB0byByZXRyaWV2ZSB0aGUgcGF5bG9hZC5cbiAqXG4gKiAgVGhlIFtbRmV0Y2hSZXF1ZXN0XV0gaXMgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIG1hbnkgY29tbW9uIHNpdHVhdGlvbnMsXG4gKiAgc3VjaCBhcyByZWRpcmVjdHMsIHNlcnZlciB0aHJvdHRsaW5nLCBhdXRoZW50aWNhdGlvbiwgZXRjLlxuICpcbiAqICBJdCBhbHNvIGhhbmRsZXMgY29tbW9uIGdhdGV3YXlzLCBzdWNoIGFzIElQRlMgYW5kIGRhdGEgVVJJcy5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9mZXRjaGluZzpGZXRjaGluZyBXZWIgQ29udGVudCAgW2Fib3V0LWZldGNoXVxuICovXG5pbXBvcnQgeyBkZWNvZGVCYXNlNjQsIGVuY29kZUJhc2U2NCB9IGZyb20gXCIuL2Jhc2U2NC5qc1wiO1xuaW1wb3J0IHsgaGV4bGlmeSB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIi4vdXRmOC5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlR2V0VXJsIH0gZnJvbSBcIi4vZ2V0dXJsLmpzXCI7XG5jb25zdCBNQVhfQVRURU1QVFMgPSAxMjtcbmNvbnN0IFNMT1RfSU5URVJWQUwgPSAyNTA7XG4vLyBUaGUgZ2xvYmFsIEZldGNoR2V0VXJsRnVuYyBpbXBsZW1lbnRhdGlvbi5cbmxldCBkZWZhdWx0R2V0VXJsRnVuYyA9IGNyZWF0ZUdldFVybCgpO1xuY29uc3QgcmVEYXRhID0gbmV3IFJlZ0V4cChcIl5kYXRhOihbXjs6XSopPyg7YmFzZTY0KT8sKC4qKSRcIiwgXCJpXCIpO1xuY29uc3QgcmVJcGZzID0gbmV3IFJlZ0V4cChcIl5pcGZzOi9cXC8oaXBmcy8pPyguKikkXCIsIFwiaVwiKTtcbi8vIElmIGxvY2tlZCwgbmV3IEdhdGV3YXlzIGNhbm5vdCBiZSBhZGRlZFxubGV0IGxvY2tlZCA9IGZhbHNlO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSTHNcbmFzeW5jIGZ1bmN0aW9uIGRhdGFHYXRld2F5RnVuYyh1cmwsIHNpZ25hbCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlRGF0YSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoMjAwLCBcIk9LXCIsIHtcbiAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IChtYXRjaFsxXSB8fCBcInRleHQvcGxhaW5cIiksXG4gICAgICAgIH0sIChtYXRjaFsyXSA/IGRlY29kZUJhc2U2NChtYXRjaFszXSkgOiB1bnBlcmNlbnQobWF0Y2hbM10pKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIGRhdGE6IFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XG4gICAgfVxufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRmV0Y2hHYXRld2F5RnVuY11dIGZvciBmZXRjaGluZyBjb250ZW50IGZyb20gYSBzdGFuZGFyZFxuICogIElQRlMgZ2F0ZXdheSBob3N0ZWQgYXQgJSViYXNlVXJsJSUuXG4gKi9cbmZ1bmN0aW9uIGdldElwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2F0ZXdheUlwZnModXJsLCBzaWduYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlSXBmcyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBsaW5rXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlcXVlc3QoYCR7YmFzZVVybH0ke21hdGNoWzJdfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgXCJCQUQgUkVRVUVTVCAoaW52YWxpZCBJUEZTIFVSSSlcIiwge30sIG51bGwsIG5ldyBGZXRjaFJlcXVlc3QodXJsKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdhdGV3YXlJcGZzO1xufVxuY29uc3QgR2F0ZXdheXMgPSB7XG4gICAgXCJkYXRhXCI6IGRhdGFHYXRld2F5RnVuYyxcbiAgICBcImlwZnNcIjogZ2V0SXBmc0dhdGV3YXlGdW5jKFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiKVxufTtcbmNvbnN0IGZldGNoU2lnbmFscyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hDYW5jZWxTaWduYWwge1xuICAgICNsaXN0ZW5lcnM7XG4gICAgI2NhbmNlbGxlZDtcbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgZmV0Y2hTaWduYWxzLnNldChyZXF1ZXN0LCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy4jY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGxpc3RlbmVyKCk7IH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICBhc3NlcnQoIXRoaXMuI2NhbmNlbGxlZCwgXCJzaW5nYWwgYWxyZWFkeSBjYW5jZWxsZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZldGNoQ2FuY2VsU2lnbmFsLmFkZENhbmNlbExpc3RlbmVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgZ2V0IGNhbmNlbGxlZCgpIHsgcmV0dXJuIHRoaXMuI2NhbmNlbGxlZDsgfVxuICAgIGNoZWNrU2lnbmFsKCkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuY2FuY2VsbGVkLCBcImNhbmNlbGxlZFwiLCBcIkNBTkNFTExFRFwiLCB7fSk7XG4gICAgfVxufVxuLy8gQ2hlY2sgdGhlIHNpZ25hbCwgdGhyb3dpbmcgaWYgaXQgaXMgY2FuY2VsbGVkXG5mdW5jdGlvbiBjaGVja1NpZ25hbChzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBzaWduYWwuY2hlY2tTaWduYWwoKTtcbiAgICByZXR1cm4gc2lnbmFsO1xufVxuLyoqXG4gKiAgUmVwcmVzZW50cyBhIHJlcXVlc3QgZm9yIGEgcmVzb3VyY2UgdXNpbmcgYSBVUkkuXG4gKlxuICogIEJ5IGRlZmF1bHQsIHRoZSBzdXBwb3J0ZWQgc2NoZW1lcyBhcmUgYGBIVFRQYGAsIGBgSFRUUFNgYCwgYGBkYXRhOmBgLFxuICogIGFuZCBgYElQRlM6YGAuXG4gKlxuICogIEFkZGl0aW9uYWwgc2NoZW1lcyBjYW4gYmUgYWRkZWQgZ2xvYmFsbHkgdXNpbmcgW1tyZWdpc3RlckdhdGV3YXldXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KFwiaHR0cHM6Ly93d3cucmljbW9vLmNvbVwiKVxuICogICAgcmVzcCA9IGF3YWl0IHJlcS5zZW5kKClcbiAqICAgIHJlc3AuYm9keS5sZW5ndGhcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVxdWVzdCB7XG4gICAgI2FsbG93SW5zZWN1cmU7XG4gICAgI2d6aXA7XG4gICAgI2hlYWRlcnM7XG4gICAgI21ldGhvZDtcbiAgICAjdGltZW91dDtcbiAgICAjdXJsO1xuICAgICNib2R5O1xuICAgICNib2R5VHlwZTtcbiAgICAjY3JlZHM7XG4gICAgLy8gSG9va3NcbiAgICAjcHJlZmxpZ2h0O1xuICAgICNwcm9jZXNzO1xuICAgICNyZXRyeTtcbiAgICAjc2lnbmFsO1xuICAgICN0aHJvdHRsZTtcbiAgICAjZ2V0VXJsRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIFVSTCB0byByZXF1ZXN0LlxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLiN1cmw7IH1cbiAgICBzZXQgdXJsKHVybCkge1xuICAgICAgICB0aGlzLiN1cmwgPSBTdHJpbmcodXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBmZXRjaCBib2R5LCBpZiBhbnksIHRvIHNlbmQgYXMgdGhlIHJlcXVlc3QgYm9keS4gLy8oZGVmYXVsdDogbnVsbCkvL1xuICAgICAqXG4gICAgICogIFdoZW4gc2V0dGluZyBhIGJvZHksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogIHNldCBhbmQgd2lsbCBiZSB1c2VkIGlmICoqbm90IG92ZXJyaWRkZW4qKiBieSBzZXR0aW5nIGEgY3VzdG9tXG4gICAgICogIGhlYWRlci5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBudWxsLCB0aGUgYm9keSBpcyBjbGVhcmVkIChhbG9uZyB3aXRoIHRoZVxuICAgICAqICBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCkuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYSBzdHJpbmcsIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGB0ZXh0L3BsYWluYGAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYSBVaW50OEFycmF5LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXMgc2V0IHRvXG4gICAgICogIGBgYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtYGAuXG4gICAgICpcbiAgICAgKiAgSWYgJSVib2R5JSUgaXMgYW55IG90aGVyIG9iamVjdCwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzXG4gICAgICogIHNldCB0byBgYGFwcGxpY2F0aW9uL2pzb25gYC5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2JvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICBzZXQgYm9keShib2R5KSB7XG4gICAgICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoYm9keSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwidGV4dC9wbGFpblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGJvZHkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLiNib2R5ID0gdG9VdGY4Qnl0ZXMoSlNPTi5zdHJpbmdpZnkoYm9keSkpO1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm9keVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSByZXF1ZXN0IGhhcyBhIGJvZHkuXG4gICAgICovXG4gICAgaGFzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEhUVFAgbWV0aG9kIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdGhlIFVSSS4gSWYgbm8gbWV0aG9kXG4gICAgICogIGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0LCB0aGVuIGBgR0VUYGAgaXMgdXNlZCBpZiB0aGUgYm9keSBpc1xuICAgICAqICBudWxsIGFuZCBgYFBPU1RgYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI21ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNCb2R5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlBPU1RcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJHRVRcIjtcbiAgICB9XG4gICAgc2V0IG1ldGhvZChtZXRob2QpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21ldGhvZCA9IFN0cmluZyhtZXRob2QpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgaGVhZGVycyB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIHJlcXVlc3RpbmcgdGhlIFVSSS4gQWxsXG4gICAgICogIGtleXMgYXJlIGxvd2VyLWNhc2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBvYmplY3QgaXMgYSBjb3B5LCBzbyBhbnkgY2hhbmdlcyB3aWxsICoqTk9UKiogYmUgcmVmbGVjdGVkXG4gICAgICogIGluIHRoZSBgYEZldGNoUmVxdWVzdGBgLlxuICAgICAqXG4gICAgICogIFRvIHNldCBhIGhlYWRlciBlbnRyeSwgdXNlIHRoZSBgYHNldEhlYWRlcmBgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy4jY3JlZHMpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJhc2ljICR7ZW5jb2RlQmFzZTY0KHRvVXRmOEJ5dGVzKHRoaXMuI2NyZWRzKSl9YDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmICh0aGlzLmFsbG93R3ppcCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImFjY2VwdC1lbmNvZGluZ1wiXSA9IFwiZ3ppcFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwgJiYgdGhpcy4jYm9keVR5cGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSB0aGlzLiNib2R5VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib2R5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPSBTdHJpbmcodGhpcy5ib2R5Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSwgaWdub3JpbmcgY2FzZS5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUgdG8gJSV2YWx1ZSUlLiBBbGwgdmFsdWVzIGFyZSBjb2VyY2VkXG4gICAgICogIHRvIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnNbU3RyaW5nKGtleSkudG9Mb3dlckNhc2UoKV0gPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYWxsIGhlYWRlcnMsIHJlc2V0dGluZyBhbGwgaW50cmluc2ljIGhlYWRlcnMuXG4gICAgICovXG4gICAgY2xlYXJIZWFkZXJzKCkge1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUgdGhhdCB3aWxsIGJlIHNlbnQgZm9yIHRoZSBgYEF1dGhvcml6YXRpb25gYCBoZWFkZXIuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IHRoZSBjcmVkZW50aWFscywgdXNlIHRoZSBgYHNldENyZWRlbnRpYWxzYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBjcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NyZWRzIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXRzIGFuIGBgQXV0aG9yaXphdGlvbmBgIGZvciAlJXVzZXJuYW1lJSUgd2l0aCAlJXBhc3N3b3JkJSUuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHModXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCF1c2VybmFtZS5tYXRjaCgvOi8pLCBcImludmFsaWQgYmFzaWMgYXV0aGVudGljYXRpb24gdXNlcm5hbWVcIiwgXCJ1c2VybmFtZVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI2NyZWRzID0gYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuYWJsZSBhbmQgcmVxdWVzdCBnemlwLWVuY29kZWQgcmVzcG9uc2VzLiBUaGUgcmVzcG9uc2Ugd2lsbFxuICAgICAqICBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC4gLy8oZGVmYXVsdDogdHJ1ZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0d6aXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnemlwO1xuICAgIH1cbiAgICBzZXQgYWxsb3dHemlwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2d6aXAgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxsb3cgYGBBdXRoZW50aWNhdGlvbmBgIGNyZWRlbnRpYWxzIHRvIGJlIHNlbnQgb3ZlciBpbnNlY3VyZVxuICAgICAqICBjaGFubmVscy4gLy8oZGVmYXVsdDogZmFsc2UpLy9cbiAgICAgKi9cbiAgICBnZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNhbGxvd0luc2VjdXJlO1xuICAgIH1cbiAgICBzZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcykgdG8gd2FpdCBmb3IgYSBjb21wbGV0ZSByZXNwb25zZS5cbiAgICAgKiAgLy8oZGVmYXVsdDogNSBtaW51dGVzKS8vXG4gICAgICovXG4gICAgZ2V0IHRpbWVvdXQoKSB7IHJldHVybiB0aGlzLiN0aW1lb3V0OyB9XG4gICAgc2V0IHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aW1lb3V0ID49IDAsIFwidGltZW91dCBtdXN0IGJlIG5vbi16ZXJvXCIsIFwidGltZW91dFwiLCB0aW1lb3V0KTtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBwcmlvciB0byBlYWNoIHJlcXVlc3QsIGZvciBleGFtcGxlXG4gICAgICogIGR1cmluZyBhIHJlZGlyZWN0aW9uIG9yIHJldHJ5IGluIGNhc2Ugb2Ygc2VydmVyIHRocm90dGxpbmcuXG4gICAgICpcbiAgICAgKiAgVGhpcyBvZmZlcnMgYW4gb3Bwb3J0dW5pdHkgdG8gcG9wdWxhdGUgaGVhZGVycyBvciB1cGRhdGVcbiAgICAgKiAgY29udGVudCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHByZWZsaWdodEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcmVmbGlnaHQgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByZWZsaWdodEZ1bmMocHJlZmxpZ2h0KSB7XG4gICAgICAgIHRoaXMuI3ByZWZsaWdodCA9IHByZWZsaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGVhY2ggcmVzcG9uc2UsIG9mZmVyaW5nIGFuXG4gICAgICogIG9wcG9ydHVuaXR5IHRvIHByb3ZpZGUgY2xpZW50LWxldmVsIHRocm90dGxpbmcgb3IgdXBkYXRpbmdcbiAgICAgKiAgcmVzcG9uc2UgZGF0YS5cbiAgICAgKlxuICAgICAqICBBbnkgZXJyb3IgdGhyb3duIGluIHRoaXMgY2F1c2VzIHRoZSBgYHNlbmQoKWBgIHRvIHRocm93LlxuICAgICAqXG4gICAgICogIFRvIHNjaGVkdWxlIGEgcmV0cnkgYXR0ZW1wdCAoYXNzdW1pbmcgdGhlIG1heGltdW0gcmV0cnkgbGltaXRcbiAgICAgKiAgaGFzIG5vdCBiZWVuIHJlYWNoZWQpLCB1c2UgW1tyZXNwb25zZS50aHJvd1Rocm90dGxlRXJyb3JdXS5cbiAgICAgKi9cbiAgICBnZXQgcHJvY2Vzc0Z1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9jZXNzIHx8IG51bGw7XG4gICAgfVxuICAgIHNldCBwcm9jZXNzRnVuYyhwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3MgPSBwcm9jZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCByZXRyeSBhdHRlbXB0LlxuICAgICAqL1xuICAgIGdldCByZXRyeUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXRyeSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcmV0cnlGdW5jKHJldHJ5KSB7XG4gICAgICAgIHRoaXMuI3JldHJ5ID0gcmV0cnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBmZXRjaCBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcyBhbmQgaXMgcGxhdGZvcm0gc3BlY2lmaWMgKGUuZy4gbm9kZWpzIHZzXG4gICAgICogIGJyb3dzZXJzKS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGJ5IGRlZmF1bHQgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIGdsb2JhbCBnZXRVcmxcbiAgICAgKiAgZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSBjaGFuZ2VkIHVzaW5nIFtbcmVnaXN0ZXJHZXRVcmxdXS5cbiAgICAgKiAgSWYgdGhpcyBoYXMgYmVlbiBzZXQsIHNldHRpbmcgaXMgdG8gYGBudWxsYGAgd2lsbCBjYXVzZVxuICAgICAqICB0aGlzIEZldGNoUmVxdWVzdCAoYW5kIGFueSBmdXR1cmUgY2xvbmVzKSB0byByZXZlcnQgYmFjayB0b1xuICAgICAqICB1c2luZyB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBTZXR0aW5nIHRoaXMgaXMgZ2VuZXJhbGx5IG5vdCBuZWNlc3NhcnksIGJ1dCBtYXkgYmUgdXNlZnVsXG4gICAgICogIGZvciBkZXZlbG9wZXJzIHRoYXQgd2lzaCB0byBpbnRlcmNlcHQgcmVxdWVzdHMgb3IgdG9cbiAgICAgKiAgY29uZmlndXJlZ2UgYSBwcm94eSBvciBvdGhlciBhZ2VudC5cbiAgICAgKi9cbiAgICBnZXQgZ2V0VXJsRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFVybEZ1bmMgfHwgZGVmYXVsdEdldFVybEZ1bmM7XG4gICAgfVxuICAgIHNldCBnZXRVcmxGdW5jKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBGZXRjaFJlcXVlc3QgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBPbmNlIGNyZWF0ZWQsIGVhY2ggcHJvcGVydHkgbWF5IGJlIHNldCBiZWZvcmUgaXNzdWluZyBhXG4gICAgICogIGBgLnNlbmQoKWBgIHRvIG1ha2UgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgICAgICB0aGlzLiNhbGxvd0luc2VjdXJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2d6aXAgPSB0cnVlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0ge307XG4gICAgICAgIHRoaXMuI21ldGhvZCA9IFwiXCI7XG4gICAgICAgIHRoaXMuI3RpbWVvdXQgPSAzMDAwMDA7XG4gICAgICAgIHRoaXMuI3Rocm90dGxlID0ge1xuICAgICAgICAgICAgc2xvdEludGVydmFsOiBTTE9UX0lOVEVSVkFMLFxuICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IE1BWF9BVFRFTVBUU1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNnZXRVcmxGdW5jID0gbnVsbDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPEZldGNoUmVxdWVzdCBtZXRob2Q9JHtKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGhvZCl9IHVybD0ke0pTT04uc3RyaW5naWZ5KHRoaXMudXJsKX0gaGVhZGVycz0ke0pTT04uc3RyaW5naWZ5KHRoaXMuaGVhZGVycyl9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXBkYXRlIHRoZSB0aHJvdHRsZSBwYXJhbWV0ZXJzIHVzZWQgdG8gZGV0ZXJtaW5lIG1heGltdW1cbiAgICAgKiAgYXR0ZW1wdHMgYW5kIGV4cG9uZW50aWFsLWJhY2tvZmYgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBzZXRUaHJvdHRsZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zbG90SW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsID0gcGFyYW1zLnNsb3RJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm1heEF0dGVtcHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzID0gcGFyYW1zLm1heEF0dGVtcHRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNzZW5kKGF0dGVtcHQsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgX3Jlc3BvbnNlKSB7XG4gICAgICAgIGlmIChhdHRlbXB0ID49IHRoaXMuI3Rocm90dGxlLm1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImV4Y2VlZGVkIG1heGltdW0gcmV0cnkgbGltaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGdldFRpbWUoKSA8PSBleHBpcmVzLCBcInRpbWVvdXRcIiwgXCJUSU1FT1VUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0LnNlbmRcIiwgcmVhc29uOiBcInRpbWVvdXRcIiwgcmVxdWVzdDogX3JlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXEgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHNjaGVtZSA9IChyZXEudXJsLnNwbGl0KFwiOlwiKVswXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBQcm9jZXNzIGFueSBHYXRld2F5c1xuICAgICAgICBpZiAoc2NoZW1lIGluIEdhdGV3YXlzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBHYXRld2F5c1tzY2hlbWVdKHJlcS51cmwsIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGZXRjaFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhyb3R0bGluZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGEgcHJlZmxpZ2h0IGZ1bmN0aW9uOyB1cGRhdGUgdGhlIHJlcXVlc3RcbiAgICAgICAgaWYgKHRoaXMucHJlZmxpZ2h0RnVuYykge1xuICAgICAgICAgICAgcmVxID0gYXdhaXQgdGhpcy5wcmVmbGlnaHRGdW5jKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZ2V0VXJsRnVuYyhyZXEsIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEZldGNoUmVzcG9uc2UocmVzcC5zdGF0dXNDb2RlLCByZXNwLnN0YXR1c01lc3NhZ2UsIHJlc3AuaGVhZGVycywgcmVzcC5ib2R5LCBfcmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAyKSB7XG4gICAgICAgICAgICAvLyBSZWRpcmVjdFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLnJlZGlyZWN0KGxvY2F0aW9uKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgMCwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAvLyBUaGluZ3Mgd29uJ3QgZ2V0IGFueSBiZXR0ZXIgb24gYW5vdGhlciBhdHRlbXB0OyBhYm9ydFxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSkge1xuICAgICAgICAgICAgLy8gVGhyb3R0bGVcbiAgICAgICAgICAgIGlmICh0aGlzLnJldHJ5RnVuYyA9PSBudWxsIHx8IChhd2FpdCB0aGlzLnJldHJ5RnVuYyhyZXEsIHJlc3BvbnNlLCBhdHRlbXB0KSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gcmVzcG9uc2UuaGVhZGVyc1tcInJldHJ5LWFmdGVyXCJdO1xuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXRyeUFmdGVyKSA9PT0gXCJzdHJpbmdcIiAmJiByZXRyeUFmdGVyLm1hdGNoKC9eWzEtOV1bMC05XSokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBwYXJzZUludChyZXRyeUFmdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzRnVuYyhyZXEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBwcm9jZXNzaW5nOyB0aHJvdyBhIDV4eCBzZXJ2ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IudGhyb3R0bGUgPT0gbnVsbCB8fCB0eXBlb2YgKGVycm9yLnN0YWxsKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tYWtlU2VydmVyRXJyb3IoXCJlcnJvciBpbiBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb25cIiwgZXJyb3IpLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRocm90dGxlXG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhbGwgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IGVycm9yLnN0YWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXNwb25zZSBieSBzZW5kaW5nIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNlbmQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNzaWduYWwgPT0gbnVsbCwgXCJyZXF1ZXN0IGFscmVhZHkgc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3Quc2VuZFwiIH0pO1xuICAgICAgICB0aGlzLiNzaWduYWwgPSBuZXcgRmV0Y2hDYW5jZWxTaWduYWwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNzZW5kKDAsIGdldFRpbWUoKSArIHRoaXMudGltZW91dCwgMCwgdGhpcywgbmV3IEZldGNoUmVzcG9uc2UoMCwgXCJcIiwge30sIG51bGwsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbmNlbHMgdGhlIGluZmxpZ2h0IHJlc3BvbnNlLCBjYXVzaW5nIGEgYGBDQU5DRUxMRURgYFxuICAgICAqICBlcnJvciB0byBiZSByZWplY3RlZCBmcm9tIHRoZSBbW3NlbmRdXS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLiNzaWduYWwgIT0gbnVsbCwgXCJyZXF1ZXN0IGhhcyBub3QgYmVlbiBzZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZldGNoUmVxdWVzdC5jYW5jZWxcIiB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gZmV0Y2hTaWduYWxzLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKCFzaWduYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgc2lnbmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGZXRjaFJlcXVlc3RdXSB0aGF0IHJlcHJlc2VudHMgdGhlIHJlZGlyZWN0aW9uXG4gICAgICogIHRvICUlbG9jYXRpb24lJS5cbiAgICAgKi9cbiAgICByZWRpcmVjdChsb2NhdGlvbikge1xuICAgICAgICAvLyBSZWRpcmVjdGlvbjsgZm9yIG5vdyB3ZSBvbmx5IHN1cHBvcnQgYWJzb2x1dGUgbG9jYXRpb25zXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbG9jYXRpb24uc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIERvbid0IGFsbG93IHJlZGlyZWN0aW5nOlxuICAgICAgICAvLyAtIG5vbi1HRVQgcmVxdWVzdHNcbiAgICAgICAgLy8gLSBkb3duZ3JhZGluZyB0aGUgc2VjdXJpdHkgKGUuZy4gaHR0cHMgPT4gaHR0cClcbiAgICAgICAgLy8gLSB0byBub24tSFRUUCAob3Igbm9uLUhUVFBTKSBwcm90b2NvbHMgW3RoaXMgY291bGQgYmUgcmVsYXhlZD9dXG4gICAgICAgIGFzc2VydCh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiAoY3VycmVudCAhPT0gXCJodHRwc1wiIHx8IHRhcmdldCAhPT0gXCJodHRwXCIpICYmIGxvY2F0aW9uLm1hdGNoKC9eaHR0cHM/Oi8pLCBgdW5zdXBwb3J0ZWQgcmVkaXJlY3RgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IGByZWRpcmVjdCgke3RoaXMubWV0aG9kfSAke0pTT04uc3RyaW5naWZ5KHRoaXMudXJsKX0gPT4gJHtKU09OLnN0cmluZ2lmeShsb2NhdGlvbil9KWBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyByZXF1ZXN0LCB3aXRoIGEgbmV3IFVSTFxuICAgICAgICBjb25zdCByZXEgPSBuZXcgRmV0Y2hSZXF1ZXN0KGxvY2F0aW9uKTtcbiAgICAgICAgcmVxLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgIHJlcS5hbGxvd0d6aXAgPSB0aGlzLmFsbG93R3ppcDtcbiAgICAgICAgcmVxLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIHJlcS4jaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy4jYm9keSkge1xuICAgICAgICAgICAgcmVxLiNib2R5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxLiNib2R5VHlwZSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICAvLyBEbyBub3QgZm9yd2FyZCBjcmVkZW50aWFscyB1bmxlc3Mgb24gdGhlIHNhbWUgZG9tYWluOyBvbmx5IGFic29sdXRlXG4gICAgICAgIC8vcmVxLmFsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgLy8gcGF0aHMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQ7IG1heSB3YW50IGEgd2F5IHRvIHNwZWNpZnkgdG8gZm9yd2FyZD9cbiAgICAgICAgLy9zZXRTdG9yZShyZXEuI3Byb3BzLCBcImNyZWRzXCIsIGdldFN0b3JlKHRoaXMuI3Byb3MsIFwiY3JlZHNcIikpO1xuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IGNvcHkgb2YgdGhpcyByZXF1ZXN0LlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBGZXRjaFJlcXVlc3QodGhpcy51cmwpO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgbWV0aG9kXCIgKGkuZS4gbnVsbClcbiAgICAgICAgY2xvbmUuI21ldGhvZCA9IHRoaXMuI21ldGhvZDtcbiAgICAgICAgLy8gUHJlc2VydmUgXCJkZWZhdWx0IGJvZHlcIiB3aXRoIHR5cGUsIGNvcHlpbmcgdGhlIFVpbnQ4QXJyYXkgaXMgcHJlc2VudFxuICAgICAgICBpZiAodGhpcy4jYm9keSkge1xuICAgICAgICAgICAgY2xvbmUuI2JvZHkgPSB0aGlzLiNib2R5O1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLiNib2R5VHlwZSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgaGVhZGVyc1wiXG4gICAgICAgIGNsb25lLiNoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIC8vIENyZWRlbnRpYWxzIGlzIHJlYWRvbmx5LCBzbyB3ZSBjb3B5IGludGVybmFsbHlcbiAgICAgICAgY2xvbmUuI2NyZWRzID0gdGhpcy4jY3JlZHM7XG4gICAgICAgIGlmICh0aGlzLmFsbG93R3ppcCkge1xuICAgICAgICAgICAgY2xvbmUuYWxsb3dHemlwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICBpZiAodGhpcy5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgICAgIGNsb25lLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuI3ByZWZsaWdodCA9IHRoaXMuI3ByZWZsaWdodDtcbiAgICAgICAgY2xvbmUuI3Byb2Nlc3MgPSB0aGlzLiNwcm9jZXNzO1xuICAgICAgICBjbG9uZS4jcmV0cnkgPSB0aGlzLiNyZXRyeTtcbiAgICAgICAgY2xvbmUuI3Rocm90dGxlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jdGhyb3R0bGUpO1xuICAgICAgICBjbG9uZS4jZ2V0VXJsRnVuYyA9IHRoaXMuI2dldFVybEZ1bmM7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIExvY2tzIGFsbCBzdGF0aWMgY29uZmlndXJhdGlvbiBmb3IgZ2F0ZXdheXMgYW5kIEZldGNoR2V0VXJsRnVuY1xuICAgICAqICByZWdpc3RyYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGxvY2tDb25maWcoKSB7XG4gICAgICAgIGxvY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGN1cnJlbnQgR2F0ZXdheSBmdW5jdGlvbiBmb3IgJSVzY2hlbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0R2F0ZXdheShzY2hlbWUpIHtcbiAgICAgICAgcmV0dXJuIEdhdGV3YXlzW3NjaGVtZS50b0xvd2VyQ2FzZSgpXSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlIHRoZSAlJWZ1bmMlJSB3aGVuIGZldGNoaW5nIFVSSXMgdXNpbmcgJSVzY2hlbWUlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBhZmZlY3RzIGFsbCByZXF1ZXN0cyBnbG9iYWxseS5cbiAgICAgKlxuICAgICAqICBJZiBbW2xvY2tDb25maWddXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNoYW5nZSBpcyBtYWRlIGFuZCB0aGlzXG4gICAgICogIHRocm93cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXJHYXRld2F5KHNjaGVtZSwgZnVuYykge1xuICAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJodHRwXCIgfHwgc2NoZW1lID09PSBcImh0dHBzXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGludGVyY2VwdCAke3NjaGVtZX07IHVzZSByZWdpc3RlckdldFVybGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdhdGV3YXlzIGxvY2tlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBHYXRld2F5c1tzY2hlbWVdID0gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVzZSAlJWdldFVybCUlIHdoZW4gZmV0Y2hpbmcgVVJJcyBvdmVyIEhUVFAgYW5kIEhUVFBTIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdldFVybChnZXRVcmwpIHtcbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRHZXRVcmxGdW5jID0gZ2V0VXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGdldFVybCBmdW5jdGlvbiB0aGF0IGZldGNoZXMgY29udGVudCBmcm9tIEhUVFAgYW5kXG4gICAgICogIEhUVFBTIFVSTHMuXG4gICAgICpcbiAgICAgKiAgVGhlIGF2YWlsYWJsZSAlJW9wdGlvbnMlJSBhcmUgZGVwZW5kZW50IG9uIHRoZSBwbGF0Zm9ybVxuICAgICAqICBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGVmYXVsdCBnZXRVcmwgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub3QgZ2VuZXJhbGx5IHNvbWV0aGluZyB0aGF0IGlzIG5lZWRlZCwgYnV0IGlzIHVzZWZ1bFxuICAgICAqICB3aGVuIHRyeWluZyB0byBjdXN0b21pemUgc2ltcGxlIGJlaGF2aW91ciB3aGVuIGZldGNoaW5nIEhUVFBcbiAgICAgKiAgY29udGVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlR2V0VXJsRnVuYyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVHZXRVcmwob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjYW4gXCJmZXRjaFwiIGRhdGEgVVJJcy5cbiAgICAgKlxuICAgICAqICBOb3RlIHRoYXQgdGhpcyBpcyBhdXRvbWF0aWNhbGx5IGRvbmUgaW50ZXJuYWxseSB0byBzdXBwb3J0XG4gICAgICogIGRhdGEgVVJJcywgc28gaXQgaXMgbm90IG5lY2Vzc2FyeSB0byByZWdpc3RlciBpdC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgbWF5XG4gICAgICogIGJlIHVzZWZ1bCBpbiBhIHdyYXBwZXIgdG8gcGVyZm9tIGN1c3RvbSBkYXRhIFVSSSBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEYXRhR2F0ZXdheSgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFHYXRld2F5RnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZmV0Y2ggSVBGUyAodW52YWxpZGF0ZWQpIGZyb21cbiAgICAgKiAgYSBjdXN0b20gZ2F0ZXdheSBiYXNlVXJsLlxuICAgICAqXG4gICAgICogIFRoZSBkZWZhdWx0IElQRlMgZ2F0ZXdheSB1c2VkIGludGVybmFsbHkgaXNcbiAgICAgKiAgYGBcImh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy9cImBgLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCkge1xuICAgICAgICByZXR1cm4gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpO1xuICAgIH1cbn1cbjtcbi8qKlxuICogIFRoZSByZXNwb25zZSBmb3IgYSBGZXRjaFJlcXVlc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaFJlc3BvbnNlIHtcbiAgICAjc3RhdHVzQ29kZTtcbiAgICAjc3RhdHVzTWVzc2FnZTtcbiAgICAjaGVhZGVycztcbiAgICAjYm9keTtcbiAgICAjcmVxdWVzdDtcbiAgICAjZXJyb3I7XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPEZldGNoUmVzcG9uc2Ugc3RhdHVzPSR7dGhpcy5zdGF0dXNDb2RlfSBib2R5PSR7dGhpcy4jYm9keSA/IGhleGxpZnkodGhpcy4jYm9keSkgOiBcIm51bGxcIn0+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBzdGF0dXMgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzQ29kZSgpIHsgcmV0dXJuIHRoaXMuI3N0YXR1c0NvZGU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBtZXNzYWdlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNNZXNzYWdlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzTWVzc2FnZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgaGVhZGVycy4gQWxsIGtleXMgYXJlIGxvd2VyLWNhc2UuXG4gICAgICovXG4gICAgZ2V0IGhlYWRlcnMoKSB7IHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgb3IgYGBudWxsYGAgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5IGFzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcsIG9yIHRoZSBlbXB0eVxuICAgICAqICBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIFVURi04IGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGJvZHlUZXh0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gXCJcIiA6IHRvVXRmOFN0cmluZyh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBVVEYtOCBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiYm9keVRleHRcIiwgaW5mbzogeyByZXNwb25zZTogdGhpcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIGRlY29kZWQgYXMgSlNPTi5cbiAgICAgKlxuICAgICAqICBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGJvZHkgaXMgaW52YWxpZCBKU09OLWVuY29kZWQgZGF0YVxuICAgICAqICBvciBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keUpzb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmJvZHlUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBKU09OXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiYm9keUpzb25cIiwgaW5mbzogeyByZXNwb25zZTogdGhpcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzLCBib2R5LCByZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuI3N0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLiNzdGF0dXNNZXNzYWdlID0gc3RhdHVzTWVzc2FnZTtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZSgoYWNjdW0sIGspID0+IHtcbiAgICAgICAgICAgIGFjY3VtW2sudG9Mb3dlckNhc2UoKV0gPSBTdHJpbmcoaGVhZGVyc1trXSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy4jYm9keSA9ICgoYm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheShib2R5KSk7XG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSAocmVxdWVzdCB8fCBudWxsKTtcbiAgICAgICAgdGhpcy4jZXJyb3IgPSB7IG1lc3NhZ2U6IFwiXCIgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIFJlc3BvbnNlIHdpdGggbWF0Y2hpbmcgaGVhZGVycyBhbmQgYm9keSwgYnV0IHdpdGhcbiAgICAgKiAgYW4gZXJyb3Igc3RhdHVzIGNvZGUgKGkuZS4gNTk5KSBhbmQgJSVtZXNzYWdlJSUgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJWVycm9yJSUuXG4gICAgICovXG4gICAgbWFrZVNlcnZlckVycm9yKG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgIGxldCBzdGF0dXNNZXNzYWdlO1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke21lc3NhZ2V9KWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9OyAke21lc3NhZ2V9KWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIHN0YXR1c01lc3NhZ2UsIHRoaXMuaGVhZGVycywgdGhpcy5ib2R5LCB0aGlzLiNyZXF1ZXN0IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIHJlc3BvbnNlLiNlcnJvciA9IHsgbWVzc2FnZSwgZXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgY2FsbGVkIHdpdGhpbiBhIFtyZXF1ZXN0LnByb2Nlc3NGdW5jXShGZXRjaFJlcXVlc3QtcHJvY2Vzc0Z1bmMpXG4gICAgICogIGNhbGwsIGNhdXNlcyB0aGUgcmVxdWVzdCB0byByZXRyeSBhcyBpZiB0aHJvdHRsZWQgZm9yICUlc3RhbGwlJVxuICAgICAqICBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgdGhyb3dUaHJvdHRsZUVycm9yKG1lc3NhZ2UsIHN0YWxsKSB7XG4gICAgICAgIGlmIChzdGFsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFsbCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcihzdGFsbCkgJiYgc3RhbGwgPj0gMCwgXCJpbnZhbGlkIHN0YWxsIHRpbWVvdXRcIiwgXCJzdGFsbFwiLCBzdGFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBcInRocm90dGxpbmcgcmVxdWVzdHNcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgc3RhbGwsIHRocm90dGxlOiB0cnVlIH0pO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgaGVhZGVyIHZhbHVlIGZvciAlJWtleSUlLCBpZ25vcmluZyBjYXNlLlxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlc3BvbnNlIGhhcyBhIGJvZHkuXG4gICAgICovXG4gICAgaGFzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlcXVlc3QgbWFkZSBmb3IgdGhpcyByZXNwb25zZS5cbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzdCgpIHsgcmV0dXJuIHRoaXMuI3JlcXVlc3Q7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVzcG9uc2Ugd2FzIGEgc3VjY2VzcyBzdGF0dXNDb2RlLlxuICAgICAqL1xuICAgIG9rKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2Vycm9yLm1lc3NhZ2UgPT09IFwiXCIgJiYgdGhpcy5zdGF0dXNDb2RlID49IDIwMCAmJiB0aGlzLnN0YXR1c0NvZGUgPCAzMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhyb3dzIGEgYGBTRVJWRVJfRVJST1JgYCBpZiB0aGlzIHJlc3BvbnNlIGlzIG5vdCBvay5cbiAgICAgKi9cbiAgICBhc3NlcnRPaygpIHtcbiAgICAgICAgaWYgKHRoaXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1lc3NhZ2UsIGVycm9yIH0gPSB0aGlzLiNlcnJvcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgc2VydmVyIHJlc3BvbnNlICR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0VXJsID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICAgICAgcmVxdWVzdFVybCA9IHRoaXMucmVxdWVzdC51cmw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlQm9keSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYm9keSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlQm9keSA9IHRvVXRmOFN0cmluZyh0aGlzLiNib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgbWVzc2FnZSwgXCJTRVJWRVJfRVJST1JcIiwge1xuICAgICAgICAgICAgcmVxdWVzdDogKHRoaXMucmVxdWVzdCB8fCBcInVua25vd24gcmVxdWVzdFwiKSwgcmVzcG9uc2U6IHRoaXMsIGVycm9yLFxuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RVcmwsIHJlc3BvbnNlQm9keSxcbiAgICAgICAgICAgICAgICByZXNwb25zZVN0YXR1czogYCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5mdW5jdGlvbiB1bnBlcmNlbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdG9VdGY4Qnl0ZXModmFsdWUucmVwbGFjZSgvJShbMC05YS1mXVswLTlhLWZdKS9naSwgKGFsbCwgY29kZSkgPT4ge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxNikpO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/fetch.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/fixednumber.js":
/*!******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/fixednumber.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedNumber: function() { return /* binding */ FixedNumber; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ \"../common/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"../common/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"../common/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties.js */ \"../common/node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\n\n\n\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) {\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while (result.length < decimals) {\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || (val >= -limit && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        if (val > BN_0) {\n            val = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(val, width), width);\n        }\n        else {\n            val = -(0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(-val, width), width);\n        }\n    }\n    else {\n        const limit = (BN_1 << width);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof (value) === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof (value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        }\n        else if (value === \"ufixed\") {\n            signed = false;\n        }\n        else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    }\n    else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue) => {\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (v[key]) === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return { signed, width, decimals, name };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return (negative + str);\n    }\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) {\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n    return (negative + str);\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, a value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nclass FixedNumber {\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    format;\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    _value;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */\n    constructor(guard, value, format) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { format: format.name, _value });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed() { return this.#format.signed; }\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width() { return this.#format.width; }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals() { return this.#format.decimals; }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value() { return this.#val; }\n    #checkFormat(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other) { return this.#add(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other) { return this.#add(other, \"add\"); }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other) { return this.#sub(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other) { return this.#sub(other, \"sub\"); }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other) { return this.#mul(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other) { return this.#mul(other, \"mul\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other) { return this.#div(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other) { return this.#div(other, \"div\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n    cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        }\n        else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n    eq(other) { return this.cmp(other) === 0; }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n    lt(other) { return this.cmp(other) < 0; }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n    lte(other) { return this.cmp(other) <= 0; }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n    gt(other) { return this.cmp(other) > 0; }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n    gte(other) { return this.cmp(other) >= 0; }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero() { return (this.#val === BN_0); }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative() { return (this.#val < BN_0); }\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString() { return this._value; }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value, _decimals, _format) {\n        const decimals = (_decimals == null) ? 0 : (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(_decimals);\n        const format = getFormat(_format);\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        }\n        else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n        // Pad out the decimals\n        while (decimal.length < format.decimals) {\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value, _format) {\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n}\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9maXhlZG51bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBQytCO0FBQ1E7QUFDekI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsbURBQVEsQ0FBQywrQ0FBSTtBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFRLENBQUMsK0NBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCLElBQUksMERBQWM7QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvREFBUztBQUM1RDtBQUNBLG9CQUFvQixvREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtEQUFNO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFRLENBQUMsa0RBQVE7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixtREFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9maXhlZG51bWJlci5qcz9mNDkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSAqKkZpeGVkTnVtYmVyKiogY2xhc3MgcGVybWl0cyB1c2luZyB2YWx1ZXMgd2l0aCBkZWNpbWFsIHBsYWNlcyxcbiAqICB1c2luZyBmaXhlZC1wb250IG1hdGguXG4gKlxuICogIEZpeGVkLXBvaW50IG1hdGggaXMgc3RpbGwgYmFzZWQgb24gaW50ZWdlcnMgdW5kZXItdGhlLWhvb2QsIGJ1dCB1c2VzIGFuXG4gKiAgaW50ZXJuYWwgb2Zmc2V0IHRvIHN0b3JlIGZyYWN0aW9uYWwgY29tcG9uZW50cyBiZWxvdywgYW5kIGVhY2ggb3BlcmF0aW9uXG4gKiAgY29ycmVjdHMgZm9yIHRoaXMgYWZ0ZXIgZWFjaCBvcGVyYXRpb24uXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3V0aWxzL2ZpeGVkLXBvaW50LW1hdGg6Rml4ZWQtUG9pbnQgTWF0aHMgIFthYm91dC1maXhlZC1wb2ludC1tYXRoXVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydFByaXZhdGUgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBmcm9tVHdvcywgbWFzaywgdG9CaWdJbnQgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmNvbnN0IEJOX04xID0gQmlnSW50KC0xKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fNSA9IEJpZ0ludCg1KTtcbmNvbnN0IF9ndWFyZCA9IHt9O1xuLy8gQ29uc3RhbnQgdG8gcHVsbCB6ZXJvcyBmcm9tIGZvciBtdWx0aXBsaWVyc1xubGV0IFplcm9zID0gXCIwMDAwXCI7XG53aGlsZSAoWmVyb3MubGVuZ3RoIDwgODApIHtcbiAgICBaZXJvcyArPSBaZXJvcztcbn1cbi8vIFJldHVybnMgYSBzdHJpbmcgXCIxXCIgZm9sbG93ZWQgYnkgZGVjaW1hbCBcIjBcInNcbmZ1bmN0aW9uIGdldFRlbnMoZGVjaW1hbHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBkZWNpbWFscykge1xuICAgICAgICByZXN1bHQgKz0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KFwiMVwiICsgcmVzdWx0LnN1YnN0cmluZygwLCBkZWNpbWFscykpO1xufVxuZnVuY3Rpb24gY2hlY2tWYWx1ZSh2YWwsIGZvcm1hdCwgc2FmZU9wKSB7XG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZm9ybWF0LndpZHRoKTtcbiAgICBpZiAoZm9ybWF0LnNpZ25lZCkge1xuICAgICAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcbiAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gLWxpbWl0ICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBzYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgPSBmcm9tVHdvcyhtYXNrKHZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSAtZnJvbVR3b3MobWFzaygtdmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCB3aWR0aCk7XG4gICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IDAgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICB9KTtcbiAgICAgICAgdmFsID0gKCgodmFsICUgbGltaXQpICsgbGltaXQpICUgbGltaXQpICYgKGxpbWl0IC0gQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBnZXRGb3JtYXQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdmFsdWUgPSBgZml4ZWQxMjh4JHt2YWx1ZX1gO1xuICAgIH1cbiAgICBsZXQgc2lnbmVkID0gdHJ1ZTtcbiAgICBsZXQgd2lkdGggPSAxMjg7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIFBhcnNlIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0cy4uLlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcInVmaXhlZFwiKSB7XG4gICAgICAgICAgICBzaWduZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUubWF0Y2goL14odT8pZml4ZWQoWzAtOV0rKXgoWzAtOV0rKSQvKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoLCBcImludmFsaWQgZml4ZWQgZm9ybWF0XCIsIFwiZm9ybWF0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHNpZ25lZCA9IChtYXRjaFsxXSAhPT0gXCJ1XCIpO1xuICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgICAgICBkZWNpbWFscyA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAvLyBFeHRyYWN0IHRoZSB2YWx1ZXMgZnJvbSB0aGUgb2JqZWN0XG4gICAgICAgIGNvbnN0IHYgPSB2YWx1ZTtcbiAgICAgICAgY29uc3QgY2hlY2sgPSAoa2V5LCB0eXBlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZba2V5XSkgPT09IHR5cGUsIFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKFwiICsga2V5ICsgXCIgbm90IFwiICsgdHlwZSArIFwiKVwiLCBcImZvcm1hdC5cIiArIGtleSwgdltrZXldKTtcbiAgICAgICAgICAgIHJldHVybiB2W2tleV07XG4gICAgICAgIH07XG4gICAgICAgIHNpZ25lZCA9IGNoZWNrKFwic2lnbmVkXCIsIFwiYm9vbGVhblwiLCBzaWduZWQpO1xuICAgICAgICB3aWR0aCA9IGNoZWNrKFwid2lkdGhcIiwgXCJudW1iZXJcIiwgd2lkdGgpO1xuICAgICAgICBkZWNpbWFscyA9IGNoZWNrKFwiZGVjaW1hbHNcIiwgXCJudW1iZXJcIiwgZGVjaW1hbHMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudCgod2lkdGggJSA4KSA9PT0gMCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHdpZHRoIChub3QgYnl0ZSBhbGlnbmVkKVwiLCBcImZvcm1hdC53aWR0aFwiLCB3aWR0aCk7XG4gICAgYXNzZXJ0QXJndW1lbnQoZGVjaW1hbHMgPD0gODAsIFwiaW52YWxpZCBGaXhlZE51bWJlciBkZWNpbWFscyAodG9vIGxhcmdlKVwiLCBcImZvcm1hdC5kZWNpbWFsc1wiLCBkZWNpbWFscyk7XG4gICAgY29uc3QgbmFtZSA9IChzaWduZWQgPyBcIlwiIDogXCJ1XCIpICsgXCJmaXhlZFwiICsgU3RyaW5nKHdpZHRoKSArIFwieFwiICsgU3RyaW5nKGRlY2ltYWxzKTtcbiAgICByZXR1cm4geyBzaWduZWQsIHdpZHRoLCBkZWNpbWFscywgbmFtZSB9O1xufVxuZnVuY3Rpb24gdG9TdHJpbmcodmFsLCBkZWNpbWFscykge1xuICAgIGxldCBuZWdhdGl2ZSA9IFwiXCI7XG4gICAgaWYgKHZhbCA8IEJOXzApIHtcbiAgICAgICAgbmVnYXRpdmUgPSBcIi1cIjtcbiAgICAgICAgdmFsICo9IEJOX04xO1xuICAgIH1cbiAgICBsZXQgc3RyID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgLy8gTm8gZGVjaW1hbCBwb2ludCBmb3Igd2hvbGUgdmFsdWVzXG4gICAgaWYgKGRlY2ltYWxzID09PSAwKSB7XG4gICAgICAgIHJldHVybiAobmVnYXRpdmUgKyBzdHIpO1xuICAgIH1cbiAgICAvLyBQYWQgb3V0IHRvIHRoZSB3aG9sZSBjb21wb25lbnQgKGluY2x1ZGluZyBhIHdob2xlIGRpZ2l0KVxuICAgIHdoaWxlIChzdHIubGVuZ3RoIDw9IGRlY2ltYWxzKSB7XG4gICAgICAgIHN0ciA9IFplcm9zICsgc3RyO1xuICAgIH1cbiAgICAvLyBJbnNlcnQgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICBjb25zdCBpbmRleCA9IHN0ci5sZW5ndGggLSBkZWNpbWFscztcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGluZGV4KSArIFwiLlwiICsgc3RyLnN1YnN0cmluZyhpbmRleCk7XG4gICAgLy8gVHJpbSB0aGUgd2hvbGUgY29tcG9uZW50IChsZWF2aW5nIGF0IGxlYXN0IG9uZSAwKVxuICAgIHdoaWxlIChzdHJbMF0gPT09IFwiMFwiICYmIHN0clsxXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgLy8gVHJpbSB0aGUgZGVjaW1hbCBjb21wb25lbnQgKGxlYXZpbmcgYXQgbGVhc3Qgb25lIDApXG4gICAgd2hpbGUgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09IFwiMFwiICYmIHN0cltzdHIubGVuZ3RoIC0gMl0gIT09IFwiLlwiKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gKG5lZ2F0aXZlICsgc3RyKTtcbn1cbi8qKlxuICogIEEgRml4ZWROdW1iZXIgcmVwcmVzZW50cyBhIHZhbHVlIG92ZXIgaXRzIFtbRml4ZWRGb3JtYXRdXVxuICogIGFyaXRobWV0aWMgZmllbGQuXG4gKlxuICogIEEgRml4ZWROdW1iZXIgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBtYXRoLCBsb3NzbGVzc2x5LCBvblxuICogIHZhbHVlcyB3aGljaCBoYXZlIGRlY21pYWwgcGxhY2VzLlxuICpcbiAqICBBIEZpeGVkTnVtYmVyIGhhcyBhIGZpeGVkIGJpdC13aWR0aCB0byBzdG9yZSB2YWx1ZXMgaW4sIGFuZCBzdG9yZXMgYWxsXG4gKiAgdmFsdWVzIGludGVybmFsbHkgYnkgbXVsdGlwbHlpbmcgdGhlIHZhbHVlIGJ5IDEwIHJhaXNlZCB0byB0aGUgcG93ZXIgb2ZcbiAqICAlJWRlY2ltYWxzJSUuXG4gKlxuICogIElmIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCB0aGF0IGNhdXNlIGEgdmFsdWUgdG8gZ3JvdyB0b28gaGlnaCAoY2xvc2UgdG9cbiAqICBwb3NpdGl2ZSBpbmZpbml0eSkgb3IgdG9vIGxvdyAoY2xvc2UgdG8gbmVnYXRpdmUgaW5maW5pdHkpLCB0aGUgdmFsdWVcbiAqICBpcyBzYWlkIHRvIC8vb3ZlcmZsb3cvLy5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGFuIDgtYml0IHNpZ25lZCB2YWx1ZSwgd2l0aCAwIGRlY2ltYWxzIG1heSBvbmx5IGJlIHdpdGhpblxuICogIHRoZSByYW5nZSBgYC0xMjhgYCB0byBgYDEyN2BgOyBzbyBgYC0xMjggLSAxYGAgd2lsbCBvdmVyZmxvdyBhbmQgYmVjb21lXG4gKiAgYGAxMjdgYC4gTGlrZXdpc2UsIGBgMTI3ICsgMWBgIHdpbGwgb3ZlcmZsb3cgYW5kIGJlY29tZSBgYC0xMjdgYC5cbiAqXG4gKiAgTWFueSBvcGVyYXRpb24gaGF2ZSBhIG5vcm1hbCBhbmQgLy91bnNhZmUvLyB2YXJpYW50LiBUaGUgbm9ybWFsIHZhcmlhbnRcbiAqICB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIG9uIGFueSBvdmVyZmxvdywgd2hpbGUgdGhlIC8vdW5zYWZlLy9cbiAqICB2YXJpYW50IHdpbGwgc2lsZW50bHkgYWxsb3cgb3ZlcmZsb3csIGNvcnJ1cHRpbmcgaXRzIHZhbHVlIHZhbHVlLlxuICpcbiAqICBJZiBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgdGhhdCBjYXVzZSBhIHZhbHVlIHRvIGJlY29tZSB0b28gc21hbGxcbiAqICAoY2xvc2UgdG8gemVybyksIHRoZSB2YWx1ZSBsb3NlcyBwcmVjaXNvbiBhbmQgaXMgc2FpZCB0byAvL3VuZGVyZmxvdy8vLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgYSB2YWx1ZSB3aXRoIDEgZGVjaW1hbCBwbGFjZSBtYXkgc3RvcmUgYSBudW1iZXIgYXMgc21hbGxcbiAqICBhcyBgYDAuMWBgLCBidXQgdGhlIHZhbHVlIG9mIGBgMC4xIC8gMmBgIGlzIGBgMC4wNWBgLCB3aGljaCBjYW5ub3QgZml0XG4gKiAgaW50byAxIGRlY2ltYWwgcGxhY2UsIHNvIHVuZGVyZmxvdyBvY2N1cnMgd2hpY2ggbWVhbnMgcHJlY2lzaW9uIGlzIGxvc3RcbiAqICBhbmQgdGhlIHZhbHVlIGJlY29tZXMgYGAwYGAuXG4gKlxuICogIFNvbWUgb3BlcmF0aW9ucyBoYXZlIGEgbm9ybWFsIGFuZCAvL3NpZ25hbGxpbmcvLyB2YXJpYW50LiBUaGUgbm9ybWFsXG4gKiAgdmFyaWFudCB3aWxsIHNpbGVudGx5IGlnbm9yZSB1bmRlcmZsb3csIHdoaWxlIHRoZSAvL3NpZ25hbGxpbmcvLyB2YXJpYW50XG4gKiAgd2lsbCB0aG93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIG9uIHVuZGVyZmxvdy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpeGVkTnVtYmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNwZWNpZmljIGZpeGVkLXBvaW50IGFyaXRobWV0aWMgZmllbGQgZm9yIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgZm9ybWF0O1xuICAgICNmb3JtYXQ7XG4gICAgLy8gVGhlIGFjdHVhbCB2YWx1ZSAoYWNjb3VudGluZyBmb3IgZGVjaW1hbHMpXG4gICAgI3ZhbDtcbiAgICAvLyBBIGJhc2UtMTAgdmFsdWUgdG8gbXVsdGlwbGUgdmFsdWVzIGJ5IHRvIG1haW50YWluIHRoZSBtYWduaXR1ZGVcbiAgICAjdGVucztcbiAgICAvKipcbiAgICAgKiAgVGhpcyBpcyBhIHByb3BlcnR5IHNvIGNvbnNvbGUubG9nIHNob3dzIGEgaHVtYW4tbWVhbmluZ2Z1bCB2YWx1ZS5cbiAgICAgKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF92YWx1ZTtcbiAgICAvLyBVc2UgdGhpcyB3aGVuIGNoYW5naW5nIHRoaXMgZmlsZSB0byBnZXQgc29tZSB0eXBpbmcgaW5mbyxcbiAgICAvLyBidXQgdGhlbiBzd2l0Y2ggdG8gYW55IHRvIG1hc2sgdGhlIGludGVybmFsIHR5cGVcbiAgICAvL2NvbnN0cnVjdG9yKGd1YXJkOiBhbnksIHZhbHVlOiBiaWdpbnQsIGZvcm1hdDogX0ZpeGVkRm9ybWF0KSB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkZpeGVkTnVtYmVyXCIpO1xuICAgICAgICB0aGlzLiN2YWwgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy4jZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICBjb25zdCBfdmFsdWUgPSB0b1N0cmluZyh2YWx1ZSwgZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZvcm1hdDogZm9ybWF0Lm5hbWUsIF92YWx1ZSB9KTtcbiAgICAgICAgdGhpcy4jdGVucyA9IGdldFRlbnMoZm9ybWF0LmRlY2ltYWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIHRydWUsIG5lZ2F0aXZlIHZhbHVlcyBhcmUgcGVybWl0dGVkLCBvdGhlcndpc2Ugb25seVxuICAgICAqICBwb3NpdGl2ZSB2YWx1ZXMgYW5kIHplcm8gYXJlIGFsbG93ZWQuXG4gICAgICovXG4gICAgZ2V0IHNpZ25lZCgpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC5zaWduZWQ7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiBiaXRzIGF2YWlsYWJsZSB0byBzdG9yZSB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LndpZHRoOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaW4gdGhlIGZpeGVkLXBvaW50IGFyaXRobWVudCBmaWVsZC5cbiAgICAgKi9cbiAgICBnZXQgZGVjaW1hbHMoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQuZGVjaW1hbHM7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlIGFzIGFuIGludGVnZXIsIGJhc2VkIG9uIHRoZSBzbWFsbGVzdCB1bml0IHRoZVxuICAgICAqICBbW2RlY2ltYWxzXV0gYWxsb3cuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy4jdmFsOyB9XG4gICAgI2NoZWNrRm9ybWF0KG90aGVyKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHRoaXMuZm9ybWF0ID09PSBvdGhlci5mb3JtYXQsIFwiaW5jb21wYXRpYmxlIGZvcm1hdDsgdXNlIGZpeGVkTnVtYmVyLnRvRm9ybWF0XCIsIFwib3RoZXJcIiwgb3RoZXIpO1xuICAgIH1cbiAgICAjY2hlY2tWYWx1ZSh2YWwsIHNhZmVPcCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gLWxpbWl0ICAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogPHN0cmluZz5zYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID4gQk5fMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZnJvbVR3b3MobWFzayh2YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gLWZyb21Ud29zKG1hc2soLXZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFza2VkID0gbWFzayh2YWwsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gMCAmJiB2YWwgPT09IG1hc2tlZCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogPHN0cmluZz5zYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG1hc2tlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIHZhbCA9IGNoZWNrVmFsdWUodmFsLCB0aGlzLiNmb3JtYXQsIHNhZmVPcCk7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWwsIHRoaXMuI2Zvcm1hdCk7XG4gICAgfVxuICAgICNhZGQobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh0aGlzLiN2YWwgKyBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcbiAgICAgKiAgdG8gJSVvdGhlciUlLCBpZ25vcmluZyBvdmVyZmxvdy5cbiAgICAgKi9cbiAgICBhZGRVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2FkZChvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGFkZGVkXG4gICAgICogIHRvICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XG4gICAgICogIG9jY3Vycy5cbiAgICAgKi9cbiAgICBhZGQob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2FkZChvdGhlciwgXCJhZGRcIik7IH1cbiAgICAjc3ViKG8sIHNhZmVPcCkge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodGhpcy4jdmFsIC0gby4jdmFsLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUlb3RoZXIlJSBzdWJ0cmFjdGVkXG4gICAgICogIGZyb20gJSV0aGlzJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxuICAgICAqL1xuICAgIHN1YlVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jc3ViKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSVvdGhlciUlIHN1YnRyYWN0ZWRcbiAgICAgKiAgZnJvbSAlJXRoaXMlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XG4gICAgICogIG9jY3Vycy5cbiAgICAgKi9cbiAgICBzdWIob3RoZXIpIHsgcmV0dXJuIHRoaXMuI3N1YihvdGhlciwgXCJzdWJcIik7IH1cbiAgICAjbXVsKG8sIHNhZmVPcCkge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUoKHRoaXMuI3ZhbCAqIG8uI3ZhbCkgLyB0aGlzLiN0ZW5zLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyBvdmVyZmxvdyBhbmQgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXG4gICAgICovXG4gICAgbXVsVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNtdWwob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBtdWx0aXBsaWVkXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XG4gICAgICogIG9jY3Vycy5cbiAgICAgKi9cbiAgICBtdWwob3RoZXIpIHsgcmV0dXJuIHRoaXMuI211bChvdGhlciwgXCJtdWxcIik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzIG9yIGlmIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpIG9jY3Vycy5cbiAgICAgKi9cbiAgICBtdWxTaWduYWwob3RoZXIpIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZhbCAqIG90aGVyLiN2YWw7XG4gICAgICAgIGFzc2VydCgodmFsdWUgJSB0aGlzLiN0ZW5zKSA9PT0gQk5fMCwgXCJwcmVjaXNpb24gbG9zdCBkdXJpbmcgc2lnbmFsbGluZyBtdWxcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJtdWxTaWduYWxcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh2YWx1ZSAvIHRoaXMuI3RlbnMsIFwibXVsU2lnbmFsXCIpO1xuICAgIH1cbiAgICAjZGl2KG8sIHNhZmVPcCkge1xuICAgICAgICBhc3NlcnQoby4jdmFsICE9PSBCTl8wLCBcImRpdmlzaW9uIGJ5IHplcm9cIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkaXZcIiwgZmF1bHQ6IFwiZGl2aWRlLWJ5LXplcm9cIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogdGhpcy4jdGVucykgLyBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLiBBXG4gICAgICogIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3cgb2NjdXJzLlxuICAgICAqL1xuICAgIGRpdlVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jZGl2KG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLiBBXG4gICAgICogIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3cgb2NjdXJzLlxuICAgICAqL1xuICAgIGRpdihvdGhlcikgeyByZXR1cm4gdGhpcy4jZGl2KG90aGVyLCBcImRpdlwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgZGl2aWRlZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiB1bmRlcmZsb3dcbiAgICAgKiAgKHByZWNpc2lvbiBsb3NzKSBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2U2lnbmFsKG90aGVyKSB7XG4gICAgICAgIGFzc2VydChvdGhlci4jdmFsICE9PSBCTl8wLCBcImRpdmlzaW9uIGJ5IHplcm9cIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkaXZcIiwgZmF1bHQ6IFwiZGl2aWRlLWJ5LXplcm9cIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAodGhpcy4jdmFsICogdGhpcy4jdGVucyk7XG4gICAgICAgIGFzc2VydCgodmFsdWUgJSBvdGhlci4jdmFsKSA9PT0gQk5fMCwgXCJwcmVjaXNpb24gbG9zdCBkdXJpbmcgc2lnbmFsbGluZyBkaXZcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkaXZTaWduYWxcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh2YWx1ZSAvIG90aGVyLiN2YWwsIFwiZGl2U2lnbmFsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGNvbXBhcmlzb24gcmVzdWx0IGJldHdlZW4gJSV0aGlzJSUgYW5kICUlb3RoZXIlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHN1aXRhYmxlIGZvciB1c2UgaW4gc29ydGluZywgd2hlcmUgYGAtMWBgIGltcGxpZXMgJSV0aGlzJSVcbiAgICAgKiAgaXMgc21hbGxlciwgYGAxYGAgaW1wbGllcyAlJXRoaXMlJSBpcyBsYXJnZXIgYW5kIGBgMGBgIGltcGxpZXNcbiAgICAgKiAgYm90aCBhcmUgZXF1YWwuXG4gICAgICovXG4gICAgY21wKG90aGVyKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy52YWx1ZSwgYiA9IG90aGVyLnZhbHVlO1xuICAgICAgICAvLyBDb2VyY2UgYSBhbmQgYiB0byB0aGUgc2FtZSBtYWduaXR1ZGVcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLmRlY2ltYWxzIC0gb3RoZXIuZGVjaW1hbHM7XG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGIgKj0gZ2V0VGVucyhkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICBhICo9IGdldFRlbnMoLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21ucGFyZVxuICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID09PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgbGVzcyB0aGFuIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGx0KG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPCAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGx0ZShvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpIDw9IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBncmVhdGVyIHRoYW4gdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgZ3Qob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA+IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgZ3RlKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPj0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aGljaCBpcyB0aGUgbGFyZ2VzdCAqKmludGVnZXIqKlxuICAgICAqICB0aGF0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVjaW1hbCBjb21wb25lbnQgb2YgdGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBgYDBgYC5cbiAgICAgKi9cbiAgICBmbG9vcigpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXMuI3ZhbDtcbiAgICAgICAgaWYgKHRoaXMuI3ZhbCA8IEJOXzApIHtcbiAgICAgICAgICAgIHZhbCAtPSB0aGlzLiN0ZW5zIC0gQk5fMTtcbiAgICAgICAgfVxuICAgICAgICB2YWwgPSAodGhpcy4jdmFsIC8gdGhpcy4jdGVucykgKiB0aGlzLiN0ZW5zO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh2YWwsIFwiZmxvb3JcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aGljaCBpcyB0aGUgc21hbGxlc3QgKippbnRlZ2VyKipcbiAgICAgKiAgdGhhdCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlY2ltYWwgY29tcG9uZW50IG9mIHRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgYGAwYGAuXG4gICAgICovXG4gICAgY2VpbGluZygpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXMuI3ZhbDtcbiAgICAgICAgaWYgKHRoaXMuI3ZhbCA+IEJOXzApIHtcbiAgICAgICAgICAgIHZhbCArPSB0aGlzLiN0ZW5zIC0gQk5fMTtcbiAgICAgICAgfVxuICAgICAgICB2YWwgPSAodGhpcy4jdmFsIC8gdGhpcy4jdGVucykgKiB0aGlzLiN0ZW5zO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh2YWwsIFwiY2VpbGluZ1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIGRlY2ltYWwgY29tcG9uZW50XG4gICAgICogIHJvdW5kZWQgdXAgb24gdGllcyBhdCAlJWRlY2ltYWxzJSUgcGxhY2VzLlxuICAgICAqL1xuICAgIHJvdW5kKGRlY2ltYWxzKSB7XG4gICAgICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWNpbWFscyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IGVub3VnaCBwcmVjaXNpb24gdG8gbm90IGFscmVhZHkgYmUgcm91bmRlZFxuICAgICAgICBpZiAoZGVjaW1hbHMgPj0gdGhpcy5kZWNpbWFscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLmRlY2ltYWxzIC0gZGVjaW1hbHM7XG4gICAgICAgIGNvbnN0IGJ1bXAgPSBCTl81ICogZ2V0VGVucyhkZWx0YSAtIDEpO1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnZhbHVlICsgYnVtcDtcbiAgICAgICAgY29uc3QgdGVucyA9IGdldFRlbnMoZGVsdGEpO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAvIHRlbnMpICogdGVucztcbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgdGhpcy4jZm9ybWF0LCBcInJvdW5kXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIHRoaXMuI2Zvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgZXF1YWwgdG8gYGAwYGAuXG4gICAgICovXG4gICAgaXNaZXJvKCkgeyByZXR1cm4gKHRoaXMuI3ZhbCA9PT0gQk5fMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGxlc3MgdGhhbiBgYDBgYC5cbiAgICAgKi9cbiAgICBpc05lZ2F0aXZlKCkgeyByZXR1cm4gKHRoaXMuI3ZhbCA8IEJOXzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmbG9hdCBhcHByb3hpbWF0aW9uLlxuICAgICAqXG4gICAgICogIER1ZSB0byBJRUVFIDc1NCBwcmVjaXNzaW9uIChvciBsYWNrIHRoZXJlb2YpLCB0aGlzIGZ1bmN0aW9uXG4gICAgICogIGNhbiBvbmx5IHJldHVybiBhbiBhcHByb3hpbWF0aW9uIGFuZCBtb3N0IHZhbHVlcyB3aWxsIGNvbnRhaW5cbiAgICAgKiAgcm91bmRpbmcgZXJyb3JzLlxuICAgICAqL1xuICAgIHRvVW5zYWZlRmxvYXQoKSB7IHJldHVybiBwYXJzZUZsb2F0KHRoaXMudG9TdHJpbmcoKSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBzYW1lIHZhbHVlIGJ1dCBoYXMgaGFkXG4gICAgICogIGl0cyBmaWVsZCBzZXQgdG8gJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgaWYgdGhlIHZhbHVlIGNhbm5vdCBmaXQgaW50byAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIHRvRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh0aGlzLnRvU3RyaW5nKCksIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSBmb3IgJSV2YWx1ZSUlIGRpdmlkZWQgYnlcbiAgICAgKiAgJSVkZWNpbWFsJSUgcGxhY2VzIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIChvbmNlIGFkanVzdGVkXG4gICAgICogIGZvciAlJWRlY2ltYWxzJSUpIGNhbm5vdCBmaXQgaW4gJSVmb3JtYXQlJSwgZWl0aGVyIGR1ZSB0byBvdmVyZmxvd1xuICAgICAqICBvciB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVZhbHVlKF92YWx1ZSwgX2RlY2ltYWxzLCBfZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IGRlY2ltYWxzID0gKF9kZWNpbWFscyA9PSBudWxsKSA/IDAgOiBnZXROdW1iZXIoX2RlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGRlY2ltYWxzIC0gZm9ybWF0LmRlY2ltYWxzO1xuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW5zID0gZ2V0VGVucyhkZWx0YSk7XG4gICAgICAgICAgICBhc3NlcnQoKHZhbHVlICUgdGVucykgPT09IEJOXzAsIFwidmFsdWUgbG9zZXMgcHJlY2lzaW9uIGZvciBmb3JtYXRcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJvbVZhbHVlXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhbHVlIC89IHRlbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICB2YWx1ZSAqPSBnZXRUZW5zKC1kZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21WYWx1ZVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gZm9yICUldmFsdWUlJSB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSBjYW5ub3QgZml0XG4gICAgICogIGluICUlZm9ybWF0JSUsIGVpdGhlciBkdWUgdG8gb3ZlcmZsb3cgb3IgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJpbmcoX3ZhbHVlLCBfZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gX3ZhbHVlLm1hdGNoKC9eKC0/KShbMC05XSopXFwuPyhbMC05XSopJC8pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChtYXRjaCAmJiAobWF0Y2hbMl0ubGVuZ3RoICsgbWF0Y2hbM10ubGVuZ3RoKSA+IDAsIFwiaW52YWxpZCBGaXhlZE51bWJlciBzdHJpbmcgdmFsdWVcIiwgXCJ2YWx1ZVwiLCBfdmFsdWUpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XG4gICAgICAgIGxldCB3aG9sZSA9IChtYXRjaFsyXSB8fCBcIjBcIiksIGRlY2ltYWwgPSAobWF0Y2hbM10gfHwgXCJcIik7XG4gICAgICAgIC8vIFBhZCBvdXQgdGhlIGRlY2ltYWxzXG4gICAgICAgIHdoaWxlIChkZWNpbWFsLmxlbmd0aCA8IGZvcm1hdC5kZWNpbWFscykge1xuICAgICAgICAgICAgZGVjaW1hbCArPSBaZXJvcztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBwcmVjaXNpb24gaXMgc2FmZVxuICAgICAgICBhc3NlcnQoZGVjaW1hbC5zdWJzdHJpbmcoZm9ybWF0LmRlY2ltYWxzKS5tYXRjaCgvXjAqJC8pLCBcInRvbyBtYW55IGRlY2ltYWxzIGZvciBmb3JtYXRcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tU3RyaW5nXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZW1vdmUgZXh0cmEgcGFkZGluZ1xuICAgICAgICBkZWNpbWFsID0gZGVjaW1hbC5zdWJzdHJpbmcoMCwgZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCaWdJbnQobWF0Y2hbMV0gKyB3aG9sZSArIGRlY2ltYWwpO1xuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgYmlnLWVuZGlhbiByZXByZXNlbnRhdGlvblxuICAgICAqICAlJXZhbHVlJSUgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgY2Fubm90IGZpdFxuICAgICAqICBpbiAlJWZvcm1hdCUlIGR1ZSB0byBvdmVyZmxvdy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKF92YWx1ZSwgX2Zvcm1hdCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0b0JpZ0ludChnZXRCeXRlcyhfdmFsdWUsIFwidmFsdWVcIikpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XG4gICAgICAgIGlmIChmb3JtYXQuc2lnbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZyb21Ud29zKHZhbHVlLCBmb3JtYXQud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tQnl0ZXNcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG59XG4vL2NvbnN0IGYxID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjEyLjU2XCIsIFwiZml4ZWQxNngyXCIpO1xuLy9jb25zdCBmMiA9IEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoXCIwLjNcIiwgXCJmaXhlZDE2eDJcIik7XG4vL2NvbnNvbGUubG9nKGYxLmRpdlNpZ25hbChmMikpO1xuLy9jb25zdCBCVU1QID0gRml4ZWROdW1iZXIuZnJvbShcIjAuNVwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkbnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/fixednumber.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/geturl-browser.js":
/*!*********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/geturl-browser.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGetUrl: function() { return /* binding */ createGetUrl; },\n/* harmony export */   getUrl: function() { return /* binding */ getUrl; }\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"../common/node_modules/ethers/lib.esm/utils/errors.js\");\n\nfunction createGetUrl(options) {\n    async function getUrl(req, _signal) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(_signal == null || !_signal.cancelled, \"request cancelled before sending\", \"CANCELLED\");\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n            info: { protocol },\n            operation: \"request\"\n        });\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n        let error = null;\n        const controller = new AbortController();\n        const timer = setTimeout(() => {\n            error = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"request timeout\", \"TIMEOUT\");\n            controller.abort();\n        }, req.timeout);\n        if (_signal) {\n            _signal.addListener(() => {\n                error = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"request cancelled\", \"CANCELLED\");\n                controller.abort();\n            });\n        }\n        const init = Object.assign({}, options, {\n            method: req.method,\n            headers: new Headers(Array.from(req)),\n            body: req.body || undefined,\n            signal: controller.signal\n        });\n        let resp;\n        try {\n            resp = await fetch(req.url, init);\n        }\n        catch (_error) {\n            clearTimeout(timer);\n            if (error) {\n                throw error;\n            }\n            throw _error;\n        }\n        clearTimeout(timer);\n        const headers = {};\n        resp.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n        const respBody = await resp.arrayBuffer();\n        const body = (respBody == null) ? null : new Uint8Array(respBody);\n        return {\n            statusCode: resp.status,\n            statusMessage: resp.statusText,\n            headers, body\n        };\n    }\n    return getUrl;\n}\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\nasync function getUrl(req, _signal) {\n    return defaultGetUrl(req, _signal);\n}\n//# sourceMappingURL=geturl-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9nZXR1cmwtYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0Q7QUFDekM7QUFDUDtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFFBQVEsa0RBQU0sc0VBQXNFLFNBQVM7QUFDN0Ysb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxTQUFTO0FBQ1QsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBUztBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFTO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixxQ0FBcUM7QUFDOUI7QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZ2V0dXJsLWJyb3dzZXIuanM/NzU1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQsIG1ha2VFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdldFVybChvcHRpb25zKSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgX3NpZ25hbCkge1xuICAgICAgICBhc3NlcnQoX3NpZ25hbCA9PSBudWxsIHx8ICFfc2lnbmFsLmNhbmNlbGxlZCwgXCJyZXF1ZXN0IGNhbmNlbGxlZCBiZWZvcmUgc2VuZGluZ1wiLCBcIkNBTkNFTExFRFwiKTtcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSByZXEudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhc3NlcnQocHJvdG9jb2wgPT09IFwiaHR0cFwiIHx8IHByb3RvY29sID09PSBcImh0dHBzXCIsIGB1bnN1cHBvcnRlZCBwcm90b2NvbCAke3Byb3RvY29sfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIGluZm86IHsgcHJvdG9jb2wgfSxcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGFzc2VydChwcm90b2NvbCA9PT0gXCJodHRwc1wiIHx8ICFyZXEuY3JlZGVudGlhbHMgfHwgcmVxLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiwgXCJpbnNlY3VyZSBhdXRob3JpemVkIGNvbm5lY3Rpb25zIHVuc3VwcG9ydGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXF1ZXN0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBlcnJvciA9IG1ha2VFcnJvcihcInJlcXVlc3QgdGltZW91dFwiLCBcIlRJTUVPVVRcIik7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0sIHJlcS50aW1lb3V0KTtcbiAgICAgICAgaWYgKF9zaWduYWwpIHtcbiAgICAgICAgICAgIF9zaWduYWwuYWRkTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbWFrZUVycm9yKFwicmVxdWVzdCBjYW5jZWxsZWRcIiwgXCJDQU5DRUxMRURcIik7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5pdCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKEFycmF5LmZyb20ocmVxKSksXG4gICAgICAgICAgICBib2R5OiByZXEuYm9keSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3AgPSBhd2FpdCBmZXRjaChyZXEudXJsLCBpbml0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBfZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICByZXNwLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BCb2R5ID0gYXdhaXQgcmVzcC5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBib2R5ID0gKHJlc3BCb2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHJlc3BCb2R5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3Auc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcC5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVycywgYm9keVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0VXJsO1xufVxuLy8gQFRPRE86IHJlbW92ZSBpbiB2NzsgcHJvdmlkZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRcbmNvbnN0IGRlZmF1bHRHZXRVcmwgPSBjcmVhdGVHZXRVcmwoe30pO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVybChyZXEsIF9zaWduYWwpIHtcbiAgICByZXR1cm4gZGVmYXVsdEdldFVybChyZXEsIF9zaWduYWwpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0dXJsLWJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/geturl-browser.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/index.js":
/*!************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: function() { return /* reexport safe */ _events_js__WEBPACK_IMPORTED_MODULE_4__.EventPayload; },\n/* harmony export */   FetchCancelSignal: function() { return /* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_5__.FetchCancelSignal; },\n/* harmony export */   FetchRequest: function() { return /* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest; },\n/* harmony export */   FetchResponse: function() { return /* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_5__.FetchResponse; },\n/* harmony export */   FixedNumber: function() { return /* reexport safe */ _fixednumber_js__WEBPACK_IMPORTED_MODULE_6__.FixedNumber; },\n/* harmony export */   Utf8ErrorFuncs: function() { return /* reexport safe */ _utf8_js__WEBPACK_IMPORTED_MODULE_12__.Utf8ErrorFuncs; },\n/* harmony export */   assert: function() { return /* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.assert; },\n/* harmony export */   assertArgument: function() { return /* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument; },\n/* harmony export */   assertArgumentCount: function() { return /* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.assertArgumentCount; },\n/* harmony export */   assertNormalize: function() { return /* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.assertNormalize; },\n/* harmony export */   assertPrivate: function() { return /* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.assertPrivate; },\n/* harmony export */   concat: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.concat; },\n/* harmony export */   dataLength: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.dataLength; },\n/* harmony export */   dataSlice: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice; },\n/* harmony export */   decodeBase58: function() { return /* reexport safe */ _base58_js__WEBPACK_IMPORTED_MODULE_0__.decodeBase58; },\n/* harmony export */   decodeBase64: function() { return /* reexport safe */ _base64_js__WEBPACK_IMPORTED_MODULE_1__.decodeBase64; },\n/* harmony export */   decodeRlp: function() { return /* reexport safe */ _rlp_decode_js__WEBPACK_IMPORTED_MODULE_9__.decodeRlp; },\n/* harmony export */   defineProperties: function() { return /* reexport safe */ _properties_js__WEBPACK_IMPORTED_MODULE_8__.defineProperties; },\n/* harmony export */   encodeBase58: function() { return /* reexport safe */ _base58_js__WEBPACK_IMPORTED_MODULE_0__.encodeBase58; },\n/* harmony export */   encodeBase64: function() { return /* reexport safe */ _base64_js__WEBPACK_IMPORTED_MODULE_1__.encodeBase64; },\n/* harmony export */   encodeRlp: function() { return /* reexport safe */ _rlp_encode_js__WEBPACK_IMPORTED_MODULE_10__.encodeRlp; },\n/* harmony export */   formatEther: function() { return /* reexport safe */ _units_js__WEBPACK_IMPORTED_MODULE_11__.formatEther; },\n/* harmony export */   formatUnits: function() { return /* reexport safe */ _units_js__WEBPACK_IMPORTED_MODULE_11__.formatUnits; },\n/* harmony export */   fromTwos: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.fromTwos; },\n/* harmony export */   getBigInt: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.getBigInt; },\n/* harmony export */   getBytes: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.getBytes; },\n/* harmony export */   getBytesCopy: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy; },\n/* harmony export */   getNumber: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.getNumber; },\n/* harmony export */   getUint: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.getUint; },\n/* harmony export */   hexlify: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.hexlify; },\n/* harmony export */   isBytesLike: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.isBytesLike; },\n/* harmony export */   isCallException: function() { return /* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.isCallException; },\n/* harmony export */   isError: function() { return /* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.isError; },\n/* harmony export */   isHexString: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.isHexString; },\n/* harmony export */   makeError: function() { return /* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.makeError; },\n/* harmony export */   mask: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.mask; },\n/* harmony export */   parseEther: function() { return /* reexport safe */ _units_js__WEBPACK_IMPORTED_MODULE_11__.parseEther; },\n/* harmony export */   parseUnits: function() { return /* reexport safe */ _units_js__WEBPACK_IMPORTED_MODULE_11__.parseUnits; },\n/* harmony export */   resolveProperties: function() { return /* reexport safe */ _properties_js__WEBPACK_IMPORTED_MODULE_8__.resolveProperties; },\n/* harmony export */   stripZerosLeft: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.stripZerosLeft; },\n/* harmony export */   toBeArray: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toBeArray; },\n/* harmony export */   toBeHex: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toBeHex; },\n/* harmony export */   toBigInt: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toBigInt; },\n/* harmony export */   toNumber: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toNumber; },\n/* harmony export */   toQuantity: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toQuantity; },\n/* harmony export */   toTwos: function() { return /* reexport safe */ _maths_js__WEBPACK_IMPORTED_MODULE_7__.toTwos; },\n/* harmony export */   toUtf8Bytes: function() { return /* reexport safe */ _utf8_js__WEBPACK_IMPORTED_MODULE_12__.toUtf8Bytes; },\n/* harmony export */   toUtf8CodePoints: function() { return /* reexport safe */ _utf8_js__WEBPACK_IMPORTED_MODULE_12__.toUtf8CodePoints; },\n/* harmony export */   toUtf8String: function() { return /* reexport safe */ _utf8_js__WEBPACK_IMPORTED_MODULE_12__.toUtf8String; },\n/* harmony export */   uuidV4: function() { return /* reexport safe */ _uuid_js__WEBPACK_IMPORTED_MODULE_13__.uuidV4; },\n/* harmony export */   zeroPadBytes: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.zeroPadBytes; },\n/* harmony export */   zeroPadValue: function() { return /* reexport safe */ _data_js__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue; }\n/* harmony export */ });\n/* harmony import */ var _base58_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base58.js */ \"../common/node_modules/ethers/lib.esm/utils/base58.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ \"../common/node_modules/ethers/lib.esm/utils/base64-browser.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"../common/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"../common/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ \"../common/node_modules/ethers/lib.esm/utils/events.js\");\n/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fetch.js */ \"../common/node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fixednumber.js */ \"../common/node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./maths.js */ \"../common/node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./properties.js */ \"../common/node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _rlp_decode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rlp-decode.js */ \"../common/node_modules/ethers/lib.esm/utils/rlp-decode.js\");\n/* harmony import */ var _rlp_encode_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rlp-encode.js */ \"../common/node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _units_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./units.js */ \"../common/node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utf8.js */ \"../common/node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _uuid_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./uuid.js */ \"../common/node_modules/ethers/lib.esm/utils/uuid.js\");\n/**\n *  There are many simple utilities required to interact with\n *  Ethereum and to simplify the library, without increasing\n *  the library dependencies for simple functions.\n *\n *  @_section api/utils:Utilities  [about-utils]\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RDtBQUNBO0FBQ3dHO0FBQ2xCO0FBQ3BHO0FBQ2tDO0FBQzlCO0FBQ3dGO0FBQ2pFO0FBQzFCO0FBQ0E7QUFDa0M7QUFDVztBQUN0RDtBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9pbmRleC5qcz82OTAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZXJlIGFyZSBtYW55IHNpbXBsZSB1dGlsaXRpZXMgcmVxdWlyZWQgdG8gaW50ZXJhY3Qgd2l0aFxuICogIEV0aGVyZXVtIGFuZCB0byBzaW1wbGlmeSB0aGUgbGlicmFyeSwgd2l0aG91dCBpbmNyZWFzaW5nXG4gKiAgdGhlIGxpYnJhcnkgZGVwZW5kZW5jaWVzIGZvciBzaW1wbGUgZnVuY3Rpb25zLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzOlV0aWxpdGllcyAgW2Fib3V0LXV0aWxzXVxuICovXG5leHBvcnQgeyBkZWNvZGVCYXNlNTgsIGVuY29kZUJhc2U1OCB9IGZyb20gXCIuL2Jhc2U1OC5qc1wiO1xuZXhwb3J0IHsgZGVjb2RlQmFzZTY0LCBlbmNvZGVCYXNlNjQgfSBmcm9tIFwiLi9iYXNlNjQuanNcIjtcbmV4cG9ydCB7IGdldEJ5dGVzLCBnZXRCeXRlc0NvcHksIGlzSGV4U3RyaW5nLCBpc0J5dGVzTGlrZSwgaGV4bGlmeSwgY29uY2F0LCBkYXRhTGVuZ3RoLCBkYXRhU2xpY2UsIHN0cmlwWmVyb3NMZWZ0LCB6ZXJvUGFkVmFsdWUsIHplcm9QYWRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmV4cG9ydCB7IGlzQ2FsbEV4Y2VwdGlvbiwgaXNFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0QXJndW1lbnRDb3VudCwgYXNzZXJ0UHJpdmF0ZSwgYXNzZXJ0Tm9ybWFsaXplLCBtYWtlRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmV4cG9ydCB7IEV2ZW50UGF5bG9hZCB9IGZyb20gXCIuL2V2ZW50cy5qc1wiO1xuZXhwb3J0IHsgRmV0Y2hSZXF1ZXN0LCBGZXRjaFJlc3BvbnNlLCBGZXRjaENhbmNlbFNpZ25hbCwgfSBmcm9tIFwiLi9mZXRjaC5qc1wiO1xuZXhwb3J0IHsgRml4ZWROdW1iZXIgfSBmcm9tIFwiLi9maXhlZG51bWJlci5qc1wiO1xuZXhwb3J0IHsgZnJvbVR3b3MsIHRvVHdvcywgbWFzaywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGdldFVpbnQsIHRvQmlnSW50LCB0b051bWJlciwgdG9CZUhleCwgdG9CZUFycmF5LCB0b1F1YW50aXR5IH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcbmV4cG9ydCB7IHJlc29sdmVQcm9wZXJ0aWVzLCBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuZXhwb3J0IHsgZGVjb2RlUmxwIH0gZnJvbSBcIi4vcmxwLWRlY29kZS5qc1wiO1xuZXhwb3J0IHsgZW5jb2RlUmxwIH0gZnJvbSBcIi4vcmxwLWVuY29kZS5qc1wiO1xuZXhwb3J0IHsgZm9ybWF0RXRoZXIsIHBhcnNlRXRoZXIsIGZvcm1hdFVuaXRzLCBwYXJzZVVuaXRzIH0gZnJvbSBcIi4vdW5pdHMuanNcIjtcbmV4cG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhDb2RlUG9pbnRzLCB0b1V0ZjhTdHJpbmcsIFV0ZjhFcnJvckZ1bmNzLCB9IGZyb20gXCIuL3V0ZjguanNcIjtcbmV4cG9ydCB7IHV1aWRWNCB9IGZyb20gXCIuL3V1aWQuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/maths.js":
/*!************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/maths.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: function() { return /* binding */ fromTwos; },\n/* harmony export */   getBigInt: function() { return /* binding */ getBigInt; },\n/* harmony export */   getNumber: function() { return /* binding */ getNumber; },\n/* harmony export */   getUint: function() { return /* binding */ getUint; },\n/* harmony export */   mask: function() { return /* binding */ mask; },\n/* harmony export */   toBeArray: function() { return /* binding */ toBeArray; },\n/* harmony export */   toBeHex: function() { return /* binding */ toBeHex; },\n/* harmony export */   toBigInt: function() { return /* binding */ toBigInt; },\n/* harmony export */   toNumber: function() { return /* binding */ toNumber; },\n/* harmony export */   toQuantity: function() { return /* binding */ toQuantity; },\n/* harmony export */   toTwos: function() { return /* binding */ toTwos; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"../common/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"../common/node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nfunction fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nfunction toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = (BN_1 << (width - BN_1));\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    }\n    else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nfunction mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getBigInt(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            }\n            catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nfunction getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nfunction toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getNumber(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            }\n            catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nfunction toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nfunction toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    }\n    else {\n        const width = getNumber(_width, \"width\");\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while (result.length < (width * 2)) {\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nfunction toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nfunction toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) {\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n}\n//# sourceMappingURL=maths.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9tYXRocy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpRDtBQUNJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxJQUFJLGtEQUFNO0FBQ1Y7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQWM7QUFDMUIsWUFBWSwwREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQWMsd0NBQXdDLFVBQVU7QUFDaEY7QUFDQTtBQUNBLElBQUksMERBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxJQUFJLGtEQUFNO0FBQ1Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZLDBEQUFjO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLDBEQUFjO0FBQzFCLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFjLG1DQUFtQyxVQUFVO0FBQzNFO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNLHFEQUFxRCxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixpREFBTyxDQUFDLHFEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9tYXRocy5qcz8wZWRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFNvbWUgbWF0aGVtYXRpYyBvcGVyYXRpb25zLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpNYXRoIEhlbHBlcnMgIFthYm91dC1tYXRoc11cbiAqL1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlc0xpa2UgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbi8vY29uc3QgQk5fTWF4MjU2ID0gKEJOXzEgPDwgQmlnSW50KDI1NikpIC0gQk5fMTtcbi8vIElFRUUgNzU0IHN1cHBvcnQgNTMtYml0cyBvZiBtYW50aXNzYVxuY29uc3QgbWF4VmFsdWUgPSAweDFmZmZmZmZmZmZmZmZmO1xuLyoqXG4gKiAgQ29udmVydCAlJXZhbHVlJSUgZnJvbSBhIHR3b3MtY29tcGxpbWVudCByZXByZXNlbnRhdGlvbiBvZiAlJXdpZHRoJSVcbiAqICBiaXRzIHRvIGl0cyB2YWx1ZS5cbiAqXG4gKiAgSWYgdGhlIGhpZ2hlc3QgYml0IGlzIGBgMWBgLCB0aGUgcmVzdWx0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHdvcyhfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKSk7XG4gICAgYXNzZXJ0KCh2YWx1ZSA+PiB3aWR0aCkgPT09IEJOXzAsIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImZyb21Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICB9KTtcbiAgICAvLyBUb3AgYml0IHNldDsgdHJlYXQgYXMgYSBuZWdhdGl2ZSB2YWx1ZVxuICAgIGlmICh2YWx1ZSA+PiAod2lkdGggLSBCTl8xKSkge1xuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcbiAgICAgICAgcmV0dXJuIC0oKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgQ29udmVydCAlJXZhbHVlJSUgdG8gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2ZcbiAqICAlJXdpZHRoJSUgYml0cy5cbiAqXG4gKiAgVGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBwb3NpdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHdvcyhfdmFsdWUsIF93aWR0aCkge1xuICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKSk7XG4gICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgaWYgKHZhbHVlIDwgQk5fMCkge1xuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDw9IGxpbWl0LCBcInRvbyBsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAoKH52YWx1ZSkgJiBtYXNrKSArIEJOXzE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnQodmFsdWUgPCBsaW1pdCwgXCJ0b28gaGlnaFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqICBNYXNrICUldmFsdWUlJSB3aXRoIGEgYml0bWFzayBvZiAlJWJpdHMlJSBvbmVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFzayhfdmFsdWUsIF9iaXRzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCBiaXRzID0gQmlnSW50KGdldE51bWJlcihfYml0cywgXCJiaXRzXCIpKTtcbiAgICByZXR1cm4gdmFsdWUgJiAoKEJOXzEgPDwgYml0cykgLSBCTl8xKTtcbn1cbi8qKlxuICogIEdldHMgYSBCaWdJbnQgZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXG4gKiAgYSBCaWdJbnQsIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCaWdJbnQodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjogcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSwgXCJ1bmRlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIiAmJiB2YWx1ZVsxXSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1CaWdJbnQodmFsdWUuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBCaWdOdW1iZXJpc2ggc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIEJpZ051bWJlcmlzaCB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyAlJXZhbHVlJSUgYXMgYSBiaWdpbnQsIHZhbGlkYXRpbmcgaXQgaXMgdmFsaWQgYXMgYSBiaWdpbnRcbiAqICB2YWx1ZSBhbmQgdGhhdCBpdCBpcyBwb3NpdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVpbnQodmFsdWUsIG5hbWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXRCaWdJbnQodmFsdWUsIG5hbWUpO1xuICAgIGFzc2VydChyZXN1bHQgPj0gQk5fMCwgXCJ1bnNpZ25lZCB2YWx1ZSBjYW5ub3QgYmUgbmVnYXRpdmVcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgb3BlcmF0aW9uOiBcImdldFVpbnRcIiwgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgTmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLypcbiAqIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZ0ludC4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqIGlzIHRyZWF0ZWQgYXMgQmlnIEVuZGlhbiBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4MFwiO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBOaWJibGVzW3YgPj4gNF07XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ICYgMHgwZl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlKTtcbn1cbi8qKlxuICogIEdldHMgYSAvL251bWJlci8vIGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgLy9udW1iZXIvLywgdGhlbiBhbiBBcmd1bWVudEVycm9yIHdpbGwgYmUgdGhyb3duIGZvciAlJW5hbWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKEJpZ0ludCh2YWx1ZSksIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgbnVtZXJpYyBzdHJpbmc6ICR7ZS5tZXNzYWdlfWAsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgbnVtZXJpYyB2YWx1ZVwiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgbnVtYmVyLiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogIGlzIHRyZWF0ZWQgYXMgQmlnIEVuZGlhbiBkYXRhLiBUaHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBzYWZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gZ2V0TnVtYmVyKHRvQmlnSW50KHZhbHVlKSk7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIGhleHN0cmluZywgb3B0aW9uYWxseSBwYWRkZWQgdG9cbiAqICAlJXdpZHRoJSUgYnl0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JlSGV4KF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIGlmIChfd2lkdGggPT0gbnVsbCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIHZhbHVlIGlzIG9mIGV2ZW4gbGVuZ3RoXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKTtcbiAgICAgICAgYXNzZXJ0KHdpZHRoICogMiA+PSByZXN1bHQubGVuZ3RoLCBgdmFsdWUgZXhjZWVkcyB3aWR0aCAoJHt3aWR0aH0gYnl0ZXMpYCwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b0JlSGV4XCIsXG4gICAgICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLFxuICAgICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUGFkIHRoZSB2YWx1ZSB0byB0aGUgcmVxdWlyZWQgd2lkdGhcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAod2lkdGggKiAyKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmVBcnJheShfdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGlmICh2YWx1ZSA9PT0gQk5fMCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW10pO1xuICAgIH1cbiAgICBsZXQgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiAyO1xuICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludChoZXguc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0hleFN0cmluZ11dIGZvciAlJXZhbHVlJSUgc2FmZSB0byB1c2UgYXMgYSAvL1F1YW50aXR5Ly8uXG4gKlxuICogIEEgLy9RdWFudGl0eS8vIGRvZXMgbm90IGhhdmUgYW5kIGxlYWRpbmcgMCB2YWx1ZXMgdW5sZXNzIHRoZSB2YWx1ZSBpc1xuICogIHRoZSBsaXRlcmFsIHZhbHVlIGAweDBgLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgdXNlZCBmb3IgSlNTT04tUlBDXG4gKiAgbnVtZXJpYyB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1F1YW50aXR5KHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGhleGxpZnkoaXNCeXRlc0xpa2UodmFsdWUpID8gdmFsdWUgOiB0b0JlQXJyYXkodmFsdWUpKS5zdWJzdHJpbmcoMik7XG4gICAgd2hpbGUgKHJlc3VsdC5zdGFydHNXaXRoKFwiMFwiKSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/maths.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/properties.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/properties.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: function() { return /* binding */ defineProperties; },\n/* harmony export */   resolveProperties: function() { return /* binding */ resolveProperties; }\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof (value) === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nasync function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\n    return results.reduce((accum, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nfunction defineProperties(target, values, types) {\n    for (let key in values) {\n        let value = values[key];\n        const type = (types ? types[key] : null);\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n//# sourceMappingURL=properties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9wcm9wZXJ0aWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNEO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwQ0FBMEM7QUFDdkY7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3Byb3BlcnRpZXMuanM/ZTRjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBQcm9wZXJ0eSBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlByb3BlcnRpZXMgIFthYm91dC1wcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXModmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcCgoaykgPT4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlW2tdKSkpO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY3VtW2tleXNbaW5kZXhdXSA9IHY7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqICBBc3NpZ25zIHRoZSAlJXZhbHVlcyUlIHRvICUldGFyZ2V0JSUgYXMgcmVhZC1vbmx5IHZhbHVlcy5cbiAqXG4gKiAgSXQgJSV0eXBlcyUlIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlcyBhcmUgY2hlY2tlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB2YWx1ZXMsIHR5cGVzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgdHlwZSA9ICh0eXBlcyA/IHR5cGVzW2tleV0gOiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/properties.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/rlp-decode.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/rlp-decode.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlp: function() { return /* binding */ decodeRlp; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"../common/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"../common/node_modules/ethers/lib.esm/utils/errors.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while (result.length < 2) {\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length, offset\n        });\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data, length: 0, offset: 1\n    });\n    const checkOffset = (offset) => {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length: data.length, offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlifyByte(data[offset]) };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nfunction decodeRlp(_data) {\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    const decoded = _decode(data, 0);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}\n//# sourceMappingURL=rlp-decode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZGVjb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ29DO0FBQ2lCO0FBQ2hCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFPO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBTztBQUM5QixpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixrREFBUTtBQUN6QjtBQUNBLElBQUksMERBQWM7QUFDbEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1kZWNvZGUuanM/MjM3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGhleGxpZnkgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmZ1bmN0aW9uIGhleGxpZnlCeXRlKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgIGFzc2VydChjaGlsZE9mZnNldCA8PSBvZmZzZXQgKyAxICsgbGVuZ3RoLCBcImNoaWxkIGRhdGEgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbn1cbi8vIHJldHVybnMgeyBjb25zdW1lZDogbnVtYmVyLCByZXN1bHQ6IE9iamVjdCB9XG5mdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGFzc2VydChkYXRhLmxlbmd0aCAhPT0gMCwgXCJkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IDAsIG9mZnNldDogMVxuICAgIH0pO1xuICAgIGNvbnN0IGNoZWNrT2Zmc2V0ID0gKG9mZnNldCkgPT4ge1xuICAgICAgICBhc3NlcnQob2Zmc2V0IDw9IGRhdGEubGVuZ3RoLCBcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGRhdGEsIGxlbmd0aDogZGF0YS5sZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGMwO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4ODApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnlCeXRlKGRhdGFbb2Zmc2V0XSkgfTtcbn1cbi8qKlxuICogIERlY29kZXMgJSVkYXRhJSUgaW50byB0aGUgc3RydWN0dXJlZCBkYXRhIGl0IHJlcHJlc2VudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHAoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCAwKTtcbiAgICBhc3NlcnRBcmd1bWVudChkZWNvZGVkLmNvbnN1bWVkID09PSBkYXRhLmxlbmd0aCwgXCJ1bmV4cGVjdGVkIGp1bmsgYWZ0ZXIgcmxwIHBheWxvYWRcIiwgXCJkYXRhXCIsIF9kYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlZC5yZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZGVjb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/rlp-decode.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/rlp-encode.js":
/*!*****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/rlp-encode.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeRlp: function() { return /* binding */ encodeRlp; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"../common/node_modules/ethers/lib.esm/utils/data.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */\nfunction encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)) {\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}\n//# sourceMappingURL=rlp-encode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZW5jb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrREFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcz8yNzE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfZW5jb2RlKG9iamVjdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5jb25jYXQoX2VuY29kZShjaGlsZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVuc2hpZnQoMHhjMCArIHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aC51bnNoaWZ0KDB4ZjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aC5jb25jYXQocGF5bG9hZCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChnZXRCeXRlcyhvYmplY3QsIFwib2JqZWN0XCIpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuY29uc3QgbmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgRW5jb2RlcyAlJW9iamVjdCUlIGFzIGFuIFJMUC1lbmNvZGVkIFtbRGF0YUhleFN0cmluZ11dLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUmxwKG9iamVjdCkge1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChjb25zdCB2IG9mIF9lbmNvZGUob2JqZWN0KSkge1xuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ID4+IDRdO1xuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ICYgMHhmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC1lbmNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/rlp-encode.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/units.js":
/*!************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/units.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatEther: function() { return /* binding */ formatEther; },\n/* harmony export */   formatUnits: function() { return /* binding */ formatUnits; },\n/* harmony export */   parseEther: function() { return /* binding */ parseEther; },\n/* harmony export */   parseUnits: function() { return /* binding */ parseUnits; }\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"../common/node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fixednumber.js */ \"../common/node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"../common/node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */\n\n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */\nfunction formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\n}\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */\nfunction parseUnits(value, unit) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromString(value, { decimals, width: 512 }).value;\n}\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */\nfunction formatEther(wei) {\n    return formatUnits(wei, 18);\n}\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */\nfunction parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n//# sourceMappingURL=units.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91bml0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZDO0FBQ0U7QUFDUjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFTO0FBQzVCO0FBQ0EsV0FBVyx3REFBVyw4QkFBOEIsc0JBQXNCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBUztBQUM1QjtBQUNBLFdBQVcsd0RBQVcscUJBQXFCLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdW5pdHMuanM/NGUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBNb3N0IGludGVyYWN0aW9ucyB3aXRoIEV0aGVyZXVtIHJlcXVpcmVzIGludGVnZXIgdmFsdWVzLCB3aGljaCB1c2VcbiAqICB0aGUgc21hbGxlc3QgbWFnbml0dWRlIHVuaXQuXG4gKlxuICogIEZvciBleGFtcGxlLCBpbWFnaW5lIGRlYWxpbmcgd2l0aCBkb2xsYXJzIGFuZCBjZW50cy4gU2luY2UgZG9sbGFyc1xuICogIGFyZSBkaXZpc2libGUsIG5vbi1pbnRlZ2VyIHZhbHVlcyBhcmUgcG9zc2libGUsIHN1Y2ggYXMgYGAkMTAuNzdgYC5cbiAqICBCeSB1c2luZyB0aGUgc21hbGxlc3QgaW5kaXZpc2libGUgdW5pdCAoaS5lLiBjZW50cyksIHRoZSB2YWx1ZSBjYW5cbiAqICBiZSBrZXB0IGFzIHRoZSBpbnRlZ2VyIGBgMTA3N2BgLlxuICpcbiAqICBXaGVuIHJlY2VpdmluZyBkZWNpbWFsIGlucHV0IGZyb20gdGhlIHVzZXIgKGFzIGEgZGVjaW1hbCBzdHJpbmcpLFxuICogIHRoZSB2YWx1ZSBzaG91bGQgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXIgYW5kIHdoZW4gc2hvd2luZyBhIHVzZXJcbiAqICBhIHZhbHVlLCB0aGUgaW50ZWdlciB2YWx1ZSBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogIFRoaXMgY3JlYXRlcyBhIGNsZWFyIGRpc3RpbmN0aW9uLCBiZXR3ZWVuIHZhbHVlcyB0byBiZSB1c2VkIGJ5IGNvZGVcbiAqICAoaW50ZWdlcnMpIGFuZCB2YWx1ZXMgdXNlZCBmb3IgZGlzcGxheSBsb2dpYyB0byB1c2VycyAoZGVjaW1hbHMpLlxuICpcbiAqICBUaGUgbmF0aXZlIHVuaXQgaW4gRXRoZXJldW0sIC8vZXRoZXIvLyBpcyBkaXZpc2libGUgdG8gMTggZGVjaW1hbCBwbGFjZXMsXG4gKiAgd2hlcmUgZWFjaCBpbmRpdmlkdWFsIHVuaXQgaXMgY2FsbGVkIGEgLy93ZWkvLy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpVbml0IENvbnZlcnNpb24gIFthYm91dC11bml0c11cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IEZpeGVkTnVtYmVyIH0gZnJvbSBcIi4vZml4ZWRudW1iZXIuanNcIjtcbmltcG9ydCB7IGdldE51bWJlciB9IGZyb20gXCIuL21hdGhzLmpzXCI7XG5jb25zdCBuYW1lcyA9IFtcbiAgICBcIndlaVwiLFxuICAgIFwia3dlaVwiLFxuICAgIFwibXdlaVwiLFxuICAgIFwiZ3dlaVwiLFxuICAgIFwic3phYm9cIixcbiAgICBcImZpbm5leVwiLFxuICAgIFwiZXRoZXJcIixcbl07XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgaW50byBhIC8vZGVjaW1hbCBzdHJpbmcvLywgYXNzdW1pbmcgJSV1bml0JSUgZGVjaW1hbFxuICogIHBsYWNlcy4gVGhlICUldW5pdCUlIG1heSBiZSB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9yIHRoZSBuYW1lIG9mXG4gKiAgYSB1bml0IChlLmcuIGBgXCJnd2VpXCJgYCBmb3IgOSBkZWNpbWFsIHBsYWNlcykuXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VW5pdHModmFsdWUsIHVuaXQpIHtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh1bml0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdCk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAsIFwiaW52YWxpZCB1bml0XCIsIFwidW5pdFwiLCB1bml0KTtcbiAgICAgICAgZGVjaW1hbHMgPSAzICogaW5kZXg7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVuaXQgIT0gbnVsbCkge1xuICAgICAgICBkZWNpbWFscyA9IGdldE51bWJlcih1bml0LCBcInVuaXRcIik7XG4gICAgfVxuICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUodmFsdWUsIGRlY2ltYWxzLCB7IGRlY2ltYWxzLCB3aWR0aDogNTEyIH0pLnRvU3RyaW5nKCk7XG59XG4vKipcbiAqICBDb252ZXJ0cyB0aGUgLy9kZWNpbWFsIHN0cmluZy8vICUldmFsdWUlJSB0byBhIEJpZ0ludCwgYXNzdW1pbmdcbiAqICAlJXVuaXQlJSBkZWNpbWFsIHBsYWNlcy4gVGhlICUldW5pdCUlIG1heSB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiAgb3IgdGhlIG5hbWUgb2YgYSB1bml0IChlLmcuIGBgXCJnd2VpXCJgYCBmb3IgOSBkZWNpbWFsIHBsYWNlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVuaXRzKHZhbHVlLCB1bml0KSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh1bml0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdCk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAsIFwiaW52YWxpZCB1bml0XCIsIFwidW5pdFwiLCB1bml0KTtcbiAgICAgICAgZGVjaW1hbHMgPSAzICogaW5kZXg7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVuaXQgIT0gbnVsbCkge1xuICAgICAgICBkZWNpbWFscyA9IGdldE51bWJlcih1bml0LCBcInVuaXRcIik7XG4gICAgfVxuICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHZhbHVlLCB7IGRlY2ltYWxzLCB3aWR0aDogNTEyIH0pLnZhbHVlO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8gdXNpbmcgMTggZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRFdGhlcih3ZWkpIHtcbiAgICByZXR1cm4gZm9ybWF0VW5pdHMod2VpLCAxOCk7XG59XG4vKipcbiAqICBDb252ZXJ0cyB0aGUgLy9kZWNpbWFsIHN0cmluZy8vICUlZXRoZXIlJSB0byBhIEJpZ0ludCwgdXNpbmcgMThcbiAqICBkZWNpbWFsIHBsYWNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXRoZXIoZXRoZXIpIHtcbiAgICByZXR1cm4gcGFyc2VVbml0cyhldGhlciwgMTgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pdHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/units.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/utf8.js":
/*!***********************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/utf8.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utf8ErrorFuncs: function() { return /* binding */ Utf8ErrorFuncs; },\n/* harmony export */   toUtf8Bytes: function() { return /* binding */ toUtf8Bytes; },\n/* harmony export */   toUtf8CodePoints: function() { return /* binding */ toUtf8CodePoints; },\n/* harmony export */   toUtf8String: function() { return /* binding */ toUtf8String; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"../common/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"../common/node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */\n\n\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (badCodepoint) === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            }\n            else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nfunction toUtf8Bytes(str, form) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (str) === \"string\", \"invalid string value\", \"str\", str);\n    if (form != null) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(i < str.length && ((c2 & 0xfc00) === 0xdc00), \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nfunction toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dGY4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDeUI7QUFDOUQ7QUFDQSxJQUFJLDBEQUFjLHVDQUF1QyxTQUFTLEVBQUUsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLFFBQVEsMERBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0RBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYztBQUNsQjtBQUNBLFFBQVEsMkRBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dGY4LmpzPzk0MjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVXNpbmcgc3RyaW5ncyBpbiBFdGhlcmV1bSAob3IgYW55IHNlY3VyaXR5LWJhc2Qgc3lzdGVtKSByZXF1aXJlc1xuICogIGFkZGl0aW9uYWwgY2FyZS4gVGhlc2UgdXRpbGl0aWVzIGF0dGVtcHQgdG8gbWl0aWdhdGUgc29tZSBvZiB0aGVcbiAqICBzYWZldHkgaXNzdWVzIGFzIHdlbGwgYXMgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byByZWNvdmVyIGFuZCBhbmFseXNlXG4gKiAgc3RyaW5ncy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpTdHJpbmdzIGFuZCBVVEYtOCAgW2Fib3V0LXN0cmluZ3NdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIGFzc2VydE5vcm1hbGl6ZSB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gZXJyb3JGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFwiQkFEX1BSRUZJWFwiIHx8IHJlYXNvbiA9PT0gXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSUlVOXCIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBcIk9WRVJMT05HXCIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChiYWRDb2RlcG9pbnQpID09PSBcIm51bWJlclwiLCBcImludmFsaWQgYmFkIGNvZGUgcG9pbnQgZm9yIHJlcGxhY2VtZW50XCIsIFwiYmFkQ29kZXBvaW50XCIsIGJhZENvZGVwb2ludCk7XG4gICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcbiAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBhcyBpZiBpZ25vcmluZyBlcnJvcnNcbiAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KTtcbn1cbi8qKlxuICogIEEgaGFuZGZ1bCBvZiBwb3B1bGFyLCBidWlsdC1pbiBVVEYtOCBlcnJvciBoYW5kbGluZyBzdHJhdGVnaWVzLlxuICpcbiAqICAqKmBgXCJlcnJvclwiYGAqKiAtIHRocm93cyBvbiBBTlkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSBvclxuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzICh0aGlzIGlzIHRoZSBkZWZhdWx0KVxuICpcbiAqICAqKmBgXCJpZ25vcmVcImBgKiogLSBzaWxlbnRseSBkcm9wcyBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZVxuICogIGFuZCBhY2NlcHRzIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogICoqYGBcInJlcGxhY2VcImBgKiogLSByZXBsYWNlIGFueSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlIHdpdGggdGhlXG4gKiAgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyIChpLmUuIGBgXCJcXFxcdWZmZmRcImBgKSBhbmQgYWNjZXB0c1xuICogIG5vbi1jYW5vbmljYWwgKG92ZXJsb25nKSBjb2RlcG9pbnRzXG4gKlxuICogIEByZXR1cm5zOiBSZWNvcmQ8XCJlcnJvclwiIHwgXCJpZ25vcmVcIiB8IFwicmVwbGFjZVwiLCBVdGY4RXJyb3JGdW5jPlxuICovXG5leHBvcnQgY29uc3QgVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogZXJyb3JGdW5jLFxuICAgIGlnbm9yZTogaWdub3JlRnVuYyxcbiAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xufSk7XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMzU2NDkzL2RlY29kZS11dGYtOC13aXRoLWphdmFzY3JpcHQjMTM2OTE0OTlcbmZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKF9ieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKF9ieXRlcywgXCJieXRlc1wiKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVORVhQRUNURURfQ09OVElOVUVcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiQkFEX1BSRUZJWFwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSUlVOXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiTUlTU0lOR19DT05USU5VRVwiLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9VVF9PRl9SQU5HRVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIlVURjE2X1NVUlJPR0FURVwiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9WRVJMT05HXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBieXRlIHJlcHJlc2VudGF0aW9uIG9mICUlc3RyJSUuXG4gKlxuICogIElmICUlZm9ybSUlIGlzIHNwZWNpZmllZCwgdGhlIHN0cmluZyBpcyBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChzdHIpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgc3RyaW5nIHZhbHVlXCIsIFwic3RyXCIsIHN0cik7XG4gICAgaWYgKGZvcm0gIT0gbnVsbCkge1xuICAgICAgICBhc3NlcnROb3JtYWxpemUoZm9ybSk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpIDwgc3RyLmxlbmd0aCAmJiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSwgXCJpbnZhbGlkIHN1cnJvZ2F0ZSBwYWlyXCIsIFwic3RyXCIsIHN0cik7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cbjtcbi8vZXhwb3J0IFxuZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKChjb2RlUG9pbnQpID0+IHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50ZWQgYnkgdGhlIFVURi04IGRhdGEgJSVieXRlcyUlLlxuICpcbiAqICBXaGVuICUlb25FcnJvciUlIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgaXMgY2FsbGVkIG9uIFVURi04XG4gKiAgZXJyb3JzIGFsbG93aW5nIHJlY292ZXJ5IHVzaW5nIHRoZSBbW1V0ZjhFcnJvckZ1bmNdXSBBUEkuXG4gKiAgKGRlZmF1bHQ6IFtlcnJvcl0oVXRmOEVycm9yRnVuY3MpKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIFVURi04IGNvZGUtcG9pbnRzIGZvciAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtKSB7XG4gICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/utf8.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/utils/uuid.js":
/*!***********************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/utils/uuid.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uuidV4: function() { return /* binding */ uuidV4; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"../common/node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  Explain UUID and link to RFC here.\n *\n *  @_subsection: api/utils:UUID  [about-uuid]\n */\n\n/**\n *  Returns the version 4 [[link-uuid]] for the %%randomBytes%%.\n *\n *  @see: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n */\nfunction uuidV4(randomBytes) {\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(randomBytes, \"randomBytes\");\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    const value = (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n    return [\n        value.substring(2, 10),\n        value.substring(10, 14),\n        value.substring(14, 18),\n        value.substring(18, 22),\n        value.substring(22, 34),\n    ].join(\"-\");\n}\n//# sourceMappingURL=uuid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dWlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQkFBa0Isa0RBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3V1aWQuanM/ZWJiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBFeHBsYWluIFVVSUQgYW5kIGxpbmsgdG8gUkZDIGhlcmUuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOlVVSUQgIFthYm91dC11dWlkXVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSB9IGZyb20gXCIuL2RhdGEuanNcIjtcbi8qKlxuICogIFJldHVybnMgdGhlIHZlcnNpb24gNCBbW2xpbmstdXVpZF1dIGZvciB0aGUgJSVyYW5kb21CeXRlcyUlLlxuICpcbiAqICBAc2VlOiBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHQgKFNlY3Rpb24gNC40KVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXVpZFY0KHJhbmRvbUJ5dGVzKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhyYW5kb21CeXRlcywgXCJyYW5kb21CeXRlc1wiKTtcbiAgICAvLyBTZWN0aW9uOiA0LjEuMzpcbiAgICAvLyAtIHRpbWVfaGlfYW5kX3ZlcnNpb25bMTI6MTZdID0gMGIwMTAwXG4gICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgLy8gU2VjdGlvbiA0LjRcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbNl0gPSAwYjBcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbN10gPSAwYjFcbiAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICBjb25zdCB2YWx1ZSA9IGhleGxpZnkoYnl0ZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygyLCAxMCksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxMCwgMTQpLFxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTQsIDE4KSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDE4LCAyMiksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygyMiwgMzQpLFxuICAgIF0uam9pbihcIi1cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/utils/uuid.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wallet/base-wallet.js":
/*!*******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wallet/base-wallet.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWallet: function() { return /* binding */ BaseWallet; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../hash/index.js */ \"../common/node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _providers_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/index.js */ \"../common/node_modules/ethers/lib.esm/providers/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n\n\n\n\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nclass BaseWallet extends _providers_index_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    address;\n    #signingKey;\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%% is not specified, only offline methods can\n     *  be used.\n     */\n    constructor(privateKey, provider) {\n        super(provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(privateKey && typeof (privateKey.sign) === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n        this.#signingKey = privateKey;\n        const address = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.computeAddress)(this.signingKey.publicKey);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, { address });\n    }\n    // Store private values behind getters to reduce visibility\n    // in console.log\n    /**\n     *  The [[SigningKey]] used for signing payloads.\n     */\n    get signingKey() { return this.#signingKey; }\n    /**\n     *  The private key for this wallet.\n     */\n    get privateKey() { return this.signingKey.privateKey; }\n    async getAddress() { return this.address; }\n    connect(provider) {\n        return new BaseWallet(this.#signingKey, provider);\n    }\n    async signTransaction(tx) {\n        tx = (0,_providers_index_js__WEBPACK_IMPORTED_MODULE_0__.copyRequest)(tx);\n        // Replace any Addressable or ENS name with an address\n        const { to, from } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveProperties)({\n            to: (tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveAddress)(tx.to, this) : undefined),\n            from: (tx.from ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveAddress)(tx.from, this) : undefined)\n        });\n        if (to != null) {\n            tx.to = to;\n        }\n        if (from != null) {\n            tx.from = from;\n        }\n        if (tx.from != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)((tx.from)) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n            delete tx.from;\n        }\n        // Build the transaction\n        const btx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.Transaction.from(tx);\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\n        return btx.serialized;\n    }\n    async signMessage(message) {\n        return this.signMessageSync(message);\n    }\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\n    // all parameters are known?\n    /**\n     *  Returns the signature for %%message%% signed with this wallet.\n     */\n    signMessageSync(message) {\n        return this.signingKey.sign((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_4__.hashMessage)(message)).serialized;\n    }\n    /**\n     *  Returns the Authorization for %%auth%%.\n     */\n    authorizeSync(auth) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof (auth.address) === \"string\", \"invalid address for authorizeSync\", \"auth.address\", auth);\n        const signature = this.signingKey.sign((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_4__.hashAuthorization)(auth));\n        return Object.assign({}, {\n            address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(auth.address),\n            nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(auth.nonce || 0),\n            chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(auth.chainId || 0),\n        }, { signature });\n    }\n    /**\n     *  Resolves to the Authorization for %%auth%%.\n     */\n    async authorize(auth) {\n        auth = Object.assign({}, auth, {\n            address: await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveAddress)(auth.address, this)\n        });\n        return this.authorizeSync(await this.populateAuthorization(auth));\n    }\n    async signTypedData(domain, types, value) {\n        // Populate any ENS names\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_4__.TypedDataEncoder.resolveNames(domain, types, value, async (name) => {\n            // @TODO: this should use resolveName; addresses don't\n            //        need a provider\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"resolveName\",\n                info: { name }\n            });\n            const address = await this.provider.resolveName(name);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n                value: name\n            });\n            return address;\n        });\n        return this.signingKey.sign(_hash_index_js__WEBPACK_IMPORTED_MODULE_4__.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n    }\n}\n//# sourceMappingURL=base-wallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvYmFzZS13YWxsZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlFO0FBQ21CO0FBQ2hCO0FBQ0U7QUFDcUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QiwrREFBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBLHdCQUF3QixxRUFBYztBQUN0QyxRQUFRLGlFQUFnQixTQUFTLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdFQUFXO0FBQ3hCO0FBQ0EsZ0JBQWdCLFdBQVcsUUFBUSxrRUFBaUI7QUFDcEQseUJBQXlCLGlFQUFjO0FBQ3ZDLDZCQUE2QixpRUFBYztBQUMzQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFjLENBQUMsNkRBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyREFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QiwrQ0FBK0MsaUVBQWlCO0FBQ2hFLCtCQUErQjtBQUMvQixxQkFBcUIsNkRBQVU7QUFDL0IsbUJBQW1CLDBEQUFTO0FBQzVCLHFCQUFxQiwwREFBUztBQUM5QixTQUFTLElBQUksV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDJCQUEyQixpRUFBYztBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNERBQWdCO0FBQ2hELG1EQUFtRDtBQUNuRDtBQUNBLFlBQVksdURBQU07QUFDbEI7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0EsWUFBWSx1REFBTTtBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsNERBQWdCO0FBQ3BEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvYmFzZS13YWxsZXQuanM/NDgzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBoYXNoQXV0aG9yaXphdGlvbiwgaGFzaE1lc3NhZ2UsIFR5cGVkRGF0YUVuY29kZXIgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIsIGNvcHlSZXF1ZXN0IH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29tcHV0ZUFkZHJlc3MsIFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBUaGUgKipCYXNlV2FsbGV0KiogaXMgYSBzdHJlYW0tbGluZWQgaW1wbGVtZW50YXRpb24gb2YgYVxuICogIFtbU2lnbmVyXV0gdGhhdCBvcGVyYXRlcyB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFtbV2FsbGV0XV0gY2xhc3MsIGFzIGl0IG9mZmVyc1xuICogIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSBhbmQgc2ltcGxpZmllcyBsb2FkaW5nIGEgdmFyaWV0eVxuICogIG9mIEpTT04gZm9ybWF0cywgTW5lbW9uaWMgUGhyYXNlcywgZXRjLlxuICpcbiAqICBUaGlzIGNsYXNzIG1heSBiZSBvZiB1c2UgZm9yIHRob3NlIGF0dGVtcHRpbmcgdG8gaW1wbGVtZW50XG4gKiAgYSBtaW5pbWFsIFNpZ25lci5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VXYWxsZXQgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogIFRoZSB3YWxsZXQgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgICNzaWduaW5nS2V5O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEJhc2VXYWxsZXQgZm9yICUlcHJpdmF0ZUtleSUlLCBvcHRpb25hbGx5XG4gICAgICogIGNvbm5lY3RlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwcm92aWRlciUlIGlzIG5vdCBzcGVjaWZpZWQsIG9ubHkgb2ZmbGluZSBtZXRob2RzIGNhblxuICAgICAqICBiZSB1c2VkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXksIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHJpdmF0ZUtleSAmJiB0eXBlb2YgKHByaXZhdGVLZXkuc2lnbikgPT09IFwiZnVuY3Rpb25cIiwgXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgdGhpcy4jc2lnbmluZ0tleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcyh0aGlzLnNpZ25pbmdLZXkucHVibGljS2V5KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIC8vIFN0b3JlIHByaXZhdGUgdmFsdWVzIGJlaGluZCBnZXR0ZXJzIHRvIHJlZHVjZSB2aXNpYmlsaXR5XG4gICAgLy8gaW4gY29uc29sZS5sb2dcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbU2lnbmluZ0tleV1dIHVzZWQgZm9yIHNpZ25pbmcgcGF5bG9hZHMuXG4gICAgICovXG4gICAgZ2V0IHNpZ25pbmdLZXkoKSB7IHJldHVybiB0aGlzLiNzaWduaW5nS2V5OyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcml2YXRlIGtleSBmb3IgdGhpcyB3YWxsZXQuXG4gICAgICovXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLnNpZ25pbmdLZXkucHJpdmF0ZUtleTsgfVxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiB0aGlzLmFkZHJlc3M7IH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZVdhbGxldCh0aGlzLiNzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICB0eCA9IGNvcHlSZXF1ZXN0KHR4KTtcbiAgICAgICAgLy8gUmVwbGFjZSBhbnkgQWRkcmVzc2FibGUgb3IgRU5TIG5hbWUgd2l0aCBhbiBhZGRyZXNzXG4gICAgICAgIGNvbnN0IHsgdG8sIGZyb20gfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHRvOiAodHgudG8gPyByZXNvbHZlQWRkcmVzcyh0eC50bywgdGhpcykgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgZnJvbTogKHR4LmZyb20gPyByZXNvbHZlQWRkcmVzcyh0eC5mcm9tLCB0aGlzKSA6IHVuZGVmaW5lZClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0byAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC50byA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGdldEFkZHJlc3MoKHR4LmZyb20pKSA9PT0gdGhpcy5hZGRyZXNzLCBcInRyYW5zYWN0aW9uIGZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInR4LmZyb21cIiwgdHguZnJvbSk7XG4gICAgICAgICAgICBkZWxldGUgdHguZnJvbTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgYnR4ID0gVHJhbnNhY3Rpb24uZnJvbSh0eCk7XG4gICAgICAgIGJ0eC5zaWduYXR1cmUgPSB0aGlzLnNpZ25pbmdLZXkuc2lnbihidHgudW5zaWduZWRIYXNoKTtcbiAgICAgICAgcmV0dXJuIGJ0eC5zZXJpYWxpemVkO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25NZXNzYWdlU3luYyhtZXNzYWdlKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEFkZCBhIHNlY2lhbGl6ZWQgc2lnblR4IGFuZCBzaWduVHlwZWQgc3luYyB0aGF0IGVuZm9yY2VzXG4gICAgLy8gYWxsIHBhcmFtZXRlcnMgYXJlIGtub3duP1xuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzaWduYXR1cmUgZm9yICUlbWVzc2FnZSUlIHNpZ25lZCB3aXRoIHRoaXMgd2FsbGV0LlxuICAgICAqL1xuICAgIHNpZ25NZXNzYWdlU3luYyhtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25pbmdLZXkuc2lnbihoYXNoTWVzc2FnZShtZXNzYWdlKSkuc2VyaWFsaXplZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIEF1dGhvcml6YXRpb24gZm9yICUlYXV0aCUlLlxuICAgICAqL1xuICAgIGF1dGhvcml6ZVN5bmMoYXV0aCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGF1dGguYWRkcmVzcykgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBhZGRyZXNzIGZvciBhdXRob3JpemVTeW5jXCIsIFwiYXV0aC5hZGRyZXNzXCIsIGF1dGgpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLnNpZ25pbmdLZXkuc2lnbihoYXNoQXV0aG9yaXphdGlvbihhdXRoKSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGF1dGguYWRkcmVzcyksXG4gICAgICAgICAgICBub25jZTogZ2V0QmlnSW50KGF1dGgubm9uY2UgfHwgMCksXG4gICAgICAgICAgICBjaGFpbklkOiBnZXRCaWdJbnQoYXV0aC5jaGFpbklkIHx8IDApLFxuICAgICAgICB9LCB7IHNpZ25hdHVyZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBBdXRob3JpemF0aW9uIGZvciAlJWF1dGglJS5cbiAgICAgKi9cbiAgICBhc3luYyBhdXRob3JpemUoYXV0aCkge1xuICAgICAgICBhdXRoID0gT2JqZWN0LmFzc2lnbih7fSwgYXV0aCwge1xuICAgICAgICAgICAgYWRkcmVzczogYXdhaXQgcmVzb2x2ZUFkZHJlc3MoYXV0aC5hZGRyZXNzLCB0aGlzKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aG9yaXplU3luYyhhd2FpdCB0aGlzLnBvcHVsYXRlQXV0aG9yaXphdGlvbihhdXRoKSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lc1xuICAgICAgICBjb25zdCBwb3B1bGF0ZWQgPSBhd2FpdCBUeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgYXN5bmMgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGlzIHNob3VsZCB1c2UgcmVzb2x2ZU5hbWU7IGFkZHJlc3NlcyBkb24ndFxuICAgICAgICAgICAgLy8gICAgICAgIG5lZWQgYSBwcm92aWRlclxuICAgICAgICAgICAgYXNzZXJ0KHRoaXMucHJvdmlkZXIgIT0gbnVsbCwgXCJjYW5ub3QgcmVzb2x2ZSBFTlMgbmFtZXMgd2l0aG91dCBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IG5hbWUgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIGFzc2VydChhZGRyZXNzICE9IG51bGwsIFwidW5jb25maWd1cmVkIEVOUyBuYW1lXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmluZ0tleS5zaWduKFR5cGVkRGF0YUVuY29kZXIuaGFzaChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSkuc2VyaWFsaXplZDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLXdhbGxldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wallet/base-wallet.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wallet/hdwallet.js":
/*!****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wallet/hdwallet.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HDNodeVoidWallet: function() { return /* binding */ HDNodeVoidWallet; },\n/* harmony export */   HDNodeWallet: function() { return /* binding */ HDNodeWallet; },\n/* harmony export */   defaultPath: function() { return /* binding */ defaultPath; },\n/* harmony export */   getAccountPath: function() { return /* binding */ getAccountPath; },\n/* harmony export */   getIndexedAccountPath: function() { return /* binding */ getIndexedAccountPath; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _providers_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../providers/index.js */ \"../common/node_modules/ethers/lib.esm/providers/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../wordlists/lang-en.js */ \"../common/node_modules/ethers/lib.esm/wordlists/lang-en.js\");\n/* harmony import */ var _base_wallet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base-wallet.js */ \"../common/node_modules/ethers/lib.esm/wallet/base-wallet.js\");\n/* harmony import */ var _mnemonic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mnemonic.js */ \"../common/node_modules/ethers/lib.esm/wallet/mnemonic.js\");\n/* harmony import */ var _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-keystore.js */ \"../common/node_modules/ethers/lib.esm/wallet/json-keystore.js\");\n/**\n *  Explain HD Wallets..\n *\n *  @_subsection: api/wallet:HD Wallets  [hd-wallets]\n */\n\n\n\n\n\n\n\n\n/**\n *  The default derivation path for Ethereum HD Nodes. (i.e. ``\"m/44'/60'/0'/0/0\"``)\n */\nconst defaultPath = \"m/44'/60'/0'/0/0\";\n// \"Bitcoin seed\"\nconst MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);\nconst HardenedBit = 0x80000000;\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst Nibbles = \"0123456789abcdef\";\nfunction zpad(value, length) {\n    let result = \"\";\n    while (value) {\n        result = Nibbles[value % 16] + result;\n        value = Math.trunc(value / 16);\n    }\n    while (result.length < length * 2) {\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction encodeBase58Check(_value) {\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_value);\n    const check = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(value)), 0, 4);\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([value, check]);\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.encodeBase58)(bytes);\n}\nconst _guard = {};\nfunction ser_I(index, chainCode, publicKey, privateKey) {\n    const data = new Uint8Array(37);\n    if (index & HardenedBit) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(privateKey != null, \"cannot derive child of neutered node\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"deriveChild\"\n        });\n        // Data = 0x00 || ser_256(k_par)\n        data.set((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(privateKey), 1);\n    }\n    else {\n        // Data = ser_p(point(k_par))\n        data.set((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(publicKey));\n    }\n    // Data += ser_32(i)\n    for (let i = 24; i >= 0; i -= 8) {\n        data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\n    }\n    const I = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.computeHmac)(\"sha512\", chainCode, data));\n    return { IL: I.slice(0, 32), IR: I.slice(32) };\n}\nfunction derivePath(node, path) {\n    const components = path.split(\"/\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(components.length > 0, \"invalid path\", \"path\", path);\n    if (components[0] === \"m\") {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(node.depth === 0, `cannot derive root path (i.e. path starting with \"m/\") for a node at non-zero depth ${node.depth}`, \"path\", path);\n        components.shift();\n    }\n    let result = node;\n    for (let i = 0; i < components.length; i++) {\n        const component = components[i];\n        if (component.match(/^[0-9]+'$/)) {\n            const index = parseInt(component.substring(0, component.length - 1));\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\n            result = result.deriveChild(HardenedBit + index);\n        }\n        else if (component.match(/^[0-9]+$/)) {\n            const index = parseInt(component);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\n            result = result.deriveChild(index);\n        }\n        else {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid path component\", `path[${i}]`, component);\n        }\n    }\n    return result;\n}\n/**\n *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived\n *  from an HD Node using the [[link-bip-32]] stantard.\n *\n *  An HD Node forms a hierarchal structure with each HD Node having a\n *  private key and the ability to derive child HD Nodes, defined by\n *  a path indicating the index of each child.\n */\nclass HDNodeWallet extends _base_wallet_js__WEBPACK_IMPORTED_MODULE_2__.BaseWallet {\n    /**\n     *  The compressed public key.\n     */\n    publicKey;\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    fingerprint;\n    /**\n     *  The parent fingerprint.\n     */\n    parentFingerprint;\n    /**\n     *  The mnemonic used to create this HD Node, if available.\n     *\n     *  Sources such as extended keys do not encode the mnemonic, in\n     *  which case this will be ``null``.\n     */\n    mnemonic;\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    chainCode;\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provide full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  encode it.\n     */\n    path;\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    index;\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    depth;\n    /**\n     *  @private\n     */\n    constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {\n        super(signingKey, provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"HDNodeWallet\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { publicKey: signingKey.compressedPublicKey });\n        const fingerprint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.ripemd160)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(this.publicKey)), 0, 4);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            parentFingerprint, fingerprint,\n            chainCode, path, index, depth\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { mnemonic });\n    }\n    connect(provider) {\n        return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\n    }\n    #account() {\n        const account = { address: this.address, privateKey: this.privateKey };\n        const m = this.mnemonic;\n        if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\n            account.mnemonic = {\n                path: this.path,\n                locale: \"en\",\n                entropy: m.entropy\n            };\n        }\n        return account;\n    }\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */\n    async encrypt(password, progressCallback) {\n        return await (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.encryptKeystoreJson)(this.#account(), password, { progressCallback });\n    }\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */\n    encryptSync(password) {\n        return (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.encryptKeystoreJsonSync)(this.#account(), password);\n    }\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpriv`` and can be used to\n     *  reconstruct this HD Node to derive its children.\n     */\n    get extendedKey() {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", { operation: \"extendedKey\" });\n        return encodeBase58Check((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x0488ADE4\", zpad(this.depth, 1), this.parentFingerprint,\n            zpad(this.index, 4), this.chainCode,\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\"0x00\", this.privateKey])\n        ]));\n    }\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */\n    hasPath() { return (this.path != null); }\n    /**\n     *  Returns a neutered HD Node, which removes the private details\n     *  of an HD Node.\n     *\n     *  A neutered node has no private key, but can be used to derive\n     *  child addresses and other public data about the HD Node.\n     */\n    neuter() {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);\n    }\n    /**\n     *  Return the child for %%index%%.\n     */\n    deriveChild(_index) {\n        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(_index, \"index\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) {\n                path += \"'\";\n            }\n        }\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);\n        const ki = new _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeHex)(((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt)(IL) + BigInt(this.privateKey)) % N, 32));\n        return new HDNodeWallet(_guard, ki, this.fingerprint, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(IR), path, index, this.depth + 1, this.mnemonic, this.provider);\n    }\n    /**\n     *  Return the HDNode for %%path%% from this node.\n     */\n    derivePath(path) {\n        return derivePath(this, path);\n    }\n    static #fromSeed(_seed, mnemonic) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\");\n        const seed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_seed, \"seed\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(seed.length >= 16 && seed.length <= 64, \"invalid seed\", \"seed\", \"[REDACTED]\");\n        const I = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.computeHmac)(\"sha512\", MasterSecret, seed));\n        const signingKey = new _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(I.slice(0, 32)));\n        return new HDNodeWallet(_guard, signingKey, \"0x00000000\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(I.slice(32)), \"m\", 0, 0, mnemonic, null);\n    }\n    /**\n     *  Creates a new HD Node from %%extendedKey%%.\n     *\n     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or\n     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])\n     *  or full HD Node ([[HDNodeWallet) respectively.\n     */\n    static fromExtendedKey(extendedKey) {\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.decodeBase58)(extendedKey)); // @TODO: redact\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, \"invalid extended key\", \"extendedKey\", \"[ REDACTED ]\");\n        const depth = bytes[4];\n        const parentFingerprint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(5, 9));\n        const index = parseInt((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n        switch ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\":\n            case \"0x043587cf\": {\n                const publicKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(key);\n                return new HDNodeVoidWallet(_guard, (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);\n            }\n            // Private Key\n            case \"0x0488ade4\":\n            case \"0x04358394 \":\n                if (key[0] !== 0) {\n                    break;\n                }\n                return new HDNodeWallet(_guard, new _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid extended key prefix\", \"extendedKey\", \"[ REDACTED ]\");\n    }\n    /**\n     *  Creates a new random HDNode.\n     */\n    static createRandom(password, path, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (path == null) {\n            path = defaultPath;\n        }\n        if (wordlist == null) {\n            wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_5__.LangEn.wordlist();\n        }\n        const mnemonic = _mnemonic_js__WEBPACK_IMPORTED_MODULE_6__.Mnemonic.fromEntropy((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(16), password, wordlist);\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Create an HD Node from %%mnemonic%%.\n     */\n    static fromMnemonic(mnemonic, path) {\n        if (!path) {\n            path = defaultPath;\n        }\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Creates an HD Node from a mnemonic %%phrase%%.\n     */\n    static fromPhrase(phrase, password, path, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (path == null) {\n            path = defaultPath;\n        }\n        if (wordlist == null) {\n            wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_5__.LangEn.wordlist();\n        }\n        const mnemonic = _mnemonic_js__WEBPACK_IMPORTED_MODULE_6__.Mnemonic.fromPhrase(phrase, password, wordlist);\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Creates an HD Node from a %%seed%%.\n     */\n    static fromSeed(seed) {\n        return HDNodeWallet.#fromSeed(seed, null);\n    }\n}\n/**\n *  A **HDNodeVoidWallet** cannot sign, but provides access to\n *  the children nodes of a [[link-bip-32]] HD wallet addresses.\n *\n *  The can be created by using an extended ``xpub`` key to\n *  [[HDNodeWallet_fromExtendedKey]] or by\n *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].\n */\nclass HDNodeVoidWallet extends _providers_index_js__WEBPACK_IMPORTED_MODULE_7__.VoidSigner {\n    /**\n     *  The compressed public key.\n     */\n    publicKey;\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    fingerprint;\n    /**\n     *  The parent node fingerprint.\n     */\n    parentFingerprint;\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    chainCode;\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provider full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  enocde it.\n     */\n    path;\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    index;\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    depth;\n    /**\n     *  @private\n     */\n    constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {\n        super(address, provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"HDNodeVoidWallet\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { publicKey });\n        const fingerprint = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.ripemd160)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(publicKey)), 0, 4);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            publicKey, fingerprint, parentFingerprint, chainCode, path, index, depth\n        });\n    }\n    connect(provider) {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\n    }\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpub`` and can be used to\n     *  reconstruct this neutered key to derive its children addresses.\n     */\n    get extendedKey() {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", { operation: \"extendedKey\" });\n        return encodeBase58Check((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x0488B21E\",\n            zpad(this.depth, 1),\n            this.parentFingerprint,\n            zpad(this.index, 4),\n            this.chainCode,\n            this.publicKey,\n        ]));\n    }\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */\n    hasPath() { return (this.path != null); }\n    /**\n     *  Return the child for %%index%%.\n     */\n    deriveChild(_index) {\n        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(_index, \"index\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) {\n                path += \"'\";\n            }\n        }\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);\n        const Ki = _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey.addPoints(IL, this.publicKey, true);\n        const address = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.computeAddress)(Ki);\n        return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(IR), path, index, this.depth + 1, this.provider);\n    }\n    /**\n     *  Return the signer for %%path%% from this node.\n     */\n    derivePath(path) {\n        return derivePath(this, path);\n    }\n}\n/*\nexport class HDNodeWalletManager {\n    #root: HDNodeWallet;\n\n    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = \"m/44'/60'/0'/0\"; }\n        if (locale == null) { locale = LangEn.wordlist(); }\n        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);\n    }\n\n    getSigner(index?: number): HDNodeWallet {\n        return this.#root.deriveChild((index == null) ? 0: index);\n    }\n}\n*/\n/**\n *  Returns the [[link-bip-32]] path for the account at %%index%%.\n *\n *  This is the pattern used by wallets like Ledger.\n *\n *  There is also an [alternate pattern](getIndexedAccountPath) used by\n *  some software.\n */\nfunction getAccountPath(_index) {\n    const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(_index, \"index\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/${index}'/0/0`;\n}\n/**\n *  Returns the path using an alternative pattern for deriving accounts,\n *  at %%index%%.\n *\n *  This derivation path uses the //index// component rather than the\n *  //account// component to derive sequential accounts.\n *\n *  This is the pattern used by wallets like MetaMask.\n */\nfunction getIndexedAccountPath(_index) {\n    const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(_index, \"index\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/0'/0/${index}`;\n}\n//# sourceMappingURL=hdwallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvaGR3YWxsZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkY7QUFDMUM7QUFDTTtBQUMySjtBQUNuSztBQUNIO0FBQ0w7QUFDMEM7QUFDbkY7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlEQUFRO0FBQzFCLGtCQUFrQiwwREFBUyxDQUFDLHdEQUFNLENBQUMsd0RBQU07QUFDekMsa0JBQWtCLHVEQUFNO0FBQ3hCLFdBQVcsNkRBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBLGlCQUFpQix5REFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQVE7QUFDekI7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxjQUFjLHlEQUFRLENBQUMsNkRBQVc7QUFDbEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQSxRQUFRLCtEQUFjLDBHQUEwRyxXQUFXO0FBQzNJO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYyxvREFBb0QsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWMsb0RBQW9ELEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBYywwQ0FBMEMsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsdURBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBYTtBQUNyQixRQUFRLGlFQUFnQixTQUFTLDJDQUEyQztBQUM1RSw0QkFBNEIsMERBQVMsQ0FBQywyREFBUyxDQUFDLHdEQUFNO0FBQ3RELFFBQVEsaUVBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSxpRUFBZ0IsU0FBUyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNFQUFtQiw4QkFBOEIsa0JBQWtCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEVBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTSxnRUFBZ0UsMEJBQTBCO0FBQ3hHLGlDQUFpQyx1REFBTTtBQUN2QztBQUNBO0FBQ0EsWUFBWSx1REFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBUztBQUMvQixRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6Qix1QkFBdUIsd0RBQVUsQ0FBQyx3REFBTyxFQUFFLHlEQUFRO0FBQ25ELDhEQUE4RCx3REFBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYyxDQUFDLDREQUFXO0FBQ2xDLHFCQUFxQix5REFBUTtBQUM3QixRQUFRLCtEQUFjO0FBQ3RCLGtCQUFrQix5REFBUSxDQUFDLDZEQUFXO0FBQ3RDLCtCQUErQix3REFBVSxDQUFDLHdEQUFPO0FBQ2pELGtFQUFrRSx3REFBTztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQVMsQ0FBQyw2REFBWSxnQkFBZ0I7QUFDNUQsUUFBUSwrREFBYztBQUN0QjtBQUNBLGtDQUFrQyx3REFBTztBQUN6QywrQkFBK0Isd0RBQU87QUFDdEMsMEJBQTBCLHdEQUFPO0FBQ2pDO0FBQ0EsZ0JBQWdCLHdEQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3REFBTztBQUN6QyxvREFBb0QscUVBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsd0RBQVU7QUFDOUQ7QUFDQSxRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBTTtBQUM3QjtBQUNBLHlCQUF5QixrREFBUSxhQUFhLDZEQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFNO0FBQzdCO0FBQ0EseUJBQXlCLGtEQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMkRBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQWE7QUFDckIsUUFBUSxpRUFBZ0IsU0FBUyxXQUFXO0FBQzVDLDRCQUE0QiwwREFBUyxDQUFDLDJEQUFTLENBQUMsd0RBQU07QUFDdEQsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFNLGdFQUFnRSwwQkFBMEI7QUFDeEcsaUNBQWlDLHVEQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBUztBQUMvQixRQUFRLCtEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixtQkFBbUIsd0RBQVU7QUFDN0Isd0JBQXdCLHFFQUFjO0FBQ3RDLDJFQUEyRSx3REFBTztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLDBEQUFTO0FBQzNCLElBQUksK0RBQWM7QUFDbEIsd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtCQUFrQiwwREFBUztBQUMzQixJQUFJLCtEQUFjO0FBQ2xCLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L2hkd2FsbGV0LmpzP2M3NDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRXhwbGFpbiBIRCBXYWxsZXRzLi5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvd2FsbGV0OkhEIFdhbGxldHMgIFtoZC13YWxsZXRzXVxuICovXG5pbXBvcnQgeyBjb21wdXRlSG1hYywgcmFuZG9tQnl0ZXMsIHJpcGVtZDE2MCwgU2lnbmluZ0tleSwgc2hhMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVm9pZFNpZ25lciB9IGZyb20gXCIuLi9wcm92aWRlcnMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbXB1dGVBZGRyZXNzIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZGVjb2RlQmFzZTU4LCBkZWZpbmVQcm9wZXJ0aWVzLCBlbmNvZGVCYXNlNTgsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSwgZ2V0TnVtYmVyLCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b0JlSGV4LCBhc3NlcnRQcml2YXRlLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBMYW5nRW4gfSBmcm9tIFwiLi4vd29yZGxpc3RzL2xhbmctZW4uanNcIjtcbmltcG9ydCB7IEJhc2VXYWxsZXQgfSBmcm9tIFwiLi9iYXNlLXdhbGxldC5qc1wiO1xuaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tIFwiLi9tbmVtb25pYy5qc1wiO1xuaW1wb3J0IHsgZW5jcnlwdEtleXN0b3JlSnNvbiwgZW5jcnlwdEtleXN0b3JlSnNvblN5bmMsIH0gZnJvbSBcIi4vanNvbi1rZXlzdG9yZS5qc1wiO1xuLyoqXG4gKiAgVGhlIGRlZmF1bHQgZGVyaXZhdGlvbiBwYXRoIGZvciBFdGhlcmV1bSBIRCBOb2Rlcy4gKGkuZS4gYGBcIm0vNDQnLzYwJy8wJy8wLzBcImBgKVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFBhdGggPSBcIm0vNDQnLzYwJy8wJy8wLzBcIjtcbi8vIFwiQml0Y29pbiBzZWVkXCJcbmNvbnN0IE1hc3RlclNlY3JldCA9IG5ldyBVaW50OEFycmF5KFs2NiwgMTA1LCAxMTYsIDk5LCAxMTEsIDEwNSwgMTEwLCAzMiwgMTE1LCAxMDEsIDEwMSwgMTAwXSk7XG5jb25zdCBIYXJkZW5lZEJpdCA9IDB4ODAwMDAwMDA7XG5jb25zdCBOID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxXCIpO1xuY29uc3QgTmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuZnVuY3Rpb24genBhZCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdCA9IE5pYmJsZXNbdmFsdWUgJSAxNl0gKyByZXN1bHQ7XG4gICAgICAgIHZhbHVlID0gTWF0aC50cnVuYyh2YWx1ZSAvIDE2KTtcbiAgICB9XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBsZW5ndGggKiAyKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gZW5jb2RlQmFzZTU4Q2hlY2soX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRCeXRlcyhfdmFsdWUpO1xuICAgIGNvbnN0IGNoZWNrID0gZGF0YVNsaWNlKHNoYTI1NihzaGEyNTYodmFsdWUpKSwgMCwgNCk7XG4gICAgY29uc3QgYnl0ZXMgPSBjb25jYXQoW3ZhbHVlLCBjaGVja10pO1xuICAgIHJldHVybiBlbmNvZGVCYXNlNTgoYnl0ZXMpO1xufVxuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiBzZXJfSShpbmRleCwgY2hhaW5Db2RlLCBwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoMzcpO1xuICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XG4gICAgICAgIGFzc2VydChwcml2YXRlS2V5ICE9IG51bGwsIFwiY2Fubm90IGRlcml2ZSBjaGlsZCBvZiBuZXV0ZXJlZCBub2RlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkZXJpdmVDaGlsZFwiXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEYXRhID0gMHgwMCB8fCBzZXJfMjU2KGtfcGFyKVxuICAgICAgICBkYXRhLnNldChnZXRCeXRlcyhwcml2YXRlS2V5KSwgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEYXRhID0gc2VyX3AocG9pbnQoa19wYXIpKVxuICAgICAgICBkYXRhLnNldChnZXRCeXRlcyhwdWJsaWNLZXkpKTtcbiAgICB9XG4gICAgLy8gRGF0YSArPSBzZXJfMzIoaSlcbiAgICBmb3IgKGxldCBpID0gMjQ7IGkgPj0gMDsgaSAtPSA4KSB7XG4gICAgICAgIGRhdGFbMzMgKyAoaSA+PiAzKV0gPSAoKGluZGV4ID4+ICgyNCAtIGkpKSAmIDB4ZmYpO1xuICAgIH1cbiAgICBjb25zdCBJID0gZ2V0Qnl0ZXMoY29tcHV0ZUhtYWMoXCJzaGE1MTJcIiwgY2hhaW5Db2RlLCBkYXRhKSk7XG4gICAgcmV0dXJuIHsgSUw6IEkuc2xpY2UoMCwgMzIpLCBJUjogSS5zbGljZSgzMikgfTtcbn1cbmZ1bmN0aW9uIGRlcml2ZVBhdGgobm9kZSwgcGF0aCkge1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICBhc3NlcnRBcmd1bWVudChjb21wb25lbnRzLmxlbmd0aCA+IDAsIFwiaW52YWxpZCBwYXRoXCIsIFwicGF0aFwiLCBwYXRoKTtcbiAgICBpZiAoY29tcG9uZW50c1swXSA9PT0gXCJtXCIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobm9kZS5kZXB0aCA9PT0gMCwgYGNhbm5vdCBkZXJpdmUgcm9vdCBwYXRoIChpLmUuIHBhdGggc3RhcnRpbmcgd2l0aCBcIm0vXCIpIGZvciBhIG5vZGUgYXQgbm9uLXplcm8gZGVwdGggJHtub2RlLmRlcHRofWAsIFwicGF0aFwiLCBwYXRoKTtcbiAgICAgICAgY29tcG9uZW50cy5zaGlmdCgpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gbm9kZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5tYXRjaCgvXlswLTldKyckLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoY29tcG9uZW50LnN1YnN0cmluZygwLCBjb21wb25lbnQubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIHBhdGggaW5kZXhcIiwgYHBhdGhbJHtpfV1gLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRlcml2ZUNoaWxkKEhhcmRlbmVkQml0ICsgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIHBhdGggaW5kZXhcIiwgYHBhdGhbJHtpfV1gLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRlcml2ZUNoaWxkKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgcGF0aCBjb21wb25lbnRcIiwgYHBhdGhbJHtpfV1gLCBjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBBbiAqKkhETm9kZVdhbGxldCoqIGlzIGEgW1tTaWduZXJdXSBiYWNrZWQgYnkgdGhlIHByaXZhdGUga2V5IGRlcml2ZWRcbiAqICBmcm9tIGFuIEhEIE5vZGUgdXNpbmcgdGhlIFtbbGluay1iaXAtMzJdXSBzdGFudGFyZC5cbiAqXG4gKiAgQW4gSEQgTm9kZSBmb3JtcyBhIGhpZXJhcmNoYWwgc3RydWN0dXJlIHdpdGggZWFjaCBIRCBOb2RlIGhhdmluZyBhXG4gKiAgcHJpdmF0ZSBrZXkgYW5kIHRoZSBhYmlsaXR5IHRvIGRlcml2ZSBjaGlsZCBIRCBOb2RlcywgZGVmaW5lZCBieVxuICogIGEgcGF0aCBpbmRpY2F0aW5nIHRoZSBpbmRleCBvZiBlYWNoIGNoaWxkLlxuICovXG5leHBvcnQgY2xhc3MgSEROb2RlV2FsbGV0IGV4dGVuZHMgQmFzZVdhbGxldCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICovXG4gICAgcHVibGljS2V5O1xuICAgIC8qKlxuICAgICAqICBUaGUgZmluZ2VycHJpbnQuXG4gICAgICpcbiAgICAgKiAgQSBmaW5nZXJwcmludCBhbGxvd3MgcXVpY2sgcWF5IHRvIGRldGVjdCBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzLFxuICAgICAqICBidXQgZGV2ZWxvcGVycyBzaG91bGQgYmUgcHJlcGFyZWQgdG8gZGVhbCB3aXRoIGNvbGxpc2lvbnMgYXMgaXRcbiAgICAgKiAgaXMgb25seSA0IGJ5dGVzLlxuICAgICAqL1xuICAgIGZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFyZW50IGZpbmdlcnByaW50LlxuICAgICAqL1xuICAgIHBhcmVudEZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbW5lbW9uaWMgdXNlZCB0byBjcmVhdGUgdGhpcyBIRCBOb2RlLCBpZiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiAgU291cmNlcyBzdWNoIGFzIGV4dGVuZGVkIGtleXMgZG8gbm90IGVuY29kZSB0aGUgbW5lbW9uaWMsIGluXG4gICAgICogIHdoaWNoIGNhc2UgdGhpcyB3aWxsIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIG1uZW1vbmljO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW5jb2RlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhIHB1YmxpYyBrZXkgdXNlZFxuICAgICAqICB0byBkZXJpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY2hhaW5Db2RlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVyaXZhdGlvbiBwYXRoIG9mIHRoaXMgd2FsbGV0LlxuICAgICAqXG4gICAgICogIFNpbmNlIGV4dGVuZGVkIGtleXMgZG8gbm90IHByb3ZpZGUgZnVsbCBwYXRoIGRldGFpbHMsIHRoaXNcbiAgICAgKiAgbWF5IGJlIGBgbnVsbGBgLCBpZiBpbnN0YW50aWF0ZWQgZnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90XG4gICAgICogIGVuY29kZSBpdC5cbiAgICAgKi9cbiAgICBwYXRoO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hpbGQgaW5kZXggb2YgdGhpcyB3YWxsZXQuIFZhbHVlcyBvdmVyIGBgMiAqXFwqIDMxYGAgaW5kaWNhdGVcbiAgICAgKiAgdGhlIG5vZGUgaXMgaGFyZGVuZWQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXB0aCBvZiB0aGlzIHdhbGxldCwgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXG4gICAgICogIGluIGl0cyBwYXRoLlxuICAgICAqL1xuICAgIGRlcHRoO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBzaWduaW5nS2V5LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGgsIG1uZW1vbmljLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJIRE5vZGVXYWxsZXRcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwdWJsaWNLZXk6IHNpZ25pbmdLZXkuY29tcHJlc3NlZFB1YmxpY0tleSB9KTtcbiAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSBkYXRhU2xpY2UocmlwZW1kMTYwKHNoYTI1Nih0aGlzLnB1YmxpY0tleSkpLCAwLCA0KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludCwgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aFxuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG1uZW1vbmljIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlV2FsbGV0KF9ndWFyZCwgdGhpcy5zaWduaW5nS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wYXRoLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCB0aGlzLm1uZW1vbmljLCBwcm92aWRlcik7XG4gICAgfVxuICAgICNhY2NvdW50KCkge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsIHByaXZhdGVLZXk6IHRoaXMucHJpdmF0ZUtleSB9O1xuICAgICAgICBjb25zdCBtID0gdGhpcy5tbmVtb25pYztcbiAgICAgICAgaWYgKHRoaXMucGF0aCAmJiBtICYmIG0ud29yZGxpc3QubG9jYWxlID09PSBcImVuXCIgJiYgbS5wYXNzd29yZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgYWNjb3VudC5tbmVtb25pYyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBcImVuXCIsXG4gICAgICAgICAgICAgICAgZW50cm9weTogbS5lbnRyb3B5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwdGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIElmICUlcHJvZ3Jlc3NDYWxsYmFjayUlIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZWNlaXZlIHBlcmlvZGljXG4gICAgICogIHVwZGF0ZXMgYXMgdGhlIGVuY3J5cHRpb24gcHJvY2VzcyBwcm9ncmVzZXMuXG4gICAgICovXG4gICAgYXN5bmMgZW5jcnlwdChwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW5jcnlwdEtleXN0b3JlSnNvbih0aGlzLiNhY2NvdW50KCksIHBhc3N3b3JkLCB7IHByb2dyZXNzQ2FsbGJhY2sgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2ZXJzaW9uXShlbmNyeXB0KSBpbnN0ZWFkLFxuICAgICAqICB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgKGZyZWV6aW5nIGFsbCBVSSkgdW50aWxcbiAgICAgKiAgaXQgaXMgY29tcGxldGUsIHdoaWNoIG1heSBiZSBhIG5vbi10cml2aWFsIGR1cmF0aW9uLlxuICAgICAqL1xuICAgIGVuY3J5cHRTeW5jKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyh0aGlzLiNhY2NvdW50KCksIHBhc3N3b3JkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBleHRlbmRlZCBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBrZXkgd2lsbCBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGB4cHJpdmBgIGFuZCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICByZWNvbnN0cnVjdCB0aGlzIEhEIE5vZGUgdG8gZGVyaXZlIGl0cyBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBnZXQgZXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgbWFpbm5ldCB2YWx1ZXMgZm9yIG5vdywgYnV0IGlmIGFueW9uZSBuZWVkc1xuICAgICAgICAvLyB0ZXN0bmV0IHZhbHVlcywgbGV0IG1lIGtub3cuIEkgYmVsaWV2ZSBjdXJyZW50IHNlbnRpbWVudCBpcyB0aGF0XG4gICAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgdXNlIG1haW5uZXQsIGFuZCB1c2UgQklQLTQ0IHRvIGRlcml2ZSB0aGUgbmV0d29ya1xuICAgICAgICAvLyAgIC0gTWFpbm5ldDogcHVibGljPTB4MDQ4OEIyMUUsIHByaXZhdGU9MHgwNDg4QURFNFxuICAgICAgICAvLyAgIC0gVGVzdG5ldDogcHVibGljPTB4MDQzNTg3Q0YsIHByaXZhdGU9MHgwNDM1ODM5NFxuICAgICAgICBhc3NlcnQodGhpcy5kZXB0aCA8IDI1NiwgXCJEZXB0aCB0b28gZGVlcFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJleHRlbmRlZEtleVwiIH0pO1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTU4Q2hlY2soY29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgwNDg4QURFNFwiLCB6cGFkKHRoaXMuZGVwdGgsIDEpLCB0aGlzLnBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICAgICAgenBhZCh0aGlzLmluZGV4LCA0KSwgdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgICAgICBjb25jYXQoW1wiMHgwMFwiLCB0aGlzLnByaXZhdGVLZXldKVxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB3YWxsZXQgaGFzIGEgcGF0aCwgcHJvdmlkaW5nIGEgVHlwZSBHdWFyZFxuICAgICAqICB0aGF0IHRoZSBwYXRoIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGhhc1BhdGgoKSB7IHJldHVybiAodGhpcy5wYXRoICE9IG51bGwpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXV0ZXJlZCBIRCBOb2RlLCB3aGljaCByZW1vdmVzIHRoZSBwcml2YXRlIGRldGFpbHNcbiAgICAgKiAgb2YgYW4gSEQgTm9kZS5cbiAgICAgKlxuICAgICAqICBBIG5ldXRlcmVkIG5vZGUgaGFzIG5vIHByaXZhdGUga2V5LCBidXQgY2FuIGJlIHVzZWQgdG8gZGVyaXZlXG4gICAgICogIGNoaWxkIGFkZHJlc3NlcyBhbmQgb3RoZXIgcHVibGljIGRhdGEgYWJvdXQgdGhlIEhEIE5vZGUuXG4gICAgICovXG4gICAgbmV1dGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCB0aGlzLmFkZHJlc3MsIHRoaXMucHVibGljS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wYXRoLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCB0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgY2hpbGQgZm9yICUlaW5kZXglJS5cbiAgICAgKi9cbiAgICBkZXJpdmVDaGlsZChfaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA8PSAweGZmZmZmZmZmLCBcImludmFsaWQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIC8vIEJhc2UgcGF0aFxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgSVIsIElMIH0gPSBzZXJfSShpbmRleCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucHVibGljS2V5LCB0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBraSA9IG5ldyBTaWduaW5nS2V5KHRvQmVIZXgoKHRvQmlnSW50KElMKSArIEJpZ0ludCh0aGlzLnByaXZhdGVLZXkpKSAlIE4sIDMyKSk7XG4gICAgICAgIHJldHVybiBuZXcgSEROb2RlV2FsbGV0KF9ndWFyZCwga2ksIHRoaXMuZmluZ2VycHJpbnQsIGhleGxpZnkoSVIpLCBwYXRoLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIHRoaXMubW5lbW9uaWMsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBIRE5vZGUgZm9yICUlcGF0aCUlIGZyb20gdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGRlcml2ZVBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gZGVyaXZlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICB9XG4gICAgc3RhdGljICNmcm9tU2VlZChfc2VlZCwgbW5lbW9uaWMpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNCeXRlc0xpa2UoX3NlZWQpLCBcImludmFsaWQgc2VlZFwiLCBcInNlZWRcIiwgXCJbUkVEQUNURURdXCIpO1xuICAgICAgICBjb25zdCBzZWVkID0gZ2V0Qnl0ZXMoX3NlZWQsIFwic2VlZFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2VlZC5sZW5ndGggPj0gMTYgJiYgc2VlZC5sZW5ndGggPD0gNjQsIFwiaW52YWxpZCBzZWVkXCIsIFwic2VlZFwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIGNvbnN0IEkgPSBnZXRCeXRlcyhjb21wdXRlSG1hYyhcInNoYTUxMlwiLCBNYXN0ZXJTZWNyZXQsIHNlZWQpKTtcbiAgICAgICAgY29uc3Qgc2lnbmluZ0tleSA9IG5ldyBTaWduaW5nS2V5KGhleGxpZnkoSS5zbGljZSgwLCAzMikpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBzaWduaW5nS2V5LCBcIjB4MDAwMDAwMDBcIiwgaGV4bGlmeShJLnNsaWNlKDMyKSksIFwibVwiLCAwLCAwLCBtbmVtb25pYywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEhEIE5vZGUgZnJvbSAlJWV4dGVuZGVkS2V5JSUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUlZXh0ZW5kZWRLZXklJSB3aWxsIGVpdGhlciBoYXZlIGEgcHJlZml4IG9yIGBgeHB1YmBgIG9yXG4gICAgICogIGBgeHByaXZgYCwgcmV0dXJuaW5nIGEgbmV1dGVyZWQgSEQgTm9kZSAoW1tIRE5vZGVWb2lkV2FsbGV0XV0pXG4gICAgICogIG9yIGZ1bGwgSEQgTm9kZSAoW1tIRE5vZGVXYWxsZXQpIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGV4dGVuZGVkS2V5KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdG9CZUFycmF5KGRlY29kZUJhc2U1OChleHRlbmRlZEtleSkpOyAvLyBAVE9ETzogcmVkYWN0XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gODIgfHwgZW5jb2RlQmFzZTU4Q2hlY2soYnl0ZXMuc2xpY2UoMCwgNzgpKSA9PT0gZXh0ZW5kZWRLZXksIFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgY29uc3QgZGVwdGggPSBieXRlc1s0XTtcbiAgICAgICAgY29uc3QgcGFyZW50RmluZ2VycHJpbnQgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDUsIDkpKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDksIDEzKSkuc3Vic3RyaW5nKDIpLCAxNik7XG4gICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMTMsIDQ1KSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGJ5dGVzLnNsaWNlKDQ1LCA3OCk7XG4gICAgICAgIHN3aXRjaCAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkpIHtcbiAgICAgICAgICAgIC8vIFB1YmxpYyBLZXlcbiAgICAgICAgICAgIGNhc2UgXCIweDA0ODhiMjFlXCI6XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDM1ODdjZlwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gaGV4bGlmeShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlVm9pZFdhbGxldChfZ3VhcmQsIGNvbXB1dGVBZGRyZXNzKHB1YmxpY0tleSksIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgbnVsbCwgaW5kZXgsIGRlcHRoLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByaXZhdGUgS2V5XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDg4YWRlNFwiOlxuICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTgzOTQgXCI6XG4gICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBuZXcgU2lnbmluZ0tleShrZXkuc2xpY2UoMSkpLCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBudWxsLCBpbmRleCwgZGVwdGgsIG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZXh0ZW5kZWQga2V5IHByZWZpeFwiLCBcImV4dGVuZGVkS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyByYW5kb20gSEROb2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20ocGFzc3dvcmQsIHBhdGgsIHdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aCA9IGRlZmF1bHRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IExhbmdFbi53b3JkbGlzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1uZW1vbmljID0gTW5lbW9uaWMuZnJvbUVudHJvcHkocmFuZG9tQnl0ZXMoMTYpLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhbiBIRCBOb2RlIGZyb20gJSVtbmVtb25pYyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW5lbW9uaWMobW5lbW9uaWMsIHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gZGVmYXVsdFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQobW5lbW9uaWMuY29tcHV0ZVNlZWQoKSwgbW5lbW9uaWMpLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGFuIEhEIE5vZGUgZnJvbSBhIG1uZW1vbmljICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgcGF0aCwgd29yZGxpc3QpIHtcbiAgICAgICAgaWYgKHBhc3N3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhc3N3b3JkID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXRoID0gZGVmYXVsdFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW5lbW9uaWMgPSBNbmVtb25pYy5mcm9tUGhyYXNlKHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KTtcbiAgICAgICAgcmV0dXJuIEhETm9kZVdhbGxldC4jZnJvbVNlZWQobW5lbW9uaWMuY29tcHV0ZVNlZWQoKSwgbW5lbW9uaWMpLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGFuIEhEIE5vZGUgZnJvbSBhICUlc2VlZCUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2VlZChzZWVkKSB7XG4gICAgICAgIHJldHVybiBIRE5vZGVXYWxsZXQuI2Zyb21TZWVkKHNlZWQsIG51bGwpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipIRE5vZGVWb2lkV2FsbGV0KiogY2Fubm90IHNpZ24sIGJ1dCBwcm92aWRlcyBhY2Nlc3MgdG9cbiAqICB0aGUgY2hpbGRyZW4gbm9kZXMgb2YgYSBbW2xpbmstYmlwLTMyXV0gSEQgd2FsbGV0IGFkZHJlc3Nlcy5cbiAqXG4gKiAgVGhlIGNhbiBiZSBjcmVhdGVkIGJ5IHVzaW5nIGFuIGV4dGVuZGVkIGBgeHB1YmBgIGtleSB0b1xuICogIFtbSEROb2RlV2FsbGV0X2Zyb21FeHRlbmRlZEtleV1dIG9yIGJ5XG4gKiAgW251ZXRlcmluZ10oSEROb2RlV2FsbGV0LW5ldXRlcikgYSBbW0hETm9kZVdhbGxldF1dLlxuICovXG5leHBvcnQgY2xhc3MgSEROb2RlVm9pZFdhbGxldCBleHRlbmRzIFZvaWRTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqL1xuICAgIHB1YmxpY0tleTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZpbmdlcnByaW50LlxuICAgICAqXG4gICAgICogIEEgZmluZ2VycHJpbnQgYWxsb3dzIHF1aWNrIHFheSB0byBkZXRlY3QgcGFyZW50IGFuZCBjaGlsZCBub2RlcyxcbiAgICAgKiAgYnV0IGRldmVsb3BlcnMgc2hvdWxkIGJlIHByZXBhcmVkIHRvIGRlYWwgd2l0aCBjb2xsaXNpb25zIGFzIGl0XG4gICAgICogIGlzIG9ubHkgNCBieXRlcy5cbiAgICAgKi9cbiAgICBmaW5nZXJwcmludDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcmVudCBub2RlIGZpbmdlcnByaW50LlxuICAgICAqL1xuICAgIHBhcmVudEZpbmdlcnByaW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW5jb2RlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhIHB1YmxpYyBrZXkgdXNlZFxuICAgICAqICB0byBkZXJpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY2hhaW5Db2RlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVyaXZhdGlvbiBwYXRoIG9mIHRoaXMgd2FsbGV0LlxuICAgICAqXG4gICAgICogIFNpbmNlIGV4dGVuZGVkIGtleXMgZG8gbm90IHByb3ZpZGVyIGZ1bGwgcGF0aCBkZXRhaWxzLCB0aGlzXG4gICAgICogIG1heSBiZSBgYG51bGxgYCwgaWYgaW5zdGFudGlhdGVkIGZyb20gYSBzb3VyY2UgdGhhdCBkb2VzIG5vdFxuICAgICAqICBlbm9jZGUgaXQuXG4gICAgICovXG4gICAgcGF0aDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoaWxkIGluZGV4IG9mIHRoaXMgd2FsbGV0LiBWYWx1ZXMgb3ZlciBgYDIgKlxcKiAzMWBgIGluZGljYXRlXG4gICAgICogIHRoZSBub2RlIGlzIGhhcmRlbmVkLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgZGVwdGggb2YgdGhpcyB3YWxsZXQsIHdoaWNoIGlzIHRoZSBudW1iZXIgb2YgY29tcG9uZW50c1xuICAgICAqICBpbiBpdHMgcGF0aC5cbiAgICAgKi9cbiAgICBkZXB0aDtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgYWRkcmVzcywgcHVibGljS2V5LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKGFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIkhETm9kZVZvaWRXYWxsZXRcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwdWJsaWNLZXkgfSk7XG4gICAgICAgIGNvbnN0IGZpbmdlcnByaW50ID0gZGF0YVNsaWNlKHJpcGVtZDE2MChzaGEyNTYocHVibGljS2V5KSksIDAsIDQpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHB1YmxpY0tleSwgZmluZ2VycHJpbnQsIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCB0aGlzLmFkZHJlc3MsIHRoaXMucHVibGljS2V5LCB0aGlzLnBhcmVudEZpbmdlcnByaW50LCB0aGlzLmNoYWluQ29kZSwgdGhpcy5wYXRoLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXh0ZW5kZWQga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMga2V5IHdpbGwgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgeHB1YmBgIGFuZCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICByZWNvbnN0cnVjdCB0aGlzIG5ldXRlcmVkIGtleSB0byBkZXJpdmUgaXRzIGNoaWxkcmVuIGFkZHJlc3Nlcy5cbiAgICAgKi9cbiAgICBnZXQgZXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgbWFpbm5ldCB2YWx1ZXMgZm9yIG5vdywgYnV0IGlmIGFueW9uZSBuZWVkc1xuICAgICAgICAvLyB0ZXN0bmV0IHZhbHVlcywgbGV0IG1lIGtub3cuIEkgYmVsaWV2ZSBjdXJyZW50IHNlbnRpbWVudCBpcyB0aGF0XG4gICAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgdXNlIG1haW5uZXQsIGFuZCB1c2UgQklQLTQ0IHRvIGRlcml2ZSB0aGUgbmV0d29ya1xuICAgICAgICAvLyAgIC0gTWFpbm5ldDogcHVibGljPTB4MDQ4OEIyMUUsIHByaXZhdGU9MHgwNDg4QURFNFxuICAgICAgICAvLyAgIC0gVGVzdG5ldDogcHVibGljPTB4MDQzNTg3Q0YsIHByaXZhdGU9MHgwNDM1ODM5NFxuICAgICAgICBhc3NlcnQodGhpcy5kZXB0aCA8IDI1NiwgXCJEZXB0aCB0b28gZGVlcFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJleHRlbmRlZEtleVwiIH0pO1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTU4Q2hlY2soY29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgwNDg4QjIxRVwiLFxuICAgICAgICAgICAgenBhZCh0aGlzLmRlcHRoLCAxKSxcbiAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICB6cGFkKHRoaXMuaW5kZXgsIDQpLFxuICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgd2FsbGV0IGhhcyBhIHBhdGgsIHByb3ZpZGluZyBhIFR5cGUgR3VhcmRcbiAgICAgKiAgdGhhdCB0aGUgcGF0aCBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBoYXNQYXRoKCkgeyByZXR1cm4gKHRoaXMucGF0aCAhPSBudWxsKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGNoaWxkIGZvciAlJWluZGV4JSUuXG4gICAgICovXG4gICAgZGVyaXZlQ2hpbGQoX2luZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TnVtYmVyKF9pbmRleCwgXCJpbmRleFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPD0gMHhmZmZmZmZmZiwgXCJpbnZhbGlkIGluZGV4XCIsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICAvLyBCYXNlIHBhdGhcbiAgICAgICAgbGV0IHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoICs9IFwiL1wiICsgKGluZGV4ICYgfkhhcmRlbmVkQml0KTtcbiAgICAgICAgICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBcIidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IElSLCBJTCB9ID0gc2VyX0koaW5kZXgsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLnB1YmxpY0tleSwgbnVsbCk7XG4gICAgICAgIGNvbnN0IEtpID0gU2lnbmluZ0tleS5hZGRQb2ludHMoSUwsIHRoaXMucHVibGljS2V5LCB0cnVlKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzKEtpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgYWRkcmVzcywgS2ksIHRoaXMuZmluZ2VycHJpbnQsIGhleGxpZnkoSVIpLCBwYXRoLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzaWduZXIgZm9yICUlcGF0aCUlIGZyb20gdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGRlcml2ZVBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gZGVyaXZlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICB9XG59XG4vKlxuZXhwb3J0IGNsYXNzIEhETm9kZVdhbGxldE1hbmFnZXIge1xuICAgICNyb290OiBIRE5vZGVXYWxsZXQ7XG5cbiAgICBjb25zdHJ1Y3RvcihwaHJhc2U6IHN0cmluZywgcGFzc3dvcmQ/OiBudWxsIHwgc3RyaW5nLCBwYXRoPzogbnVsbCB8IHN0cmluZywgbG9jYWxlPzogbnVsbCB8IFdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7IHBhc3N3b3JkID0gXCJcIjsgfVxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7IHBhdGggPSBcIm0vNDQnLzYwJy8wJy8wXCI7IH1cbiAgICAgICAgaWYgKGxvY2FsZSA9PSBudWxsKSB7IGxvY2FsZSA9IExhbmdFbi53b3JkbGlzdCgpOyB9XG4gICAgICAgIHRoaXMuI3Jvb3QgPSBIRE5vZGVXYWxsZXQuZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCBwYXRoLCBsb2NhbGUpO1xuICAgIH1cblxuICAgIGdldFNpZ25lcihpbmRleD86IG51bWJlcik6IEhETm9kZVdhbGxldCB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyb290LmRlcml2ZUNoaWxkKChpbmRleCA9PSBudWxsKSA/IDA6IGluZGV4KTtcbiAgICB9XG59XG4qL1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgW1tsaW5rLWJpcC0zMl1dIHBhdGggZm9yIHRoZSBhY2NvdW50IGF0ICUlaW5kZXglJS5cbiAqXG4gKiAgVGhpcyBpcyB0aGUgcGF0dGVybiB1c2VkIGJ5IHdhbGxldHMgbGlrZSBMZWRnZXIuXG4gKlxuICogIFRoZXJlIGlzIGFsc28gYW4gW2FsdGVybmF0ZSBwYXR0ZXJuXShnZXRJbmRleGVkQWNjb3VudFBhdGgpIHVzZWQgYnlcbiAqICBzb21lIHNvZnR3YXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjb3VudFBhdGgoX2luZGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAgJiYgaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvJHtpbmRleH0nLzAvMGA7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBwYXRoIHVzaW5nIGFuIGFsdGVybmF0aXZlIHBhdHRlcm4gZm9yIGRlcml2aW5nIGFjY291bnRzLFxuICogIGF0ICUlaW5kZXglJS5cbiAqXG4gKiAgVGhpcyBkZXJpdmF0aW9uIHBhdGggdXNlcyB0aGUgLy9pbmRleC8vIGNvbXBvbmVudCByYXRoZXIgdGhhbiB0aGVcbiAqICAvL2FjY291bnQvLyBjb21wb25lbnQgdG8gZGVyaXZlIHNlcXVlbnRpYWwgYWNjb3VudHMuXG4gKlxuICogIFRoaXMgaXMgdGhlIHBhdHRlcm4gdXNlZCBieSB3YWxsZXRzIGxpa2UgTWV0YU1hc2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleGVkQWNjb3VudFBhdGgoX2luZGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIoX2luZGV4LCBcImluZGV4XCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluZGV4ID49IDAgJiYgaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvMCcvMC8ke2luZGV4fWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZHdhbGxldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wallet/hdwallet.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wallet/index.js":
/*!*************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wallet/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWallet: function() { return /* reexport safe */ _base_wallet_js__WEBPACK_IMPORTED_MODULE_0__.BaseWallet; },\n/* harmony export */   HDNodeVoidWallet: function() { return /* reexport safe */ _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__.HDNodeVoidWallet; },\n/* harmony export */   HDNodeWallet: function() { return /* reexport safe */ _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__.HDNodeWallet; },\n/* harmony export */   Mnemonic: function() { return /* reexport safe */ _mnemonic_js__WEBPACK_IMPORTED_MODULE_4__.Mnemonic; },\n/* harmony export */   Wallet: function() { return /* reexport safe */ _wallet_js__WEBPACK_IMPORTED_MODULE_5__.Wallet; },\n/* harmony export */   decryptCrowdsaleJson: function() { return /* reexport safe */ _json_crowdsale_js__WEBPACK_IMPORTED_MODULE_2__.decryptCrowdsaleJson; },\n/* harmony export */   decryptKeystoreJson: function() { return /* reexport safe */ _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.decryptKeystoreJson; },\n/* harmony export */   decryptKeystoreJsonSync: function() { return /* reexport safe */ _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.decryptKeystoreJsonSync; },\n/* harmony export */   defaultPath: function() { return /* reexport safe */ _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__.defaultPath; },\n/* harmony export */   encryptKeystoreJson: function() { return /* reexport safe */ _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.encryptKeystoreJson; },\n/* harmony export */   encryptKeystoreJsonSync: function() { return /* reexport safe */ _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.encryptKeystoreJsonSync; },\n/* harmony export */   getAccountPath: function() { return /* reexport safe */ _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__.getAccountPath; },\n/* harmony export */   getIndexedAccountPath: function() { return /* reexport safe */ _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__.getIndexedAccountPath; },\n/* harmony export */   isCrowdsaleJson: function() { return /* reexport safe */ _json_crowdsale_js__WEBPACK_IMPORTED_MODULE_2__.isCrowdsaleJson; },\n/* harmony export */   isKeystoreJson: function() { return /* reexport safe */ _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__.isKeystoreJson; }\n/* harmony export */ });\n/* harmony import */ var _base_wallet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-wallet.js */ \"../common/node_modules/ethers/lib.esm/wallet/base-wallet.js\");\n/* harmony import */ var _hdwallet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hdwallet.js */ \"../common/node_modules/ethers/lib.esm/wallet/hdwallet.js\");\n/* harmony import */ var _json_crowdsale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-crowdsale.js */ \"../common/node_modules/ethers/lib.esm/wallet/json-crowdsale.js\");\n/* harmony import */ var _json_keystore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-keystore.js */ \"../common/node_modules/ethers/lib.esm/wallet/json-keystore.js\");\n/* harmony import */ var _mnemonic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mnemonic.js */ \"../common/node_modules/ethers/lib.esm/wallet/mnemonic.js\");\n/* harmony import */ var _wallet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wallet.js */ \"../common/node_modules/ethers/lib.esm/wallet/wallet.js\");\n/**\n *  When interacting with Ethereum, it is necessary to use a private\n *  key authenticate actions by signing a payload.\n *\n *  Wallets are the simplest way to expose the concept of an\n *  //Externally Owner Account// (EOA) as it wraps a private key\n *  and supports high-level methods to sign common types of interaction\n *  and send transactions.\n *\n *  The class most developers will want to use is [[Wallet]], which\n *  can load a private key directly or from any common wallet format.\n *\n *  The [[HDNodeWallet]] can be used when it is necessary to access\n *  low-level details of how an HD wallets are derived, exported\n *  or imported.\n *\n *  @_section: api/wallet:Wallets  [about-wallets]\n */\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQ3NFO0FBQ3hDO0FBQ29FO0FBQ3ZHO0FBQ0o7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd2FsbGV0L2luZGV4LmpzP2E4NGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgV2hlbiBpbnRlcmFjdGluZyB3aXRoIEV0aGVyZXVtLCBpdCBpcyBuZWNlc3NhcnkgdG8gdXNlIGEgcHJpdmF0ZVxuICogIGtleSBhdXRoZW50aWNhdGUgYWN0aW9ucyBieSBzaWduaW5nIGEgcGF5bG9hZC5cbiAqXG4gKiAgV2FsbGV0cyBhcmUgdGhlIHNpbXBsZXN0IHdheSB0byBleHBvc2UgdGhlIGNvbmNlcHQgb2YgYW5cbiAqICAvL0V4dGVybmFsbHkgT3duZXIgQWNjb3VudC8vIChFT0EpIGFzIGl0IHdyYXBzIGEgcHJpdmF0ZSBrZXlcbiAqICBhbmQgc3VwcG9ydHMgaGlnaC1sZXZlbCBtZXRob2RzIHRvIHNpZ24gY29tbW9uIHR5cGVzIG9mIGludGVyYWN0aW9uXG4gKiAgYW5kIHNlbmQgdHJhbnNhY3Rpb25zLlxuICpcbiAqICBUaGUgY2xhc3MgbW9zdCBkZXZlbG9wZXJzIHdpbGwgd2FudCB0byB1c2UgaXMgW1tXYWxsZXRdXSwgd2hpY2hcbiAqICBjYW4gbG9hZCBhIHByaXZhdGUga2V5IGRpcmVjdGx5IG9yIGZyb20gYW55IGNvbW1vbiB3YWxsZXQgZm9ybWF0LlxuICpcbiAqICBUaGUgW1tIRE5vZGVXYWxsZXRdXSBjYW4gYmUgdXNlZCB3aGVuIGl0IGlzIG5lY2Vzc2FyeSB0byBhY2Nlc3NcbiAqICBsb3ctbGV2ZWwgZGV0YWlscyBvZiBob3cgYW4gSEQgd2FsbGV0cyBhcmUgZGVyaXZlZCwgZXhwb3J0ZWRcbiAqICBvciBpbXBvcnRlZC5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvd2FsbGV0OldhbGxldHMgIFthYm91dC13YWxsZXRzXVxuICovXG5leHBvcnQgeyBCYXNlV2FsbGV0IH0gZnJvbSBcIi4vYmFzZS13YWxsZXQuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHRQYXRoLCBnZXRBY2NvdW50UGF0aCwgZ2V0SW5kZXhlZEFjY291bnRQYXRoLCBIRE5vZGVXYWxsZXQsIEhETm9kZVZvaWRXYWxsZXQsIH0gZnJvbSBcIi4vaGR3YWxsZXQuanNcIjtcbmV4cG9ydCB7IGlzQ3Jvd2RzYWxlSnNvbiwgZGVjcnlwdENyb3dkc2FsZUpzb24gfSBmcm9tIFwiLi9qc29uLWNyb3dkc2FsZS5qc1wiO1xuZXhwb3J0IHsgaXNLZXlzdG9yZUpzb24sIGRlY3J5cHRLZXlzdG9yZUpzb25TeW5jLCBkZWNyeXB0S2V5c3RvcmVKc29uLCBlbmNyeXB0S2V5c3RvcmVKc29uLCBlbmNyeXB0S2V5c3RvcmVKc29uU3luYyB9IGZyb20gXCIuL2pzb24ta2V5c3RvcmUuanNcIjtcbmV4cG9ydCB7IE1uZW1vbmljIH0gZnJvbSBcIi4vbW5lbW9uaWMuanNcIjtcbmV4cG9ydCB7IFdhbGxldCB9IGZyb20gXCIuL3dhbGxldC5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wallet/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wallet/json-crowdsale.js":
/*!**********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wallet/json-crowdsale.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptCrowdsaleJson: function() { return /* binding */ decryptCrowdsaleJson; },\n/* harmony export */   isCrowdsaleJson: function() { return /* binding */ isCrowdsaleJson; }\n/* harmony export */ });\n/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aes-js */ \"../common/node_modules/aes-js/lib.esm/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../hash/index.js */ \"../common/node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../common/node_modules/ethers/lib.esm/wallet/utils.js\");\n/**\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\n\n\n\n\n\n\n/**\n *  Returns true if %%json%% is a valid JSON Crowdsale wallet.\n */\nfunction isCrowdsaleJson(json) {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) {\n            return true;\n        }\n    }\n    catch (error) { }\n    return false;\n}\n// See: https://github.com/ethereum/pyethsaletool\n/**\n *  Before Ethereum launched, it was necessary to create a wallet\n *  format for backers to use, which would be used to receive ether\n *  as a reward for contributing to the project.\n *\n *  The [[link-crowdsale]] format is now obsolete, but it is still\n *  useful to support and the additional code is fairly trivial as\n *  all the primitives required are used through core portions of\n *  the library.\n */\nfunction decryptCrowdsaleJson(json, _password) {\n    const data = JSON.parse(json);\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(_password);\n    // Ethereum Address\n    const address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"ethaddr:string!\"));\n    // Encrypted Seed\n    const encseed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.looseArrayify)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"encseed:string!\"));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(encseed && (encseed.length % 16) === 0, \"invalid encseed\", \"json\", json);\n    const key = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n    // Decrypt the seed\n    const aesCbc = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CBC(key, iv);\n    const seed = (0,aes_js__WEBPACK_IMPORTED_MODULE_0__.pkcs7Strip)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(aesCbc.decrypt(encryptedSeed)));\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for (let i = 0; i < seed.length; i++) {\n        seedHex += String.fromCharCode(seed[i]);\n    }\n    return { address, privateKey: (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_5__.id)(seedHex) };\n}\n//# sourceMappingURL=json-crowdsale.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvanNvbi1jcm93ZHNhbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDeUM7QUFDUTtBQUNMO0FBQ047QUFDdUI7QUFDSTtBQUNqRTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUJBQXFCLHNEQUFXO0FBQ2hDO0FBQ0Esb0JBQW9CLDZEQUFVLENBQUMsa0RBQU87QUFDdEM7QUFDQSxvQkFBb0Isd0RBQWEsQ0FBQyxrREFBTztBQUN6QyxJQUFJLCtEQUFjO0FBQ2xCLGdCQUFnQix5REFBUSxDQUFDLHdEQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1Q0FBRztBQUMxQixpQkFBaUIsa0RBQVUsQ0FBQyx5REFBUTtBQUNwQztBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0EsYUFBYSxxQkFBcUIsa0RBQUU7QUFDcEM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvanNvbi1jcm93ZHNhbGUuanM/NmE5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBAX3N1YnNlY3Rpb246IGFwaS93YWxsZXQ6SlNPTiBXYWxsZXRzICBbanNvbi13YWxsZXRzXVxuICovXG5pbXBvcnQgeyBDQkMsIHBrY3M3U3RyaXAgfSBmcm9tIFwiYWVzLWpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0UGFzc3dvcmQsIGxvb3NlQXJyYXlpZnksIHNwZWx1bmsgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlanNvbiUlIGlzIGEgdmFsaWQgSlNPTiBDcm93ZHNhbGUgd2FsbGV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDcm93ZHNhbGVKc29uKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgaWYgKGRhdGEuZW5jc2VlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9weWV0aHNhbGV0b29sXG4vKipcbiAqICBCZWZvcmUgRXRoZXJldW0gbGF1bmNoZWQsIGl0IHdhcyBuZWNlc3NhcnkgdG8gY3JlYXRlIGEgd2FsbGV0XG4gKiAgZm9ybWF0IGZvciBiYWNrZXJzIHRvIHVzZSwgd2hpY2ggd291bGQgYmUgdXNlZCB0byByZWNlaXZlIGV0aGVyXG4gKiAgYXMgYSByZXdhcmQgZm9yIGNvbnRyaWJ1dGluZyB0byB0aGUgcHJvamVjdC5cbiAqXG4gKiAgVGhlIFtbbGluay1jcm93ZHNhbGVdXSBmb3JtYXQgaXMgbm93IG9ic29sZXRlLCBidXQgaXQgaXMgc3RpbGxcbiAqICB1c2VmdWwgdG8gc3VwcG9ydCBhbmQgdGhlIGFkZGl0aW9uYWwgY29kZSBpcyBmYWlybHkgdHJpdmlhbCBhc1xuICogIGFsbCB0aGUgcHJpbWl0aXZlcyByZXF1aXJlZCBhcmUgdXNlZCB0aHJvdWdoIGNvcmUgcG9ydGlvbnMgb2ZcbiAqICB0aGUgbGlicmFyeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRDcm93ZHNhbGVKc29uKGpzb24sIF9wYXNzd29yZCkge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gZ2V0UGFzc3dvcmQoX3Bhc3N3b3JkKTtcbiAgICAvLyBFdGhlcmV1bSBBZGRyZXNzXG4gICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3Moc3BlbHVuayhkYXRhLCBcImV0aGFkZHI6c3RyaW5nIVwiKSk7XG4gICAgLy8gRW5jcnlwdGVkIFNlZWRcbiAgICBjb25zdCBlbmNzZWVkID0gbG9vc2VBcnJheWlmeShzcGVsdW5rKGRhdGEsIFwiZW5jc2VlZDpzdHJpbmchXCIpKTtcbiAgICBhc3NlcnRBcmd1bWVudChlbmNzZWVkICYmIChlbmNzZWVkLmxlbmd0aCAlIDE2KSA9PT0gMCwgXCJpbnZhbGlkIGVuY3NlZWRcIiwgXCJqc29uXCIsIGpzb24pO1xuICAgIGNvbnN0IGtleSA9IGdldEJ5dGVzKHBia2RmMihwYXNzd29yZCwgcGFzc3dvcmQsIDIwMDAsIDMyLCBcInNoYTI1NlwiKSkuc2xpY2UoMCwgMTYpO1xuICAgIGNvbnN0IGl2ID0gZW5jc2VlZC5zbGljZSgwLCAxNik7XG4gICAgY29uc3QgZW5jcnlwdGVkU2VlZCA9IGVuY3NlZWQuc2xpY2UoMTYpO1xuICAgIC8vIERlY3J5cHQgdGhlIHNlZWRcbiAgICBjb25zdCBhZXNDYmMgPSBuZXcgQ0JDKGtleSwgaXYpO1xuICAgIGNvbnN0IHNlZWQgPSBwa2NzN1N0cmlwKGdldEJ5dGVzKGFlc0NiYy5kZWNyeXB0KGVuY3J5cHRlZFNlZWQpKSk7XG4gICAgLy8gVGhpcyB3YWxsZXQgZm9ybWF0IGlzIHdlaXJkLi4uIENvbnZlcnQgdGhlIGJpbmFyeSBlbmNvZGVkIGhleCB0byBhIHN0cmluZy5cbiAgICBsZXQgc2VlZEhleCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlZWRIZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzZWVkW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgYWRkcmVzcywgcHJpdmF0ZUtleTogaWQoc2VlZEhleCkgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24tY3Jvd2RzYWxlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wallet/json-crowdsale.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wallet/json-keystore.js":
/*!*********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wallet/json-keystore.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptKeystoreJson: function() { return /* binding */ decryptKeystoreJson; },\n/* harmony export */   decryptKeystoreJsonSync: function() { return /* binding */ decryptKeystoreJsonSync; },\n/* harmony export */   encryptKeystoreJson: function() { return /* binding */ encryptKeystoreJson; },\n/* harmony export */   encryptKeystoreJsonSync: function() { return /* binding */ encryptKeystoreJsonSync; },\n/* harmony export */   isKeystoreJson: function() { return /* binding */ isKeystoreJson; }\n/* harmony export */ });\n/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aes-js */ \"../common/node_modules/aes-js/lib.esm/index.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../address/index.js */ \"../common/node_modules/ethers/lib.esm/address/index.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"../common/node_modules/ethers/lib.esm/transaction/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../common/node_modules/ethers/lib.esm/wallet/utils.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../_version.js */ \"../common/node_modules/ethers/lib.esm/_version.js\");\n/**\n *  The JSON Wallet formats allow a simple way to store the private\n *  keys needed in Ethereum along with related information and allows\n *  for extensible forms of encryption.\n *\n *  These utilities facilitate decrypting and encrypting the most common\n *  JSON Wallet formats.\n *\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\n\n\n\n\n\n\n\nconst defaultPath = \"m/44'/60'/0'/0/0\";\n/**\n *  Returns true if %%json%% is a valid JSON Keystore Wallet.\n */\nfunction isKeystoreJson(json) {\n    try {\n        const data = JSON.parse(json);\n        const version = ((data.version != null) ? parseInt(data.version) : 0);\n        if (version === 3) {\n            return true;\n        }\n    }\n    catch (error) { }\n    return false;\n}\nfunction decrypt(data, key, ciphertext) {\n    const cipher = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.cipher:string\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.cipherparams.iv:data!\");\n        const aesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(key, iv);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(aesCtr.decrypt(ciphertext));\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"decrypt\"\n    });\n}\nfunction getAccount(data, _key) {\n    const key = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_key);\n    const ciphertext = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.ciphertext:data!\");\n    const computedMAC = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([key.slice(16, 32), ciphertext]))).substring(2);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(computedMAC === (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.mac:string!\").toLowerCase(), \"incorrect password\", \"password\", \"[ REDACTED ]\");\n    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);\n    const address = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.computeAddress)(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (!check.startsWith(\"0x\")) {\n            check = \"0x\" + check;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_5__.getAddress)(check) === address, \"keystore address/privateKey mismatch\", \"address\", data.address);\n    }\n    const account = { address, privateKey };\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    const version = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.version:string\");\n    if (version === \"0.1\") {\n        const mnemonicKey = key.slice(32, 64);\n        const mnemonicCiphertext = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.mnemonicCiphertext:data!\");\n        const mnemonicIv = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.mnemonicCounter:data!\");\n        const mnemonicAesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(mnemonicKey, mnemonicIv);\n        account.mnemonic = {\n            path: ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.path:string\") || defaultPath),\n            locale: ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"x-ethers.locale:string\") || \"en\"),\n            entropy: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\n        };\n    }\n    return account;\n}\nfunction getDecryptKdfParams(data) {\n    const kdf = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdf:string\");\n    if (kdf && typeof (kdf) === \"string\") {\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n            const N = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.n:int!\");\n            const r = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.r:int!\");\n            const p = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.p:int!\");\n            // Make sure N is a power of 2\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(N > 0 && (N & (N - 1)) === 0, \"invalid kdf.N\", \"kdf.N\", N);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf);\n            const dkLen = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dflen\", dkLen);\n            return { name: \"scrypt\", salt, N, r, p, dkLen: 64 };\n        }\n        else if (kdf.toLowerCase() === \"pbkdf2\") {\n            const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n            const prf = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.prf:string!\");\n            const algorithm = prf.split(\"-\").pop();\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(algorithm === \"sha256\" || algorithm === \"sha512\", \"invalid kdf.pdf\", \"kdf.pdf\", prf);\n            const count = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.c:int!\");\n            const dkLen = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dklen\", dkLen);\n            return { name: \"pbkdf2\", salt, count, dkLen, algorithm };\n        }\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unsupported key-derivation function\", \"kdf\", kdf);\n}\n/**\n *  Returns the account details for the JSON Keystore Wallet %%json%%\n *  using %%password%%.\n *\n *  It is preferred to use the [async version](decryptKeystoreJson)\n *  instead, which allows a [[ProgressCallback]] to keep the user informed\n *  as to the decryption status.\n *\n *  This method will block the event loop (freezing all UI) until decryption\n *  is complete, which can take quite some time, depending on the wallet\n *  paramters and platform.\n */\nfunction decryptKeystoreJsonSync(json, _password) {\n    const data = JSON.parse(json);\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(_password);\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dkLen, algorithm } = params;\n        const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.pbkdf2)(password, salt, count, dkLen, algorithm);\n        return getAccount(data, key);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params });\n    const { salt, N, r, p, dkLen } = params;\n    const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.scryptSync)(password, salt, N, r, p, dkLen);\n    return getAccount(data, key);\n}\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\n}\n/**\n *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n *  %%password%%.\n *\n *  If provided, %%progress%% will be called periodically during the\n *  decrpytion to provide feedback, and if the function returns\n *  ``false`` will halt decryption.\n *\n *  The %%progressCallback%% will **always** receive ``0`` before\n *  decryption begins and ``1`` when complete.\n */\nasync function decryptKeystoreJson(json, _password, progress) {\n    const data = JSON.parse(json);\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(_password);\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        if (progress) {\n            progress(0);\n            await stall(0);\n        }\n        const { salt, count, dkLen, algorithm } = params;\n        const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.pbkdf2)(password, salt, count, dkLen, algorithm);\n        if (progress) {\n            progress(1);\n            await stall(0);\n        }\n        return getAccount(data, key);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params });\n    const { salt, N, r, p, dkLen } = params;\n    const key = await (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.scrypt)(password, salt, N, r, p, dkLen, progress);\n    return getAccount(data, key);\n}\nfunction getEncryptKdfParams(options) {\n    // Check/generate the salt\n    const salt = (options.salt != null) ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(options.salt, \"options.salt\") : (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(32);\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) {\n            N = options.scrypt.N;\n        }\n        if (options.scrypt.r) {\n            r = options.scrypt.r;\n        }\n        if (options.scrypt.p) {\n            p = options.scrypt.p;\n        }\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof (N) === \"number\" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), \"invalid scrypt N parameter\", \"options.N\", N);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof (r) === \"number\" && r > 0 && Number.isSafeInteger(r), \"invalid scrypt r parameter\", \"options.r\", r);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof (p) === \"number\" && p > 0 && Number.isSafeInteger(p), \"invalid scrypt p parameter\", \"options.p\", p);\n    return { name: \"scrypt\", dkLen: 32, salt, N, r, p };\n}\nfunction _encryptKeystore(key, kdf, account, options) {\n    const privateKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(account.privateKey, \"privateKey\");\n    // Override initialization vector\n    const iv = (options.iv != null) ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(options.iv, \"options.iv\") : (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(16);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(iv.length === 16, \"invalid options.iv length\", \"options.iv\", options.iv);\n    // Override the uuid\n    const uuidRandom = (options.uuid != null) ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(options.uuid, \"options.uuid\") : (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(16);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(uuidRandom.length === 16, \"invalid options.uuid length\", \"options.uuid\", options.iv);\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\n    // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    const derivedKey = key.slice(0, 16);\n    const macPrefix = key.slice(16, 32);\n    // Encrypt the private key\n    const aesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(derivedKey, iv);\n    const ciphertext = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(aesCtr.encrypt(privateKey));\n    // Compute the message authentication code, used to check the password\n    const mac = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([macPrefix, ciphertext]));\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n    const data = {\n        address: account.address.substring(2).toLowerCase(),\n        id: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.uuidV4)(uuidRandom),\n        version: 3,\n        Crypto: {\n            cipher: \"aes-128-ctr\",\n            cipherparams: {\n                iv: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(iv).substring(2),\n            },\n            ciphertext: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(ciphertext).substring(2),\n            kdf: \"scrypt\",\n            kdfparams: {\n                salt: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(kdf.salt).substring(2),\n                n: kdf.N,\n                dklen: 32,\n                p: kdf.p,\n                r: kdf.r\n            },\n            mac: mac.substring(2)\n        }\n    };\n    // If we have a mnemonic, encrypt it into the JSON wallet\n    if (account.mnemonic) {\n        const client = (options.client != null) ? options.client : `ethers/${_version_js__WEBPACK_IMPORTED_MODULE_6__.version}`;\n        const path = account.mnemonic.path || defaultPath;\n        const locale = account.mnemonic.locale || \"en\";\n        const mnemonicKey = key.slice(32, 64);\n        const entropy = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(account.mnemonic.entropy, \"account.mnemonic.entropy\");\n        const mnemonicIv = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(16);\n        const mnemonicAesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0__.CTR(mnemonicKey, mnemonicIv);\n        const mnemonicCiphertext = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(mnemonicAesCtr.encrypt(entropy));\n        const now = new Date();\n        const timestamp = (now.getUTCFullYear() + \"-\" +\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCMonth() + 1, 2) + \"-\" +\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCDate(), 2) + \"T\" +\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCHours(), 2) + \"-\" +\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCMinutes(), 2) + \"-\" +\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.zpad)(now.getUTCSeconds(), 2) + \".0Z\");\n        const gethFilename = (\"UTC--\" + timestamp + \"--\" + data.address);\n        data[\"x-ethers\"] = {\n            client, gethFilename, path, locale,\n            mnemonicCounter: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(mnemonicIv).substring(2),\n            mnemonicCiphertext: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(mnemonicCiphertext).substring(2),\n            version: \"0.1\"\n        };\n    }\n    return JSON.stringify(data);\n}\n/**\n *  Return the JSON Keystore Wallet for %%account%% encrypted with\n *  %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used. Any provided [[ProgressCallback]] is ignord.\n */\nfunction encryptKeystoreJsonSync(account, password, options) {\n    if (options == null) {\n        options = {};\n    }\n    const passwordBytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);\n    return _encryptKeystore((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(key), kdf, account, options);\n}\n/**\n *  Resolved to the JSON Keystore Wallet for %%account%% encrypted\n *  with %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used and provide a [[ProgressCallback]] to receive periodic updates\n *  on the completion status..\n */\nasync function encryptKeystoreJson(account, password, options) {\n    if (options == null) {\n        options = {};\n    }\n    const passwordBytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPassword)(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = await (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);\n    return _encryptKeystore((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(key), kdf, account, options);\n}\n//# sourceMappingURL=json-keystore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvanNvbi1rZXlzdG9yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QjtBQUNvQjtBQUN1QztBQUMvQjtBQUNxQztBQUN0QztBQUNmO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFPO0FBQzFCO0FBQ0EsbUJBQW1CLGtEQUFPO0FBQzFCLDJCQUEyQix1Q0FBRztBQUM5QixlQUFlLHdEQUFPO0FBQ3RCO0FBQ0EsSUFBSSx1REFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVE7QUFDeEIsdUJBQXVCLGtEQUFPO0FBQzlCLHdCQUF3Qix3REFBTyxDQUFDLDJEQUFTLENBQUMsdURBQU07QUFDaEQsSUFBSSwrREFBYyxpQkFBaUIsa0RBQU87QUFDMUM7QUFDQSxvQkFBb0IscUVBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWMsQ0FBQyw2REFBVTtBQUNqQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFPO0FBQzFDLDJCQUEyQixrREFBTztBQUNsQyxtQ0FBbUMsdUNBQUc7QUFDdEM7QUFDQSxtQkFBbUIsa0RBQU87QUFDMUIscUJBQXFCLGtEQUFPO0FBQzVCLHFCQUFxQix3REFBTyxDQUFDLHlEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQU87QUFDdkI7QUFDQTtBQUNBLHlCQUF5QixrREFBTztBQUNoQyxzQkFBc0Isa0RBQU87QUFDN0Isc0JBQXNCLGtEQUFPO0FBQzdCLHNCQUFzQixr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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzREFBVztBQUNyQztBQUNBLHNCQUFzQix3REFBTTtBQUM1Qiw0QkFBNEIseURBQVE7QUFDcEM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvanNvbi1rZXlzdG9yZS5qcz9iY2VlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSBKU09OIFdhbGxldCBmb3JtYXRzIGFsbG93IGEgc2ltcGxlIHdheSB0byBzdG9yZSB0aGUgcHJpdmF0ZVxuICogIGtleXMgbmVlZGVkIGluIEV0aGVyZXVtIGFsb25nIHdpdGggcmVsYXRlZCBpbmZvcm1hdGlvbiBhbmQgYWxsb3dzXG4gKiAgZm9yIGV4dGVuc2libGUgZm9ybXMgb2YgZW5jcnlwdGlvbi5cbiAqXG4gKiAgVGhlc2UgdXRpbGl0aWVzIGZhY2lsaXRhdGUgZGVjcnlwdGluZyBhbmQgZW5jcnlwdGluZyB0aGUgbW9zdCBjb21tb25cbiAqICBKU09OIFdhbGxldCBmb3JtYXRzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS93YWxsZXQ6SlNPTiBXYWxsZXRzICBbanNvbi13YWxsZXRzXVxuICovXG5pbXBvcnQgeyBDVFIgfSBmcm9tIFwiYWVzLWpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiwgcGJrZGYyLCByYW5kb21CeXRlcywgc2NyeXB0LCBzY3J5cHRTeW5jIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29tcHV0ZUFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZ2V0Qnl0ZXMsIGhleGxpZnksIHV1aWRWNCwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0UGFzc3dvcmQsIHNwZWx1bmssIHpwYWQgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fdmVyc2lvbi5qc1wiO1xuY29uc3QgZGVmYXVsdFBhdGggPSBcIm0vNDQnLzYwJy8wJy8wLzBcIjtcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWpzb24lJSBpcyBhIHZhbGlkIEpTT04gS2V5c3RvcmUgV2FsbGV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNLZXlzdG9yZUpzb24oanNvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gKChkYXRhLnZlcnNpb24gIT0gbnVsbCkgPyBwYXJzZUludChkYXRhLnZlcnNpb24pIDogMCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlY3J5cHQoZGF0YSwga2V5LCBjaXBoZXJ0ZXh0KSB7XG4gICAgY29uc3QgY2lwaGVyID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5jaXBoZXI6c3RyaW5nXCIpO1xuICAgIGlmIChjaXBoZXIgPT09IFwiYWVzLTEyOC1jdHJcIikge1xuICAgICAgICBjb25zdCBpdiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8uY2lwaGVycGFyYW1zLml2OmRhdGEhXCIpO1xuICAgICAgICBjb25zdCBhZXNDdHIgPSBuZXcgQ1RSKGtleSwgaXYpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShhZXNDdHIuZGVjcnlwdChjaXBoZXJ0ZXh0KSk7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBjaXBoZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZGVjcnlwdFwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRBY2NvdW50KGRhdGEsIF9rZXkpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRCeXRlcyhfa2V5KTtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5jaXBoZXJ0ZXh0OmRhdGEhXCIpO1xuICAgIGNvbnN0IGNvbXB1dGVkTUFDID0gaGV4bGlmeShrZWNjYWsyNTYoY29uY2F0KFtrZXkuc2xpY2UoMTYsIDMyKSwgY2lwaGVydGV4dF0pKSkuc3Vic3RyaW5nKDIpO1xuICAgIGFzc2VydEFyZ3VtZW50KGNvbXB1dGVkTUFDID09PSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLm1hYzpzdHJpbmchXCIpLnRvTG93ZXJDYXNlKCksIFwiaW5jb3JyZWN0IHBhc3N3b3JkXCIsIFwicGFzc3dvcmRcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGRlY3J5cHQoZGF0YSwga2V5LnNsaWNlKDAsIDE2KSwgY2lwaGVydGV4dCk7XG4gICAgY29uc3QgYWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzKHByaXZhdGVLZXkpO1xuICAgIGlmIChkYXRhLmFkZHJlc3MpIHtcbiAgICAgICAgbGV0IGNoZWNrID0gZGF0YS5hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghY2hlY2suc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgICAgICBjaGVjayA9IFwiMHhcIiArIGNoZWNrO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGdldEFkZHJlc3MoY2hlY2spID09PSBhZGRyZXNzLCBcImtleXN0b3JlIGFkZHJlc3MvcHJpdmF0ZUtleSBtaXNtYXRjaFwiLCBcImFkZHJlc3NcIiwgZGF0YS5hZGRyZXNzKTtcbiAgICB9XG4gICAgY29uc3QgYWNjb3VudCA9IHsgYWRkcmVzcywgcHJpdmF0ZUtleSB9O1xuICAgIC8vIFZlcnNpb24gMC4xIHgtZXRoZXJzIG1ldGFkYXRhIG11c3QgY29udGFpbiBhbiBlbmNyeXB0ZWQgbW5lbW9uaWMgcGhyYXNlXG4gICAgY29uc3QgdmVyc2lvbiA9IHNwZWx1bmsoZGF0YSwgXCJ4LWV0aGVycy52ZXJzaW9uOnN0cmluZ1wiKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gXCIwLjFcIikge1xuICAgICAgICBjb25zdCBtbmVtb25pY0tleSA9IGtleS5zbGljZSgzMiwgNjQpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0NpcGhlcnRleHQgPSBzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMubW5lbW9uaWNDaXBoZXJ0ZXh0OmRhdGEhXCIpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0l2ID0gc3BlbHVuayhkYXRhLCBcIngtZXRoZXJzLm1uZW1vbmljQ291bnRlcjpkYXRhIVwiKTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNBZXNDdHIgPSBuZXcgQ1RSKG1uZW1vbmljS2V5LCBtbmVtb25pY0l2KTtcbiAgICAgICAgYWNjb3VudC5tbmVtb25pYyA9IHtcbiAgICAgICAgICAgIHBhdGg6IChzcGVsdW5rKGRhdGEsIFwieC1ldGhlcnMucGF0aDpzdHJpbmdcIikgfHwgZGVmYXVsdFBhdGgpLFxuICAgICAgICAgICAgbG9jYWxlOiAoc3BlbHVuayhkYXRhLCBcIngtZXRoZXJzLmxvY2FsZTpzdHJpbmdcIikgfHwgXCJlblwiKSxcbiAgICAgICAgICAgIGVudHJvcHk6IGhleGxpZnkoZ2V0Qnl0ZXMobW5lbW9uaWNBZXNDdHIuZGVjcnlwdChtbmVtb25pY0NpcGhlcnRleHQpKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnQ7XG59XG5mdW5jdGlvbiBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpIHtcbiAgICBjb25zdCBrZGYgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZjpzdHJpbmdcIik7XG4gICAgaWYgKGtkZiAmJiB0eXBlb2YgKGtkZikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGtkZi50b0xvd2VyQ2FzZSgpID09PSBcInNjcnlwdFwiKSB7XG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuc2FsdDpkYXRhIVwiKTtcbiAgICAgICAgICAgIGNvbnN0IE4gPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5uOmludCFcIik7XG4gICAgICAgICAgICBjb25zdCByID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMucjppbnQhXCIpO1xuICAgICAgICAgICAgY29uc3QgcCA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnA6aW50IVwiKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBOIGlzIGEgcG93ZXIgb2YgMlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTiA+IDAgJiYgKE4gJiAoTiAtIDEpKSA9PT0gMCwgXCJpbnZhbGlkIGtkZi5OXCIsIFwia2RmLk5cIiwgTik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyID4gMCAmJiBwID4gMCwgXCJpbnZhbGlkIGtkZlwiLCBcImtkZlwiLCBrZGYpO1xuICAgICAgICAgICAgY29uc3QgZGtMZW4gPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5ka2xlbjppbnQhXCIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGtMZW4gPT09IDMyLCBcImludmFsaWQga2RmLmRrbGVuXCIsIFwia2RmLmRmbGVuXCIsIGRrTGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwic2NyeXB0XCIsIHNhbHQsIE4sIHIsIHAsIGRrTGVuOiA2NCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtkZi50b0xvd2VyQ2FzZSgpID09PSBcInBia2RmMlwiKSB7XG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gc3BlbHVuayhkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuc2FsdDpkYXRhIVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHByZiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnByZjpzdHJpbmchXCIpO1xuICAgICAgICAgICAgY29uc3QgYWxnb3JpdGhtID0gcHJmLnNwbGl0KFwiLVwiKS5wb3AoKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFsZ29yaXRobSA9PT0gXCJzaGEyNTZcIiB8fCBhbGdvcml0aG0gPT09IFwic2hhNTEyXCIsIFwiaW52YWxpZCBrZGYucGRmXCIsIFwia2RmLnBkZlwiLCBwcmYpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBzcGVsdW5rKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5jOmludCFcIik7XG4gICAgICAgICAgICBjb25zdCBka0xlbiA9IHNwZWx1bmsoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmRrbGVuOmludCFcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChka0xlbiA9PT0gMzIsIFwiaW52YWxpZCBrZGYuZGtsZW5cIiwgXCJrZGYuZGtsZW5cIiwgZGtMZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJwYmtkZjJcIiwgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvblwiLCBcImtkZlwiLCBrZGYpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWNjb3VudCBkZXRhaWxzIGZvciB0aGUgSlNPTiBLZXlzdG9yZSBXYWxsZXQgJSVqc29uJSVcbiAqICB1c2luZyAlJXBhc3N3b3JkJSUuXG4gKlxuICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2ZXJzaW9uXShkZWNyeXB0S2V5c3RvcmVKc29uKVxuICogIGluc3RlYWQsIHdoaWNoIGFsbG93cyBhIFtbUHJvZ3Jlc3NDYWxsYmFja11dIHRvIGtlZXAgdGhlIHVzZXIgaW5mb3JtZWRcbiAqICBhcyB0byB0aGUgZGVjcnlwdGlvbiBzdGF0dXMuXG4gKlxuICogIFRoaXMgbWV0aG9kIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgKGZyZWV6aW5nIGFsbCBVSSkgdW50aWwgZGVjcnlwdGlvblxuICogIGlzIGNvbXBsZXRlLCB3aGljaCBjYW4gdGFrZSBxdWl0ZSBzb21lIHRpbWUsIGRlcGVuZGluZyBvbiB0aGUgd2FsbGV0XG4gKiAgcGFyYW10ZXJzIGFuZCBwbGF0Zm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRLZXlzdG9yZUpzb25TeW5jKGpzb24sIF9wYXNzd29yZCkge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gZ2V0UGFzc3dvcmQoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBwYXJhbXMgPSBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpO1xuICAgIGlmIChwYXJhbXMubmFtZSA9PT0gXCJwYmtkZjJcIikge1xuICAgICAgICBjb25zdCB7IHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IGtleSA9IHBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0pO1xuICAgICAgICByZXR1cm4gZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xuICAgIH1cbiAgICBhc3NlcnQocGFyYW1zLm5hbWUgPT09IFwic2NyeXB0XCIsIFwiY2Fubm90IGJlIHJlYWNoZWRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgcGFyYW1zIH0pO1xuICAgIGNvbnN0IHsgc2FsdCwgTiwgciwgcCwgZGtMZW4gfSA9IHBhcmFtcztcbiAgICBjb25zdCBrZXkgPSBzY3J5cHRTeW5jKHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbik7XG4gICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IHNldFRpbWVvdXQoKCkgPT4geyByZXNvbHZlKCk7IH0sIGR1cmF0aW9uKTsgfSk7XG59XG4vKipcbiAqICBSZXNvbHZlcyB0byB0aGUgZGVjcnlwdGVkIEpTT04gS2V5c3RvcmUgV2FsbGV0ICUlanNvbiUlIHVzaW5nIHRoZVxuICogICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgSWYgcHJvdmlkZWQsICUlcHJvZ3Jlc3MlJSB3aWxsIGJlIGNhbGxlZCBwZXJpb2RpY2FsbHkgZHVyaW5nIHRoZVxuICogIGRlY3JweXRpb24gdG8gcHJvdmlkZSBmZWVkYmFjaywgYW5kIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gKiAgYGBmYWxzZWBgIHdpbGwgaGFsdCBkZWNyeXB0aW9uLlxuICpcbiAqICBUaGUgJSVwcm9ncmVzc0NhbGxiYWNrJSUgd2lsbCAqKmFsd2F5cyoqIHJlY2VpdmUgYGAwYGAgYmVmb3JlXG4gKiAgZGVjcnlwdGlvbiBiZWdpbnMgYW5kIGBgMWBgIHdoZW4gY29tcGxldGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0S2V5c3RvcmVKc29uKGpzb24sIF9wYXNzd29yZCwgcHJvZ3Jlc3MpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IGdldFBhc3N3b3JkKF9wYXNzd29yZCk7XG4gICAgY29uc3QgcGFyYW1zID0gZ2V0RGVjcnlwdEtkZlBhcmFtcyhkYXRhKTtcbiAgICBpZiAocGFyYW1zLm5hbWUgPT09IFwicGJrZGYyXCIpIHtcbiAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICBwcm9ncmVzcygwKTtcbiAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0gfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3Qga2V5ID0gcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSk7XG4gICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgcHJvZ3Jlc3MoMSk7XG4gICAgICAgICAgICBhd2FpdCBzdGFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xuICAgIH1cbiAgICBhc3NlcnQocGFyYW1zLm5hbWUgPT09IFwic2NyeXB0XCIsIFwiY2Fubm90IGJlIHJlYWNoZWRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgcGFyYW1zIH0pO1xuICAgIGNvbnN0IHsgc2FsdCwgTiwgciwgcCwgZGtMZW4gfSA9IHBhcmFtcztcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBzY3J5cHQocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzcyk7XG4gICAgcmV0dXJuIGdldEFjY291bnQoZGF0YSwga2V5KTtcbn1cbmZ1bmN0aW9uIGdldEVuY3J5cHRLZGZQYXJhbXMob3B0aW9ucykge1xuICAgIC8vIENoZWNrL2dlbmVyYXRlIHRoZSBzYWx0XG4gICAgY29uc3Qgc2FsdCA9IChvcHRpb25zLnNhbHQgIT0gbnVsbCkgPyBnZXRCeXRlcyhvcHRpb25zLnNhbHQsIFwib3B0aW9ucy5zYWx0XCIpIDogcmFuZG9tQnl0ZXMoMzIpO1xuICAgIC8vIE92ZXJyaWRlIHRoZSBzY3J5cHQgcGFzc3dvcmQtYmFzZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVyc1xuICAgIGxldCBOID0gKDEgPDwgMTcpLCByID0gOCwgcCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuc2NyeXB0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5OKSB7XG4gICAgICAgICAgICBOID0gb3B0aW9ucy5zY3J5cHQuTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQucikge1xuICAgICAgICAgICAgciA9IG9wdGlvbnMuc2NyeXB0LnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0LnApIHtcbiAgICAgICAgICAgIHAgPSBvcHRpb25zLnNjcnlwdC5wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoTikgPT09IFwibnVtYmVyXCIgJiYgTiA+IDAgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIoTikgJiYgKEJpZ0ludChOKSAmIEJpZ0ludChOIC0gMSkpID09PSBCaWdJbnQoMCksIFwiaW52YWxpZCBzY3J5cHQgTiBwYXJhbWV0ZXJcIiwgXCJvcHRpb25zLk5cIiwgTik7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChyKSA9PT0gXCJudW1iZXJcIiAmJiByID4gMCAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihyKSwgXCJpbnZhbGlkIHNjcnlwdCByIHBhcmFtZXRlclwiLCBcIm9wdGlvbnMuclwiLCByKTtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHApID09PSBcIm51bWJlclwiICYmIHAgPiAwICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHApLCBcImludmFsaWQgc2NyeXB0IHAgcGFyYW1ldGVyXCIsIFwib3B0aW9ucy5wXCIsIHApO1xuICAgIHJldHVybiB7IG5hbWU6IFwic2NyeXB0XCIsIGRrTGVuOiAzMiwgc2FsdCwgTiwgciwgcCB9O1xufVxuZnVuY3Rpb24gX2VuY3J5cHRLZXlzdG9yZShrZXksIGtkZiwgYWNjb3VudCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBnZXRCeXRlcyhhY2NvdW50LnByaXZhdGVLZXksIFwicHJpdmF0ZUtleVwiKTtcbiAgICAvLyBPdmVycmlkZSBpbml0aWFsaXphdGlvbiB2ZWN0b3JcbiAgICBjb25zdCBpdiA9IChvcHRpb25zLml2ICE9IG51bGwpID8gZ2V0Qnl0ZXMob3B0aW9ucy5pdiwgXCJvcHRpb25zLml2XCIpIDogcmFuZG9tQnl0ZXMoMTYpO1xuICAgIGFzc2VydEFyZ3VtZW50KGl2Lmxlbmd0aCA9PT0gMTYsIFwiaW52YWxpZCBvcHRpb25zLml2IGxlbmd0aFwiLCBcIm9wdGlvbnMuaXZcIiwgb3B0aW9ucy5pdik7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIHV1aWRcbiAgICBjb25zdCB1dWlkUmFuZG9tID0gKG9wdGlvbnMudXVpZCAhPSBudWxsKSA/IGdldEJ5dGVzKG9wdGlvbnMudXVpZCwgXCJvcHRpb25zLnV1aWRcIikgOiByYW5kb21CeXRlcygxNik7XG4gICAgYXNzZXJ0QXJndW1lbnQodXVpZFJhbmRvbS5sZW5ndGggPT09IDE2LCBcImludmFsaWQgb3B0aW9ucy51dWlkIGxlbmd0aFwiLCBcIm9wdGlvbnMudXVpZFwiLCBvcHRpb25zLml2KTtcbiAgICAvLyBUaGlzIHdpbGwgYmUgdXNlZCB0byBlbmNyeXB0IHRoZSB3YWxsZXQgKGFzIHBlciBXZWIzIHNlY3JldCBzdG9yYWdlKVxuICAgIC8vIC0gMzIgYnl0ZXMgICBBcyBub3JtYWwgZm9yIHRoZSBXZWIzIHNlY3JldCBzdG9yYWdlIChkZXJpdmVkS2V5LCBtYWNQcmVmaXgpXG4gICAgLy8gLSAzMiBieXRlcyAgIEFFUyBrZXkgdG8gZW5jcnlwdCBtbmVtb25pYyB3aXRoIChyZXF1aXJlZCBoZXJlIHRvIGJlIEV0aGVycyBXYWxsZXQpXG4gICAgY29uc3QgZGVyaXZlZEtleSA9IGtleS5zbGljZSgwLCAxNik7XG4gICAgY29uc3QgbWFjUHJlZml4ID0ga2V5LnNsaWNlKDE2LCAzMik7XG4gICAgLy8gRW5jcnlwdCB0aGUgcHJpdmF0ZSBrZXlcbiAgICBjb25zdCBhZXNDdHIgPSBuZXcgQ1RSKGRlcml2ZWRLZXksIGl2KTtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gZ2V0Qnl0ZXMoYWVzQ3RyLmVuY3J5cHQocHJpdmF0ZUtleSkpO1xuICAgIC8vIENvbXB1dGUgdGhlIG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZSwgdXNlZCB0byBjaGVjayB0aGUgcGFzc3dvcmRcbiAgICBjb25zdCBtYWMgPSBrZWNjYWsyNTYoY29uY2F0KFttYWNQcmVmaXgsIGNpcGhlcnRleHRdKSk7XG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1dlYjMtU2VjcmV0LVN0b3JhZ2UtRGVmaW5pdGlvblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgaWQ6IHV1aWRWNCh1dWlkUmFuZG9tKSxcbiAgICAgICAgdmVyc2lvbjogMyxcbiAgICAgICAgQ3J5cHRvOiB7XG4gICAgICAgICAgICBjaXBoZXI6IFwiYWVzLTEyOC1jdHJcIixcbiAgICAgICAgICAgIGNpcGhlcnBhcmFtczoge1xuICAgICAgICAgICAgICAgIGl2OiBoZXhsaWZ5KGl2KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2lwaGVydGV4dDogaGV4bGlmeShjaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICBrZGY6IFwic2NyeXB0XCIsXG4gICAgICAgICAgICBrZGZwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBzYWx0OiBoZXhsaWZ5KGtkZi5zYWx0KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICAgICAgbjoga2RmLk4sXG4gICAgICAgICAgICAgICAgZGtsZW46IDMyLFxuICAgICAgICAgICAgICAgIHA6IGtkZi5wLFxuICAgICAgICAgICAgICAgIHI6IGtkZi5yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFjOiBtYWMuc3Vic3RyaW5nKDIpXG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElmIHdlIGhhdmUgYSBtbmVtb25pYywgZW5jcnlwdCBpdCBpbnRvIHRoZSBKU09OIHdhbGxldFxuICAgIGlmIChhY2NvdW50Lm1uZW1vbmljKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IChvcHRpb25zLmNsaWVudCAhPSBudWxsKSA/IG9wdGlvbnMuY2xpZW50IDogYGV0aGVycy8ke3ZlcnNpb259YDtcbiAgICAgICAgY29uc3QgcGF0aCA9IGFjY291bnQubW5lbW9uaWMucGF0aCB8fCBkZWZhdWx0UGF0aDtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gYWNjb3VudC5tbmVtb25pYy5sb2NhbGUgfHwgXCJlblwiO1xuICAgICAgICBjb25zdCBtbmVtb25pY0tleSA9IGtleS5zbGljZSgzMiwgNjQpO1xuICAgICAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Qnl0ZXMoYWNjb3VudC5tbmVtb25pYy5lbnRyb3B5LCBcImFjY291bnQubW5lbW9uaWMuZW50cm9weVwiKTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNJdiA9IHJhbmRvbUJ5dGVzKDE2KTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNBZXNDdHIgPSBuZXcgQ1RSKG1uZW1vbmljS2V5LCBtbmVtb25pY0l2KTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gZ2V0Qnl0ZXMobW5lbW9uaWNBZXNDdHIuZW5jcnlwdChlbnRyb3B5KSk7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IChub3cuZ2V0VVRDRnVsbFllYXIoKSArIFwiLVwiICtcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICtcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ0RhdGUoKSwgMikgKyBcIlRcIiArXG4gICAgICAgICAgICB6cGFkKG5vdy5nZXRVVENIb3VycygpLCAyKSArIFwiLVwiICtcbiAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ01pbnV0ZXMoKSwgMikgKyBcIi1cIiArXG4gICAgICAgICAgICB6cGFkKG5vdy5nZXRVVENTZWNvbmRzKCksIDIpICsgXCIuMFpcIik7XG4gICAgICAgIGNvbnN0IGdldGhGaWxlbmFtZSA9IChcIlVUQy0tXCIgKyB0aW1lc3RhbXAgKyBcIi0tXCIgKyBkYXRhLmFkZHJlc3MpO1xuICAgICAgICBkYXRhW1wieC1ldGhlcnNcIl0gPSB7XG4gICAgICAgICAgICBjbGllbnQsIGdldGhGaWxlbmFtZSwgcGF0aCwgbG9jYWxlLFxuICAgICAgICAgICAgbW5lbW9uaWNDb3VudGVyOiBoZXhsaWZ5KG1uZW1vbmljSXYpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgIG1uZW1vbmljQ2lwaGVydGV4dDogaGV4bGlmeShtbmVtb25pY0NpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgIHZlcnNpb246IFwiMC4xXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCBmb3IgJSVhY2NvdW50JSUgZW5jcnlwdGVkIHdpdGhcbiAqICAlJXBhc3N3b3JkJSUuXG4gKlxuICogIFRoZSAlJW9wdGlvbnMlJSBjYW4gYmUgdXNlZCB0byB0dW5lIHRoZSBwYXNzd29yZC1iYXNlZCBrZXlcbiAqICBkZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIGV4cGxpY2l0bHkgc2V0IHRoZSByYW5kb20gdmFsdWVzXG4gKiAgdXNlZC4gQW55IHByb3ZpZGVkIFtbUHJvZ3Jlc3NDYWxsYmFja11dIGlzIGlnbm9yZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY3J5cHRLZXlzdG9yZUpzb25TeW5jKGFjY291bnQsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGNvbnN0IHBhc3N3b3JkQnl0ZXMgPSBnZXRQYXNzd29yZChwYXNzd29yZCk7XG4gICAgY29uc3Qga2RmID0gZ2V0RW5jcnlwdEtkZlBhcmFtcyhvcHRpb25zKTtcbiAgICBjb25zdCBrZXkgPSBzY3J5cHRTeW5jKHBhc3N3b3JkQnl0ZXMsIGtkZi5zYWx0LCBrZGYuTiwga2RmLnIsIGtkZi5wLCA2NCk7XG4gICAgcmV0dXJuIF9lbmNyeXB0S2V5c3RvcmUoZ2V0Qnl0ZXMoa2V5KSwga2RmLCBhY2NvdW50LCBvcHRpb25zKTtcbn1cbi8qKlxuICogIFJlc29sdmVkIHRvIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCBmb3IgJSVhY2NvdW50JSUgZW5jcnlwdGVkXG4gKiAgd2l0aCAlJXBhc3N3b3JkJSUuXG4gKlxuICogIFRoZSAlJW9wdGlvbnMlJSBjYW4gYmUgdXNlZCB0byB0dW5lIHRoZSBwYXNzd29yZC1iYXNlZCBrZXlcbiAqICBkZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIGV4cGxpY2l0bHkgc2V0IHRoZSByYW5kb20gdmFsdWVzXG4gKiAgdXNlZCBhbmQgcHJvdmlkZSBhIFtbUHJvZ3Jlc3NDYWxsYmFja11dIHRvIHJlY2VpdmUgcGVyaW9kaWMgdXBkYXRlc1xuICogIG9uIHRoZSBjb21wbGV0aW9uIHN0YXR1cy4uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0S2V5c3RvcmVKc29uKGFjY291bnQsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGNvbnN0IHBhc3N3b3JkQnl0ZXMgPSBnZXRQYXNzd29yZChwYXNzd29yZCk7XG4gICAgY29uc3Qga2RmID0gZ2V0RW5jcnlwdEtkZlBhcmFtcyhvcHRpb25zKTtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBzY3J5cHQocGFzc3dvcmRCeXRlcywga2RmLnNhbHQsIGtkZi5OLCBrZGYuciwga2RmLnAsIDY0LCBvcHRpb25zLnByb2dyZXNzQ2FsbGJhY2spO1xuICAgIHJldHVybiBfZW5jcnlwdEtleXN0b3JlKGdldEJ5dGVzKGtleSksIGtkZiwgYWNjb3VudCwgb3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLWtleXN0b3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wallet/json-keystore.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wallet/mnemonic.js":
/*!****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wallet/mnemonic.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mnemonic: function() { return /* binding */ Mnemonic; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wordlists/lang-en.js */ \"../common/node_modules/ethers/lib.esm/wordlists/lang-en.js\");\n\n\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n    return ((1 << bits) - 1) << (8 - bits) & 0xff;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n    return ((1 << bits) - 1) & 0xff;\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(\"NFKD\");\n    if (wordlist == null) {\n        wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn.wordlist();\n    }\n    const words = wordlist.split(mnemonic);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((words.length % 3) === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n    const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, `invalid mnemonic word at index ${i}`, \"mnemonic\", \"[ REDACTED ]\");\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n    const entropyBits = 32 * words.length / 3;\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n    const checksum = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(entropy.slice(0, entropyBits / 8));\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((entropy.length % 4) === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n    if (wordlist == null) {\n        wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn.wordlist();\n    }\n    const indices = [0];\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n            remainingBits -= 8;\n            // This byte will complete an 11-bit index\n        }\n        else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n            remainingBits += 3;\n        }\n    }\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = parseInt((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n    return wordlist.join(indices.map((index) => wordlist.getWord(index)));\n}\nconst _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */\nclass Mnemonic {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    phrase;\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     *  is the empty string (i.e. ``\"\"``) as per the specification.\n     */\n    password;\n    /**\n     *  The wordlist for this mnemonic.\n     */\n    wordlist;\n    /**\n     *  The underlying entropy which the mnemonic encodes.\n     */\n    entropy;\n    /**\n     *  @private\n     */\n    constructor(guard, entropy, phrase, password, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (wordlist == null) {\n            wordlist = _wordlists_lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn.wordlist();\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"Mnemonic\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { phrase, password, wordlist, entropy });\n    }\n    /**\n     *  Returns the seed for the mnemonic.\n     */\n    computeSeed() {\n        const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(\"mnemonic\" + this.password, \"NFKD\");\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.pbkdf2)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n    }\n    /**\n     *  Creates a new Mnemonic for the %%phrase%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromPhrase(phrase, password, wordlist) {\n        // Normalize the case and space; throws if invalid\n        const entropy = mnemonicToEntropy(phrase, wordlist);\n        phrase = entropyToMnemonic((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(entropy), wordlist);\n        return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n    }\n    /**\n     *  Create a new **Mnemonic** from the %%entropy%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromEntropy(_entropy, password, wordlist) {\n        const entropy = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_entropy, \"entropy\");\n        const phrase = entropyToMnemonic(entropy, wordlist);\n        return new Mnemonic(_guard, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(entropy), phrase, password, wordlist);\n    }\n    /**\n     *  Returns the phrase for %%mnemonic%%.\n     */\n    static entropyToPhrase(_entropy, wordlist) {\n        const entropy = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_entropy, \"entropy\");\n        return entropyToMnemonic(entropy, wordlist);\n    }\n    /**\n     *  Returns the entropy for %%phrase%%.\n     */\n    static phraseToEntropy(phrase, wordlist) {\n        return mnemonicToEntropy(phrase, wordlist);\n    }\n    /**\n     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n     *\n     *  This checks all the provided words belong to the %%wordlist%%,\n     *  that the length is valid and the checksum is correct.\n     */\n    static isValidMnemonic(phrase, wordlist) {\n        try {\n            mnemonicToEntropy(phrase, wordlist);\n            return true;\n        }\n        catch (error) { }\n        return false;\n    }\n}\n//# sourceMappingURL=mnemonic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvbW5lbW9uaWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUNpRjtBQUNwRjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFlO0FBQ25CO0FBQ0EsbUJBQW1CLHlEQUFNO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsUUFBUSwrREFBYywrQ0FBK0MsRUFBRTtBQUN2RSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseURBQVEsQ0FBQyx3REFBTTtBQUNwQyxJQUFJLCtEQUFjO0FBQ2xCLFdBQVcsd0RBQU87QUFDbEI7QUFDQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQSxtQkFBbUIseURBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdEQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQU07QUFDN0I7QUFDQSxRQUFRLDhEQUFhO0FBQ3JCLFFBQVEsaUVBQWdCLFNBQVMscUNBQXFDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQVc7QUFDaEMsZUFBZSx3REFBTSxDQUFDLDREQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxtQ0FBbUMseURBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFRO0FBQ2hDO0FBQ0Esb0NBQW9DLHdEQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseURBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dhbGxldC9tbmVtb25pYy5qcz84NGEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBia2RmMiwgc2hhMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0Qnl0ZXMsIGhleGxpZnksIGFzc2VydE5vcm1hbGl6ZSwgYXNzZXJ0UHJpdmF0ZSwgYXNzZXJ0QXJndW1lbnQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBMYW5nRW4gfSBmcm9tIFwiLi4vd29yZGxpc3RzL2xhbmctZW4uanNcIjtcbi8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIE1TQiBiaXRzIHNldFxuZnVuY3Rpb24gZ2V0VXBwZXJNYXNrKGJpdHMpIHtcbiAgICByZXR1cm4gKCgxIDw8IGJpdHMpIC0gMSkgPDwgKDggLSBiaXRzKSAmIDB4ZmY7XG59XG4vLyBSZXR1cm5zIGEgYnl0ZSB3aXRoIHRoZSBMU0IgYml0cyBzZXRcbmZ1bmN0aW9uIGdldExvd2VyTWFzayhiaXRzKSB7XG4gICAgcmV0dXJuICgoMSA8PCBiaXRzKSAtIDEpICYgMHhmZjtcbn1cbmZ1bmN0aW9uIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCkge1xuICAgIGFzc2VydE5vcm1hbGl6ZShcIk5GS0RcIik7XG4gICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgd29yZGxpc3QgPSBMYW5nRW4ud29yZGxpc3QoKTtcbiAgICB9XG4gICAgY29uc3Qgd29yZHMgPSB3b3JkbGlzdC5zcGxpdChtbmVtb25pYyk7XG4gICAgYXNzZXJ0QXJndW1lbnQoKHdvcmRzLmxlbmd0aCAlIDMpID09PSAwICYmIHdvcmRzLmxlbmd0aCA+PSAxMiAmJiB3b3Jkcy5sZW5ndGggPD0gMjQsIFwiaW52YWxpZCBtbmVtb25pYyBsZW5ndGhcIiwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICBjb25zdCBlbnRyb3B5ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKDExICogd29yZHMubGVuZ3RoIC8gOCkpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGluZGV4ID0gd29yZGxpc3QuZ2V0V29yZEluZGV4KHdvcmRzW2ldLm5vcm1hbGl6ZShcIk5GS0RcIikpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBgaW52YWxpZCBtbmVtb25pYyB3b3JkIGF0IGluZGV4ICR7aX1gLCBcIm1uZW1vbmljXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICBmb3IgKGxldCBiaXQgPSAwOyBiaXQgPCAxMTsgYml0KyspIHtcbiAgICAgICAgICAgIGlmIChpbmRleCAmICgxIDw8ICgxMCAtIGJpdCkpKSB7XG4gICAgICAgICAgICAgICAgZW50cm9weVtvZmZzZXQgPj4gM10gfD0gKDEgPDwgKDcgLSAob2Zmc2V0ICUgOCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVudHJvcHlCaXRzID0gMzIgKiB3b3Jkcy5sZW5ndGggLyAzO1xuICAgIGNvbnN0IGNoZWNrc3VtQml0cyA9IHdvcmRzLmxlbmd0aCAvIDM7XG4gICAgY29uc3QgY2hlY2tzdW1NYXNrID0gZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBnZXRCeXRlcyhzaGEyNTYoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKSlbMF0gJiBjaGVja3N1bU1hc2s7XG4gICAgYXNzZXJ0QXJndW1lbnQoY2hlY2tzdW0gPT09IChlbnRyb3B5W2VudHJvcHkubGVuZ3RoIC0gMV0gJiBjaGVja3N1bU1hc2spLCBcImludmFsaWQgbW5lbW9uaWMgY2hlY2tzdW1cIiwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpO1xufVxuZnVuY3Rpb24gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICBhc3NlcnRBcmd1bWVudCgoZW50cm9weS5sZW5ndGggJSA0KSA9PT0gMCAmJiBlbnRyb3B5Lmxlbmd0aCA+PSAxNiAmJiBlbnRyb3B5Lmxlbmd0aCA8PSAzMiwgXCJpbnZhbGlkIGVudHJvcHkgc2l6ZVwiLCBcImVudHJvcHlcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgd29yZGxpc3QgPSBMYW5nRW4ud29yZGxpc3QoKTtcbiAgICB9XG4gICAgY29uc3QgaW5kaWNlcyA9IFswXTtcbiAgICBsZXQgcmVtYWluaW5nQml0cyA9IDExO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDb25zdW1lIHRoZSB3aG9sZSBieXRlICh3aXRoIHN0aWxsIG1vcmUgdG8gZ28pXG4gICAgICAgIGlmIChyZW1haW5pbmdCaXRzID4gOCkge1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSA4O1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV07XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG4gICAgICAgICAgICAvLyBUaGlzIGJ5dGUgd2lsbCBjb21wbGV0ZSBhbiAxMS1iaXQgaW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gcmVtYWluaW5nQml0cztcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldID4+ICg4IC0gcmVtYWluaW5nQml0cyk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCB3b3JkXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goZW50cm9weVtpXSAmIGdldExvd2VyTWFzayg4IC0gcmVtYWluaW5nQml0cykpO1xuICAgICAgICAgICAgcmVtYWluaW5nQml0cyArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIGNoZWNrc3VtIGJpdHNcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSBlbnRyb3B5Lmxlbmd0aCAvIDQ7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBwYXJzZUludChzaGEyNTYoZW50cm9weSkuc3Vic3RyaW5nKDIsIDQpLCAxNikgJiBnZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtcbiAgICAvLyBTaGlmdCB0aGUgY2hlY2tzdW0gaW50byB0aGUgd29yZCBpbmRpY2VzXG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSBjaGVja3N1bUJpdHM7XG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IChjaGVja3N1bSA+PiAoOCAtIGNoZWNrc3VtQml0cykpO1xuICAgIHJldHVybiB3b3JkbGlzdC5qb2luKGluZGljZXMubWFwKChpbmRleCkgPT4gd29yZGxpc3QuZ2V0V29yZChpbmRleCkpKTtcbn1cbmNvbnN0IF9ndWFyZCA9IHt9O1xuLyoqXG4gKiAgQSAqKk1uZW1vbmljKiogd3JhcHMgYWxsIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gY29tcHV0ZSBbW2xpbmstYmlwLTM5XV1cbiAqICBzZWVkcyBhbmQgY29udmVydCBiZXR3ZWVuIHBocmFzZXMgYW5kIGVudHJvcHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBNbmVtb25pYyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtbmVtb25pYyBwaHJhc2Ugb2YgMTIsIDE1LCAxOCwgMjEgb3IgMjQgd29yZHMuXG4gICAgICpcbiAgICAgKiAgVXNlIHRoZSBbW3dvcmRsaXN0XV0gYGBzcGxpdGBgIG1ldGhvZCB0byBnZXQgdGhlIGluZGl2aWR1YWwgd29yZHMuXG4gICAgICovXG4gICAgcGhyYXNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcGFzc3dvcmQgdXNlZCBmb3IgdGhpcyBtbmVtb25pYy4gSWYgbm8gcGFzc3dvcmQgaXMgdXNlZCB0aGlzXG4gICAgICogIGlzIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGFzIHBlciB0aGUgc3BlY2lmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBwYXNzd29yZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHdvcmRsaXN0IGZvciB0aGlzIG1uZW1vbmljLlxuICAgICAqL1xuICAgIHdvcmRsaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgdW5kZXJseWluZyBlbnRyb3B5IHdoaWNoIHRoZSBtbmVtb25pYyBlbmNvZGVzLlxuICAgICAqL1xuICAgIGVudHJvcHk7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGVudHJvcHksIHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIk1uZW1vbmljXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QsIGVudHJvcHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzZWVkIGZvciB0aGUgbW5lbW9uaWMuXG4gICAgICovXG4gICAgY29tcHV0ZVNlZWQoKSB7XG4gICAgICAgIGNvbnN0IHNhbHQgPSB0b1V0ZjhCeXRlcyhcIm1uZW1vbmljXCIgKyB0aGlzLnBhc3N3b3JkLCBcIk5GS0RcIik7XG4gICAgICAgIHJldHVybiBwYmtkZjIodG9VdGY4Qnl0ZXModGhpcy5waHJhc2UsIFwiTkZLRFwiKSwgc2FsdCwgMjA0OCwgNjQsIFwic2hhNTEyXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBNbmVtb25pYyBmb3IgdGhlICUlcGhyYXNlJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgJSVwYXNzd29yZCUlIGlzIHRoZSBlbXB0eSBzdHJpbmcgYW5kIHRoZSBkZWZhdWx0XG4gICAgICogIHdvcmRsaXN0IGlzIHRoZSBbRW5nbGlzaCB3b3JkbGlzdHNdKExhbmdFbikuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBjYXNlIGFuZCBzcGFjZTsgdGhyb3dzIGlmIGludmFsaWRcbiAgICAgICAgY29uc3QgZW50cm9weSA9IG1uZW1vbmljVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpO1xuICAgICAgICBwaHJhc2UgPSBlbnRyb3B5VG9NbmVtb25pYyhnZXRCeXRlcyhlbnRyb3B5KSwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gbmV3IE1uZW1vbmljKF9ndWFyZCwgZW50cm9weSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqTW5lbW9uaWMqKiBmcm9tIHRoZSAlJWVudHJvcHklJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVmYXVsdCAlJXBhc3N3b3JkJSUgaXMgdGhlIGVtcHR5IHN0cmluZyBhbmQgdGhlIGRlZmF1bHRcbiAgICAgKiAgd29yZGxpc3QgaXMgdGhlIFtFbmdsaXNoIHdvcmRsaXN0c10oTGFuZ0VuKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUVudHJvcHkoX2VudHJvcHksIHBhc3N3b3JkLCB3b3JkbGlzdCkge1xuICAgICAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Qnl0ZXMoX2VudHJvcHksIFwiZW50cm9weVwiKTtcbiAgICAgICAgY29uc3QgcGhyYXNlID0gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gbmV3IE1uZW1vbmljKF9ndWFyZCwgaGV4bGlmeShlbnRyb3B5KSwgcGhyYXNlLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcGhyYXNlIGZvciAlJW1uZW1vbmljJSUuXG4gICAgICovXG4gICAgc3RhdGljIGVudHJvcHlUb1BocmFzZShfZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICAgICAgY29uc3QgZW50cm9weSA9IGdldEJ5dGVzKF9lbnRyb3B5LCBcImVudHJvcHlcIik7XG4gICAgICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRyb3B5IGZvciAlJXBocmFzZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBwaHJhc2VUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCkge1xuICAgICAgICByZXR1cm4gbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVwaHJhc2UlJSBpcyBhIHZhbGlkIFtbbGluay1iaXAtMzldXSBwaHJhc2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjaGVja3MgYWxsIHRoZSBwcm92aWRlZCB3b3JkcyBiZWxvbmcgdG8gdGhlICUld29yZGxpc3QlJSxcbiAgICAgKiAgdGhhdCB0aGUgbGVuZ3RoIGlzIHZhbGlkIGFuZCB0aGUgY2hlY2tzdW0gaXMgY29ycmVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZE1uZW1vbmljKHBocmFzZSwgd29yZGxpc3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1uZW1vbmljVG9FbnRyb3B5KHBocmFzZSwgd29yZGxpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1uZW1vbmljLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wallet/mnemonic.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wallet/utils.js":
/*!*************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wallet/utils.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPassword: function() { return /* binding */ getPassword; },\n/* harmony export */   looseArrayify: function() { return /* binding */ looseArrayify; },\n/* harmony export */   spelunk: function() { return /* binding */ spelunk; },\n/* harmony export */   zpad: function() { return /* binding */ zpad; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/**\n *  @_ignore\n */\n\nfunction looseArrayify(hexString) {\n    if (typeof (hexString) === \"string\" && !hexString.startsWith(\"0x\")) {\n        hexString = \"0x\" + hexString;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(hexString);\n}\nfunction zpad(value, length) {\n    value = String(value);\n    while (value.length < length) {\n        value = '0' + value;\n    }\n    return value;\n}\nfunction getPassword(password) {\n    if (typeof (password) === 'string') {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(password, \"NFKC\");\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(password);\n}\nfunction spelunk(object, _path) {\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match != null, \"invalid path\", \"path\", _path);\n    const path = match[1];\n    const type = match[3];\n    const reqd = (match[4] === \"!\");\n    let cur = object;\n    for (const comp of path.toLowerCase().split('.')) {\n        // Search for a child object with a case-insensitive matching key\n        if (Array.isArray(cur)) {\n            if (!comp.match(/^[0-9]+$/)) {\n                break;\n            }\n            cur = cur[parseInt(comp)];\n        }\n        else if (typeof (cur) === \"object\") {\n            let found = null;\n            for (const key in cur) {\n                if (key.toLowerCase() === comp) {\n                    found = cur[key];\n                    break;\n                }\n            }\n            cur = found;\n        }\n        else {\n            cur = null;\n        }\n        if (cur == null) {\n            break;\n        }\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(!reqd || cur != null, \"missing required value\", \"path\", path);\n    if (type && cur != null) {\n        if (type === \"int\") {\n            if (typeof (cur) === \"string\" && cur.match(/^-?[0-9]+$/)) {\n                return parseInt(cur);\n            }\n            else if (Number.isSafeInteger(cur)) {\n                return cur;\n            }\n        }\n        if (type === \"number\") {\n            if (typeof (cur) === \"string\" && cur.match(/^-?[0-9.]*$/)) {\n                return parseFloat(cur);\n            }\n        }\n        if (type === \"data\") {\n            if (typeof (cur) === \"string\") {\n                return looseArrayify(cur);\n            }\n        }\n        if (type === \"array\" && Array.isArray(cur)) {\n            return cur;\n        }\n        if (type === typeof (cur)) {\n            return cur;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `wrong type found for ${type} `, \"path\", path);\n    }\n    return cur;\n}\n/*\nexport function follow(object: any, path: string): null | string {\n    let currentChild = object;\n\n    for (const comp of path.toLowerCase().split('/')) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comp) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        if (matchingChild === null) { return null; }\n\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// \"path/to/something:type!\"\nexport function followRequired(data: any, path: string): string {\n    const value = follow(data, path);\n    if (value != null) { return value; }\n    return logger.throwArgumentError(\"invalid value\", `data:${ path }`,\n    JSON.stringify(data));\n}\n*/\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n/*\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n*/\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDOEU7QUFDdkU7QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFZO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSw0REFBVztBQUMxQjtBQUNBLFdBQVcsNkRBQVk7QUFDdkI7QUFDTztBQUNQO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWMsZ0NBQWdDLE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvdXRpbHMuanM/Mjc2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBAX2lnbm9yZVxuICovXG5pbXBvcnQgeyBnZXRCeXRlc0NvcHksIGFzc2VydEFyZ3VtZW50LCB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGxvb3NlQXJyYXlpZnkoaGV4U3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiAoaGV4U3RyaW5nKSA9PT0gXCJzdHJpbmdcIiAmJiAhaGV4U3RyaW5nLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICBoZXhTdHJpbmcgPSBcIjB4XCIgKyBoZXhTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlc0NvcHkoaGV4U3RyaW5nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB6cGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9ICcwJyArIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICBpZiAodHlwZW9mIChwYXNzd29yZCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXNDb3B5KHBhc3N3b3JkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGVsdW5rKG9iamVjdCwgX3BhdGgpIHtcbiAgICBjb25zdCBtYXRjaCA9IF9wYXRoLm1hdGNoKC9eKFthLXowLTkkXy4tXSopKDooW2Etel0rKSk/KCEpPyQvaSk7XG4gICAgYXNzZXJ0QXJndW1lbnQobWF0Y2ggIT0gbnVsbCwgXCJpbnZhbGlkIHBhdGhcIiwgXCJwYXRoXCIsIF9wYXRoKTtcbiAgICBjb25zdCBwYXRoID0gbWF0Y2hbMV07XG4gICAgY29uc3QgdHlwZSA9IG1hdGNoWzNdO1xuICAgIGNvbnN0IHJlcWQgPSAobWF0Y2hbNF0gPT09IFwiIVwiKTtcbiAgICBsZXQgY3VyID0gb2JqZWN0O1xuICAgIGZvciAoY29uc3QgY29tcCBvZiBwYXRoLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy4nKSkge1xuICAgICAgICAvLyBTZWFyY2ggZm9yIGEgY2hpbGQgb2JqZWN0IHdpdGggYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nIGtleVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXIpKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXAubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGN1cltwYXJzZUludChjb21wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChjdXIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBjb21wKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gY3VyW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KCFyZXFkIHx8IGN1ciAhPSBudWxsLCBcIm1pc3NpbmcgcmVxdWlyZWQgdmFsdWVcIiwgXCJwYXRoXCIsIHBhdGgpO1xuICAgIGlmICh0eXBlICYmIGN1ciAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjdXIpID09PSBcInN0cmluZ1wiICYmIGN1ci5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihjdXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJzdHJpbmdcIiAmJiBjdXIubWF0Y2goL14tP1swLTkuXSokLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb29zZUFycmF5aWZ5KGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGN1cikpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IHR5cGVvZiAoY3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYHdyb25nIHR5cGUgZm91bmQgZm9yICR7dHlwZX0gYCwgXCJwYXRoXCIsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gY3VyO1xufVxuLypcbmV4cG9ydCBmdW5jdGlvbiBmb2xsb3cob2JqZWN0OiBhbnksIHBhdGg6IHN0cmluZyk6IG51bGwgfCBzdHJpbmcge1xuICAgIGxldCBjdXJyZW50Q2hpbGQgPSBvYmplY3Q7XG5cbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJykpIHtcblxuICAgICAgICAvLyBTZWFyY2ggZm9yIGEgY2hpbGQgb2JqZWN0IHdpdGggYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nIGtleVxuICAgICAgICBsZXQgbWF0Y2hpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gY29tcCkge1xuICAgICAgICAgICAgICAgICBtYXRjaGluZ0NoaWxkID0gY3VycmVudENoaWxkW2tleV07XG4gICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGluZ0NoaWxkID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgY3VycmVudENoaWxkID0gbWF0Y2hpbmdDaGlsZDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudENoaWxkO1xufVxuXG4vLyBcInBhdGgvdG8vc29tZXRoaW5nOnR5cGUhXCJcbmV4cG9ydCBmdW5jdGlvbiBmb2xsb3dSZXF1aXJlZChkYXRhOiBhbnksIHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgdmFsdWUgPSBmb2xsb3coZGF0YSwgcGF0aCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHsgcmV0dXJuIHZhbHVlOyB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHZhbHVlXCIsIGBkYXRhOiR7IHBhdGggfWAsXG4gICAgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xufVxuKi9cbi8vIFNlZTogaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQxMjIudHh0IChTZWN0aW9uIDQuNClcbi8qXG5leHBvcnQgZnVuY3Rpb24gdXVpZFY0KHJhbmRvbUJ5dGVzOiBCeXRlc0xpa2UpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMocmFuZG9tQnl0ZXMsIFwicmFuZG9tQnl0ZXNcIik7XG5cbiAgICAvLyBTZWN0aW9uOiA0LjEuMzpcbiAgICAvLyAtIHRpbWVfaGlfYW5kX3ZlcnNpb25bMTI6MTZdID0gMGIwMTAwXG4gICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XG5cbiAgICAvLyBTZWN0aW9uIDQuNFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs2XSA9IDBiMFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs3XSA9IDBiMVxuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gICAgY29uc3QgdmFsdWUgPSBoZXhsaWZ5KGJ5dGVzKTtcblxuICAgIHJldHVybiBbXG4gICAgICAgdmFsdWUuc3Vic3RyaW5nKDIsIDEwKSxcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTAsIDE0KSxcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTQsIDE4KSxcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTgsIDIyKSxcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMjIsIDM0KSxcbiAgICBdLmpvaW4oXCItXCIpO1xufVxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wallet/utils.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wallet/wallet.js":
/*!**************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wallet/wallet.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Wallet: function() { return /* binding */ Wallet; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"../common/node_modules/ethers/lib.esm/crypto/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _base_wallet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-wallet.js */ \"../common/node_modules/ethers/lib.esm/wallet/base-wallet.js\");\n/* harmony import */ var _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hdwallet.js */ \"../common/node_modules/ethers/lib.esm/wallet/hdwallet.js\");\n/* harmony import */ var _json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./json-crowdsale.js */ \"../common/node_modules/ethers/lib.esm/wallet/json-crowdsale.js\");\n/* harmony import */ var _json_keystore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-keystore.js */ \"../common/node_modules/ethers/lib.esm/wallet/json-keystore.js\");\n/* harmony import */ var _mnemonic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mnemonic.js */ \"../common/node_modules/ethers/lib.esm/wallet/mnemonic.js\");\n\n\n\n\n\n\n\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\n}\n/**\n *  A **Wallet** manages a single private key which is used to sign\n *  transactions, messages and other common payloads.\n *\n *  This class is generally the main entry point for developers\n *  that wish to use a private key directly, as it can create\n *  instances from a large variety of common sources, including\n *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON\n *  wallets.\n */\nclass Wallet extends _base_wallet_js__WEBPACK_IMPORTED_MODULE_0__.BaseWallet {\n    /**\n     *  Create a new wallet for the private %%key%%, optionally connected\n     *  to %%provider%%.\n     */\n    constructor(key, provider) {\n        if (typeof (key) === \"string\" && !key.startsWith(\"0x\")) {\n            key = \"0x\" + key;\n        }\n        let signingKey = (typeof (key) === \"string\") ? new _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.SigningKey(key) : key;\n        super(signingKey, provider);\n    }\n    connect(provider) {\n        return new Wallet(this.signingKey, provider);\n    }\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */\n    async encrypt(password, progressCallback) {\n        const account = { address: this.address, privateKey: this.privateKey };\n        return await (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.encryptKeystoreJson)(account, password, { progressCallback });\n    }\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */\n    encryptSync(password) {\n        const account = { address: this.address, privateKey: this.privateKey };\n        return (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.encryptKeystoreJsonSync)(account, password);\n    }\n    static #fromAccount(account) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        if (\"mnemonic\" in account && account.mnemonic && account.mnemonic.locale === \"en\") {\n            const mnemonic = _mnemonic_js__WEBPACK_IMPORTED_MODULE_4__.Mnemonic.fromEntropy(account.mnemonic.entropy);\n            const wallet = _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);\n            if (wallet.address === account.address && wallet.privateKey === account.privateKey) {\n                return wallet;\n            }\n            console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\");\n        }\n        const wallet = new Wallet(account.privateKey);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(wallet.address === account.address, \"address/privateKey mismatch\", \"json\", \"[ REDACTED ]\");\n        return wallet;\n    }\n    /**\n     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%\n     *  with %%password%%.\n     *\n     *  If %%progress%% is provided, it is called periodically during\n     *  decryption so that any UI can be updated.\n     */\n    static async fromEncryptedJson(json, password, progress) {\n        let account = null;\n        if ((0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.isKeystoreJson)(json)) {\n            account = await (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.decryptKeystoreJson)(json, password, progress);\n        }\n        else if ((0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.isCrowdsaleJson)(json)) {\n            if (progress) {\n                progress(0);\n                await stall(0);\n            }\n            account = (0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.decryptCrowdsaleJson)(json, password);\n            if (progress) {\n                progress(1);\n                await stall(0);\n            }\n        }\n        return Wallet.#fromAccount(account);\n    }\n    /**\n     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.\n     *\n     *  The [[fromEncryptedJson]] method is preferred, as this method\n     *  will lock up and freeze the UI during decryption, which may take\n     *  some time.\n     */\n    static fromEncryptedJsonSync(json, password) {\n        let account = null;\n        if ((0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.isKeystoreJson)(json)) {\n            account = (0,_json_keystore_js__WEBPACK_IMPORTED_MODULE_2__.decryptKeystoreJsonSync)(json, password);\n        }\n        else if ((0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.isCrowdsaleJson)(json)) {\n            account = (0,_json_crowdsale_js__WEBPACK_IMPORTED_MODULE_6__.decryptCrowdsaleJson)(json, password);\n        }\n        else {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        }\n        return Wallet.#fromAccount(account);\n    }\n    /**\n     *  Creates a new random [[HDNodeWallet]] using the available\n     *  [cryptographic random source](randomBytes).\n     *\n     *  If there is no crytographic random source, this will throw.\n     */\n    static createRandom(provider) {\n        const wallet = _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__.HDNodeWallet.createRandom();\n        if (provider) {\n            return wallet.connect(provider);\n        }\n        return wallet;\n    }\n    /**\n     *  Creates a [[HDNodeWallet]] for %%phrase%%.\n     */\n    static fromPhrase(phrase, provider) {\n        const wallet = _hdwallet_js__WEBPACK_IMPORTED_MODULE_5__.HDNodeWallet.fromPhrase(phrase);\n        if (provider) {\n            return wallet.connect(provider);\n        }\n        return wallet;\n    }\n}\n//# sourceMappingURL=wallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvd2FsbGV0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0c7QUFDTDtBQUNEO0FBQytCO0FBQ29FO0FBQ3ZHO0FBQ3pDO0FBQ0Esc0NBQXNDLG1CQUFtQixZQUFZLGNBQWM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQix1REFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHdEQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHFCQUFxQixzRUFBbUIsc0JBQXNCLGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZUFBZSwwRUFBdUI7QUFDdEM7QUFDQTtBQUNBLFFBQVEsK0RBQWM7QUFDdEI7QUFDQSw2QkFBNkIsa0RBQVE7QUFDckMsMkJBQTJCLHNEQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBYztBQUMxQiw0QkFBNEIsc0VBQW1CO0FBQy9DO0FBQ0EsaUJBQWlCLG1FQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdFQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQWM7QUFDMUIsc0JBQXNCLDBFQUF1QjtBQUM3QztBQUNBLGlCQUFpQixtRUFBZTtBQUNoQyxzQkFBc0Isd0VBQW9CO0FBQzFDO0FBQ0E7QUFDQSxZQUFZLCtEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93YWxsZXQvd2FsbGV0LmpzP2NjZmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBCYXNlV2FsbGV0IH0gZnJvbSBcIi4vYmFzZS13YWxsZXQuanNcIjtcbmltcG9ydCB7IEhETm9kZVdhbGxldCB9IGZyb20gXCIuL2hkd2FsbGV0LmpzXCI7XG5pbXBvcnQgeyBkZWNyeXB0Q3Jvd2RzYWxlSnNvbiwgaXNDcm93ZHNhbGVKc29uIH0gZnJvbSBcIi4vanNvbi1jcm93ZHNhbGUuanNcIjtcbmltcG9ydCB7IGRlY3J5cHRLZXlzdG9yZUpzb24sIGRlY3J5cHRLZXlzdG9yZUpzb25TeW5jLCBlbmNyeXB0S2V5c3RvcmVKc29uLCBlbmNyeXB0S2V5c3RvcmVKc29uU3luYywgaXNLZXlzdG9yZUpzb24gfSBmcm9tIFwiLi9qc29uLWtleXN0b3JlLmpzXCI7XG5pbXBvcnQgeyBNbmVtb25pYyB9IGZyb20gXCIuL21uZW1vbmljLmpzXCI7XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4geyBzZXRUaW1lb3V0KCgpID0+IHsgcmVzb2x2ZSgpOyB9LCBkdXJhdGlvbik7IH0pO1xufVxuLyoqXG4gKiAgQSAqKldhbGxldCoqIG1hbmFnZXMgYSBzaW5nbGUgcHJpdmF0ZSBrZXkgd2hpY2ggaXMgdXNlZCB0byBzaWduXG4gKiAgdHJhbnNhY3Rpb25zLCBtZXNzYWdlcyBhbmQgb3RoZXIgY29tbW9uIHBheWxvYWRzLlxuICpcbiAqICBUaGlzIGNsYXNzIGlzIGdlbmVyYWxseSB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgZGV2ZWxvcGVyc1xuICogIHRoYXQgd2lzaCB0byB1c2UgYSBwcml2YXRlIGtleSBkaXJlY3RseSwgYXMgaXQgY2FuIGNyZWF0ZVxuICogIGluc3RhbmNlcyBmcm9tIGEgbGFyZ2UgdmFyaWV0eSBvZiBjb21tb24gc291cmNlcywgaW5jbHVkaW5nXG4gKiAgcmF3IHByaXZhdGUga2V5LCBbW2xpbmstYmlwLTM5XV0gbW5lbW9uaWNzIGFuZCBlbmNyeXB0ZSBKU09OXG4gKiAgd2FsbGV0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFdhbGxldCBleHRlbmRzIEJhc2VXYWxsZXQge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgd2FsbGV0IGZvciB0aGUgcHJpdmF0ZSAlJWtleSUlLCBvcHRpb25hbGx5IGNvbm5lY3RlZFxuICAgICAqICB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioa2V5LCBwcm92aWRlcikge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiICYmICFrZXkuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgICAgICBrZXkgPSBcIjB4XCIgKyBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25pbmdLZXkgPSAodHlwZW9mIChrZXkpID09PSBcInN0cmluZ1wiKSA/IG5ldyBTaWduaW5nS2V5KGtleSkgOiBrZXk7XG4gICAgICAgIHN1cGVyKHNpZ25pbmdLZXksIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLnNpZ25pbmdLZXksIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cHRlZCB3aXRoXG4gICAgICogICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXByb2dyZXNzQ2FsbGJhY2slJSBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVjZWl2ZSBwZXJpb2RpY1xuICAgICAqICB1cGRhdGVzIGFzIHRoZSBlbmNyeXB0aW9uIHByb2Nlc3MgcHJvZ3Jlc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGVuY3J5cHQocGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHsgYWRkcmVzczogdGhpcy5hZGRyZXNzLCBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXkgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVuY3J5cHRLZXlzdG9yZUpzb24oYWNjb3VudCwgcGFzc3dvcmQsIHsgcHJvZ3Jlc3NDYWxsYmFjayB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBbSlNPTiBLZXlzdG9yZSBXYWxsZXRdKGpzb24td2FsbGV0cykgZW5jcnlwZWQgd2l0aFxuICAgICAqICAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSXQgaXMgcHJlZmVycmVkIHRvIHVzZSB0aGUgW2FzeW5jIHZlcnNpb25dKGVuY3J5cHQpIGluc3RlYWQsXG4gICAgICogIHdoaWNoIGFsbG93cyBhIFtbUHJvZ3Jlc3NDYWxsYmFja11dIHRvIGtlZXAgdGhlIHVzZXIgaW5mb3JtZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2Qgd2lsbCBibG9jayB0aGUgZXZlbnQgbG9vcCAoZnJlZXppbmcgYWxsIFVJKSB1bnRpbFxuICAgICAqICBpdCBpcyBjb21wbGV0ZSwgd2hpY2ggbWF5IGJlIGEgbm9uLXRyaXZpYWwgZHVyYXRpb24uXG4gICAgICovXG4gICAgZW5jcnlwdFN5bmMocGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHsgYWRkcmVzczogdGhpcy5hZGRyZXNzLCBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXkgfTtcbiAgICAgICAgcmV0dXJuIGVuY3J5cHRLZXlzdG9yZUpzb25TeW5jKGFjY291bnQsIHBhc3N3b3JkKTtcbiAgICB9XG4gICAgc3RhdGljICNmcm9tQWNjb3VudChhY2NvdW50KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGFjY291bnQsIFwiaW52YWxpZCBKU09OIHdhbGxldFwiLCBcImpzb25cIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIGlmIChcIm1uZW1vbmljXCIgaW4gYWNjb3VudCAmJiBhY2NvdW50Lm1uZW1vbmljICYmIGFjY291bnQubW5lbW9uaWMubG9jYWxlID09PSBcImVuXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1uZW1vbmljID0gTW5lbW9uaWMuZnJvbUVudHJvcHkoYWNjb3VudC5tbmVtb25pYy5lbnRyb3B5KTtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IEhETm9kZVdhbGxldC5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIGFjY291bnQubW5lbW9uaWMucGF0aCk7XG4gICAgICAgICAgICBpZiAod2FsbGV0LmFkZHJlc3MgPT09IGFjY291bnQuYWRkcmVzcyAmJiB3YWxsZXQucHJpdmF0ZUtleSA9PT0gYWNjb3VudC5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogSlNPTiBtaXNtYXRjaCBhZGRyZXNzL3ByaXZhdGVLZXkgIT0gbW5lbW9uaWM7IGZhbGxiYWNrIG9udG8gcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gbmV3IFdhbGxldChhY2NvdW50LnByaXZhdGVLZXkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh3YWxsZXQuYWRkcmVzcyA9PT0gYWNjb3VudC5hZGRyZXNzLCBcImFkZHJlc3MvcHJpdmF0ZUtleSBtaXNtYXRjaFwiLCBcImpzb25cIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIChhc3luY2hyb25vdXNseSkgYSAqKldhbGxldCoqIGJ5IGRlY3J5cHRpbmcgdGhlICUlanNvbiUlXG4gICAgICogIHdpdGggJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIElmICUlcHJvZ3Jlc3MlJSBpcyBwcm92aWRlZCwgaXQgaXMgY2FsbGVkIHBlcmlvZGljYWxseSBkdXJpbmdcbiAgICAgKiAgZGVjcnlwdGlvbiBzbyB0aGF0IGFueSBVSSBjYW4gYmUgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUVuY3J5cHRlZEpzb24oanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzKSB7XG4gICAgICAgIGxldCBhY2NvdW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzS2V5c3RvcmVKc29uKGpzb24pKSB7XG4gICAgICAgICAgICBhY2NvdW50ID0gYXdhaXQgZGVjcnlwdEtleXN0b3JlSnNvbihqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ3Jvd2RzYWxlSnNvbihqc29uKSkge1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MoMCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2NvdW50ID0gZGVjcnlwdENyb3dkc2FsZUpzb24oanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MoMSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdhbGxldC4jZnJvbUFjY291bnQoYWNjb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgKipXYWxsZXQqKiBieSBkZWNyeXB0aW5nIHRoZSAlJWpzb24lJSB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBUaGUgW1tmcm9tRW5jcnlwdGVkSnNvbl1dIG1ldGhvZCBpcyBwcmVmZXJyZWQsIGFzIHRoaXMgbWV0aG9kXG4gICAgICogIHdpbGwgbG9jayB1cCBhbmQgZnJlZXplIHRoZSBVSSBkdXJpbmcgZGVjcnlwdGlvbiwgd2hpY2ggbWF5IHRha2VcbiAgICAgKiAgc29tZSB0aW1lLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRW5jcnlwdGVkSnNvblN5bmMoanNvbiwgcGFzc3dvcmQpIHtcbiAgICAgICAgbGV0IGFjY291bnQgPSBudWxsO1xuICAgICAgICBpZiAoaXNLZXlzdG9yZUpzb24oanNvbikpIHtcbiAgICAgICAgICAgIGFjY291bnQgPSBkZWNyeXB0S2V5c3RvcmVKc29uU3luYyhqc29uLCBwYXNzd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDcm93ZHNhbGVKc29uKGpzb24pKSB7XG4gICAgICAgICAgICBhY2NvdW50ID0gZGVjcnlwdENyb3dkc2FsZUpzb24oanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBKU09OIHdhbGxldFwiLCBcImpzb25cIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdhbGxldC4jZnJvbUFjY291bnQoYWNjb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IHJhbmRvbSBbW0hETm9kZVdhbGxldF1dIHVzaW5nIHRoZSBhdmFpbGFibGVcbiAgICAgKiAgW2NyeXB0b2dyYXBoaWMgcmFuZG9tIHNvdXJjZV0ocmFuZG9tQnl0ZXMpLlxuICAgICAqXG4gICAgICogIElmIHRoZXJlIGlzIG5vIGNyeXRvZ3JhcGhpYyByYW5kb20gc291cmNlLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJhbmRvbShwcm92aWRlcikge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBIRE5vZGVXYWxsZXQuY3JlYXRlUmFuZG9tKCk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIFtbSEROb2RlV2FsbGV0XV0gZm9yICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBIRE5vZGVXYWxsZXQuZnJvbVBocmFzZShwaHJhc2UpO1xuICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQuY29ubmVjdChwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxsZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wallet/wallet.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wordlists/bit-reader.js":
/*!*********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wordlists/bit-reader.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBits: function() { return /* binding */ decodeBits; }\n/* harmony export */ });\nconst Base64 = \")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\";\n/**\n *  @_ignore\n */\nfunction decodeBits(width, data) {\n    const maxValue = (1 << width) - 1;\n    const result = [];\n    let accum = 0, bits = 0, flood = 0;\n    for (let i = 0; i < data.length; i++) {\n        // Accumulate 6 bits of data\n        accum = ((accum << 6) | Base64.indexOf(data[i]));\n        bits += 6;\n        // While we have enough for a word...\n        while (bits >= width) {\n            // ...read the word\n            const value = (accum >> (bits - width));\n            accum &= (1 << (bits - width)) - 1;\n            bits -= width;\n            // A value of 0 indicates we exceeded maxValue, it\n            // floods over into the next value\n            if (value === 0) {\n                flood += maxValue;\n            }\n            else {\n                result.push(value + flood);\n                flood = 0;\n            }\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=bit-reader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvYml0LXJlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvYml0LXJlYWRlci5qcz84YTA2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJhc2U2NCA9IFwiKSFAIyQlXiYqKEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotX1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJpdHMod2lkdGgsIGRhdGEpIHtcbiAgICBjb25zdCBtYXhWYWx1ZSA9ICgxIDw8IHdpZHRoKSAtIDE7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGFjY3VtID0gMCwgYml0cyA9IDAsIGZsb29kID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gQWNjdW11bGF0ZSA2IGJpdHMgb2YgZGF0YVxuICAgICAgICBhY2N1bSA9ICgoYWNjdW0gPDwgNikgfCBCYXNlNjQuaW5kZXhPZihkYXRhW2ldKSk7XG4gICAgICAgIGJpdHMgKz0gNjtcbiAgICAgICAgLy8gV2hpbGUgd2UgaGF2ZSBlbm91Z2ggZm9yIGEgd29yZC4uLlxuICAgICAgICB3aGlsZSAoYml0cyA+PSB3aWR0aCkge1xuICAgICAgICAgICAgLy8gLi4ucmVhZCB0aGUgd29yZFxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoYWNjdW0gPj4gKGJpdHMgLSB3aWR0aCkpO1xuICAgICAgICAgICAgYWNjdW0gJj0gKDEgPDwgKGJpdHMgLSB3aWR0aCkpIC0gMTtcbiAgICAgICAgICAgIGJpdHMgLT0gd2lkdGg7XG4gICAgICAgICAgICAvLyBBIHZhbHVlIG9mIDAgaW5kaWNhdGVzIHdlIGV4Y2VlZGVkIG1heFZhbHVlLCBpdFxuICAgICAgICAgICAgLy8gZmxvb2RzIG92ZXIgaW50byB0aGUgbmV4dCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmxvb2QgKz0gbWF4VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSArIGZsb29kKTtcbiAgICAgICAgICAgICAgICBmbG9vZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdC1yZWFkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wordlists/bit-reader.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wordlists/decode-owl.js":
/*!*********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wordlists/decode-owl.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   decodeOwl: function() { return /* binding */ decodeOwl; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\nconst subsChrs = \" !#$%&'()*+,-./<=>?@[]^_`{|}~\";\nconst Word = /^[a-z]*$/i;\nfunction unfold(words, sep) {\n    let initial = 97;\n    return words.reduce((accum, word) => {\n        if (word === sep) {\n            initial++;\n        }\n        else if (word.match(Word)) {\n            accum.push(String.fromCharCode(initial) + word);\n        }\n        else {\n            initial = 97;\n            accum.push(word);\n        }\n        return accum;\n    }, []);\n}\n/**\n *  @_ignore\n */\nfunction decode(data, subs) {\n    // Replace all the substitutions with their expanded form\n    for (let i = subsChrs.length - 1; i >= 0; i--) {\n        data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));\n    }\n    // Get all tle clumps; each suffix, first-increment and second-increment\n    const clumps = [];\n    const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {\n        if (semi) {\n            for (let i = parseInt(semi); i >= 0; i--) {\n                clumps.push(\";\");\n            }\n        }\n        else {\n            clumps.push(item.toLowerCase());\n        }\n        return \"\";\n    });\n    /* c8 ignore start */\n    if (leftover) {\n        throw new Error(`leftovers: ${JSON.stringify(leftover)}`);\n    }\n    /* c8 ignore stop */\n    return unfold(unfold(clumps, \";\"), \":\");\n}\n/**\n *  @_ignore\n */\nfunction decodeOwl(data) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(data[0] === \"0\", \"unsupported auwl data\", \"data\", data);\n    return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));\n}\n//# sourceMappingURL=decode-owl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvZGVjb2RlLW93bC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUQ7QUFDbkQsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvZGVjb2RlLW93bC5qcz8wNGNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBzdWJzQ2hycyA9IFwiICEjJCUmJygpKissLS4vPD0+P0BbXV5fYHt8fX5cIjtcbmNvbnN0IFdvcmQgPSAvXlthLXpdKiQvaTtcbmZ1bmN0aW9uIHVuZm9sZCh3b3Jkcywgc2VwKSB7XG4gICAgbGV0IGluaXRpYWwgPSA5NztcbiAgICByZXR1cm4gd29yZHMucmVkdWNlKChhY2N1bSwgd29yZCkgPT4ge1xuICAgICAgICBpZiAod29yZCA9PT0gc2VwKSB7XG4gICAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod29yZC5tYXRjaChXb3JkKSkge1xuICAgICAgICAgICAgYWNjdW0ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGluaXRpYWwpICsgd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsID0gOTc7XG4gICAgICAgICAgICBhY2N1bS5wdXNoKHdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCBbXSk7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGRhdGEsIHN1YnMpIHtcbiAgICAvLyBSZXBsYWNlIGFsbCB0aGUgc3Vic3RpdHV0aW9ucyB3aXRoIHRoZWlyIGV4cGFuZGVkIGZvcm1cbiAgICBmb3IgKGxldCBpID0gc3Vic0NocnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoc3Vic0NocnNbaV0pLmpvaW4oc3Vicy5zdWJzdHJpbmcoMiAqIGksIDIgKiBpICsgMikpO1xuICAgIH1cbiAgICAvLyBHZXQgYWxsIHRsZSBjbHVtcHM7IGVhY2ggc3VmZml4LCBmaXJzdC1pbmNyZW1lbnQgYW5kIHNlY29uZC1pbmNyZW1lbnRcbiAgICBjb25zdCBjbHVtcHMgPSBbXTtcbiAgICBjb25zdCBsZWZ0b3ZlciA9IGRhdGEucmVwbGFjZSgvKDp8KFswLTldKXwoW0EtWl1bYS16XSopKS9nLCAoYWxsLCBpdGVtLCBzZW1pLCB3b3JkKSA9PiB7XG4gICAgICAgIGlmIChzZW1pKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VJbnQoc2VtaSk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY2x1bXBzLnB1c2goXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2x1bXBzLnB1c2goaXRlbS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9KTtcbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobGVmdG92ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBsZWZ0b3ZlcnM6ICR7SlNPTi5zdHJpbmdpZnkobGVmdG92ZXIpfWApO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIHJldHVybiB1bmZvbGQodW5mb2xkKGNsdW1wcywgXCI7XCIpLCBcIjpcIik7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlT3dsKGRhdGEpIHtcbiAgICBhc3NlcnRBcmd1bWVudChkYXRhWzBdID09PSBcIjBcIiwgXCJ1bnN1cHBvcnRlZCBhdXdsIGRhdGFcIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIHJldHVybiBkZWNvZGUoZGF0YS5zdWJzdHJpbmcoMSArIDIgKiBzdWJzQ2hycy5sZW5ndGgpLCBkYXRhLnN1YnN0cmluZygxLCAxICsgMiAqIHN1YnNDaHJzLmxlbmd0aCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlLW93bC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wordlists/decode-owl.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wordlists/decode-owla.js":
/*!**********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wordlists/decode-owla.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeOwlA: function() { return /* binding */ decodeOwlA; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _bit_reader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bit-reader.js */ \"../common/node_modules/ethers/lib.esm/wordlists/bit-reader.js\");\n/* harmony import */ var _decode_owl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decode-owl.js */ \"../common/node_modules/ethers/lib.esm/wordlists/decode-owl.js\");\n\n\n\n/**\n *  @_ignore\n */\nfunction decodeOwlA(data, accents) {\n    let words = (0,_decode_owl_js__WEBPACK_IMPORTED_MODULE_0__.decodeOwl)(data).join(\",\");\n    // Inject the accents\n    accents.split(/,/g).forEach((accent) => {\n        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(match !== null, \"internal error parsing accents\", \"accents\", accents);\n        let posOffset = 0;\n        const positions = (0,_bit_reader_js__WEBPACK_IMPORTED_MODULE_2__.decodeBits)(parseInt(match[3]), match[4]);\n        const charCode = parseInt(match[2]);\n        const regex = new RegExp(`([${match[1]}])`, \"g\");\n        words = words.replace(regex, (all, letter) => {\n            const rem = --positions[posOffset];\n            if (rem === 0) {\n                letter = String.fromCharCode(letter.charCodeAt(0), charCode);\n                posOffset++;\n            }\n            return letter;\n        });\n    });\n    return words.split(\",\");\n}\n//# sourceMappingURL=decode-owla.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvZGVjb2RlLW93bGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtRDtBQUNOO0FBQ0Q7QUFDNUM7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0IseURBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYztBQUN0QjtBQUNBLDBCQUEwQiwwREFBVTtBQUNwQztBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL2RlY29kZS1vd2xhLmpzP2QwNmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGRlY29kZUJpdHMgfSBmcm9tIFwiLi9iaXQtcmVhZGVyLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVPd2wgfSBmcm9tIFwiLi9kZWNvZGUtb3dsLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlT3dsQShkYXRhLCBhY2NlbnRzKSB7XG4gICAgbGV0IHdvcmRzID0gZGVjb2RlT3dsKGRhdGEpLmpvaW4oXCIsXCIpO1xuICAgIC8vIEluamVjdCB0aGUgYWNjZW50c1xuICAgIGFjY2VudHMuc3BsaXQoLywvZykuZm9yRWFjaCgoYWNjZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gYWNjZW50Lm1hdGNoKC9eKFthLXpdKikoWzAtOV0rKShbMC05XSkoLiopJC8pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChtYXRjaCAhPT0gbnVsbCwgXCJpbnRlcm5hbCBlcnJvciBwYXJzaW5nIGFjY2VudHNcIiwgXCJhY2NlbnRzXCIsIGFjY2VudHMpO1xuICAgICAgICBsZXQgcG9zT2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gZGVjb2RlQml0cyhwYXJzZUludChtYXRjaFszXSksIG1hdGNoWzRdKTtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFske21hdGNoWzFdfV0pYCwgXCJnXCIpO1xuICAgICAgICB3b3JkcyA9IHdvcmRzLnJlcGxhY2UocmVnZXgsIChhbGwsIGxldHRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVtID0gLS1wb3NpdGlvbnNbcG9zT2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChyZW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXR0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxldHRlci5jaGFyQ29kZUF0KDApLCBjaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgcG9zT2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGV0dGVyO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gd29yZHMuc3BsaXQoXCIsXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlLW93bGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wordlists/decode-owla.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wordlists/index.js":
/*!****************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wordlists/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangEn: function() { return /* reexport safe */ _lang_en_js__WEBPACK_IMPORTED_MODULE_1__.LangEn; },\n/* harmony export */   Wordlist: function() { return /* reexport safe */ _wordlist_js__WEBPACK_IMPORTED_MODULE_0__.Wordlist; },\n/* harmony export */   WordlistOwl: function() { return /* reexport safe */ _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_2__.WordlistOwl; },\n/* harmony export */   WordlistOwlA: function() { return /* reexport safe */ _wordlist_owla_js__WEBPACK_IMPORTED_MODULE_3__.WordlistOwlA; },\n/* harmony export */   wordlists: function() { return /* reexport safe */ _wordlists_js__WEBPACK_IMPORTED_MODULE_4__.wordlists; }\n/* harmony export */ });\n/* harmony import */ var _wordlist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist.js */ \"../common/node_modules/ethers/lib.esm/wordlists/wordlist.js\");\n/* harmony import */ var _lang_en_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lang-en.js */ \"../common/node_modules/ethers/lib.esm/wordlists/lang-en.js\");\n/* harmony import */ var _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wordlist-owl.js */ \"../common/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js\");\n/* harmony import */ var _wordlist_owla_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wordlist-owla.js */ \"../common/node_modules/ethers/lib.esm/wordlists/wordlist-owla.js\");\n/* harmony import */ var _wordlists_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wordlists.js */ \"../common/node_modules/ethers/lib.esm/wordlists/wordlists-browser.js\");\n/**\n *  A Wordlist is a set of 2048 words used to encode private keys\n *  (or other binary data) that is easier for humans to write down,\n *  transcribe and dictate.\n *\n *  The [[link-bip-39]] standard includes several checksum bits,\n *  depending on the size of the mnemonic phrase.\n *\n *  A mnemonic phrase may be 12, 15, 18, 21 or 24 words long. For\n *  most purposes 12 word mnemonics should be used, as including\n *  additional words increases the difficulty and potential for\n *  mistakes and does not offer any effective improvement on security.\n *\n *  There are a variety of [[link-bip39-wordlists]] for different\n *  languages, but for maximal compatibility, the\n *  [English Wordlist](LangEn) is recommended.\n *\n *  @_section: api/wordlists:Wordlists [about-wordlists]\n */\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ0g7QUFDVTtBQUNFO0FBQ1A7QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL2luZGV4LmpzPzA1MzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBXb3JkbGlzdCBpcyBhIHNldCBvZiAyMDQ4IHdvcmRzIHVzZWQgdG8gZW5jb2RlIHByaXZhdGUga2V5c1xuICogIChvciBvdGhlciBiaW5hcnkgZGF0YSkgdGhhdCBpcyBlYXNpZXIgZm9yIGh1bWFucyB0byB3cml0ZSBkb3duLFxuICogIHRyYW5zY3JpYmUgYW5kIGRpY3RhdGUuXG4gKlxuICogIFRoZSBbW2xpbmstYmlwLTM5XV0gc3RhbmRhcmQgaW5jbHVkZXMgc2V2ZXJhbCBjaGVja3N1bSBiaXRzLFxuICogIGRlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZiB0aGUgbW5lbW9uaWMgcGhyYXNlLlxuICpcbiAqICBBIG1uZW1vbmljIHBocmFzZSBtYXkgYmUgMTIsIDE1LCAxOCwgMjEgb3IgMjQgd29yZHMgbG9uZy4gRm9yXG4gKiAgbW9zdCBwdXJwb3NlcyAxMiB3b3JkIG1uZW1vbmljcyBzaG91bGQgYmUgdXNlZCwgYXMgaW5jbHVkaW5nXG4gKiAgYWRkaXRpb25hbCB3b3JkcyBpbmNyZWFzZXMgdGhlIGRpZmZpY3VsdHkgYW5kIHBvdGVudGlhbCBmb3JcbiAqICBtaXN0YWtlcyBhbmQgZG9lcyBub3Qgb2ZmZXIgYW55IGVmZmVjdGl2ZSBpbXByb3ZlbWVudCBvbiBzZWN1cml0eS5cbiAqXG4gKiAgVGhlcmUgYXJlIGEgdmFyaWV0eSBvZiBbW2xpbmstYmlwMzktd29yZGxpc3RzXV0gZm9yIGRpZmZlcmVudFxuICogIGxhbmd1YWdlcywgYnV0IGZvciBtYXhpbWFsIGNvbXBhdGliaWxpdHksIHRoZVxuICogIFtFbmdsaXNoIFdvcmRsaXN0XShMYW5nRW4pIGlzIHJlY29tbWVuZGVkLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS93b3JkbGlzdHM6V29yZGxpc3RzIFthYm91dC13b3JkbGlzdHNdXG4gKi9cbmV4cG9ydCB7IFdvcmRsaXN0IH0gZnJvbSBcIi4vd29yZGxpc3QuanNcIjtcbmV4cG9ydCB7IExhbmdFbiB9IGZyb20gXCIuL2xhbmctZW4uanNcIjtcbmV4cG9ydCB7IFdvcmRsaXN0T3dsIH0gZnJvbSBcIi4vd29yZGxpc3Qtb3dsLmpzXCI7XG5leHBvcnQgeyBXb3JkbGlzdE93bEEgfSBmcm9tIFwiLi93b3JkbGlzdC1vd2xhLmpzXCI7XG5leHBvcnQgeyB3b3JkbGlzdHMgfSBmcm9tIFwiLi93b3JkbGlzdHMuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wordlists/index.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wordlists/lang-en.js":
/*!******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wordlists/lang-en.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangEn: function() { return /* binding */ LangEn; }\n/* harmony export */ });\n/* harmony import */ var _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist-owl.js */ \"../common/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js\");\n\nconst words = \"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\";\nconst checksum = \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */\nclass LangEn extends _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_0__.WordlistOwl {\n    /**\n     *  Creates a new instance of the English language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEn]] should suffice.\n     *\n     *  @_ignore:\n     */\n    constructor() { super(\"en\", words, checksum); }\n    /**\n     *  Returns a singleton instance of a ``LangEn``, creating it\n     *  if this is the first time being called.\n     */\n    static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangEn();\n        }\n        return wordlist;\n    }\n}\n//# sourceMappingURL=lang-en.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvbGFuZy1lbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRDtBQUNoRCxrUEFBa1AsZ01BQWdNLDhNQUE4TSxpRkFBaUYsb0JBQW9CLHlRQUF5USxhQUFhLFVBQVUsWUFBWSxtREFBbUQsZUFBZSx3RkFBd0YsNERBQTRELFVBQVUseUJBQXlCLGk0QkFBaTRCLDRCQUE0QiwyQ0FBMkMsMGRBQTBkLGNBQWMsb0xBQW9MLHdDQUF3Qyw2QkFBNkIsdU5BQXVOLHlqQkFBeWpCLGdIQUFnSCxvQ0FBb0MsY0FBYyxnQkFBZ0IsME9BQTBPLHNVQUFzVSx5REFBeUQsc0lBQXNJLE9BQU8saUpBQWlKLG1NQUFtTSxRQUFRLE1BQU0sd1hBQXdYLDBDQUEwQyxrQkFBa0IsNEJBQTRCLDhGQUE4RixzVUFBc1UsNkJBQTZCO0FBQzkxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQix5REFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvbGFuZy1lbi5qcz9kOGE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdvcmRsaXN0T3dsIH0gZnJvbSBcIi4vd29yZGxpc3Qtb3dsLmpzXCI7XG5jb25zdCB3b3JkcyA9IFwiMGVybGVvbmFsb3JlbnNlaW5jZXJlZ2VzdGljaXRTdGFudmV0ZWFyY3Rzc2kjY2gyQXRoY2smdG5lTGwwQW5kI0lsLnlMZU91dE89U3xTJWIvcmFAU3VyZFUnMENlW0NpZHxDb3VudEN1J0hpZT1JZE91LC1RdWkqUm9bVFRdVCVUKltUdSQwQXB0REQtdEQqW0p1LE0uVWx0VjwpVmkpMFJvYi0wRmFpckYlZFJhaWQwQShFRW50UmVlMEVhZDBNUlJwJXRTIV9ybUJ1bUNvaG9sRXJ0SSZMTGV5TG93TW8sT31QaGFSZWFkeVNvVCBXYXlzMEE+dXJBeihnT25nT3VudFUnZDBBbHksQ2glQ2l8RyBHIUdyeUltJEshTm91bilOdSRPYCBTdyBUJm5hVGlxdWVYaWV0eVkxQXJ0T2xvZ3lQZT9QIVBybz1SaWwxQ2hDdC1FYUVuYUd1ZU1NZWRNJU15T3VuZFI8K1JlLFJpPVJvd1RUZWZhQFRpLFR3JWswS1BlQFNhdWx0U2V0U2ksU3VtZVRobWEwSCE+T21UYXtUJmRULnVkZVRyYUAwQ3RdRC5HdSxOdFRoJVRvVHVtbjBFcmErT2NhZG9PaWQwQWtlQSpBeUVzb21lRnVsS3c/ZDBJczpCeUNoZWwlQyNEK0dMPClMYyN5fk1ib29OPGFObiBSUmVseVJnYShSKmxTZVMtU2tldFR0ITNBXkFuQXV0eUNhdSdDb21lRWZGJWVHKEhhPUgoZExpZT1Mb3dMdE5eTmVmLi9UcmF5VHQgVHdlJlkjZDNDeWMhREtlTmRPbG9neVJkUmBUdCBfe0FkZUFtZUFua2V0QSxFYWtFW0luZE9vZE9bb21PdSdVZVVyVXNoX3JkQXREeUlsTWJOZU51c09rTyxSZCBSKGdScm93U3NUdG9tVW4pWFlfe2V0QShBbmRBW0E9RWFkRWV6ZUl7SWQrSWVmSWdodEluZ0lza09jY29saU9rJk9uemVPb21PYCBPd25Vc2gyQmIhRGR5RCt0RmYkb0lsZExiTGtMIXROZCFOayBSZCZSZyBSLFNTKGVbU3lUdCBZIFp6OkJiYStCKEIhQ3R1c0dlS2V+TG1NIGFNcE5OJE4pbE5keU5uI05vZU52YXNOeSNQYWIhUC4kUHRhKFJSYiNSZFJnb1JwZXRScnlSdFNlU2hTKG8vIVN1JFRUJG9nVF5UZWcleVR0IVVnaHRVJ1V0XVZlM0lsKGdMIHlNfE5zdXNOdHVyeVJlJFJ0YShfaXJBbGtBbXBdQW4rQW9zQXB0IEFyK0EnQXRFYXBFe0VlJ0VmRXJyeUUsSXsmSWVmSWxkSW19eU9pKU9vJ1IjLVV7IVVua1VybjBHP05uYW0jUmMhVGl6JlR5VmlsX2ltQXBBcmlmeUF3QXlFPEVya0V2IEl7SXxJZmZJbWJJbi1JcE97T2dPJ09gT3VkT3duVWJVbXBVLCBVdF5fXkEsQyN1dERlRmZlZUlsSW5MIUBMJUx1bW5NYihlTWVNZiV0TS1NbSNNcDx5TmMgdE5kdUBOZmlybU5nKltOfUBOc2lkIE50cm9sTnYoKU9rT2xQcCBQeVIkUmVSblIqQC9UdCNVXlVudHJ5VXAhVXInVXMoViBZbz5fe0FkIUFmdEFtQX1Bc2hBdCBBd2xBenlFYW1FZC5FZWtFd0l7ZXRJbWVJc3BJdC1PcE9bT3VeT3dkVWNpJFVlbFVpJ1VtYiFVbl5Vc2hZWSwkMkJlTHR1KlBQYm8/ZFJpb3VzUnJ8UnRhKFI9U2hdL29tVGUzQyE6RE1hK01wTilOZyBSKGdTaFVnaHQgV25ZM0FsQmE+QnJpc0NhZGVDZW1iIENpZGVDbChlQyVhPkMqYSdFckYmJ0YoZUZ5RyplTGF5TGl2IE08ZE1pJ05pJE50aSxOeVA/dFAmZFBvcy5QYFB1dHlSaT1TY3JpYmVTIHRTaWduU2tTcGFpci9yb3lUYWlsVGVAVmVsb3BWaSlWbz4zQWdyYW1BbEFtI2RBcnlDZUUnbEV0RmYgRy4kR24ueUxlbW1hTm4gTm9zYXVyUmVAUnRTYWcqZVNjb3YgU2VhJ1NoU21pW1MlZCBTcGxheS88KVYgdFZpZGVWJSlaenk1Q3QlQ3VtfEd+THBoKE1hKE5hPk5rZXlOJU9yU2VVYiFWZV9mdEFnI0FtYUEsLUF3RWFtRVtJZnRJbGxJbmtJcEk9T3BVbVkyQ2tNYk5lUihnL1ReVHkxQXJmMU5hbS06RyBHIVJseVJuUmBTaWx5L1N5MUhvT2xvZ3lPbm9teTBHZUl0VWNhPjFGJXQwRzFHaHRUaCAyQm93RCBFQHItRWc8dEVtfEVwaDx0RXZhdCVJPlNlMEI/a0JvZHlCcmEpRXIrT3RdUGxveVBvdyBQdHkwQWIhQUBERCFbRCUnRW15RXJneUYlKUdhK0coZUg8KUpveUxpLE91Z2hSLWhSb2xsU3UqVCBUaSpUcnlWZWxvcGUxSXNvZGUwVSRVaXAwQUEnT2RlT3NdUiVVcHQwQ2FwZVNheVMmKVRhPjBFcm4kSC1zMUlkJilJbE9rZU9sPTFBQEFtcCFDZVtDaDwrQy5lQ2x1ZGVDdSdFY3U+RXJjaSdIYXUsSGliLkkhSSxJdE90LVA8ZFBlQFBpKlBsYShQbydQKltUJmRUcmEwRUVicm93OkJyLUNlQ3VsdHlEZUludElgfkwnTWVNaWx5TW91c05OY3lOdGFzeVJtU2hdVFQkVGggVGlndWVVbHRWJS5lM0F0dSpCcnU/eUQgJEVFZEVsTWEhTikvaXYkVF5WIFczQiBDdF1FbGRHdSpMZUxtTHQgTiROZE5lTmcgTmlzaFJlUm1SLFNjJFNoVFR9W1hfZ0FtZUFzaEF0QXYlRWVJZ2h0SXBPYXRPe08lT3cgVWlkVXNoWV9tQ3VzR0lsTGR+b3dPZE90UilSZSxSK3RSa1J0dX1SdW1Sdz9kU3NpbC8gVW5kWF9naSFBbWVFcXV8RXNoSSZkSW4rT2dPbnRPLE93bk96JlUuMkVsTk5ueVJuYSlSeVR1KjpEK3RJbkxheHl+IHlNZVBSYStSYmErUmQmUmwtUm18U1NwVGVUaCBVK1plM04gJE5pdXNOKk50IU51KGUvdSoyTywwQW50RnRHZyFOZyBSYWZmZVJsVmVfZEFuKUEqQVtJZGVJbXAnT2JlT29tT3J5Tz1Pd1VlX3REZGVbTGRPZE8nUmlsbGFTcGVsU3NpcFYgblduX2JBKUEoQW50QXBlQVtBdi55RWF0RSZJZEllZkl0T2MgeU91cE93VW50X3JkRVtJZGVJbHRJdD9OM006Qi5JckxmTW0gTSwgTmRQcHlSYiVSZFJzaFI9LFRWZVdrWj9kM0FkQWxgQXJ0QXZ5RCtob2dJZ2h0fm9MbWV0THBOUm8zRGQmR2h+TnRQUmUvJXk1QmJ5Q2tleUxkTGVMaWRheX5vd01lTmV5T2RQZVJuUnIlUidTcC4kL1RlbFVyViA1QkdlTTxNYiFNJU5kKmROZ3J5TnRSZCFScnlSdFNiPGQzQnJpZDoxRU9uMEVhRW50aWZ5TGUyTiVlNExMZWckTH1bMEErSXRhPk0mJ011fVBhQFBvJ1Bybz1QdWwnMENoQ2x1ZGVDb21lQyphJ0RleEQtYT5EbyVEdSxyeUY8dEZsLXRGJW1IYSFIIC5JdGkkSmVASnVyeU1hPk4gTm9jfFB1dFF1aXJ5UzxlU2VAU2lkZVNwaSovJGxUYUBUIGUsVG9WZSxWLmVWb2w9M09uMEw8ZE9sYT5TdWUwRW0xT3J5OkNrZXRHdT9SWnozQWxvdXNBbnN+eVdlbDlCSW5LZVVyfXlZNUQrSSlNcE5nIU5pJU5rLzpOZz9vbzNFbkVwVF51cFkzQ2tERH15TmROZ2RvbVNzVFReJlRlVHQmV2k0RWVJZmVPe093OkJCZWxCJURkIER5S2VNcE5ndWErUHRvcFIrVCBUKFVnaFVuZHJ5VmFXV25Xc3UuWSBaeTNBZCBBZkFybkE9Q3R1KkZ0R0ckRyZkSXN1Kk0jTmROZ2BOc09wP2RTcyNUdCBWZWwzQXJCIHR5QnI/eUMmJ0ZlRnRHaHRLZU1iTS5Oa09uUXVpZC9UdCFWZVo/ZDVBZEFuQiwgQyRDa0ctTmVseU5nT3BUdCB5VWRVbitWZVkkNUNreUdnYStNYiBOP05eWHVyeTNSLXM6Q2goZURHLUd9dElkSWxJbkolS2VNbSROTmErTmRhPk5nb05zXU51JFAhUmIhUl5SZyhSKGVSa2V0UnJpYStTa1NzLyBUXlQgaSRUaFRyaXhUdCBYaW11bVplM0Fkb3dBbkFzdSpBdENoPC1EJERpYUxvZHlMdE1iIE0leU50XU51UmN5UitSLlJyeVNoU3NhK1QkVGhvZDNEZCFEbmlnaHRMa35dTS1OZE5pbXVtTiVOdT5SYWMhUnIlUyB5U3MvYWtlWFhlZFh0dSo1QmkhRGVsRGlmeU1NfE4uJU5rZXlOLCBOYE9uUiRSZVJuKGdTcXUub1RoIFRdVCVVbnRhKFUnVmVWaWU1Q2hGZihMZUx0aXBseVNjIVNldW1TaHJvb21TLS9UdSQzU2VsZi8geVRoOkk9TWVQayhScm93L3lUXVR1KjNBckNrRWRHYXRpPUchQElgIFBoZXdSPS9UVHcla1V0ciRWIFdzWHQzQ2VHaHQ1QiFJJ00oZWVPZCFSbSRSYFNlVGFiIVRlVGgoZ1RpKVZlbFc1QyE/TWIgUidUOkswRXlKZUBMaStTY3UqUyA9VGEoVmlvdXMwQ3VyRTxUb2IgME9yMUZGIEZpKVQmMkwxQXkwREk9WW1wLTBJdDBDZUVJI0woZUx5MUVuRXJhSW5dUG8nVF0xQW4rQi5DaD9kRCBEKD95RzxJfElnKCRQaDwwVHItaDBIIDBUZG8lVCBUcHV0VHNpZGUwQWxFbkVyME5OIDBZZyYwLyAwT306Q3REZCFHZUlyTGEpTG1OZGFOZWxOLU5gIFAgUmFkZVJ8UmtScm90UnR5U3NUXlRoVGl8VHJvbFR0IG5VJ1ZlWW18M0EpQW51dEFyQXM8dEwtPE5OJHR5TmNpbE9wIVBwIFJmZUBSbS5ScyNUMk99T3RvUmEnWXMtJDBBbm9Dbi1DdHUqRSlHR2UjfkxvdE5rT30gUGUvb2xUXlp6YV8pQX10QSwtQT5BeUVhJ0VkK1V7VWdVbisyRW1FdEludEw/TGVMaSlOZE55T2xQdWw/UnRdUy5dU3NpYiEvVGF0b1R0IHlWIHR5V2QgVyBfQGkpQWknRWQtdEVmIEVwYSpFc3xFdHR5RXZ8SSlJZGVJbT95SW50SSUueUlzI0l2YT5JemVPYiFtTylbT2R1KU9mLk9ncmFtT2plQE9tbz5Pb2ZPcCB0eU9zcCBPPkBPdWRPdmlkZTJCbC1EZChnfkxwTCdNcGsoTl5QaWxQcHlSXmEnUi55UnBvJ1InU2hUWnohM1JhbWlkOjk5QWwueUFudHVtQXJ0IEUsXUl7SXRJek8+OkJiLkNjbyNDZUNrRD9EaW9JbEluSSd+eU1wTl5OZG9tTitQaWRSZVRlVGggViZXWiUzQWR5QWxBcyNCZWxCdWlsZEMkbENlaT1DaXBlQyVkQ3ljIUR1KUYhQEYlbUZ1J0ddRyp0R3VsP0plQExheExlYSdMaWVmTHlNYShNZW1iIE0oZE1vPU5kIE5ld050T3AmUGFpclBlYXRQbGEpUCV0UXVpKlNjdWVTZW1iIVNpLFNvdXIpU3AjJ1N1bHRUaSpUKmF0VHVyblVuXVZlJFZpZXdXP2QyWWBtMEJCYiNDZUNoRGVEK0YhR2h0R2lkTmdPdFBwIVNrVHUkViRWIDVBZEEsQm90QnUsQ2tldE08KU9mT2tpZU9tU2VUYT5VZ2hVbmRVPlkkNUJiIERlR0xlTk53YXlSJDpERGQhRH1bRmVJbExhZExtI0wjTHRMdT5NZU1wIU5kVGlzZnlUb3NoaVUpVXNhK1ZlWTFBIUFuQSpBdHQgRX1IZW1lSG9vbEkmKUlbJXNPcnBdT3V0UmFwUmUmUmlwdFJ1YjFBQXJeQXMjQXRDI2RDKnRDdF1DdXIueUVkRWtHbXxMZUB+TSg/TmklTidOdCYpUmllc1J2aSlTc11UdCFUdXBWJl9kb3dBZnRBbGxvd0EqRWRFbGxFcmlmZkllbGRJZnRJfUlwSXYgT3tPZU9vdE9wT3J0T3VsZCBPPVJpbXBSdWdVZmYhWTBCbChnQ2tEZUUrR2h0R25MfExrfnlMdiBNaWw/TXAhTilOZ1ImLyBUdWE+WFplMUE+RXReSUlsbEluSXJ0VWxsMEFiQW1FZXBFbmQgSSlJZGVJZ2h0SW1PZzxPdE93VXNoMEFsbEFydEkhT2tlT29gMEF7QWtlQXBJZmZPdzBBcENjIENpJENrRGFGdEw/TGRpIExpZEx1dF1MPU1lI2VOZ09uUnJ5UnRVbFVuZFVwVXIpVWAwQSlBKkF0aSRBd25FYWtFY2kkRWVkRWxsRW5kSCBlSSlJZCBJa2VJbklyLkwuT2lsT25zJU8jT3J0T3RSYXlSZWFkUihnWTBVYSpVZWV6ZVVpcipsX2IhQWRpdW1BZmZBK0FpcnNBbXBBbmRBcnRBPkF5RWFrRWVsRW1FcEUqb0l7SWxsSW5nT3tPbWFeT31Pb2xPcnlPPVJhPmd5UmVldFJpa2VSI2dSdWdnIVVkfFVmZlVtYiFZITBCamVAQm0uQndheUMpW0NoRGQmRmYgRz9HKyxJdE1tIE5ObnlOJ3RQIFBwbHlQKm1lUmVSZmEpUitScHJpJ1Jyb3VuZFI9eVNwZUAvYSgxQWxsb3dBbXBBcEFybUU/RWV0SWZ0SW1JbmdJdF5PcmQxTWJvbE1wdG9tUnVwL2VtOkIhQ2shR0lsTHxMa05rUGVSK3RTay9lVHRvb1hpM0FeQW1+Tk48dE5uaXNOdFJtL1h0X25rQXRFbWVFbkUleUUqRXlJbmdJc091Z2h0UmVlUmk9Um93VW1iVW5kIDBDa2V0RGVHIEx0TWIgTWVOeVBSZWRTc3VlVCE1QSxCYWNjb0RheURkbCBFR2VgIEkhdEsmTWF0b00lcm93TmVOZ3VlTmlnaHRPbE9gUFAtUHAhUl5SbmFkb1J0b2knU3NUJFVyaSxXP2RXIFduWV97QWRlQWZmLUFnLUEoQW5zZiBBcEFzaEE9bEF5RWF0RWVFbmRJJEliZUl7SWdnIEltSXBPcGh5T3ViIVV7VWVVbHlVbXBldFUsVWBZMkJlSXRdTWIhTmFOfWxSa2V5Um5SdCExRWw9RW50eUkpSW5JLE8xUGVQLSQ6NUx5NUIqbGxhMEFiIUF3YSpDIUNvdiBEIERvRmFpckZvbGRIYXBweUlmJW1JcXVlSXRJdiAnS25vd25Mb3tUaWxVc3UkVmVpbDFEYT5HcmFkZUhvbGRPblAgU2V0MUI8R2UwQStFRWRFZnVsRSFbVSQwSWwueTpDPHRDdXVtR3VlTGlkTCF5TD1OTmlzaFAlUmlvdXMvVWx0M0gtIUw9dE5kJU50dSpOdWVSYlJpZnlSc11SeVMnbFQgPDNBYiFCcjx0Q2lvdXNDdCV5RGVvRXd+YStOdGErT2woUnR1JFJ1c1NhUy5TdSRUJFZpZDVDJEkpSWRMYzxvTHVtZVRlWWErOkdlRyNJdExrfkxudXROdFJmYSpSbVJyaSVTaFNwL2VUIFZlWTNBbGBBcCNBckEnbEFgIEJEZChnRWsmZElyZExjb21lL1RfIUF0RWF0RWVsRW5FKklwSXNwIDBEZURgRmVMZH5OTmRvd05lTmdOa05uIE50IFJlU2RvbVNlU2hUfVs1TGZNPE5kIE9kT2xSZFJrUmxkUnJ5UmBfcEV7RSwhSSxJPk9uZzo6UmQzQXJ+b3c5VVVuZ1VgOjNCcmFSbzlOZU9cIjtcbmNvbnN0IGNoZWNrc3VtID0gXCIweDNjOGFjYzFlN2IwOGQ4ZTc2ZjlmZGEwMTVlZjQ4ZGM4YzcxMGE3M2NiN2UwZjc3YjJjMThhOWI1YTdhZGRlNjBcIjtcbmxldCB3b3JkbGlzdCA9IG51bGw7XG4vKipcbiAqICBUaGUgW1tsaW5rLWJpcDM5LWVuXV0gZm9yIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvd29yZGxpc3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBMYW5nRW4gZXh0ZW5kcyBXb3JkbGlzdE93bCB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEVuZ2xpc2ggbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nRW5dXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoXCJlblwiLCB3b3JkcywgY2hlY2tzdW0pOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdFbmBgLCBjcmVhdGluZyBpdFxuICAgICAqICBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGNhbGxlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IG5ldyBMYW5nRW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZGxpc3Q7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZy1lbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wordlists/lang-en.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js":
/*!***********************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WordlistOwl: function() { return /* binding */ WordlistOwl; }\n/* harmony export */ });\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hash/index.js */ \"../common/node_modules/ethers/lib.esm/hash/index.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n/* harmony import */ var _decode_owl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decode-owl.js */ \"../common/node_modules/ethers/lib.esm/wordlists/decode-owl.js\");\n/* harmony import */ var _wordlist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist.js */ \"../common/node_modules/ethers/lib.esm/wordlists/wordlist.js\");\n// Use the encode-latin.js script to create the necessary\n// data files to be consumed by this class\n\n\n\n\n/**\n *  An OWL format Wordlist is an encoding method that exploits\n *  the general locality of alphabetically sorted words to\n *  achieve a simple but effective means of compression.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on ASCII-7 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */\nclass WordlistOwl extends _wordlist_js__WEBPACK_IMPORTED_MODULE_0__.Wordlist {\n    #data;\n    #checksum;\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n     *  and validated against the %%checksum%%.\n     */\n    constructor(locale, data, checksum) {\n        super(locale);\n        this.#data = data;\n        this.#checksum = checksum;\n        this.#words = null;\n    }\n    /**\n     *  The OWL-encoded data.\n     */\n    get _data() { return this.#data; }\n    /**\n     *  Decode all the words for the wordlist.\n     */\n    _decodeWords() {\n        return (0,_decode_owl_js__WEBPACK_IMPORTED_MODULE_1__.decodeOwl)(this.#data);\n    }\n    #words;\n    #loadWords() {\n        if (this.#words == null) {\n            const words = this._decodeWords();\n            // Verify the computed list matches the official list\n            const checksum = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_2__.id)(words.join(\"\\n\") + \"\\n\");\n            /* c8 ignore start */\n            if (checksum !== this.#checksum) {\n                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);\n            }\n            /* c8 ignore stop */\n            this.#words = words;\n        }\n        return this.#words;\n    }\n    getWord(index) {\n        const words = this.#loadWords();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n        return words[index];\n    }\n    getWordIndex(word) {\n        return this.#loadWords().indexOf(word);\n    }\n}\n//# sourceMappingURL=wordlist-owl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvd29yZGxpc3Qtb3dsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNzQztBQUNhO0FBQ1A7QUFDSDtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsa0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQUU7QUFDL0I7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFjLDREQUE0RCxNQUFNO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy93b3JkbGlzdC1vd2wuanM/YzE2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVc2UgdGhlIGVuY29kZS1sYXRpbi5qcyBzY3JpcHQgdG8gY3JlYXRlIHRoZSBuZWNlc3Nhcnlcbi8vIGRhdGEgZmlsZXMgdG8gYmUgY29uc3VtZWQgYnkgdGhpcyBjbGFzc1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGRlY29kZU93bCB9IGZyb20gXCIuL2RlY29kZS1vd2wuanNcIjtcbmltcG9ydCB7IFdvcmRsaXN0IH0gZnJvbSBcIi4vd29yZGxpc3QuanNcIjtcbi8qKlxuICogIEFuIE9XTCBmb3JtYXQgV29yZGxpc3QgaXMgYW4gZW5jb2RpbmcgbWV0aG9kIHRoYXQgZXhwbG9pdHNcbiAqICB0aGUgZ2VuZXJhbCBsb2NhbGl0eSBvZiBhbHBoYWJldGljYWxseSBzb3J0ZWQgd29yZHMgdG9cbiAqICBhY2hpZXZlIGEgc2ltcGxlIGJ1dCBlZmZlY3RpdmUgbWVhbnMgb2YgY29tcHJlc3Npb24uXG4gKlxuICogIFRoaXMgY2xhc3MgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgdG8gbW9zdCBkZXZlbG9wZXJzIGFzXG4gKiAgaXQgaXMgdXNlZCBtYWlubHkgaW50ZXJuYWxseSB0byBrZWVwIFdvcmRsaXN0cyBmb3IgbGFuZ3VhZ2VzXG4gKiAgYmFzZWQgb24gQVNDSUktNyBzbWFsbC5cbiAqXG4gKiAgSWYgbmVjZXNzYXJ5LCB0aGVyZSBhcmUgdG9vbHMgd2l0aGluIHRoZSBgYGdlbmVyYXRpb24vYGAgZm9sZGVyXG4gKiAgdG8gY3JlYXRlIHRoZSBuZWNlc3NhcnkgZGF0YS5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmRsaXN0T3dsIGV4dGVuZHMgV29yZGxpc3Qge1xuICAgICNkYXRhO1xuICAgICNjaGVja3N1bTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBXb3JkbGlzdCBmb3IgJSVsb2NhbGUlJSB1c2luZyB0aGUgT1dMICUlZGF0YSUlXG4gICAgICogIGFuZCB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgJSVjaGVja3N1bSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSwgZGF0YSwgY2hlY2tzdW0pIHtcbiAgICAgICAgc3VwZXIobG9jYWxlKTtcbiAgICAgICAgdGhpcy4jZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuI2NoZWNrc3VtID0gY2hlY2tzdW07XG4gICAgICAgIHRoaXMuI3dvcmRzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBPV0wtZW5jb2RlZCBkYXRhLlxuICAgICAqL1xuICAgIGdldCBfZGF0YSgpIHsgcmV0dXJuIHRoaXMuI2RhdGE7IH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlIGFsbCB0aGUgd29yZHMgZm9yIHRoZSB3b3JkbGlzdC5cbiAgICAgKi9cbiAgICBfZGVjb2RlV29yZHMoKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVPd2wodGhpcy4jZGF0YSk7XG4gICAgfVxuICAgICN3b3JkcztcbiAgICAjbG9hZFdvcmRzKCkge1xuICAgICAgICBpZiAodGhpcy4jd29yZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSB0aGlzLl9kZWNvZGVXb3JkcygpO1xuICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBjb21wdXRlZCBsaXN0IG1hdGNoZXMgdGhlIG9mZmljaWFsIGxpc3RcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gaWQod29yZHMuam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoY2hlY2tzdW0gIT09IHRoaXMuI2NoZWNrc3VtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCSVAzOSBXb3JkbGlzdCBmb3IgJHt0aGlzLmxvY2FsZX0gRkFJTEVEYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jd29yZHMgPSB3b3JkcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jd29yZHM7XG4gICAgfVxuICAgIGdldFdvcmQoaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgd29yZHMgPSB0aGlzLiNsb2FkV29yZHMoKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCAmJiBpbmRleCA8IHdvcmRzLmxlbmd0aCwgYGludmFsaWQgd29yZCBpbmRleDogJHtpbmRleH1gLCBcImluZGV4XCIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHdvcmRzW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0V29yZEluZGV4KHdvcmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2xvYWRXb3JkcygpLmluZGV4T2Yod29yZCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29yZGxpc3Qtb3dsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wordlists/wordlist-owla.js":
/*!************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wordlists/wordlist-owla.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WordlistOwlA: function() { return /* binding */ WordlistOwlA; }\n/* harmony export */ });\n/* harmony import */ var _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist-owl.js */ \"../common/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js\");\n/* harmony import */ var _decode_owla_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decode-owla.js */ \"../common/node_modules/ethers/lib.esm/wordlists/decode-owla.js\");\n\n\n/**\n *  An OWL-A format Wordlist extends the OWL format to add an\n *  overlay onto an OWL format Wordlist to support diacritic\n *  marks.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on latin-1 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */\nclass WordlistOwlA extends _wordlist_owl_js__WEBPACK_IMPORTED_MODULE_0__.WordlistOwl {\n    #accent;\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%\n     *  and %%accent%% data and validated against the %%checksum%%.\n     */\n    constructor(locale, data, accent, checksum) {\n        super(locale, data, checksum);\n        this.#accent = accent;\n    }\n    /**\n     *  The OWLA-encoded accent data.\n     */\n    get _accent() { return this.#accent; }\n    /**\n     *  Decode all the words for the wordlist.\n     */\n    _decodeWords() {\n        return (0,_decode_owla_js__WEBPACK_IMPORTED_MODULE_1__.decodeOwlA)(this._data, this._accent);\n    }\n}\n//# sourceMappingURL=wordlist-owla.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvd29yZGxpc3Qtb3dsYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0Q7QUFDRjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIseURBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBVTtBQUN6QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vd29yZGxpc3RzL3dvcmRsaXN0LW93bGEuanM/N2ZmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXb3JkbGlzdE93bCB9IGZyb20gXCIuL3dvcmRsaXN0LW93bC5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlT3dsQSB9IGZyb20gXCIuL2RlY29kZS1vd2xhLmpzXCI7XG4vKipcbiAqICBBbiBPV0wtQSBmb3JtYXQgV29yZGxpc3QgZXh0ZW5kcyB0aGUgT1dMIGZvcm1hdCB0byBhZGQgYW5cbiAqICBvdmVybGF5IG9udG8gYW4gT1dMIGZvcm1hdCBXb3JkbGlzdCB0byBzdXBwb3J0IGRpYWNyaXRpY1xuICogIG1hcmtzLlxuICpcbiAqICBUaGlzIGNsYXNzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIHRvIG1vc3QgZGV2ZWxvcGVycyBhc1xuICogIGl0IGlzIHVzZWQgbWFpbmx5IGludGVybmFsbHkgdG8ga2VlcCBXb3JkbGlzdHMgZm9yIGxhbmd1YWdlc1xuICogIGJhc2VkIG9uIGxhdGluLTEgc21hbGwuXG4gKlxuICogIElmIG5lY2Vzc2FyeSwgdGhlcmUgYXJlIHRvb2xzIHdpdGhpbiB0aGUgYGBnZW5lcmF0aW9uL2BgIGZvbGRlclxuICogIHRvIGNyZWF0ZSB0aGUgbmVjZXNzYXJ5IGRhdGEuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JkbGlzdE93bEEgZXh0ZW5kcyBXb3JkbGlzdE93bCB7XG4gICAgI2FjY2VudDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBXb3JkbGlzdCBmb3IgJSVsb2NhbGUlJSB1c2luZyB0aGUgT1dMQSAlJWRhdGElJVxuICAgICAqICBhbmQgJSVhY2NlbnQlJSBkYXRhIGFuZCB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgJSVjaGVja3N1bSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSwgZGF0YSwgYWNjZW50LCBjaGVja3N1bSkge1xuICAgICAgICBzdXBlcihsb2NhbGUsIGRhdGEsIGNoZWNrc3VtKTtcbiAgICAgICAgdGhpcy4jYWNjZW50ID0gYWNjZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIE9XTEEtZW5jb2RlZCBhY2NlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgX2FjY2VudCgpIHsgcmV0dXJuIHRoaXMuI2FjY2VudDsgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgYWxsIHRoZSB3b3JkcyBmb3IgdGhlIHdvcmRsaXN0LlxuICAgICAqL1xuICAgIF9kZWNvZGVXb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZU93bEEodGhpcy5fZGF0YSwgdGhpcy5fYWNjZW50KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdC1vd2xhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wordlists/wordlist-owla.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wordlists/wordlist.js":
/*!*******************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wordlists/wordlist.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Wordlist: function() { return /* binding */ Wordlist; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"../common/node_modules/ethers/lib.esm/utils/index.js\");\n\n/**\n *  A Wordlist represents a collection of language-specific\n *  words used to encode and devoce [[link-bip-39]] encoded data\n *  by mapping words to 11-bit values and vice versa.\n */\nclass Wordlist {\n    locale;\n    /**\n     *  Creates a new Wordlist instance.\n     *\n     *  Sub-classes MUST call this if they provide their own constructor,\n     *  passing in the locale string of the language.\n     *\n     *  Generally there is no need to create instances of a Wordlist,\n     *  since each language-specific Wordlist creates an instance and\n     *  there is no state kept internally, so they are safe to share.\n     */\n    constructor(locale) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, { locale });\n    }\n    /**\n     *  Sub-classes may override this to provide a language-specific\n     *  method for spliting %%phrase%% into individual words.\n     *\n     *  By default, %%phrase%% is split using any sequences of\n     *  white-space as defined by regular expressions (i.e. ``/\\s+/``).\n     */\n    split(phrase) {\n        return phrase.toLowerCase().split(/\\s+/g);\n    }\n    /**\n     *  Sub-classes may override this to provider a language-specific\n     *  method for joining %%words%% into a phrase.\n     *\n     *  By default, %%words%% are joined by a single space.\n     */\n    join(words) {\n        return words.join(\" \");\n    }\n}\n//# sourceMappingURL=wordlist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvd29yZGxpc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0IsU0FBUyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb21tb24vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3dvcmRsaXN0cy93b3JkbGlzdC5qcz83MGFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogIEEgV29yZGxpc3QgcmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgbGFuZ3VhZ2Utc3BlY2lmaWNcbiAqICB3b3JkcyB1c2VkIHRvIGVuY29kZSBhbmQgZGV2b2NlIFtbbGluay1iaXAtMzldXSBlbmNvZGVkIGRhdGFcbiAqICBieSBtYXBwaW5nIHdvcmRzIHRvIDExLWJpdCB2YWx1ZXMgYW5kIHZpY2UgdmVyc2EuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JkbGlzdCB7XG4gICAgbG9jYWxlO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFdvcmRsaXN0IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIE1VU1QgY2FsbCB0aGlzIGlmIHRoZXkgcHJvdmlkZSB0aGVpciBvd24gY29uc3RydWN0b3IsXG4gICAgICogIHBhc3NpbmcgaW4gdGhlIGxvY2FsZSBzdHJpbmcgb2YgdGhlIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogIEdlbmVyYWxseSB0aGVyZSBpcyBubyBuZWVkIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgYSBXb3JkbGlzdCxcbiAgICAgKiAgc2luY2UgZWFjaCBsYW5ndWFnZS1zcGVjaWZpYyBXb3JkbGlzdCBjcmVhdGVzIGFuIGluc3RhbmNlIGFuZFxuICAgICAqICB0aGVyZSBpcyBubyBzdGF0ZSBrZXB0IGludGVybmFsbHksIHNvIHRoZXkgYXJlIHNhZmUgdG8gc2hhcmUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWxlKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBsb2NhbGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBwcm92aWRlIGEgbGFuZ3VhZ2Utc3BlY2lmaWNcbiAgICAgKiAgbWV0aG9kIGZvciBzcGxpdGluZyAlJXBocmFzZSUlIGludG8gaW5kaXZpZHVhbCB3b3Jkcy5cbiAgICAgKlxuICAgICAqICBCeSBkZWZhdWx0LCAlJXBocmFzZSUlIGlzIHNwbGl0IHVzaW5nIGFueSBzZXF1ZW5jZXMgb2ZcbiAgICAgKiAgd2hpdGUtc3BhY2UgYXMgZGVmaW5lZCBieSByZWd1bGFyIGV4cHJlc3Npb25zIChpLmUuIGBgL1xccysvYGApLlxuICAgICAqL1xuICAgIHNwbGl0KHBocmFzZSkge1xuICAgICAgICByZXR1cm4gcGhyYXNlLnRvTG93ZXJDYXNlKCkuc3BsaXQoL1xccysvZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBwcm92aWRlciBhIGxhbmd1YWdlLXNwZWNpZmljXG4gICAgICogIG1ldGhvZCBmb3Igam9pbmluZyAlJXdvcmRzJSUgaW50byBhIHBocmFzZS5cbiAgICAgKlxuICAgICAqICBCeSBkZWZhdWx0LCAlJXdvcmRzJSUgYXJlIGpvaW5lZCBieSBhIHNpbmdsZSBzcGFjZS5cbiAgICAgKi9cbiAgICBqb2luKHdvcmRzKSB7XG4gICAgICAgIHJldHVybiB3b3Jkcy5qb2luKFwiIFwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wordlists/wordlist.js\n"));

/***/ }),

/***/ "../common/node_modules/ethers/lib.esm/wordlists/wordlists-browser.js":
/*!****************************************************************************!*\
  !*** ../common/node_modules/ethers/lib.esm/wordlists/wordlists-browser.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wordlists: function() { return /* binding */ wordlists; }\n/* harmony export */ });\n/* harmony import */ var _lang_en_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang-en.js */ \"../common/node_modules/ethers/lib.esm/wordlists/lang-en.js\");\n\nconst wordlists = {\n    en: _lang_en_js__WEBPACK_IMPORTED_MODULE_0__.LangEn.wordlist(),\n};\n//# sourceMappingURL=wordlists-browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvd29yZGxpc3RzLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFDL0I7QUFDUCxRQUFRLCtDQUFNO0FBQ2Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29tbW9uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS93b3JkbGlzdHMvd29yZGxpc3RzLWJyb3dzZXIuanM/MTBlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5nRW4gfSBmcm9tIFwiLi9sYW5nLWVuLmpzXCI7XG5leHBvcnQgY29uc3Qgd29yZGxpc3RzID0ge1xuICAgIGVuOiBMYW5nRW4ud29yZGxpc3QoKSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdHMtYnJvd3Nlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/node_modules/ethers/lib.esm/wordlists/wordlists-browser.js\n"));

/***/ })

}]);