"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "../common/dist/PhantomMultiWalletContext.js":
/*!***************************************************!*\
  !*** ../common/dist/PhantomMultiWalletContext.js ***!
  \***************************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhantomMultiWalletProvider: function() { return /* binding */ PhantomMultiWalletProvider; },\n/* harmony export */   usePhantomMultiWallet: function() { return /* binding */ usePhantomMultiWallet; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/**\n * PhantomMultiWalletContext\n * \n * A React context for managing multiple Phantom wallet connections.\n */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n// Create context\nconst PhantomMultiWalletContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    connectedWallets: [],\n    connect: async ()=>{},\n    disconnect: ()=>{},\n    isConnecting: false,\n    error: null\n});\n// Provider component\nfunction PhantomMultiWalletProvider(param) {\n    let { children } = param;\n    _s();\n    const [connectedWallets, setConnectedWallets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Load saved wallet connections on component mount and listen for changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadWallets = ()=>{\n            try {\n                if (typeof localStorage !== \"undefined\") {\n                    // Try to get wallets from the main wallet storage\n                    const walletData = localStorage.getItem(\"walletData\");\n                    if (walletData) {\n                        const parsedData = JSON.parse(walletData);\n                        if (parsedData && parsedData.wallets && parsedData.wallets.phantom && Array.isArray(parsedData.wallets.phantom)) {\n                            // Convert wallet objects to our expected format\n                            const phantomWallets = parsedData.wallets.phantom.map((wallet)=>{\n                                // If it's already a wallet object\n                                if (typeof wallet === \"object\" && wallet !== null && wallet.address) {\n                                    return {\n                                        address: wallet.address,\n                                        publicKey: wallet.address,\n                                        chain: wallet.chain || \"solana\",\n                                        type: \"phantom\",\n                                        connectedAt: wallet.connectedAt || new Date().toISOString()\n                                    };\n                                } else if (typeof wallet === \"string\") {\n                                    return {\n                                        address: wallet,\n                                        publicKey: wallet,\n                                        chain: \"solana\",\n                                        type: \"phantom\",\n                                        connectedAt: new Date().toISOString()\n                                    };\n                                }\n                                return null;\n                            }).filter(Boolean); // Remove any null entries\n                            console.log(\"Loaded Phantom wallets from central storage:\", phantomWallets);\n                            setConnectedWallets(phantomWallets);\n                        } else {\n                            // Fallback to legacy storage\n                            const legacyWallets = localStorage.getItem(\"phantomWallets\");\n                            if (legacyWallets) {\n                                console.log(\"Using legacy Phantom wallet storage\");\n                                setConnectedWallets(JSON.parse(legacyWallets));\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                console.error(\"Error loading saved Phantom wallets:\", err);\n            }\n        };\n        // Load wallets initially\n        loadWallets();\n        // Listen for wallet connection changes\n        const handleStorageChange = (e)=>{\n            if (e.key === \"walletData\" || e.key === \"wallet-connection-changed\") {\n                console.log(\"Wallet storage changed, updating Phantom wallet list\");\n                loadWallets();\n            }\n        };\n        window.addEventListener(\"storage\", handleStorageChange);\n        window.addEventListener(\"wallet-connection-changed\", handleStorageChange);\n        return ()=>{\n            window.removeEventListener(\"storage\", handleStorageChange);\n            window.removeEventListener(\"wallet-connection-changed\", handleStorageChange);\n        };\n    }, []);\n    // Connect to a Phantom wallet\n    const connect = async ()=>{\n        setIsConnecting(true);\n        setError(null);\n        try {\n            // Check if Phantom is available\n            if (false) {}\n            if (!window.solana || !window.solana.isPhantom) {\n                throw new Error(\"Phantom wallet is not installed\");\n            }\n            // Try to connect to Phantom\n            const solanaProvider = window.solana;\n            // Request connection\n            await solanaProvider.connect();\n            if (!solanaProvider.isConnected) {\n                throw new Error(\"Failed to connect to Phantom wallet\");\n            }\n            if (!solanaProvider.publicKey) {\n                throw new Error(\"No public key available from Phantom wallet\");\n            }\n            // Create wallet object\n            const wallet = {\n                address: solanaProvider.publicKey.toString(),\n                publicKey: solanaProvider.publicKey.toString(),\n                chain: \"solana\",\n                type: \"phantom\",\n                connectedAt: new Date().toISOString()\n            };\n            // Update state\n            const updatedWallets = [\n                ...connectedWallets,\n                wallet\n            ];\n            setConnectedWallets(updatedWallets);\n            // Save to localStorage using both formats for compatibility\n            if (typeof localStorage !== \"undefined\") {\n                // Update legacy storage\n                localStorage.setItem(\"phantomWallets\", JSON.stringify(updatedWallets));\n                // Update central wallet storage\n                try {\n                    const walletData = localStorage.getItem(\"walletData\");\n                    let parsedData = walletData ? JSON.parse(walletData) : {\n                        wallets: {}\n                    };\n                    // Ensure wallets object exists\n                    if (!parsedData.wallets) {\n                        parsedData.wallets = {};\n                    }\n                    // Ensure phantom wallets array exists\n                    if (!parsedData.wallets.phantom || !Array.isArray(parsedData.wallets.phantom)) {\n                        parsedData.wallets.phantom = [];\n                    }\n                    // Add the new wallet if it doesn't exist\n                    const walletAddress = wallet.address;\n                    const existingIndex = parsedData.wallets.phantom.findIndex((w)=>typeof w === \"string\" && w === walletAddress || typeof w === \"object\" && w && w.address === walletAddress);\n                    if (existingIndex === -1) {\n                        parsedData.wallets.phantom.push({\n                            id: \"phantom-\".concat(walletAddress.substring(0, 8)),\n                            address: walletAddress,\n                            displayAddress: \"\".concat(walletAddress.substring(0, 6), \"...\").concat(walletAddress.substring(walletAddress.length - 4)),\n                            fullAddress: walletAddress,\n                            type: \"phantom\",\n                            chain: \"solana\",\n                            name: \"Phantom \".concat(walletAddress.substring(0, 6), \"...\"),\n                            connected: true,\n                            connectedAt: new Date().toISOString()\n                        });\n                    }\n                    // Save updated data\n                    localStorage.setItem(\"walletData\", JSON.stringify(parsedData));\n                    // Trigger wallet connection change event\n                    const walletChangeEvent = new CustomEvent(\"wallet-connection-changed\", {\n                        detail: {\n                            timestamp: Date.now(),\n                            walletType: \"phantom\"\n                        }\n                    });\n                    window.dispatchEvent(walletChangeEvent);\n                } catch (e) {\n                    console.error(\"Error updating central wallet storage:\", e);\n                }\n            }\n            return wallet;\n        } catch (err) {\n            const errorMessage = err.message || \"Failed to connect to Phantom wallet\";\n            setError(errorMessage);\n            console.error(\"Phantom wallet connection error:\", err);\n            throw new Error(errorMessage);\n        } finally{\n            setIsConnecting(false);\n        }\n    };\n    // Disconnect a Phantom wallet\n    const disconnect = (walletAddress)=>{\n        try {\n            const updatedWallets = connectedWallets.filter((wallet)=>wallet.address !== walletAddress);\n            setConnectedWallets(updatedWallets);\n            // Save to localStorage - update both formats\n            if (typeof localStorage !== \"undefined\") {\n                // Update legacy storage\n                localStorage.setItem(\"phantomWallets\", JSON.stringify(updatedWallets));\n                // Update central wallet storage\n                try {\n                    const walletData = localStorage.getItem(\"walletData\");\n                    if (walletData) {\n                        const parsedData = JSON.parse(walletData);\n                        // If wallet structure exists\n                        if (parsedData.wallets && parsedData.wallets.phantom && Array.isArray(parsedData.wallets.phantom)) {\n                            // Filter out the disconnected wallet\n                            parsedData.wallets.phantom = parsedData.wallets.phantom.filter((w)=>{\n                                if (typeof w === \"string\") {\n                                    return w !== walletAddress;\n                                } else if (typeof w === \"object\" && w) {\n                                    return w.address !== walletAddress;\n                                }\n                                return true;\n                            });\n                            // Save updated data\n                            localStorage.setItem(\"walletData\", JSON.stringify(parsedData));\n                            // Trigger wallet connection change event\n                            const walletChangeEvent = new CustomEvent(\"wallet-connection-changed\", {\n                                detail: {\n                                    timestamp: Date.now(),\n                                    walletType: \"phantom\",\n                                    disconnected: true\n                                }\n                            });\n                            window.dispatchEvent(walletChangeEvent);\n                        }\n                    }\n                } catch (e) {\n                    console.error(\"Error updating central wallet storage during disconnect:\", e);\n                }\n            }\n        } catch (err) {\n            console.error(\"Error disconnecting Phantom wallet:\", err);\n        }\n    };\n    const value = {\n        connectedWallets,\n        connect,\n        disconnect,\n        isConnecting,\n        error\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PhantomMultiWalletContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/karpel/Documents/GitHub/proof-of-funds/packages/common/dist/PhantomMultiWalletContext.js\",\n        lineNumber: 261,\n        columnNumber: 5\n    }, this);\n}\n_s(PhantomMultiWalletProvider, \"9hgEHRnd9RViIdC8j20UwZJHzBs=\");\n_c = PhantomMultiWalletProvider;\n// Custom hook to use the context\nfunction usePhantomMultiWallet() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PhantomMultiWalletContext);\n    if (!context) {\n        throw new Error(\"usePhantomMultiWallet must be used within a PhantomMultiWalletProvider\");\n    }\n    return context;\n}\n_s1(usePhantomMultiWallet, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"PhantomMultiWalletProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL2Rpc3QvUGhhbnRvbU11bHRpV2FsbGV0Q29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Q0FJQzs7QUFFc0U7QUFFdkUsaUJBQWlCO0FBQ2pCLE1BQU1JLDBDQUE0Qkosb0RBQWFBLENBQUM7SUFDOUNLLGtCQUFrQixFQUFFO0lBQ3BCQyxTQUFTLFdBQWE7SUFDdEJDLFlBQVksS0FBTztJQUNuQkMsY0FBYztJQUNkQyxPQUFPO0FBQ1Q7QUFFQSxxQkFBcUI7QUFDZCxTQUFTQywyQkFBMkIsS0FBWTtRQUFaLEVBQUVDLFFBQVEsRUFBRSxHQUFaOztJQUN6QyxNQUFNLENBQUNOLGtCQUFrQk8sb0JBQW9CLEdBQUdWLCtDQUFRQSxDQUFDLEVBQUU7SUFDM0QsTUFBTSxDQUFDTSxjQUFjSyxnQkFBZ0IsR0FBR1gsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDTyxPQUFPSyxTQUFTLEdBQUdaLCtDQUFRQSxDQUFDO0lBRW5DLDBFQUEwRTtJQUMxRUMsZ0RBQVNBLENBQUM7UUFDUixNQUFNWSxjQUFjO1lBQ2xCLElBQUk7Z0JBQ0YsSUFBSSxPQUFPQyxpQkFBaUIsYUFBYTtvQkFDdkMsa0RBQWtEO29CQUNsRCxNQUFNQyxhQUFhRCxhQUFhRSxPQUFPLENBQUM7b0JBQ3hDLElBQUlELFlBQVk7d0JBQ2QsTUFBTUUsYUFBYUMsS0FBS0MsS0FBSyxDQUFDSjt3QkFDOUIsSUFBSUUsY0FBY0EsV0FBV0csT0FBTyxJQUFJSCxXQUFXRyxPQUFPLENBQUNDLE9BQU8sSUFBSUMsTUFBTUMsT0FBTyxDQUFDTixXQUFXRyxPQUFPLENBQUNDLE9BQU8sR0FBRzs0QkFDL0csZ0RBQWdEOzRCQUNoRCxNQUFNRyxpQkFBaUJQLFdBQVdHLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDSSxHQUFHLENBQUNDLENBQUFBO2dDQUNwRCxrQ0FBa0M7Z0NBQ2xDLElBQUksT0FBT0EsV0FBVyxZQUFZQSxXQUFXLFFBQVFBLE9BQU9DLE9BQU8sRUFBRTtvQ0FDbkUsT0FB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R0FBR0osV0FBV0csT0FBTyxDQUFDQyxPQUFPLENBQUNhLE1BQU0sQ0FBQ3dCLENBQUFBO2dDQUM3RCxJQUFJLE9BQU9BLE1BQU0sVUFBVTtvQ0FDekIsT0FBT0EsTUFBTUg7Z0NBQ2YsT0FBTyxJQUFJLE9BQU9HLE1BQU0sWUFBWUEsR0FBRztvQ0FDckMsT0FBT0EsRUFBRS9CLE9BQU8sS0FBSzRCO2dDQUN2QjtnQ0FDQSxPQUFPOzRCQUNUOzRCQUVBLG9CQUFvQjs0QkFDcEJ6QyxhQUFhdUMsT0FBTyxDQUFDLGNBQWNuQyxLQUFLb0MsU0FBUyxDQUFDckM7NEJBRWxELHlDQUF5Qzs0QkFDekMsTUFBTWtELG9CQUFvQixJQUFJQyxZQUFZLDZCQUE2QjtnQ0FDckVDLFFBQVE7b0NBQUVDLFdBQVd0QyxLQUFLdUMsR0FBRztvQ0FBSUMsWUFBWTtvQ0FBV0ksY0FBYztnQ0FBSzs0QkFDN0U7NEJBQ0FqQyxPQUFPOEIsYUFBYSxDQUFDTjt3QkFDdkI7b0JBQ0Y7Z0JBQ0YsRUFBRSxPQUFPMUIsR0FBRztvQkFDVkwsUUFBUTdCLEtBQUssQ0FBQyw0REFBNERrQztnQkFDNUU7WUFDRjtRQUNGLEVBQUUsT0FBT0YsS0FBSztZQUNaSCxRQUFRN0IsS0FBSyxDQUFDLHVDQUF1Q2dDO1FBQ3ZEO0lBQ0Y7SUFFQSxNQUFNc0MsUUFBUTtRQUNaMUU7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtJQUVBLHFCQUNFLDhEQUFDTCwwQkFBMEI0RSxRQUFRO1FBQUNELE9BQU9BO2tCQUN4Q3BFOzs7Ozs7QUFHUDtHQXRQZ0JEO0tBQUFBO0FBd1BoQixpQ0FBaUM7QUFDMUIsU0FBU3VFOztJQUNkLE1BQU1DLFVBQVVqRixpREFBVUEsQ0FBQ0c7SUFDM0IsSUFBSSxDQUFDOEUsU0FBUztRQUNaLE1BQU0sSUFBSWxDLE1BQU07SUFDbEI7SUFDQSxPQUFPa0M7QUFDVDtJQU5nQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9kaXN0L1BoYW50b21NdWx0aVdhbGxldENvbnRleHQuanM/ZGVkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBoYW50b21NdWx0aVdhbGxldENvbnRleHRcbiAqIFxuICogQSBSZWFjdCBjb250ZXh0IGZvciBtYW5hZ2luZyBtdWx0aXBsZSBQaGFudG9tIHdhbGxldCBjb25uZWN0aW9ucy5cbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vLyBDcmVhdGUgY29udGV4dFxuY29uc3QgUGhhbnRvbU11bHRpV2FsbGV0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICBjb25uZWN0ZWRXYWxsZXRzOiBbXSxcbiAgY29ubmVjdDogYXN5bmMgKCkgPT4ge30sXG4gIGRpc2Nvbm5lY3Q6ICgpID0+IHt9LFxuICBpc0Nvbm5lY3Rpbmc6IGZhbHNlLFxuICBlcnJvcjogbnVsbFxufSk7XG5cbi8vIFByb3ZpZGVyIGNvbXBvbmVudFxuZXhwb3J0IGZ1bmN0aW9uIFBoYW50b21NdWx0aVdhbGxldFByb3ZpZGVyKHsgY2hpbGRyZW4gfSkge1xuICBjb25zdCBbY29ubmVjdGVkV2FsbGV0cywgc2V0Q29ubmVjdGVkV2FsbGV0c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtpc0Nvbm5lY3RpbmcsIHNldElzQ29ubmVjdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUobnVsbCk7XG5cbiAgLy8gTG9hZCBzYXZlZCB3YWxsZXQgY29ubmVjdGlvbnMgb24gY29tcG9uZW50IG1vdW50IGFuZCBsaXN0ZW4gZm9yIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkV2FsbGV0cyA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIFRyeSB0byBnZXQgd2FsbGV0cyBmcm9tIHRoZSBtYWluIHdhbGxldCBzdG9yYWdlXG4gICAgICAgICAgY29uc3Qgd2FsbGV0RGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxsZXREYXRhJyk7XG4gICAgICAgICAgaWYgKHdhbGxldERhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKHdhbGxldERhdGEpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZERhdGEgJiYgcGFyc2VkRGF0YS53YWxsZXRzICYmIHBhcnNlZERhdGEud2FsbGV0cy5waGFudG9tICYmIEFycmF5LmlzQXJyYXkocGFyc2VkRGF0YS53YWxsZXRzLnBoYW50b20pKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgd2FsbGV0IG9iamVjdHMgdG8gb3VyIGV4cGVjdGVkIGZvcm1hdFxuICAgICAgICAgICAgICBjb25zdCBwaGFudG9tV2FsbGV0cyA9IHBhcnNlZERhdGEud2FsbGV0cy5waGFudG9tLm1hcCh3YWxsZXQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBhIHdhbGxldCBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdhbGxldCA9PT0gJ29iamVjdCcgJiYgd2FsbGV0ICE9PSBudWxsICYmIHdhbGxldC5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB3YWxsZXQuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiB3YWxsZXQuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW46IHdhbGxldC5jaGFpbiB8fCAnc29sYW5hJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BoYW50b20nLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRBdDogd2FsbGV0LmNvbm5lY3RlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MganVzdCBhIHN0cmluZyBhZGRyZXNzXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdhbGxldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHdhbGxldCxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiB3YWxsZXQsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluOiAnc29sYW5hJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BoYW50b20nLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pOyAvLyBSZW1vdmUgYW55IG51bGwgZW50cmllc1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvYWRlZCBQaGFudG9tIHdhbGxldHMgZnJvbSBjZW50cmFsIHN0b3JhZ2U6JywgcGhhbnRvbVdhbGxldHMpO1xuICAgICAgICAgICAgICBzZXRDb25uZWN0ZWRXYWxsZXRzKHBoYW50b21XYWxsZXRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGxlZ2FjeSBzdG9yYWdlXG4gICAgICAgICAgICAgIGNvbnN0IGxlZ2FjeVdhbGxldHMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGhhbnRvbVdhbGxldHMnKTtcbiAgICAgICAgICAgICAgaWYgKGxlZ2FjeVdhbGxldHMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgbGVnYWN5IFBoYW50b20gd2FsbGV0IHN0b3JhZ2UnKTtcbiAgICAgICAgICAgICAgICBzZXRDb25uZWN0ZWRXYWxsZXRzKEpTT04ucGFyc2UobGVnYWN5V2FsbGV0cykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzYXZlZCBQaGFudG9tIHdhbGxldHM6JywgZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIExvYWQgd2FsbGV0cyBpbml0aWFsbHlcbiAgICBsb2FkV2FsbGV0cygpO1xuICAgIFxuICAgIC8vIExpc3RlbiBmb3Igd2FsbGV0IGNvbm5lY3Rpb24gY2hhbmdlc1xuICAgIGNvbnN0IGhhbmRsZVN0b3JhZ2VDaGFuZ2UgPSAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSAnd2FsbGV0RGF0YScgfHwgZS5rZXkgPT09ICd3YWxsZXQtY29ubmVjdGlvbi1jaGFuZ2VkJykge1xuICAgICAgICBjb25zb2xlLmxvZygnV2FsbGV0IHN0b3JhZ2UgY2hhbmdlZCwgdXBkYXRpbmcgUGhhbnRvbSB3YWxsZXQgbGlzdCcpO1xuICAgICAgICBsb2FkV2FsbGV0cygpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBoYW5kbGVTdG9yYWdlQ2hhbmdlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2FsbGV0LWNvbm5lY3Rpb24tY2hhbmdlZCcsIGhhbmRsZVN0b3JhZ2VDaGFuZ2UpO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGhhbmRsZVN0b3JhZ2VDaGFuZ2UpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dhbGxldC1jb25uZWN0aW9uLWNoYW5nZWQnLCBoYW5kbGVTdG9yYWdlQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gQ29ubmVjdCB0byBhIFBoYW50b20gd2FsbGV0XG4gIGNvbnN0IGNvbm5lY3QgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0SXNDb25uZWN0aW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiBQaGFudG9tIGlzIGF2YWlsYWJsZVxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbm5lY3QgdG8gUGhhbnRvbSBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghd2luZG93LnNvbGFuYSB8fCAhd2luZG93LnNvbGFuYS5pc1BoYW50b20pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaGFudG9tIHdhbGxldCBpcyBub3QgaW5zdGFsbGVkJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRyeSB0byBjb25uZWN0IHRvIFBoYW50b21cbiAgICAgIGNvbnN0IHNvbGFuYVByb3ZpZGVyID0gd2luZG93LnNvbGFuYTtcbiAgICAgIFxuICAgICAgLy8gUmVxdWVzdCBjb25uZWN0aW9uXG4gICAgICBhd2FpdCBzb2xhbmFQcm92aWRlci5jb25uZWN0KCk7XG4gICAgICBcbiAgICAgIGlmICghc29sYW5hUHJvdmlkZXIuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCB0byBQaGFudG9tIHdhbGxldCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXNvbGFuYVByb3ZpZGVyLnB1YmxpY0tleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHB1YmxpYyBrZXkgYXZhaWxhYmxlIGZyb20gUGhhbnRvbSB3YWxsZXQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHdhbGxldCBvYmplY3RcbiAgICAgIGNvbnN0IHdhbGxldCA9IHtcbiAgICAgICAgYWRkcmVzczogc29sYW5hUHJvdmlkZXIucHVibGljS2V5LnRvU3RyaW5nKCksXG4gICAgICAgIHB1YmxpY0tleTogc29sYW5hUHJvdmlkZXIucHVibGljS2V5LnRvU3RyaW5nKCksXG4gICAgICAgIGNoYWluOiAnc29sYW5hJyxcbiAgICAgICAgdHlwZTogJ3BoYW50b20nLFxuICAgICAgICBjb25uZWN0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgIGNvbnN0IHVwZGF0ZWRXYWxsZXRzID0gWy4uLmNvbm5lY3RlZFdhbGxldHMsIHdhbGxldF07XG4gICAgICBzZXRDb25uZWN0ZWRXYWxsZXRzKHVwZGF0ZWRXYWxsZXRzKTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2UgdXNpbmcgYm90aCBmb3JtYXRzIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gVXBkYXRlIGxlZ2FjeSBzdG9yYWdlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwaGFudG9tV2FsbGV0cycsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRXYWxsZXRzKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgY2VudHJhbCB3YWxsZXQgc3RvcmFnZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHdhbGxldERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsbGV0RGF0YScpO1xuICAgICAgICAgIGxldCBwYXJzZWREYXRhID0gd2FsbGV0RGF0YSA/IEpTT04ucGFyc2Uod2FsbGV0RGF0YSkgOiB7IHdhbGxldHM6IHt9IH07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRW5zdXJlIHdhbGxldHMgb2JqZWN0IGV4aXN0c1xuICAgICAgICAgIGlmICghcGFyc2VkRGF0YS53YWxsZXRzKSB7XG4gICAgICAgICAgICBwYXJzZWREYXRhLndhbGxldHMgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRW5zdXJlIHBoYW50b20gd2FsbGV0cyBhcnJheSBleGlzdHNcbiAgICAgICAgICBpZiAoIXBhcnNlZERhdGEud2FsbGV0cy5waGFudG9tIHx8ICFBcnJheS5pc0FycmF5KHBhcnNlZERhdGEud2FsbGV0cy5waGFudG9tKSkge1xuICAgICAgICAgICAgcGFyc2VkRGF0YS53YWxsZXRzLnBoYW50b20gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRkIHRoZSBuZXcgd2FsbGV0IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICBjb25zdCB3YWxsZXRBZGRyZXNzID0gd2FsbGV0LmFkZHJlc3M7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHBhcnNlZERhdGEud2FsbGV0cy5waGFudG9tLmZpbmRJbmRleCh3ID0+IFxuICAgICAgICAgICAgKHR5cGVvZiB3ID09PSAnc3RyaW5nJyAmJiB3ID09PSB3YWxsZXRBZGRyZXNzKSB8fCBcbiAgICAgICAgICAgICh0eXBlb2YgdyA9PT0gJ29iamVjdCcgJiYgdyAmJiB3LmFkZHJlc3MgPT09IHdhbGxldEFkZHJlc3MpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHBhcnNlZERhdGEud2FsbGV0cy5waGFudG9tLnB1c2goe1xuICAgICAgICAgICAgICBpZDogYHBoYW50b20tJHt3YWxsZXRBZGRyZXNzLnN1YnN0cmluZygwLCA4KX1gLFxuICAgICAgICAgICAgICBhZGRyZXNzOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgICBkaXNwbGF5QWRkcmVzczogYCR7d2FsbGV0QWRkcmVzcy5zdWJzdHJpbmcoMCwgNil9Li4uJHt3YWxsZXRBZGRyZXNzLnN1YnN0cmluZyh3YWxsZXRBZGRyZXNzLmxlbmd0aCAtIDQpfWAsXG4gICAgICAgICAgICAgIGZ1bGxBZGRyZXNzOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgICB0eXBlOiAncGhhbnRvbScsXG4gICAgICAgICAgICAgIGNoYWluOiAnc29sYW5hJyxcbiAgICAgICAgICAgICAgbmFtZTogYFBoYW50b20gJHt3YWxsZXRBZGRyZXNzLnN1YnN0cmluZygwLCA2KX0uLi5gLFxuICAgICAgICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbm5lY3RlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTYXZlIHVwZGF0ZWQgZGF0YVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3YWxsZXREYXRhJywgSlNPTi5zdHJpbmdpZnkocGFyc2VkRGF0YSkpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyaWdnZXIgd2FsbGV0IGNvbm5lY3Rpb24gY2hhbmdlIGV2ZW50XG4gICAgICAgICAgY29uc3Qgd2FsbGV0Q2hhbmdlRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3dhbGxldC1jb25uZWN0aW9uLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHsgdGltZXN0YW1wOiBEYXRlLm5vdygpLCB3YWxsZXRUeXBlOiAncGhhbnRvbScgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KHdhbGxldENoYW5nZUV2ZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGNlbnRyYWwgd2FsbGV0IHN0b3JhZ2U6JywgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gY29ubmVjdCB0byBQaGFudG9tIHdhbGxldCc7XG4gICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgY29uc29sZS5lcnJvcignUGhhbnRvbSB3YWxsZXQgY29ubmVjdGlvbiBlcnJvcjonLCBlcnIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzQ29ubmVjdGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERpc2Nvbm5lY3QgYSBQaGFudG9tIHdhbGxldFxuICBjb25zdCBkaXNjb25uZWN0ID0gKHdhbGxldEFkZHJlc3MpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXBkYXRlZFdhbGxldHMgPSBjb25uZWN0ZWRXYWxsZXRzLmZpbHRlcihcbiAgICAgICAgd2FsbGV0ID0+IHdhbGxldC5hZGRyZXNzICE9PSB3YWxsZXRBZGRyZXNzXG4gICAgICApO1xuICAgICAgc2V0Q29ubmVjdGVkV2FsbGV0cyh1cGRhdGVkV2FsbGV0cyk7XG4gICAgICBcbiAgICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlIC0gdXBkYXRlIGJvdGggZm9ybWF0c1xuICAgICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBsZWdhY3kgc3RvcmFnZVxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncGhhbnRvbVdhbGxldHMnLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkV2FsbGV0cykpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGNlbnRyYWwgd2FsbGV0IHN0b3JhZ2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB3YWxsZXREYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGxldERhdGEnKTtcbiAgICAgICAgICBpZiAod2FsbGV0RGF0YSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2Uod2FsbGV0RGF0YSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHdhbGxldCBzdHJ1Y3R1cmUgZXhpc3RzXG4gICAgICAgICAgICBpZiAocGFyc2VkRGF0YS53YWxsZXRzICYmIHBhcnNlZERhdGEud2FsbGV0cy5waGFudG9tICYmIEFycmF5LmlzQXJyYXkocGFyc2VkRGF0YS53YWxsZXRzLnBoYW50b20pKSB7XG4gICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIGRpc2Nvbm5lY3RlZCB3YWxsZXRcbiAgICAgICAgICAgICAgcGFyc2VkRGF0YS53YWxsZXRzLnBoYW50b20gPSBwYXJzZWREYXRhLndhbGxldHMucGhhbnRvbS5maWx0ZXIodyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHcgIT09IHdhbGxldEFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdyA9PT0gJ29iamVjdCcgJiYgdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHcuYWRkcmVzcyAhPT0gd2FsbGV0QWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU2F2ZSB1cGRhdGVkIGRhdGFcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dhbGxldERhdGEnLCBKU09OLnN0cmluZ2lmeShwYXJzZWREYXRhKSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBUcmlnZ2VyIHdhbGxldCBjb25uZWN0aW9uIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgICBjb25zdCB3YWxsZXRDaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnd2FsbGV0LWNvbm5lY3Rpb24tY2hhbmdlZCcsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHsgdGltZXN0YW1wOiBEYXRlLm5vdygpLCB3YWxsZXRUeXBlOiAncGhhbnRvbScsIGRpc2Nvbm5lY3RlZDogdHJ1ZSB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudCh3YWxsZXRDaGFuZ2VFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgY2VudHJhbCB3YWxsZXQgc3RvcmFnZSBkdXJpbmcgZGlzY29ubmVjdDonLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGlzY29ubmVjdGluZyBQaGFudG9tIHdhbGxldDonLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB2YWx1ZSA9IHtcbiAgICBjb25uZWN0ZWRXYWxsZXRzLFxuICAgIGNvbm5lY3QsXG4gICAgZGlzY29ubmVjdCxcbiAgICBpc0Nvbm5lY3RpbmcsXG4gICAgZXJyb3JcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxQaGFudG9tTXVsdGlXYWxsZXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9QaGFudG9tTXVsdGlXYWxsZXRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG4vLyBDdXN0b20gaG9vayB0byB1c2UgdGhlIGNvbnRleHRcbmV4cG9ydCBmdW5jdGlvbiB1c2VQaGFudG9tTXVsdGlXYWxsZXQoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFBoYW50b21NdWx0aVdhbGxldENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVBoYW50b21NdWx0aVdhbGxldCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgUGhhbnRvbU11bHRpV2FsbGV0UHJvdmlkZXInKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn0iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIlBoYW50b21NdWx0aVdhbGxldENvbnRleHQiLCJjb25uZWN0ZWRXYWxsZXRzIiwiY29ubmVjdCIsImRpc2Nvbm5lY3QiLCJpc0Nvbm5lY3RpbmciLCJlcnJvciIsIlBoYW50b21NdWx0aVdhbGxldFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzZXRDb25uZWN0ZWRXYWxsZXRzIiwic2V0SXNDb25uZWN0aW5nIiwic2V0RXJyb3IiLCJsb2FkV2FsbGV0cyIsImxvY2FsU3RvcmFnZSIsIndhbGxldERhdGEiLCJnZXRJdGVtIiwicGFyc2VkRGF0YSIsIkpTT04iLCJwYXJzZSIsIndhbGxldHMiLCJwaGFudG9tIiwiQXJyYXkiLCJpc0FycmF5IiwicGhhbnRvbVdhbGxldHMiLCJtYXAiLCJ3YWxsZXQiLCJhZGRyZXNzIiwicHVibGljS2V5IiwiY2hhaW4iLCJ0eXBlIiwiY29ubmVjdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJmaWx0ZXIiLCJCb29sZWFuIiwiY29uc29sZSIsImxvZyIsImxlZ2FjeVdhbGxldHMiLCJlcnIiLCJoYW5kbGVTdG9yYWdlQ2hhbmdlIiwiZSIsImtleSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiRXJyb3IiLCJzb2xhbmEiLCJpc1BoYW50b20iLCJzb2xhbmFQcm92aWRlciIsImlzQ29ubmVjdGVkIiwidG9TdHJpbmciLCJ1cGRhdGVkV2FsbGV0cyIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJ3YWxsZXRBZGRyZXNzIiwiZXhpc3RpbmdJbmRleCIsImZpbmRJbmRleCIsInciLCJwdXNoIiwiaWQiLCJzdWJzdHJpbmciLCJkaXNwbGF5QWRkcmVzcyIsImxlbmd0aCIsImZ1bGxBZGRyZXNzIiwibmFtZSIsImNvbm5lY3RlZCIsIndhbGxldENoYW5nZUV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJ0aW1lc3RhbXAiLCJub3ciLCJ3YWxsZXRUeXBlIiwiZGlzcGF0Y2hFdmVudCIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJkaXNjb25uZWN0ZWQiLCJ2YWx1ZSIsIlByb3ZpZGVyIiwidXNlUGhhbnRvbU11bHRpV2FsbGV0IiwiY29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../common/dist/PhantomMultiWalletContext.js\n"));

/***/ })

});