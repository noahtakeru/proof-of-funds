"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/create",{

/***/ "../common/dist/utils/walletHelpers.js":
/*!*********************************************!*\
  !*** ../common/dist/utils/walletHelpers.js ***!
  \*********************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connectMetaMask: function() { return /* binding */ connectMetaMask; },\n/* harmony export */   convertAssetsToUSD: function() { return /* binding */ convertAssetsToUSD; },\n/* harmony export */   disconnectWallet: function() { return /* binding */ disconnectWallet; },\n/* harmony export */   generateProofHash: function() { return /* binding */ generateProofHash; },\n/* harmony export */   generateTemporaryWallet: function() { return /* binding */ generateTemporaryWallet; },\n/* harmony export */   getConnectedWallets: function() { return /* binding */ getConnectedWallets; },\n/* harmony export */   isMetaMaskAvailable: function() { return /* binding */ isMetaMaskAvailable; },\n/* harmony export */   saveWalletConnection: function() { return /* binding */ saveWalletConnection; },\n/* harmony export */   scanMultiChainAssets: function() { return /* binding */ scanMultiChainAssets; }\n/* harmony export */ });\n/**\n * Wallet Helpers Module\n * \n * This module provides utility functions for interacting with cryptocurrency wallets.\n */ /**\n * Get a list of all connected wallets\n * @returns {Array} Array of connected wallet objects\n */ function getConnectedWallets() {\n    if (typeof localStorage !== \"undefined\") {\n        try {\n            const walletData = localStorage.getItem(\"walletData\");\n            if (walletData) {\n                const parsedData = JSON.parse(walletData);\n                // Handle different data formats\n                if (Array.isArray(parsedData)) {\n                    // Direct array format (old format)\n                    return parsedData;\n                } else if (parsedData && typeof parsedData === \"object\") {\n                    if (parsedData.wallets) {\n                        // New format with wallets grouped by type\n                        const result = [];\n                        // Extract all wallet objects from each wallet type\n                        Object.keys(parsedData.wallets).forEach((walletType)=>{\n                            const typeWallets = parsedData.wallets[walletType];\n                            if (Array.isArray(typeWallets)) {\n                                typeWallets.forEach((wallet)=>{\n                                    // If wallet is just an address string, convert it to a wallet object\n                                    if (typeof wallet === \"string\") {\n                                        const address = wallet;\n                                        const displayAddress = address.length > 10 ? \"\".concat(address.substring(0, 6), \"...\").concat(address.substring(address.length - 4)) : address;\n                                        result.push({\n                                            id: \"\".concat(walletType, \"-\").concat(address.substring(2, 10)),\n                                            address: address,\n                                            displayAddress: displayAddress,\n                                            fullAddress: address,\n                                            type: walletType === \"metamask\" ? \"evm\" : walletType,\n                                            name: \"\".concat(walletType === \"metamask\" ? \"MetaMask\" : \"Wallet\", \" \").concat(displayAddress),\n                                            chain: walletType === \"metamask\" ? \"ethereum\" : \"unknown\",\n                                            connected: true\n                                        });\n                                    } else if (typeof wallet === \"object\" && wallet !== null) {\n                                        // Already a wallet object\n                                        result.push(wallet);\n                                    }\n                                });\n                            }\n                        });\n                        return result;\n                    }\n                }\n            }\n        } catch (error) {\n            console.error(\"Error getting connected wallets:\", error);\n        }\n    }\n    // Default empty array if no wallets are found\n    return [];\n}\n/**\n * Save a wallet connection to localStorage\n * @param {string} walletType - Type of wallet ('metamask', 'phantom', etc.)\n * @param {Array|Object} accounts - Array of wallet addresses or single wallet object\n * @returns {Promise<boolean>} Success or failure\n * @throws {Error} If parameters are invalid\n */ async function saveWalletConnection(walletType, accounts) {\n    if (!walletType) {\n        throw new Error(\"Missing wallet type\");\n    }\n    // Fix issues with non-array inputs\n    let accountsArray;\n    // Handle different inputs to make the function more robust\n    if (!accounts) {\n        throw new Error(\"Missing accounts parameter\");\n    } else if (Array.isArray(accounts)) {\n        // Normal case: accounts is already an array\n        accountsArray = accounts;\n    } else if (typeof accounts === \"object\" && accounts.address) {\n        // Handle case where a single wallet object is passed\n        accountsArray = [\n            accounts.address\n        ];\n    } else if (typeof accounts === \"object\" && accounts.accounts && Array.isArray(accounts.accounts)) {\n        // Handle case where accounts is wrapped in an object\n        accountsArray = accounts.accounts;\n    } else if (typeof accounts === \"string\") {\n        // Handle case where a single address string is passed\n        accountsArray = [\n            accounts\n        ];\n    } else {\n        console.error(\"Invalid accounts parameter:\", accounts);\n        throw new Error(\"Invalid accounts parameter format\");\n    }\n    // Final validation after normalization\n    if (accountsArray.length === 0) {\n        throw new Error(\"Empty accounts array after normalization\");\n    }\n    if (typeof localStorage === \"undefined\") {\n        throw new Error(\"Local storage is not available in this environment\");\n    }\n    try {\n        // Get existing wallet data\n        let walletData;\n        try {\n            const storedData = localStorage.getItem(\"walletData\");\n            walletData = storedData ? JSON.parse(storedData) : {};\n        } catch (e) {\n            console.warn(\"Failed to parse existing wallet data, initializing new structure\", e);\n            walletData = {};\n        }\n        // Initialize wallets object if it doesn't exist\n        if (!walletData.wallets) {\n            walletData.wallets = {};\n        }\n        // Initialize wallet type array if it doesn't exist\n        if (!walletData.wallets[walletType] || !Array.isArray(walletData.wallets[walletType])) {\n            walletData.wallets[walletType] = [];\n        }\n        // Each account needs to be a proper wallet object\n        accountsArray.forEach((account)=>{\n            if (!account) return; // Skip null/undefined entries\n            // Handle various account formats\n            const accountStr = typeof account === \"string\" ? account : account.address || account.publicKey || account.toString();\n            // Normalize address format\n            const address = String(accountStr).toLowerCase();\n            // Create a displayAddress for UI\n            const displayAddress = address.length > 10 ? \"\".concat(address.substring(0, 6), \"...\").concat(address.substring(address.length - 4)) : address;\n            // Check if wallet already exists\n            const existingIndex = walletData.wallets[walletType] ? walletData.wallets[walletType].findIndex((wallet)=>wallet && typeof wallet === \"object\" && wallet.address && wallet.address.toLowerCase() === address.toLowerCase()) : -1;\n            // If wallet doesn't exist, create a new wallet object with all required properties\n            if (existingIndex === -1) {\n                // Generate a unique ID\n                const uniqueId = \"\".concat(walletType, \"-\").concat(address.substring(2, 10));\n                // Create a proper wallet object with all required fields\n                const walletObj = {\n                    id: uniqueId,\n                    address: address,\n                    displayAddress: displayAddress,\n                    fullAddress: address,\n                    type: walletType === \"metamask\" ? \"evm\" : walletType,\n                    name: \"\".concat(walletType === \"metamask\" ? \"MetaMask\" : \"Wallet\", \" \").concat(displayAddress),\n                    chain: walletType === \"metamask\" ? \"ethereum\" : \"unknown\",\n                    connected: true,\n                    connectedAt: new Date().toISOString()\n                };\n                // Initialize the array if needed\n                if (!Array.isArray(walletData.wallets[walletType])) {\n                    walletData.wallets[walletType] = [];\n                }\n                // Add the wallet object\n                walletData.wallets[walletType].push(walletObj);\n            }\n        });\n        // Update timestamp\n        walletData.timestamp = Date.now();\n        // Save to localStorage\n        localStorage.setItem(\"walletData\", JSON.stringify(walletData));\n        console.log(\"Saved wallet connection:\", walletType, accountsArray, walletData);\n        return true;\n    } catch (error) {\n        const enhancedError = new Error(\"Failed to save wallet connection: \".concat(error.message));\n        enhancedError.originalError = error;\n        enhancedError.walletType = walletType;\n        enhancedError.accounts = accountsArray;\n        throw enhancedError;\n    }\n}\n/**\n * Connect to MetaMask wallet\n * @returns {Promise<Object>} Connected wallet info\n * @throws {Error} If MetaMask is not installed or connection fails\n */ async function connectMetaMask() {\n    var _window_ethereum, _window_ethereum1, _window_ethereum_providers, _window_ethereum2;\n    if (false) {}\n    // Detect browser environment\n    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);\n    // Log ethereum provider details to help with debugging\n    console.log(\"Environment check:\", {\n        hasEthereum: !!window.ethereum,\n        isMetaMask: (_window_ethereum = window.ethereum) === null || _window_ethereum === void 0 ? void 0 : _window_ethereum.isMetaMask,\n        hasProviders: !!((_window_ethereum1 = window.ethereum) === null || _window_ethereum1 === void 0 ? void 0 : _window_ethereum1.providers),\n        providerCount: (_window_ethereum2 = window.ethereum) === null || _window_ethereum2 === void 0 ? void 0 : (_window_ethereum_providers = _window_ethereum2.providers) === null || _window_ethereum_providers === void 0 ? void 0 : _window_ethereum_providers.length,\n        userAgent: navigator.userAgent,\n        isSafari,\n        isMobile\n    });\n    if (!window.ethereum) {\n        if (isMobile) {\n            throw new Error(\"MetaMask not detected. On mobile, please use the MetaMask mobile app browser.\");\n        } else {\n            throw new Error(\"MetaMask is not installed. Please install the MetaMask browser extension to use this feature.\");\n        }\n    }\n    // If we have multiple providers (common with multiple wallets installed)\n    // explicitly try to find MetaMask\n    let provider = window.ethereum;\n    if (window.ethereum.providers) {\n        const metaMaskProvider = window.ethereum.providers.find((p)=>p.isMetaMask);\n        if (metaMaskProvider) {\n            console.log(\"Using dedicated MetaMask provider from multiple providers\");\n            provider = metaMaskProvider;\n        }\n    }\n    try {\n        console.log(\"Requesting MetaMask accounts...\");\n        // First, try to force disconnect to ensure we get a fresh connection popup\n        try {\n            // Force disconnect from MetaMask to ensure the popup shows\n            if (provider.isConnected && provider.isConnected()) {\n                console.log(\"Provider already connected, disconnecting first to force re-auth...\");\n                try {\n                    // Try wallet-specific disconnection methods\n                    if (provider.disconnect && typeof provider.disconnect === \"function\") {\n                        await provider.disconnect();\n                    }\n                } catch (disconnectError) {\n                    console.log(\"Disconnect attempt before connect (expected):\", disconnectError);\n                }\n            }\n            // Clear any existing permissions from MetaMask\n            try {\n                // Request to clear permissions, which forces a new popup\n                await provider.request({\n                    method: \"wallet_revokePermissions\",\n                    params: [\n                        {\n                            eth_accounts: {}\n                        }\n                    ]\n                });\n            } catch (permError) {\n                console.log(\"Permission revocation attempt (expected):\", permError);\n            }\n        } catch (preConnectErr) {\n            console.log(\"Pre-connection cleanup (non-critical):\", preConnectErr);\n        }\n        // Force MetaMask to show popup by using specific params\n        const requestAccountsOptions = {\n            method: \"eth_requestAccounts\",\n            params: [\n                {\n                    force: true\n                }\n            ] // Try to force approval screen\n        };\n        // Add a delay to ensure browser processes user interaction\n        await new Promise((resolve)=>setTimeout(resolve, 200));\n        // Request account access with forceApproval parameter to always show the popup\n        console.log(\"Calling ethereum.request with provider to force auth popup\");\n        const accounts = await provider.request(requestAccountsOptions);\n        console.log(\"MetaMask returned accounts:\", accounts);\n        if (!accounts || accounts.length === 0) {\n            throw new Error(\"No accounts found. Please unlock MetaMask and try again.\");\n        }\n        // Get the connected wallet address\n        const address = accounts[0];\n        if (!address) {\n            throw new Error(\"Failed to get wallet address\");\n        }\n        // Get the current chain ID\n        const chainIdHex = await provider.request({\n            method: \"eth_chainId\"\n        });\n        const chainId = parseInt(chainIdHex, 16);\n        let chainName = \"unknown\";\n        // Map chain ID to name\n        const chainMap = {\n            1: \"ethereum\",\n            5: \"goerli\",\n            11155111: \"sepolia\",\n            137: \"polygon\",\n            80001: \"mumbai\",\n            42161: \"arbitrum\",\n            421613: \"arbitrum-goerli\"\n        };\n        if (chainMap[chainId]) {\n            chainName = chainMap[chainId];\n        }\n        // Create wallet object for return value and storage\n        const displayAddress = address.length > 10 ? \"\".concat(address.substring(0, 6), \"...\").concat(address.substring(address.length - 4)) : address;\n        const wallet = {\n            id: \"metamask-\".concat(address.substring(2, 10)),\n            address: address,\n            displayAddress: displayAddress,\n            fullAddress: address,\n            type: \"evm\",\n            provider: \"metamask\",\n            name: \"MetaMask \".concat(displayAddress),\n            chain: chainName,\n            chainId,\n            connected: true,\n            connectedAt: new Date().toISOString()\n        };\n        // Save a full wallet object instead of just the address\n        await saveWalletConnection(\"metamask\", [\n            wallet\n        ]);\n        return wallet;\n    } catch (error) {\n        console.error(\"MetaMask connection error:\", error);\n        // Handle specific MetaMask errors\n        if (error.code === 4001) {\n            // User rejected the request\n            throw new Error(\"Connection rejected by user. Please try again.\");\n        } else if (error.code === -32002) {\n            // Request already pending\n            throw new Error(\"A connection request is already pending. Please check MetaMask.\");\n        } else if (error.code === -32603) {\n            // Internal error\n            throw new Error(\"MetaMask encountered an internal error. Please try reloading the page.\");\n        } else if (error.message && error.message.includes(\"Already processing\")) {\n            // Another common MetaMask error\n            throw new Error(\"MetaMask is busy. Please wait and try again in a few moments.\");\n        }\n        const enhancedError = new Error(\"Failed to connect to MetaMask: \".concat(error.message || \"Unknown error\"));\n        enhancedError.originalError = error;\n        enhancedError.code = error.code;\n        throw enhancedError;\n    }\n}\n/**\n * Disconnect a wallet by type and address\n * @param {string} walletType - Type of wallet (evm, solana)\n * @param {string} address - Wallet address to disconnect\n * @returns {Promise<boolean>} Success or failure\n * @throws {Error} If parameters are invalid or disconnection fails\n */ async function disconnectWallet(walletType, address) {\n    if (!walletType) {\n        throw new Error(\"walletType is required\");\n    }\n    if (!address) {\n        throw new Error(\"address is required\");\n    }\n    // Handle different wallet types\n    if (walletType === \"evm\") {\n        // Disconnect EVM wallet (MetaMask, etc.)\n        if ( true && window.ethereum) {\n            try {\n                // Some providers have a disconnect method\n                if (window.ethereum.disconnect && typeof window.ethereum.disconnect === \"function\") {\n                    await window.ethereum.disconnect();\n                }\n                // For wagmi integration\n                if (window.wagmiDisconnect && typeof window.wagmiDisconnect === \"function\") {\n                    await window.wagmiDisconnect();\n                }\n            } catch (error) {\n                console.warn(\"Could not disconnect from provider directly:\", error.message);\n            // Continue to remove from local storage even if provider disconnect fails\n            }\n        }\n    } else if (walletType === \"solana\") {\n        // Disconnect Solana wallet (Phantom, etc.)\n        if ( true && window.solana) {\n            try {\n                // Try to disconnect if the wallet supports it\n                if (window.solana.disconnect && typeof window.solana.disconnect === \"function\") {\n                    await window.solana.disconnect();\n                }\n            } catch (error) {\n                console.warn(\"Could not disconnect Solana wallet:\", error.message);\n            // Continue to remove from local storage even if wallet disconnect fails\n            }\n        }\n    }\n    // Update localStorage regardless of provider disconnect result\n    if (typeof localStorage === \"undefined\") {\n        throw new Error(\"Local storage is not available in this environment\");\n    }\n    try {\n        const walletDataStr = localStorage.getItem(\"walletData\");\n        if (walletDataStr) {\n            const walletData = JSON.parse(walletDataStr);\n            // Handle both old and new formats\n            if (Array.isArray(walletData)) {\n                // Old format - direct array of wallets\n                const updatedWallets = walletData.filter((wallet)=>!(wallet.type === walletType && (wallet.address === address || wallet.fullAddress === address)));\n                localStorage.setItem(\"walletData\", JSON.stringify(updatedWallets));\n            } else if (walletData && typeof walletData === \"object\" && walletData.wallets) {\n                // New format - wallets organized by wallet type\n                const normalizedAddress = address.toLowerCase();\n                // Find the wallet type that might contain this address\n                Object.keys(walletData.wallets).forEach((type)=>{\n                    if (Array.isArray(walletData.wallets[type])) {\n                        // Remove matching wallet objects or addresses\n                        walletData.wallets[type] = walletData.wallets[type].filter((wallet)=>{\n                            if (typeof wallet === \"string\") {\n                                return wallet.toLowerCase() !== normalizedAddress;\n                            } else if (wallet && typeof wallet === \"object\") {\n                                const walletAddr = (wallet.address || wallet.fullAddress || \"\").toLowerCase();\n                                return !(walletAddr === normalizedAddress || wallet.type === walletType && walletAddr === normalizedAddress);\n                            }\n                            return true;\n                        });\n                    }\n                });\n                localStorage.setItem(\"walletData\", JSON.stringify(walletData));\n            }\n        }\n        // Clear other wallet-related localStorage flags to prevent auto-reconnect\n        if (walletType === \"metamask\" || walletType === \"evm\") {\n            // Clear wagmi connection data to prevent auto-reconnect\n            localStorage.removeItem(\"wagmi.connected\");\n            localStorage.removeItem(\"wagmi.connectors\");\n            localStorage.removeItem(\"wagmi.injected.shimDisconnect\");\n            localStorage.removeItem(\"wagmi.store\");\n            localStorage.removeItem(\"wagmi.wallet\");\n            // Remove the userInitiatedConnection flag to prevent re-scanning\n            localStorage.removeItem(\"userInitiatedConnection\");\n            // Remove MetaMask-specific local storage data\n            localStorage.removeItem(\"WALLETCONNECT_DEEPLINK_CHOICE\");\n            localStorage.removeItem(\"metamask-disconnected\");\n            // Set flag to indicate user has explicitly disconnected wallets\n            // This prevents auto-reconnection on page refresh\n            localStorage.setItem(\"user_disconnected_wallets\", \"true\");\n        } else if (walletType === \"phantom\" || walletType === \"solana\") {\n            // Remove Phantom-specific storage\n            localStorage.removeItem(\"phantomDiscoveredWallets\");\n            localStorage.removeItem(\"phantomWalletState\");\n            // Set disconnection flag for Solana wallets too\n            localStorage.setItem(\"user_disconnected_wallets\", \"true\");\n        }\n        console.log(\"Disconnected wallet: \".concat(walletType, \" - \").concat(address));\n        return true;\n    } catch (error) {\n        const enhancedError = new Error(\"Failed to update wallet data: \".concat(error.message));\n        enhancedError.originalError = error;\n        enhancedError.walletType = walletType;\n        enhancedError.address = address;\n        throw enhancedError;\n    }\n}\n/**\n * Scan for assets across multiple blockchains\n * @returns {Promise<Array>} Array of found assets\n * @throws {Error} If scanning fails\n */ async function scanMultiChainAssets() {\n    throw new Error(\"scanMultiChainAssets function not implemented\");\n}\n/**\n * Convert cryptocurrency asset values to USD\n * @param {Object} assets - Assets to convert\n * @returns {Promise<Object>} USD values for assets\n * @throws {Error} If conversion fails\n */ async function convertAssetsToUSD(assets) {\n    if (!assets) {\n        throw new Error(\"Assets parameter is required\");\n    }\n    throw new Error(\"convertAssetsToUSD function not implemented\");\n}\n/**\n * Generate a proof hash for verification\n * @param {Object} data - Data to hash\n * @returns {string} Generated hash\n * @throws {Error} If hash generation fails\n */ function generateProofHash(data) {\n    if (!data) {\n        throw new Error(\"Data parameter is required\");\n    }\n    throw new Error(\"generateProofHash function not implemented\");\n}\n/**\n * Check if MetaMask is available and working\n * @returns {Promise<boolean>} true if MetaMask is available and responding\n */ async function isMetaMaskAvailable() {\n    if (false) {}\n    // Check for ethereum object\n    if (!window.ethereum) {\n        return false;\n    }\n    // Find the MetaMask provider if we have multiple providers\n    let provider = window.ethereum;\n    if (window.ethereum.providers) {\n        const metaMaskProvider = window.ethereum.providers.find((p)=>p.isMetaMask);\n        if (metaMaskProvider) {\n            provider = metaMaskProvider;\n        } else if (!window.ethereum.isMetaMask) {\n            return false; // No MetaMask provider found\n        }\n    } else if (!window.ethereum.isMetaMask) {\n        return false; // Not MetaMask\n    }\n    // Test if the provider is responding\n    try {\n        await provider.request({\n            method: \"eth_chainId\"\n        });\n        return true;\n    } catch (err) {\n        console.warn(\"MetaMask health check failed:\", err);\n        return false;\n    }\n}\n/**\n * Generate a temporary wallet for proof submission\n * @returns {Promise<Object>} Temporary wallet\n * @throws {Error} If wallet generation fails\n */ async function generateTemporaryWallet() {\n    throw new Error(\"generateTemporaryWallet function not implemented\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29tbW9uL2Rpc3QvdXRpbHMvd2FsbGV0SGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBRUQ7OztDQUdDLEdBQ00sU0FBU0E7SUFDZCxJQUFJLE9BQU9DLGlCQUFpQixhQUFhO1FBQ3ZDLElBQUk7WUFDRixNQUFNQyxhQUFhRCxhQUFhRSxPQUFPLENBQUM7WUFDeEMsSUFBSUQsWUFBWTtnQkFDZCxNQUFNRSxhQUFhQyxLQUFLQyxLQUFLLENBQUNKO2dCQUU5QixnQ0FBZ0M7Z0JBQ2hDLElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0osYUFBYTtvQkFDN0IsbUNBQW1DO29CQUNuQyxPQUFPQTtnQkFDVCxPQUFPLElBQUlBLGNBQWMsT0FBT0EsZUFBZSxVQUFVO29CQUN2RCxJQUFJQSxXQUFXSyxPQUFPLEVBQUU7d0JBQ3RCLDBDQUEwQzt3QkFDMUMsTUFBTUMsU0FBUyxFQUFFO3dCQUVqQixtREFBbUQ7d0JBQ25EQyxPQUFPQyxJQUFJLENBQUNSLFdBQVdLLE9BQU8sRUFBRUksT0FBTyxDQUFDQyxDQUFBQTs0QkFDdEMsTUFBTUMsY0FBY1gsV0FBV0ssT0FBTyxDQUFDSyxXQUFXOzRCQUVsRCxJQUFJUCxNQUFNQyxPQUFPLENBQUNPLGNBQWM7Z0NBQzlCQSxZQUFZRixPQUFPLENBQUNHLENBQUFBO29DQUNsQixxRUFBcUU7b0NBQ3JFLElBQUksT0FBT0EsV0FBVyxVQUFVO3dDQUM5QixNQUFNQyxVQUFVRDt3Q0FDaEIsTUFBTUUsaUJBQWlCRCxRQUFRRSxNQUFNLEdBQUcsS0FDcEIsR0FBZ0NGLE9BQTdCQSxRQUFRRyxTQUFTLENBQUMsR0FBRyxJQUFHLE9BQTJDLE9BQXRDSCxRQUFRRyxTQUFTLENBQUNILFFBQVFFLE1BQU0sR0FBRyxNQUNuRUY7d0NBRXBCUCxPQUFPVyxJQUFJLENBQUM7NENBQ1ZDLElBQUksR0FBaUJMLE9BQWRILFlBQVcsS0FBNEIsT0FBekJHLFFBQVFHLFNBQVMsQ0FBQyxHQUFHOzRDQUMxQ0gsU0FBU0E7NENBQ1RDLGdCQUFnQkE7NENBQ2hCSyxhQUFhTjs0Q0FDYk8sTUFBTVYsZUFBZSxhQUFhLFFBQVFBOzRDQUMxQ1csTUFBTSxHQUF3RFAsT0FBckRKLGVBQWUsYUFBYSxhQUFhLFVBQVMsS0FBa0IsT0FBZkk7NENBQzlEUSxPQUFPWixlQUFlLGFBQWEsYUFBYTs0Q0FDaERhLFdBQVc7d0NBQ2I7b0NBQ0YsT0FBTyxJQUFJLE9BQU9YLFdBQVcsWUFBWUEsV0FBVyxNQUFNO3dDQUN4RCwwQkFBMEI7d0NBQzFCTixPQUFPVyxJQUFJLENBQUNMO29DQUNkO2dDQUNGOzRCQUNGO3dCQUNGO3dCQUVBLE9BQU9OO29CQUNUO2dCQUNGO1lBQ0Y7UUFDRixFQUFFLE9BQU9rQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxvQ0FBb0NBO1FBQ3BEO0lBQ0Y7SUFFQSw4Q0FBOEM7SUFDOUMsT0FBTyxFQUFFO0FBQ1g7QUFFQTs7Ozs7O0NBTUMsR0FDTSxlQUFlRSxxQkFBcUJoQixVQUFVLEVBQUVpQixRQUFRO0lBQzdELElBQUksQ0FBQ2pCLFlBQVk7UUFDZixNQUFNLElBQUlrQixNQUFNO0lBQ2xCO0lBRUEsbUNBQW1DO0lBQ25DLElBQUlDO0lBRUosMkRBQTJEO0lBQzNELElBQUksQ0FBQ0YsVUFBVTtRQUNiLE1BQU0sSUFBSUMsTUFBTTtJQUNsQixPQUFPLElBQUl6QixNQUFNQyxPQUFPLENBQUN1QixXQUFXO1FBQ2xDLDRDQUE0QztRQUM1Q0UsZ0JBQWdCRjtJQUNsQixPQUFPLElBQUksT0FBT0EsYUFBYSxZQUFZQSxTQUFTZCxPQUFPLEVBQUU7UUFDM0QscURBQXFEO1FBQ3JEZ0IsZ0JBQWdCO1lBQUNGLFNBQVNkLE9BQU87U0FBQztJQUNwQyxPQUFPLElBQUksT0FBT2MsYUFBYSxZQUFZQSxTQUFTQSxRQUFRLElBQUl4QixNQUFNQyxPQUFPLENBQUN1QixTQUFTQSxRQUFRLEdBQUc7UUFDaEcscURBQXFEO1FBQ3JERSxnQkFBZ0JGLFNBQVNBLFFBQVE7SUFDbkMsT0FBTyxJQUFJLE9BQU9BLGFBQWEsVUFBVTtRQUN2QyxzREFBc0Q7UUFDdERFLGdCQUFnQjtZQUFDRjtTQUFTO0lBQzVCLE9BQU87UUFDTEYsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkc7UUFDN0MsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUEsdUNBQXVDO0lBQ3ZDLElBQUlDLGNBQWNkLE1BQU0sS0FBSyxHQUFHO1FBQzlCLE1BQU0sSUFBSWEsTUFBTTtJQUNsQjtJQUVBLElBQUksT0FBTy9CLGlCQUFpQixhQUFhO1FBQ3ZDLE1BQU0sSUFBSStCLE1BQU07SUFDbEI7SUFFQSxJQUFJO1FBQ0YsMkJBQTJCO1FBQzNCLElBQUk5QjtRQUNKLElBQUk7WUFDRixNQUFNZ0MsYUFBYWpDLGFBQWFFLE9BQU8sQ0FBQztZQUN4Q0QsYUFBYWdDLGFBQWE3QixLQUFLQyxLQUFLLENBQUM0QixjQUFjLENBQUM7UUFDdEQsRUFBRSxPQUFPQyxHQUFHO1lBQ1ZOLFFBQVFPLElBQUksQ0FBQyxvRUFBb0VEO1lBQ2pGakMsYUFBYSxDQUFDO1FBQ2hCO1FBRUEsZ0RBQWdEO1FBQ2hELElBQUksQ0FBQ0EsV0FBV08sT0FBTyxFQUFFO1lBQ3ZCUCxXQUFXTyxPQUFPLEdBQUcsQ0FBQztRQUN4QjtRQUVBLG1EQUFtRDtRQUNuRCxJQUFJLENBQUNQLFdBQVdPLE9BQU8sQ0FBQ0ssV0FBVyxJQUFJLENBQUNQLE1BQU1DLE9BQU8sQ0FBQ04sV0FBV08sT0FBTyxDQUFDSyxXQUFXLEdBQUc7WUFDckZaLFdBQVdPLE9BQU8sQ0FBQ0ssV0FBVyxHQUFHLEVBQUU7UUFDckM7UUFFQSxrREFBa0Q7UUFDbERtQixjQUFjcEIsT0FBTyxDQUFDd0IsQ0FBQUE7WUFDcEIsSUFBSSxDQUFDQSxTQUFTLFFBQVEsOEJBQThCO1lBRXBELGlDQUFpQztZQUNqQyxNQUFNQyxhQUFhLE9BQU9ELFlBQVksV0FBV0EsVUFDOUJBLFFBQVFwQixPQUFPLElBQUlvQixRQUFRRSxTQUFTLElBQUlGLFFBQVFHLFFBQVE7WUFFM0UsMkJBQTJCO1lBQzNCLE1BQU12QixVQUFVd0IsT0FBT0gsWUFBWUksV0FBVztZQUU5QyxpQ0FBaUM7WUFDakMsTUFBTXhCLGlCQUFpQkQsUUFBUUUsTUFBTSxHQUFHLEtBQ2xCLEdBQWdDRixPQUE3QkEsUUFBUUcsU0FBUyxDQUFDLEdBQUcsSUFBRyxPQUEyQyxPQUF0Q0gsUUFBUUcsU0FBUyxDQUFDSCxRQUFRRSxNQUFNLEdBQUcsTUFDbkVGO1lBRXRCLGlDQUFpQztZQUNqQyxNQUFNMEIsZ0JBQWdCekMsV0FBV08sT0FBTyxDQUFDSyxXQUFXLEdBQ2xEWixXQUFXTyxPQUFPLENBQUNLLFdBQVcsQ0FBQzhCLFNBQVMsQ0FDdEM1QixDQUFBQSxTQUFVQSxVQUFVLE9BQU9BLFdBQVcsWUFBWUEsT0FBT0MsT0FBTyxJQUNoRUQsT0FBT0MsT0FBTyxDQUFDeUIsV0FBVyxPQUFPekIsUUFBUXlCLFdBQVcsTUFDbEQsQ0FBQztZQUVQLG1GQUFtRjtZQUNuRixJQUFJQyxrQkFBa0IsQ0FBQyxHQUFHO2dCQUN4Qix1QkFBdUI7Z0JBQ3ZCLE1BQU1FLFdBQVcsR0FBaUI1QixPQUFkSCxZQUFXLEtBQTRCLE9BQXpCRyxRQUFRRyxTQUFTLENBQUMsR0FBRztnQkFFdkQseURBQXlEO2dCQUN6RCxNQUFNMEIsWUFBWTtvQkFDaEJ4QixJQUFJdUI7b0JBQ0o1QixTQUFTQTtvQkFDVEMsZ0JBQWdCQTtvQkFDaEJLLGFBQWFOO29CQUNiTyxNQUFNVixlQUFlLGFBQWEsUUFBUUE7b0JBQzFDVyxNQUFNLEdBQXdEUCxPQUFyREosZUFBZSxhQUFhLGFBQWEsVUFBUyxLQUFrQixPQUFmSTtvQkFDOURRLE9BQU9aLGVBQWUsYUFBYSxhQUFhO29CQUNoRGEsV0FBVztvQkFDWG9CLGFBQWEsSUFBSUMsT0FBT0MsV0FBVztnQkFDckM7Z0JBRUEsaUNBQWlDO2dCQUNqQyxJQUFJLENBQUMxQyxNQUFNQyxPQUFPLENBQUNOLFdBQVdPLE9BQU8sQ0FBQ0ssV0FBVyxHQUFHO29CQUNsRFosV0FBV08sT0FBTyxDQUFDSyxXQUFXLEdBQUcsRUFBRTtnQkFDckM7Z0JBRUEsd0JBQXdCO2dCQUN4QlosV0FBV08sT0FBTyxDQUFDSyxXQUFXLENBQUNPLElBQUksQ0FBQ3lCO1lBQ3RDO1FBQ0Y7UUFFQSxtQkFBbUI7UUFDbkI1QyxXQUFXZ0QsU0FBUyxHQUFHRixLQUFLRyxHQUFHO1FBRS9CLHVCQUF1QjtRQUN2QmxELGFBQWFtRCxPQUFPLENBQUMsY0FBYy9DLEtBQUtnRCxTQUFTLENBQUNuRDtRQUNsRDJCLFFBQVF5QixHQUFHLENBQUMsNEJBQTRCeEMsWUFBWW1CLGVBQWUvQjtRQUNuRSxPQUFPO0lBQ1QsRUFBRSxPQUFPMEIsT0FBTztRQUNkLE1BQU0yQixnQkFBZ0IsSUFBSXZCLE1BQU0scUNBQW1ELE9BQWRKLE1BQU00QixPQUFPO1FBQ2xGRCxjQUFjRSxhQUFhLEdBQUc3QjtRQUM5QjJCLGNBQWN6QyxVQUFVLEdBQUdBO1FBQzNCeUMsY0FBY3hCLFFBQVEsR0FBR0U7UUFDekIsTUFBTXNCO0lBQ1I7QUFDRjtBQUVBOzs7O0NBSUMsR0FDTSxlQUFlRztRQVlOQyxrQkFDSUEsbUJBQ0RBLDRCQUFBQTtJQWJqQixJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFFRCw2QkFBNkI7SUFDN0IsTUFBTUMsV0FBVyxpQ0FBaUNDLElBQUksQ0FBQ0MsVUFBVUMsU0FBUztJQUMxRSxNQUFNQyxXQUFXLDRCQUE0QkgsSUFBSSxDQUFDQyxVQUFVQyxTQUFTO0lBRXJFLHVEQUF1RDtJQUN2RGxDLFFBQVF5QixHQUFHLENBQUMsc0JBQXNCO1FBQ2hDVyxhQUFhLENBQUMsQ0FBQ04sT0FBT08sUUFBUTtRQUM5QkMsVUFBVSxHQUFFUixtQkFBQUEsT0FBT08sUUFBUSxjQUFmUCx1Q0FBQUEsaUJBQWlCUSxVQUFVO1FBQ3ZDQyxjQUFjLENBQUMsR0FBQ1Qsb0JBQUFBLE9BQU9PLFFBQVEsY0FBZlAsd0NBQUFBLGtCQUFpQlUsU0FBUztRQUMxQ0MsYUFBYSxHQUFFWCxvQkFBQUEsT0FBT08sUUFBUSxjQUFmUCx5Q0FBQUEsNkJBQUFBLGtCQUFpQlUsU0FBUyxjQUExQlYsaURBQUFBLDJCQUE0QnhDLE1BQU07UUFDakQ0QyxXQUFXRCxVQUFVQyxTQUFTO1FBQzlCSDtRQUNBSTtJQUNGO0lBRUEsSUFBSSxDQUFDTCxPQUFPTyxRQUFRLEVBQUU7UUFDcEIsSUFBSUYsVUFBVTtZQUNaLE1BQU0sSUFBSWhDLE1BQU07UUFDbEIsT0FBTztZQUNMLE1BQU0sSUFBSUEsTUFBTTtRQUNsQjtJQUNGO0lBRUEseUVBQXlFO0lBQ3pFLGtDQUFrQztJQUNsQyxJQUFJdUMsV0FBV1osT0FBT08sUUFBUTtJQUM5QixJQUFJUCxPQUFPTyxRQUFRLENBQUNHLFNBQVMsRUFBRTtRQUM3QixNQUFNRyxtQkFBbUJiLE9BQU9PLFFBQVEsQ0FBQ0csU0FBUyxDQUFDSSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVQLFVBQVU7UUFDekUsSUFBSUssa0JBQWtCO1lBQ3BCM0MsUUFBUXlCLEdBQUcsQ0FBQztZQUNaaUIsV0FBV0M7UUFDYjtJQUNGO0lBRUEsSUFBSTtRQUNGM0MsUUFBUXlCLEdBQUcsQ0FBQztRQUVaLDJFQUEyRTtRQUMzRSxJQUFJO1lBQ0YsMkRBQTJEO1lBQzNELElBQUlpQixTQUFTSSxXQUFXLElBQUlKLFNBQVNJLFdBQVcsSUFBSTtnQkFDbEQ5QyxRQUFReUIsR0FBRyxDQUFDO2dCQUNaLElBQUk7b0JBQ0YsNENBQTRDO29CQUM1QyxJQUFJaUIsU0FBU0ssVUFBVSxJQUFJLE9BQU9MLFNBQVNLLFVBQVUsS0FBSyxZQUFZO3dCQUNwRSxNQUFNTCxTQUFTSyxVQUFVO29CQUMzQjtnQkFDRixFQUFFLE9BQU9DLGlCQUFpQjtvQkFDeEJoRCxRQUFReUIsR0FBRyxDQUFDLGlEQUFpRHVCO2dCQUMvRDtZQUNGO1lBRUEsK0NBQStDO1lBQy9DLElBQUk7Z0JBQ0YseURBQXlEO2dCQUN6RCxNQUFNTixTQUFTTyxPQUFPLENBQUM7b0JBQ3JCQyxRQUFRO29CQUNSQyxRQUFRO3dCQUFDOzRCQUFFQyxjQUFjLENBQUM7d0JBQUU7cUJBQUU7Z0JBQ2hDO1lBQ0YsRUFBRSxPQUFPQyxXQUFXO2dCQUNsQnJELFFBQVF5QixHQUFHLENBQUMsNkNBQTZDNEI7WUFDM0Q7UUFDRixFQUFFLE9BQU9DLGVBQWU7WUFDdEJ0RCxRQUFReUIsR0FBRyxDQUFDLDBDQUEwQzZCO1FBQ3hEO1FBRUEsd0RBQXdEO1FBQ3hELE1BQU1DLHlCQUF5QjtZQUM3QkwsUUFBUTtZQUNSQyxRQUFRO2dCQUFDO29CQUFFSyxPQUFPO2dCQUFLO2FBQUUsQ0FBQywrQkFBK0I7UUFDM0Q7UUFFQSwyREFBMkQ7UUFDM0QsTUFBTSxJQUFJQyxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO1FBRWpELCtFQUErRTtRQUMvRTFELFFBQVF5QixHQUFHLENBQUM7UUFDWixNQUFNdkIsV0FBVyxNQUFNd0MsU0FBU08sT0FBTyxDQUFDTTtRQUV4Q3ZELFFBQVF5QixHQUFHLENBQUMsK0JBQStCdkI7UUFFM0MsSUFBSSxDQUFDQSxZQUFZQSxTQUFTWixNQUFNLEtBQUssR0FBRztZQUN0QyxNQUFNLElBQUlhLE1BQU07UUFDbEI7UUFFQSxtQ0FBbUM7UUFDbkMsTUFBTWYsVUFBVWMsUUFBUSxDQUFDLEVBQUU7UUFFM0IsSUFBSSxDQUFDZCxTQUFTO1lBQ1osTUFBTSxJQUFJZSxNQUFNO1FBQ2xCO1FBRUEsMkJBQTJCO1FBQzNCLE1BQU15RCxhQUFhLE1BQU1sQixTQUFTTyxPQUFPLENBQUM7WUFDeENDLFFBQVE7UUFDVjtRQUVBLE1BQU1XLFVBQVVDLFNBQVNGLFlBQVk7UUFDckMsSUFBSUcsWUFBWTtRQUVoQix1QkFBdUI7UUFDdkIsTUFBTUMsV0FBVztZQUNmLEdBQUc7WUFDSCxHQUFHO1lBQ0gsVUFBVTtZQUNWLEtBQUs7WUFDTCxPQUFPO1lBQ1AsT0FBTztZQUNQLFFBQVE7UUFDVjtRQUVBLElBQUlBLFFBQVEsQ0FBQ0gsUUFBUSxFQUFFO1lBQ3JCRSxZQUFZQyxRQUFRLENBQUNILFFBQVE7UUFDL0I7UUFFQSxvREFBb0Q7UUFDcEQsTUFBTXhFLGlCQUFpQkQsUUFBUUUsTUFBTSxHQUFHLEtBQ2xCLEdBQWdDRixPQUE3QkEsUUFBUUcsU0FBUyxDQUFDLEdBQUcsSUFBRyxPQUEyQyxPQUF0Q0gsUUFBUUcsU0FBUyxDQUFDSCxRQUFRRSxNQUFNLEdBQUcsTUFDbkVGO1FBRXRCLE1BQU1ELFNBQVM7WUFDYk0sSUFBSSxZQUFxQyxPQUF6QkwsUUFBUUcsU0FBUyxDQUFDLEdBQUc7WUFDckNILFNBQVNBO1lBQ1RDLGdCQUFnQkE7WUFDaEJLLGFBQWFOO1lBQ2JPLE1BQU07WUFDTitDLFVBQVU7WUFDVjlDLE1BQU0sWUFBMkIsT0FBZlA7WUFDbEJRLE9BQU9rRTtZQUNQRjtZQUNBL0QsV0FBVztZQUNYb0IsYUFBYSxJQUFJQyxPQUFPQyxXQUFXO1FBQ3JDO1FBRUEsd0RBQXdEO1FBQ3hELE1BQU1uQixxQkFBcUIsWUFBWTtZQUFDZDtTQUFPO1FBRS9DLE9BQU9BO0lBQ1QsRUFBRSxPQUFPWSxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyw4QkFBOEJBO1FBRTVDLGtDQUFrQztRQUNsQyxJQUFJQSxNQUFNa0UsSUFBSSxLQUFLLE1BQU07WUFDdkIsNEJBQTRCO1lBQzVCLE1BQU0sSUFBSTlELE1BQU07UUFDbEIsT0FBTyxJQUFJSixNQUFNa0UsSUFBSSxLQUFLLENBQUMsT0FBTztZQUNoQywwQkFBMEI7WUFDMUIsTUFBTSxJQUFJOUQsTUFBTTtRQUNsQixPQUFPLElBQUlKLE1BQU1rRSxJQUFJLEtBQUssQ0FBQyxPQUFPO1lBQ2hDLGlCQUFpQjtZQUNqQixNQUFNLElBQUk5RCxNQUFNO1FBQ2xCLE9BQU8sSUFBSUosTUFBTTRCLE9BQU8sSUFBSTVCLE1BQU00QixPQUFPLENBQUN1QyxRQUFRLENBQUMsdUJBQXVCO1lBQ3hFLGdDQUFnQztZQUNoQyxNQUFNLElBQUkvRCxNQUFNO1FBQ2xCO1FBRUEsTUFBTXVCLGdCQUFnQixJQUFJdkIsTUFBTSxrQ0FBbUUsT0FBakNKLE1BQU00QixPQUFPLElBQUk7UUFDbkZELGNBQWNFLGFBQWEsR0FBRzdCO1FBQzlCMkIsY0FBY3VDLElBQUksR0FBR2xFLE1BQU1rRSxJQUFJO1FBQy9CLE1BQU12QztJQUNSO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDTSxlQUFleUMsaUJBQWlCbEYsVUFBVSxFQUFFRyxPQUFPO0lBQ3hELElBQUksQ0FBQ0gsWUFBWTtRQUNmLE1BQU0sSUFBSWtCLE1BQU07SUFDbEI7SUFFQSxJQUFJLENBQUNmLFNBQVM7UUFDWixNQUFNLElBQUllLE1BQU07SUFDbEI7SUFFQSxnQ0FBZ0M7SUFDaEMsSUFBSWxCLGVBQWUsT0FBTztRQUN4Qix5Q0FBeUM7UUFDekMsSUFBSSxLQUFrQixJQUFlNkMsT0FBT08sUUFBUSxFQUFFO1lBQ3BELElBQUk7Z0JBQ0YsMENBQTBDO2dCQUMxQyxJQUFJUCxPQUFPTyxRQUFRLENBQUNVLFVBQVUsSUFBSSxPQUFPakIsT0FBT08sUUFBUSxDQUFDVSxVQUFVLEtBQUssWUFBWTtvQkFDbEYsTUFBTWpCLE9BQU9PLFFBQVEsQ0FBQ1UsVUFBVTtnQkFDbEM7Z0JBRUEsd0JBQXdCO2dCQUN4QixJQUFJakIsT0FBT3NDLGVBQWUsSUFBSSxPQUFPdEMsT0FBT3NDLGVBQWUsS0FBSyxZQUFZO29CQUMxRSxNQUFNdEMsT0FBT3NDLGVBQWU7Z0JBQzlCO1lBQ0YsRUFBRSxPQUFPckUsT0FBTztnQkFDZEMsUUFBUU8sSUFBSSxDQUFDLGdEQUFnRFIsTUFBTTRCLE9BQU87WUFDMUUsMEVBQTBFO1lBQzVFO1FBQ0Y7SUFDRixPQUFPLElBQUkxQyxlQUFlLFVBQVU7UUFDbEMsMkNBQTJDO1FBQzNDLElBQUksS0FBa0IsSUFBZTZDLE9BQU91QyxNQUFNLEVBQUU7WUFDbEQsSUFBSTtnQkFDRiw4Q0FBOEM7Z0JBQzlDLElBQUl2QyxPQUFPdUMsTUFBTSxDQUFDdEIsVUFBVSxJQUFJLE9BQU9qQixPQUFPdUMsTUFBTSxDQUFDdEIsVUFBVSxLQUFLLFlBQVk7b0JBQzlFLE1BQU1qQixPQUFPdUMsTUFBTSxDQUFDdEIsVUFBVTtnQkFDaEM7WUFDRixFQUFFLE9BQU9oRCxPQUFPO2dCQUNkQyxRQUFRTyxJQUFJLENBQUMsdUNBQXVDUixNQUFNNEIsT0FBTztZQUNqRSx3RUFBd0U7WUFDMUU7UUFDRjtJQUNGO0lBRUEsK0RBQStEO0lBQy9ELElBQUksT0FBT3ZELGlCQUFpQixhQUFhO1FBQ3ZDLE1BQU0sSUFBSStCLE1BQU07SUFDbEI7SUFFQSxJQUFJO1FBQ0YsTUFBTW1FLGdCQUFnQmxHLGFBQWFFLE9BQU8sQ0FBQztRQUMzQyxJQUFJZ0csZUFBZTtZQUNqQixNQUFNakcsYUFBYUcsS0FBS0MsS0FBSyxDQUFDNkY7WUFFOUIsa0NBQWtDO1lBQ2xDLElBQUk1RixNQUFNQyxPQUFPLENBQUNOLGFBQWE7Z0JBQzdCLHVDQUF1QztnQkFDdkMsTUFBTWtHLGlCQUFpQmxHLFdBQVdtRyxNQUFNLENBQUNyRixDQUFBQSxTQUN2QyxDQUFFQSxDQUFBQSxPQUFPUSxJQUFJLEtBQUtWLGNBQWVFLENBQUFBLE9BQU9DLE9BQU8sS0FBS0EsV0FBV0QsT0FBT08sV0FBVyxLQUFLTixPQUFNLENBQUM7Z0JBRS9GaEIsYUFBYW1ELE9BQU8sQ0FBQyxjQUFjL0MsS0FBS2dELFNBQVMsQ0FBQytDO1lBQ3BELE9BQU8sSUFBSWxHLGNBQWMsT0FBT0EsZUFBZSxZQUFZQSxXQUFXTyxPQUFPLEVBQUU7Z0JBQzdFLGdEQUFnRDtnQkFDaEQsTUFBTTZGLG9CQUFvQnJGLFFBQVF5QixXQUFXO2dCQUU3Qyx1REFBdUQ7Z0JBQ3ZEL0IsT0FBT0MsSUFBSSxDQUFDVixXQUFXTyxPQUFPLEVBQUVJLE9BQU8sQ0FBQ1csQ0FBQUE7b0JBQ3RDLElBQUlqQixNQUFNQyxPQUFPLENBQUNOLFdBQVdPLE9BQU8sQ0FBQ2UsS0FBSyxHQUFHO3dCQUMzQyw4Q0FBOEM7d0JBQzlDdEIsV0FBV08sT0FBTyxDQUFDZSxLQUFLLEdBQUd0QixXQUFXTyxPQUFPLENBQUNlLEtBQUssQ0FBQzZFLE1BQU0sQ0FBQ3JGLENBQUFBOzRCQUN6RCxJQUFJLE9BQU9BLFdBQVcsVUFBVTtnQ0FDOUIsT0FBT0EsT0FBTzBCLFdBQVcsT0FBTzREOzRCQUNsQyxPQUFPLElBQUl0RixVQUFVLE9BQU9BLFdBQVcsVUFBVTtnQ0FDL0MsTUFBTXVGLGFBQWEsQ0FBQ3ZGLE9BQU9DLE9BQU8sSUFBSUQsT0FBT08sV0FBVyxJQUFJLEVBQUMsRUFBR21CLFdBQVc7Z0NBQzNFLE9BQU8sQ0FBRTZELENBQUFBLGVBQWVELHFCQUNyQnRGLE9BQU9RLElBQUksS0FBS1YsY0FBY3lGLGVBQWVELGlCQUFpQjs0QkFDbkU7NEJBQ0EsT0FBTzt3QkFDVDtvQkFDRjtnQkFDRjtnQkFFQXJHLGFBQWFtRCxPQUFPLENBQUMsY0FBYy9DLEtBQUtnRCxTQUFTLENBQUNuRDtZQUNwRDtRQUNGO1FBRUEsMEVBQTBFO1FBQzFFLElBQUlZLGVBQWUsY0FBY0EsZUFBZSxPQUFPO1lBQ3JELHdEQUF3RDtZQUN4RGIsYUFBYXVHLFVBQVUsQ0FBQztZQUN4QnZHLGFBQWF1RyxVQUFVLENBQUM7WUFDeEJ2RyxhQUFhdUcsVUFBVSxDQUFDO1lBQ3hCdkcsYUFBYXVHLFVBQVUsQ0FBQztZQUN4QnZHLGFBQWF1RyxVQUFVLENBQUM7WUFFeEIsaUVBQWlFO1lBQ2pFdkcsYUFBYXVHLFVBQVUsQ0FBQztZQUV4Qiw4Q0FBOEM7WUFDOUN2RyxhQUFhdUcsVUFBVSxDQUFDO1lBQ3hCdkcsYUFBYXVHLFVBQVUsQ0FBQztZQUV4QixnRUFBZ0U7WUFDaEUsa0RBQWtEO1lBQ2xEdkcsYUFBYW1ELE9BQU8sQ0FBQyw2QkFBNkI7UUFDcEQsT0FBTyxJQUFJdEMsZUFBZSxhQUFhQSxlQUFlLFVBQVU7WUFDOUQsa0NBQWtDO1lBQ2xDYixhQUFhdUcsVUFBVSxDQUFDO1lBQ3hCdkcsYUFBYXVHLFVBQVUsQ0FBQztZQUV4QixnREFBZ0Q7WUFDaER2RyxhQUFhbUQsT0FBTyxDQUFDLDZCQUE2QjtRQUNwRDtRQUVBdkIsUUFBUXlCLEdBQUcsQ0FBQyx3QkFBd0NyQyxPQUFoQkgsWUFBVyxPQUFhLE9BQVJHO1FBQ3BELE9BQU87SUFDVCxFQUFFLE9BQU9XLE9BQU87UUFDZCxNQUFNMkIsZ0JBQWdCLElBQUl2QixNQUFNLGlDQUErQyxPQUFkSixNQUFNNEIsT0FBTztRQUM5RUQsY0FBY0UsYUFBYSxHQUFHN0I7UUFDOUIyQixjQUFjekMsVUFBVSxHQUFHQTtRQUMzQnlDLGNBQWN0QyxPQUFPLEdBQUdBO1FBQ3hCLE1BQU1zQztJQUNSO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sZUFBZWtEO0lBQ3BCLE1BQU0sSUFBSXpFLE1BQU07QUFDbEI7QUFFQTs7Ozs7Q0FLQyxHQUNNLGVBQWUwRSxtQkFBbUJDLE1BQU07SUFDN0MsSUFBSSxDQUFDQSxRQUFRO1FBQ1gsTUFBTSxJQUFJM0UsTUFBTTtJQUNsQjtJQUVBLE1BQU0sSUFBSUEsTUFBTTtBQUNsQjtBQUVBOzs7OztDQUtDLEdBQ00sU0FBUzRFLGtCQUFrQkMsSUFBSTtJQUNwQyxJQUFJLENBQUNBLE1BQU07UUFDVCxNQUFNLElBQUk3RSxNQUFNO0lBQ2xCO0lBRUEsTUFBTSxJQUFJQSxNQUFNO0FBQ2xCO0FBRUE7OztDQUdDLEdBQ00sZUFBZThFO0lBQ3BCLElBQUksS0FBa0IsRUFBYSxFQUVsQztJQUVELDRCQUE0QjtJQUM1QixJQUFJLENBQUNuRCxPQUFPTyxRQUFRLEVBQUU7UUFDcEIsT0FBTztJQUNUO0lBRUEsMkRBQTJEO0lBQzNELElBQUlLLFdBQVdaLE9BQU9PLFFBQVE7SUFDOUIsSUFBSVAsT0FBT08sUUFBUSxDQUFDRyxTQUFTLEVBQUU7UUFDN0IsTUFBTUcsbUJBQW1CYixPQUFPTyxRQUFRLENBQUNHLFNBQVMsQ0FBQ0ksSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFUCxVQUFVO1FBQ3pFLElBQUlLLGtCQUFrQjtZQUNwQkQsV0FBV0M7UUFDYixPQUFPLElBQUksQ0FBQ2IsT0FBT08sUUFBUSxDQUFDQyxVQUFVLEVBQUU7WUFDdEMsT0FBTyxPQUFPLDZCQUE2QjtRQUM3QztJQUNGLE9BQU8sSUFBSSxDQUFDUixPQUFPTyxRQUFRLENBQUNDLFVBQVUsRUFBRTtRQUN0QyxPQUFPLE9BQU8sZUFBZTtJQUMvQjtJQUVBLHFDQUFxQztJQUNyQyxJQUFJO1FBQ0YsTUFBTUksU0FBU08sT0FBTyxDQUFDO1lBQUVDLFFBQVE7UUFBYztRQUMvQyxPQUFPO0lBQ1QsRUFBRSxPQUFPZ0MsS0FBSztRQUNabEYsUUFBUU8sSUFBSSxDQUFDLGlDQUFpQzJFO1FBQzlDLE9BQU87SUFDVDtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNNLGVBQWVDO0lBQ3BCLE1BQU0sSUFBSWhGLE1BQU07QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvbW1vbi9kaXN0L3V0aWxzL3dhbGxldEhlbHBlcnMuanM/MTAyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdhbGxldCBIZWxwZXJzIE1vZHVsZVxuICogXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBjcnlwdG9jdXJyZW5jeSB3YWxsZXRzLlxuICovXG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBhbGwgY29ubmVjdGVkIHdhbGxldHNcbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgY29ubmVjdGVkIHdhbGxldCBvYmplY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25uZWN0ZWRXYWxsZXRzKCkge1xuICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgd2FsbGV0RGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxsZXREYXRhJyk7XG4gICAgICBpZiAod2FsbGV0RGF0YSkge1xuICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZSh3YWxsZXREYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgZGF0YSBmb3JtYXRzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZERhdGEpKSB7XG4gICAgICAgICAgLy8gRGlyZWN0IGFycmF5IGZvcm1hdCAob2xkIGZvcm1hdClcbiAgICAgICAgICByZXR1cm4gcGFyc2VkRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJzZWREYXRhICYmIHR5cGVvZiBwYXJzZWREYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChwYXJzZWREYXRhLndhbGxldHMpIHtcbiAgICAgICAgICAgIC8vIE5ldyBmb3JtYXQgd2l0aCB3YWxsZXRzIGdyb3VwZWQgYnkgdHlwZVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgYWxsIHdhbGxldCBvYmplY3RzIGZyb20gZWFjaCB3YWxsZXQgdHlwZVxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyc2VkRGF0YS53YWxsZXRzKS5mb3JFYWNoKHdhbGxldFR5cGUgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB0eXBlV2FsbGV0cyA9IHBhcnNlZERhdGEud2FsbGV0c1t3YWxsZXRUeXBlXTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGVXYWxsZXRzKSkge1xuICAgICAgICAgICAgICAgIHR5cGVXYWxsZXRzLmZvckVhY2god2FsbGV0ID0+IHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHdhbGxldCBpcyBqdXN0IGFuIGFkZHJlc3Mgc3RyaW5nLCBjb252ZXJ0IGl0IHRvIGEgd2FsbGV0IG9iamVjdFxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3YWxsZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB3YWxsZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlBZGRyZXNzID0gYWRkcmVzcy5sZW5ndGggPiAxMCA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2FkZHJlc3Muc3Vic3RyaW5nKDAsIDYpfS4uLiR7YWRkcmVzcy5zdWJzdHJpbmcoYWRkcmVzcy5sZW5ndGggLSA0KX1gIDogXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYCR7d2FsbGV0VHlwZX0tJHthZGRyZXNzLnN1YnN0cmluZygyLCAxMCl9YCxcbiAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlBZGRyZXNzOiBkaXNwbGF5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICBmdWxsQWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB3YWxsZXRUeXBlID09PSAnbWV0YW1hc2snID8gJ2V2bScgOiB3YWxsZXRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke3dhbGxldFR5cGUgPT09ICdtZXRhbWFzaycgPyAnTWV0YU1hc2snIDogJ1dhbGxldCd9ICR7ZGlzcGxheUFkZHJlc3N9YCxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogd2FsbGV0VHlwZSA9PT0gJ21ldGFtYXNrJyA/ICdldGhlcmV1bScgOiAndW5rbm93bicsXG4gICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2FsbGV0ID09PSAnb2JqZWN0JyAmJiB3YWxsZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBhIHdhbGxldCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god2FsbGV0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY29ubmVjdGVkIHdhbGxldHM6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRGVmYXVsdCBlbXB0eSBhcnJheSBpZiBubyB3YWxsZXRzIGFyZSBmb3VuZFxuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogU2F2ZSBhIHdhbGxldCBjb25uZWN0aW9uIHRvIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldFR5cGUgLSBUeXBlIG9mIHdhbGxldCAoJ21ldGFtYXNrJywgJ3BoYW50b20nLCBldGMuKVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFjY291bnRzIC0gQXJyYXkgb2Ygd2FsbGV0IGFkZHJlc3NlcyBvciBzaW5nbGUgd2FsbGV0IG9iamVjdFxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IFN1Y2Nlc3Mgb3IgZmFpbHVyZVxuICogQHRocm93cyB7RXJyb3J9IElmIHBhcmFtZXRlcnMgYXJlIGludmFsaWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVXYWxsZXRDb25uZWN0aW9uKHdhbGxldFR5cGUsIGFjY291bnRzKSB7XG4gIGlmICghd2FsbGV0VHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB3YWxsZXQgdHlwZScpO1xuICB9XG4gIFxuICAvLyBGaXggaXNzdWVzIHdpdGggbm9uLWFycmF5IGlucHV0c1xuICBsZXQgYWNjb3VudHNBcnJheTtcbiAgXG4gIC8vIEhhbmRsZSBkaWZmZXJlbnQgaW5wdXRzIHRvIG1ha2UgdGhlIGZ1bmN0aW9uIG1vcmUgcm9idXN0XG4gIGlmICghYWNjb3VudHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgYWNjb3VudHMgcGFyYW1ldGVyJyk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhY2NvdW50cykpIHtcbiAgICAvLyBOb3JtYWwgY2FzZTogYWNjb3VudHMgaXMgYWxyZWFkeSBhbiBhcnJheVxuICAgIGFjY291bnRzQXJyYXkgPSBhY2NvdW50cztcbiAgfSBlbHNlIGlmICh0eXBlb2YgYWNjb3VudHMgPT09ICdvYmplY3QnICYmIGFjY291bnRzLmFkZHJlc3MpIHtcbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBhIHNpbmdsZSB3YWxsZXQgb2JqZWN0IGlzIHBhc3NlZFxuICAgIGFjY291bnRzQXJyYXkgPSBbYWNjb3VudHMuYWRkcmVzc107XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFjY291bnRzID09PSAnb2JqZWN0JyAmJiBhY2NvdW50cy5hY2NvdW50cyAmJiBBcnJheS5pc0FycmF5KGFjY291bnRzLmFjY291bnRzKSkge1xuICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIGFjY291bnRzIGlzIHdyYXBwZWQgaW4gYW4gb2JqZWN0XG4gICAgYWNjb3VudHNBcnJheSA9IGFjY291bnRzLmFjY291bnRzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhY2NvdW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBhIHNpbmdsZSBhZGRyZXNzIHN0cmluZyBpcyBwYXNzZWRcbiAgICBhY2NvdW50c0FycmF5ID0gW2FjY291bnRzXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGFjY291bnRzIHBhcmFtZXRlcjonLCBhY2NvdW50cyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFjY291bnRzIHBhcmFtZXRlciBmb3JtYXQnKTtcbiAgfVxuICBcbiAgLy8gRmluYWwgdmFsaWRhdGlvbiBhZnRlciBub3JtYWxpemF0aW9uXG4gIGlmIChhY2NvdW50c0FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgYWNjb3VudHMgYXJyYXkgYWZ0ZXIgbm9ybWFsaXphdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMb2NhbCBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBHZXQgZXhpc3Rpbmcgd2FsbGV0IGRhdGFcbiAgICBsZXQgd2FsbGV0RGF0YTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxsZXREYXRhJyk7XG4gICAgICB3YWxsZXREYXRhID0gc3RvcmVkRGF0YSA/IEpTT04ucGFyc2Uoc3RvcmVkRGF0YSkgOiB7fTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyB3YWxsZXQgZGF0YSwgaW5pdGlhbGl6aW5nIG5ldyBzdHJ1Y3R1cmUnLCBlKTtcbiAgICAgIHdhbGxldERhdGEgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHdhbGxldHMgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBpZiAoIXdhbGxldERhdGEud2FsbGV0cykge1xuICAgICAgd2FsbGV0RGF0YS53YWxsZXRzID0ge307XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB3YWxsZXQgdHlwZSBhcnJheSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCF3YWxsZXREYXRhLndhbGxldHNbd2FsbGV0VHlwZV0gfHwgIUFycmF5LmlzQXJyYXkod2FsbGV0RGF0YS53YWxsZXRzW3dhbGxldFR5cGVdKSkge1xuICAgICAgd2FsbGV0RGF0YS53YWxsZXRzW3dhbGxldFR5cGVdID0gW107XG4gICAgfVxuXG4gICAgLy8gRWFjaCBhY2NvdW50IG5lZWRzIHRvIGJlIGEgcHJvcGVyIHdhbGxldCBvYmplY3RcbiAgICBhY2NvdW50c0FycmF5LmZvckVhY2goYWNjb3VudCA9PiB7XG4gICAgICBpZiAoIWFjY291bnQpIHJldHVybjsgLy8gU2tpcCBudWxsL3VuZGVmaW5lZCBlbnRyaWVzXG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSB2YXJpb3VzIGFjY291bnQgZm9ybWF0c1xuICAgICAgY29uc3QgYWNjb3VudFN0ciA9IHR5cGVvZiBhY2NvdW50ID09PSAnc3RyaW5nJyA/IGFjY291bnQgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgIChhY2NvdW50LmFkZHJlc3MgfHwgYWNjb3VudC5wdWJsaWNLZXkgfHwgYWNjb3VudC50b1N0cmluZygpKTtcbiAgICAgIFxuICAgICAgLy8gTm9ybWFsaXplIGFkZHJlc3MgZm9ybWF0XG4gICAgICBjb25zdCBhZGRyZXNzID0gU3RyaW5nKGFjY291bnRTdHIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIGRpc3BsYXlBZGRyZXNzIGZvciBVSVxuICAgICAgY29uc3QgZGlzcGxheUFkZHJlc3MgPSBhZGRyZXNzLmxlbmd0aCA+IDEwID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7YWRkcmVzcy5zdWJzdHJpbmcoMCwgNil9Li4uJHthZGRyZXNzLnN1YnN0cmluZyhhZGRyZXNzLmxlbmd0aCAtIDQpfWAgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB3YWxsZXQgYWxyZWFkeSBleGlzdHNcbiAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSB3YWxsZXREYXRhLndhbGxldHNbd2FsbGV0VHlwZV0gPyBcbiAgICAgICAgd2FsbGV0RGF0YS53YWxsZXRzW3dhbGxldFR5cGVdLmZpbmRJbmRleChcbiAgICAgICAgICB3YWxsZXQgPT4gd2FsbGV0ICYmIHR5cGVvZiB3YWxsZXQgPT09ICdvYmplY3QnICYmIHdhbGxldC5hZGRyZXNzICYmIFxuICAgICAgICAgIHdhbGxldC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICApIDogLTE7XG4gICAgICBcbiAgICAgIC8vIElmIHdhbGxldCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgYSBuZXcgd2FsbGV0IG9iamVjdCB3aXRoIGFsbCByZXF1aXJlZCBwcm9wZXJ0aWVzXG4gICAgICBpZiAoZXhpc3RpbmdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSURcbiAgICAgICAgY29uc3QgdW5pcXVlSWQgPSBgJHt3YWxsZXRUeXBlfS0ke2FkZHJlc3Muc3Vic3RyaW5nKDIsIDEwKX1gO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgcHJvcGVyIHdhbGxldCBvYmplY3Qgd2l0aCBhbGwgcmVxdWlyZWQgZmllbGRzXG4gICAgICAgIGNvbnN0IHdhbGxldE9iaiA9IHtcbiAgICAgICAgICBpZDogdW5pcXVlSWQsXG4gICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICBkaXNwbGF5QWRkcmVzczogZGlzcGxheUFkZHJlc3MsXG4gICAgICAgICAgZnVsbEFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgdHlwZTogd2FsbGV0VHlwZSA9PT0gJ21ldGFtYXNrJyA/ICdldm0nIDogd2FsbGV0VHlwZSxcbiAgICAgICAgICBuYW1lOiBgJHt3YWxsZXRUeXBlID09PSAnbWV0YW1hc2snID8gJ01ldGFNYXNrJyA6ICdXYWxsZXQnfSAke2Rpc3BsYXlBZGRyZXNzfWAsXG4gICAgICAgICAgY2hhaW46IHdhbGxldFR5cGUgPT09ICdtZXRhbWFzaycgPyAnZXRoZXJldW0nIDogJ3Vua25vd24nLFxuICAgICAgICAgIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgICBjb25uZWN0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBhcnJheSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdhbGxldERhdGEud2FsbGV0c1t3YWxsZXRUeXBlXSkpIHtcbiAgICAgICAgICB3YWxsZXREYXRhLndhbGxldHNbd2FsbGV0VHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHRoZSB3YWxsZXQgb2JqZWN0XG4gICAgICAgIHdhbGxldERhdGEud2FsbGV0c1t3YWxsZXRUeXBlXS5wdXNoKHdhbGxldE9iaik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgdGltZXN0YW1wXG4gICAgd2FsbGV0RGF0YS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dhbGxldERhdGEnLCBKU09OLnN0cmluZ2lmeSh3YWxsZXREYXRhKSk7XG4gICAgY29uc29sZS5sb2coJ1NhdmVkIHdhbGxldCBjb25uZWN0aW9uOicsIHdhbGxldFR5cGUsIGFjY291bnRzQXJyYXksIHdhbGxldERhdGEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGVuaGFuY2VkRXJyb3IgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBzYXZlIHdhbGxldCBjb25uZWN0aW9uOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgZW5oYW5jZWRFcnJvci5vcmlnaW5hbEVycm9yID0gZXJyb3I7XG4gICAgZW5oYW5jZWRFcnJvci53YWxsZXRUeXBlID0gd2FsbGV0VHlwZTtcbiAgICBlbmhhbmNlZEVycm9yLmFjY291bnRzID0gYWNjb3VudHNBcnJheTtcbiAgICB0aHJvdyBlbmhhbmNlZEVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQ29ubmVjdCB0byBNZXRhTWFzayB3YWxsZXRcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IENvbm5lY3RlZCB3YWxsZXQgaW5mb1xuICogQHRocm93cyB7RXJyb3J9IElmIE1ldGFNYXNrIGlzIG5vdCBpbnN0YWxsZWQgb3IgY29ubmVjdGlvbiBmYWlsc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29ubmVjdE1ldGFNYXNrKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25uZWN0IHRvIE1ldGFNYXNrIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQnKTtcbiAgfVxuICBcbiAgLy8gRGV0ZWN0IGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgY29uc3QgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBjb25zdCBpc01vYmlsZSA9IC9pUGhvbmV8aVBhZHxpUG9kfEFuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBcbiAgLy8gTG9nIGV0aGVyZXVtIHByb3ZpZGVyIGRldGFpbHMgdG8gaGVscCB3aXRoIGRlYnVnZ2luZ1xuICBjb25zb2xlLmxvZygnRW52aXJvbm1lbnQgY2hlY2s6JywgeyBcbiAgICBoYXNFdGhlcmV1bTogISF3aW5kb3cuZXRoZXJldW0sXG4gICAgaXNNZXRhTWFzazogd2luZG93LmV0aGVyZXVtPy5pc01ldGFNYXNrLFxuICAgIGhhc1Byb3ZpZGVyczogISF3aW5kb3cuZXRoZXJldW0/LnByb3ZpZGVycyxcbiAgICBwcm92aWRlckNvdW50OiB3aW5kb3cuZXRoZXJldW0/LnByb3ZpZGVycz8ubGVuZ3RoLFxuICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICBpc1NhZmFyaSxcbiAgICBpc01vYmlsZVxuICB9KTtcbiAgXG4gIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgaWYgKGlzTW9iaWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIG5vdCBkZXRlY3RlZC4gT24gbW9iaWxlLCBwbGVhc2UgdXNlIHRoZSBNZXRhTWFzayBtb2JpbGUgYXBwIGJyb3dzZXIuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YU1hc2sgaXMgbm90IGluc3RhbGxlZC4gUGxlYXNlIGluc3RhbGwgdGhlIE1ldGFNYXNrIGJyb3dzZXIgZXh0ZW5zaW9uIHRvIHVzZSB0aGlzIGZlYXR1cmUuJyk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBJZiB3ZSBoYXZlIG11bHRpcGxlIHByb3ZpZGVycyAoY29tbW9uIHdpdGggbXVsdGlwbGUgd2FsbGV0cyBpbnN0YWxsZWQpXG4gIC8vIGV4cGxpY2l0bHkgdHJ5IHRvIGZpbmQgTWV0YU1hc2tcbiAgbGV0IHByb3ZpZGVyID0gd2luZG93LmV0aGVyZXVtO1xuICBpZiAod2luZG93LmV0aGVyZXVtLnByb3ZpZGVycykge1xuICAgIGNvbnN0IG1ldGFNYXNrUHJvdmlkZXIgPSB3aW5kb3cuZXRoZXJldW0ucHJvdmlkZXJzLmZpbmQocCA9PiBwLmlzTWV0YU1hc2spO1xuICAgIGlmIChtZXRhTWFza1Byb3ZpZGVyKSB7XG4gICAgICBjb25zb2xlLmxvZygnVXNpbmcgZGVkaWNhdGVkIE1ldGFNYXNrIHByb3ZpZGVyIGZyb20gbXVsdGlwbGUgcHJvdmlkZXJzJyk7XG4gICAgICBwcm92aWRlciA9IG1ldGFNYXNrUHJvdmlkZXI7XG4gICAgfVxuICB9XG4gIFxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0aW5nIE1ldGFNYXNrIGFjY291bnRzLi4uJyk7XG4gICAgXG4gICAgLy8gRmlyc3QsIHRyeSB0byBmb3JjZSBkaXNjb25uZWN0IHRvIGVuc3VyZSB3ZSBnZXQgYSBmcmVzaCBjb25uZWN0aW9uIHBvcHVwXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZvcmNlIGRpc2Nvbm5lY3QgZnJvbSBNZXRhTWFzayB0byBlbnN1cmUgdGhlIHBvcHVwIHNob3dzXG4gICAgICBpZiAocHJvdmlkZXIuaXNDb25uZWN0ZWQgJiYgcHJvdmlkZXIuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnUHJvdmlkZXIgYWxyZWFkeSBjb25uZWN0ZWQsIGRpc2Nvbm5lY3RpbmcgZmlyc3QgdG8gZm9yY2UgcmUtYXV0aC4uLicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSB3YWxsZXQtc3BlY2lmaWMgZGlzY29ubmVjdGlvbiBtZXRob2RzXG4gICAgICAgICAgaWYgKHByb3ZpZGVyLmRpc2Nvbm5lY3QgJiYgdHlwZW9mIHByb3ZpZGVyLmRpc2Nvbm5lY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGF3YWl0IHByb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGRpc2Nvbm5lY3RFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdEaXNjb25uZWN0IGF0dGVtcHQgYmVmb3JlIGNvbm5lY3QgKGV4cGVjdGVkKTonLCBkaXNjb25uZWN0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBwZXJtaXNzaW9ucyBmcm9tIE1ldGFNYXNrXG4gICAgICB0cnkge1xuICAgICAgICAvLyBSZXF1ZXN0IHRvIGNsZWFyIHBlcm1pc3Npb25zLCB3aGljaCBmb3JjZXMgYSBuZXcgcG9wdXBcbiAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3Jldm9rZVBlcm1pc3Npb25zJyxcbiAgICAgICAgICBwYXJhbXM6IFt7IGV0aF9hY2NvdW50czoge30gfV1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChwZXJtRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1Blcm1pc3Npb24gcmV2b2NhdGlvbiBhdHRlbXB0IChleHBlY3RlZCk6JywgcGVybUVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChwcmVDb25uZWN0RXJyKSB7XG4gICAgICBjb25zb2xlLmxvZygnUHJlLWNvbm5lY3Rpb24gY2xlYW51cCAobm9uLWNyaXRpY2FsKTonLCBwcmVDb25uZWN0RXJyKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yY2UgTWV0YU1hc2sgdG8gc2hvdyBwb3B1cCBieSB1c2luZyBzcGVjaWZpYyBwYXJhbXNcbiAgICBjb25zdCByZXF1ZXN0QWNjb3VudHNPcHRpb25zID0geyBcbiAgICAgIG1ldGhvZDogJ2V0aF9yZXF1ZXN0QWNjb3VudHMnLFxuICAgICAgcGFyYW1zOiBbeyBmb3JjZTogdHJ1ZSB9XSAvLyBUcnkgdG8gZm9yY2UgYXBwcm92YWwgc2NyZWVuXG4gICAgfTtcbiAgICBcbiAgICAvLyBBZGQgYSBkZWxheSB0byBlbnN1cmUgYnJvd3NlciBwcm9jZXNzZXMgdXNlciBpbnRlcmFjdGlvblxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcbiAgICBcbiAgICAvLyBSZXF1ZXN0IGFjY291bnQgYWNjZXNzIHdpdGggZm9yY2VBcHByb3ZhbCBwYXJhbWV0ZXIgdG8gYWx3YXlzIHNob3cgdGhlIHBvcHVwXG4gICAgY29uc29sZS5sb2coJ0NhbGxpbmcgZXRoZXJldW0ucmVxdWVzdCB3aXRoIHByb3ZpZGVyIHRvIGZvcmNlIGF1dGggcG9wdXAnKTtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3QocmVxdWVzdEFjY291bnRzT3B0aW9ucyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ01ldGFNYXNrIHJldHVybmVkIGFjY291bnRzOicsIGFjY291bnRzKTtcbiAgICBcbiAgICBpZiAoIWFjY291bnRzIHx8IGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2NvdW50cyBmb3VuZC4gUGxlYXNlIHVubG9jayBNZXRhTWFzayBhbmQgdHJ5IGFnYWluLicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIGNvbm5lY3RlZCB3YWxsZXQgYWRkcmVzc1xuICAgIGNvbnN0IGFkZHJlc3MgPSBhY2NvdW50c1swXTtcbiAgICBcbiAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB3YWxsZXQgYWRkcmVzcycpO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgY2hhaW4gSURcbiAgICBjb25zdCBjaGFpbklkSGV4ID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7IFxuICAgICAgbWV0aG9kOiAnZXRoX2NoYWluSWQnIFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkSGV4LCAxNik7XG4gICAgbGV0IGNoYWluTmFtZSA9ICd1bmtub3duJztcbiAgICBcbiAgICAvLyBNYXAgY2hhaW4gSUQgdG8gbmFtZVxuICAgIGNvbnN0IGNoYWluTWFwID0ge1xuICAgICAgMTogJ2V0aGVyZXVtJyxcbiAgICAgIDU6ICdnb2VybGknLFxuICAgICAgMTExNTUxMTE6ICdzZXBvbGlhJyxcbiAgICAgIDEzNzogJ3BvbHlnb24nLFxuICAgICAgODAwMDE6ICdtdW1iYWknLFxuICAgICAgNDIxNjE6ICdhcmJpdHJ1bScsXG4gICAgICA0MjE2MTM6ICdhcmJpdHJ1bS1nb2VybGknXG4gICAgfTtcbiAgICBcbiAgICBpZiAoY2hhaW5NYXBbY2hhaW5JZF0pIHtcbiAgICAgIGNoYWluTmFtZSA9IGNoYWluTWFwW2NoYWluSWRdO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgd2FsbGV0IG9iamVjdCBmb3IgcmV0dXJuIHZhbHVlIGFuZCBzdG9yYWdlXG4gICAgY29uc3QgZGlzcGxheUFkZHJlc3MgPSBhZGRyZXNzLmxlbmd0aCA+IDEwID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGAke2FkZHJlc3Muc3Vic3RyaW5nKDAsIDYpfS4uLiR7YWRkcmVzcy5zdWJzdHJpbmcoYWRkcmVzcy5sZW5ndGggLSA0KX1gIDogXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M7XG4gICAgXG4gICAgY29uc3Qgd2FsbGV0ID0ge1xuICAgICAgaWQ6IGBtZXRhbWFzay0ke2FkZHJlc3Muc3Vic3RyaW5nKDIsIDEwKX1gLFxuICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgIGRpc3BsYXlBZGRyZXNzOiBkaXNwbGF5QWRkcmVzcyxcbiAgICAgIGZ1bGxBZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgdHlwZTogJ2V2bScsXG4gICAgICBwcm92aWRlcjogJ21ldGFtYXNrJyxcbiAgICAgIG5hbWU6IGBNZXRhTWFzayAke2Rpc3BsYXlBZGRyZXNzfWAsXG4gICAgICBjaGFpbjogY2hhaW5OYW1lLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgIGNvbm5lY3RlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICAgIFxuICAgIC8vIFNhdmUgYSBmdWxsIHdhbGxldCBvYmplY3QgaW5zdGVhZCBvZiBqdXN0IHRoZSBhZGRyZXNzXG4gICAgYXdhaXQgc2F2ZVdhbGxldENvbm5lY3Rpb24oJ21ldGFtYXNrJywgW3dhbGxldF0pO1xuICAgIFxuICAgIHJldHVybiB3YWxsZXQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignTWV0YU1hc2sgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgXG4gICAgLy8gSGFuZGxlIHNwZWNpZmljIE1ldGFNYXNrIGVycm9yc1xuICAgIGlmIChlcnJvci5jb2RlID09PSA0MDAxKSB7XG4gICAgICAvLyBVc2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gcmVqZWN0ZWQgYnkgdXNlci4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09IC0zMjAwMikge1xuICAgICAgLy8gUmVxdWVzdCBhbHJlYWR5IHBlbmRpbmdcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBjb25uZWN0aW9uIHJlcXVlc3QgaXMgYWxyZWFkeSBwZW5kaW5nLiBQbGVhc2UgY2hlY2sgTWV0YU1hc2suJyk7XG4gICAgfSBlbHNlIGlmIChlcnJvci5jb2RlID09PSAtMzI2MDMpIHtcbiAgICAgIC8vIEludGVybmFsIGVycm9yXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIGVuY291bnRlcmVkIGFuIGludGVybmFsIGVycm9yLiBQbGVhc2UgdHJ5IHJlbG9hZGluZyB0aGUgcGFnZS4nKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnQWxyZWFkeSBwcm9jZXNzaW5nJykpIHtcbiAgICAgIC8vIEFub3RoZXIgY29tbW9uIE1ldGFNYXNrIGVycm9yXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIGlzIGJ1c3kuIFBsZWFzZSB3YWl0IGFuZCB0cnkgYWdhaW4gaW4gYSBmZXcgbW9tZW50cy4nKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZW5oYW5jZWRFcnJvciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbm5lY3QgdG8gTWV0YU1hc2s6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgZW5oYW5jZWRFcnJvci5vcmlnaW5hbEVycm9yID0gZXJyb3I7XG4gICAgZW5oYW5jZWRFcnJvci5jb2RlID0gZXJyb3IuY29kZTtcbiAgICB0aHJvdyBlbmhhbmNlZEVycm9yO1xuICB9XG59XG5cbi8qKlxuICogRGlzY29ubmVjdCBhIHdhbGxldCBieSB0eXBlIGFuZCBhZGRyZXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0VHlwZSAtIFR5cGUgb2Ygd2FsbGV0IChldm0sIHNvbGFuYSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gV2FsbGV0IGFkZHJlc3MgdG8gZGlzY29ubmVjdFxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IFN1Y2Nlc3Mgb3IgZmFpbHVyZVxuICogQHRocm93cyB7RXJyb3J9IElmIHBhcmFtZXRlcnMgYXJlIGludmFsaWQgb3IgZGlzY29ubmVjdGlvbiBmYWlsc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlzY29ubmVjdFdhbGxldCh3YWxsZXRUeXBlLCBhZGRyZXNzKSB7XG4gIGlmICghd2FsbGV0VHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignd2FsbGV0VHlwZSBpcyByZXF1aXJlZCcpO1xuICB9XG4gIFxuICBpZiAoIWFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZHJlc3MgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBcbiAgLy8gSGFuZGxlIGRpZmZlcmVudCB3YWxsZXQgdHlwZXNcbiAgaWYgKHdhbGxldFR5cGUgPT09ICdldm0nKSB7XG4gICAgLy8gRGlzY29ubmVjdCBFVk0gd2FsbGV0IChNZXRhTWFzaywgZXRjLilcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBTb21lIHByb3ZpZGVycyBoYXZlIGEgZGlzY29ubmVjdCBtZXRob2RcbiAgICAgICAgaWYgKHdpbmRvdy5ldGhlcmV1bS5kaXNjb25uZWN0ICYmIHR5cGVvZiB3aW5kb3cuZXRoZXJldW0uZGlzY29ubmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGF3YWl0IHdpbmRvdy5ldGhlcmV1bS5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZvciB3YWdtaSBpbnRlZ3JhdGlvblxuICAgICAgICBpZiAod2luZG93LndhZ21pRGlzY29ubmVjdCAmJiB0eXBlb2Ygd2luZG93LndhZ21pRGlzY29ubmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGF3YWl0IHdpbmRvdy53YWdtaURpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZGlzY29ubmVjdCBmcm9tIHByb3ZpZGVyIGRpcmVjdGx5OicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAvLyBDb250aW51ZSB0byByZW1vdmUgZnJvbSBsb2NhbCBzdG9yYWdlIGV2ZW4gaWYgcHJvdmlkZXIgZGlzY29ubmVjdCBmYWlsc1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh3YWxsZXRUeXBlID09PSAnc29sYW5hJykge1xuICAgIC8vIERpc2Nvbm5lY3QgU29sYW5hIHdhbGxldCAoUGhhbnRvbSwgZXRjLilcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnNvbGFuYSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IHRvIGRpc2Nvbm5lY3QgaWYgdGhlIHdhbGxldCBzdXBwb3J0cyBpdFxuICAgICAgICBpZiAod2luZG93LnNvbGFuYS5kaXNjb25uZWN0ICYmIHR5cGVvZiB3aW5kb3cuc29sYW5hLmRpc2Nvbm5lY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhd2FpdCB3aW5kb3cuc29sYW5hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZGlzY29ubmVjdCBTb2xhbmEgd2FsbGV0OicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAvLyBDb250aW51ZSB0byByZW1vdmUgZnJvbSBsb2NhbCBzdG9yYWdlIGV2ZW4gaWYgd2FsbGV0IGRpc2Nvbm5lY3QgZmFpbHNcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIFVwZGF0ZSBsb2NhbFN0b3JhZ2UgcmVnYXJkbGVzcyBvZiBwcm92aWRlciBkaXNjb25uZWN0IHJlc3VsdFxuICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsIHN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgY29uc3Qgd2FsbGV0RGF0YVN0ciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxsZXREYXRhJyk7XG4gICAgaWYgKHdhbGxldERhdGFTdHIpIHtcbiAgICAgIGNvbnN0IHdhbGxldERhdGEgPSBKU09OLnBhcnNlKHdhbGxldERhdGFTdHIpO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgYm90aCBvbGQgYW5kIG5ldyBmb3JtYXRzXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh3YWxsZXREYXRhKSkge1xuICAgICAgICAvLyBPbGQgZm9ybWF0IC0gZGlyZWN0IGFycmF5IG9mIHdhbGxldHNcbiAgICAgICAgY29uc3QgdXBkYXRlZFdhbGxldHMgPSB3YWxsZXREYXRhLmZpbHRlcih3YWxsZXQgPT4gXG4gICAgICAgICAgISh3YWxsZXQudHlwZSA9PT0gd2FsbGV0VHlwZSAmJiAod2FsbGV0LmFkZHJlc3MgPT09IGFkZHJlc3MgfHwgd2FsbGV0LmZ1bGxBZGRyZXNzID09PSBhZGRyZXNzKSlcbiAgICAgICAgKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dhbGxldERhdGEnLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkV2FsbGV0cykpO1xuICAgICAgfSBlbHNlIGlmICh3YWxsZXREYXRhICYmIHR5cGVvZiB3YWxsZXREYXRhID09PSAnb2JqZWN0JyAmJiB3YWxsZXREYXRhLndhbGxldHMpIHtcbiAgICAgICAgLy8gTmV3IGZvcm1hdCAtIHdhbGxldHMgb3JnYW5pemVkIGJ5IHdhbGxldCB0eXBlXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmluZCB0aGUgd2FsbGV0IHR5cGUgdGhhdCBtaWdodCBjb250YWluIHRoaXMgYWRkcmVzc1xuICAgICAgICBPYmplY3Qua2V5cyh3YWxsZXREYXRhLndhbGxldHMpLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkod2FsbGV0RGF0YS53YWxsZXRzW3R5cGVdKSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIG1hdGNoaW5nIHdhbGxldCBvYmplY3RzIG9yIGFkZHJlc3Nlc1xuICAgICAgICAgICAgd2FsbGV0RGF0YS53YWxsZXRzW3R5cGVdID0gd2FsbGV0RGF0YS53YWxsZXRzW3R5cGVdLmZpbHRlcih3YWxsZXQgPT4ge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdhbGxldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0LnRvTG93ZXJDYXNlKCkgIT09IG5vcm1hbGl6ZWRBZGRyZXNzO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdhbGxldCAmJiB0eXBlb2Ygd2FsbGV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldEFkZHIgPSAod2FsbGV0LmFkZHJlc3MgfHwgd2FsbGV0LmZ1bGxBZGRyZXNzIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhKHdhbGxldEFkZHIgPT09IG5vcm1hbGl6ZWRBZGRyZXNzIHx8IFxuICAgICAgICAgICAgICAgICAgKHdhbGxldC50eXBlID09PSB3YWxsZXRUeXBlICYmIHdhbGxldEFkZHIgPT09IG5vcm1hbGl6ZWRBZGRyZXNzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dhbGxldERhdGEnLCBKU09OLnN0cmluZ2lmeSh3YWxsZXREYXRhKSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIG90aGVyIHdhbGxldC1yZWxhdGVkIGxvY2FsU3RvcmFnZSBmbGFncyB0byBwcmV2ZW50IGF1dG8tcmVjb25uZWN0XG4gICAgaWYgKHdhbGxldFR5cGUgPT09ICdtZXRhbWFzaycgfHwgd2FsbGV0VHlwZSA9PT0gJ2V2bScpIHtcbiAgICAgIC8vIENsZWFyIHdhZ21pIGNvbm5lY3Rpb24gZGF0YSB0byBwcmV2ZW50IGF1dG8tcmVjb25uZWN0XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2FnbWkuY29ubmVjdGVkJyk7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2FnbWkuY29ubmVjdG9ycycpO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dhZ21pLmluamVjdGVkLnNoaW1EaXNjb25uZWN0Jyk7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2FnbWkuc3RvcmUnKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3YWdtaS53YWxsZXQnKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIHRoZSB1c2VySW5pdGlhdGVkQ29ubmVjdGlvbiBmbGFnIHRvIHByZXZlbnQgcmUtc2Nhbm5pbmdcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1c2VySW5pdGlhdGVkQ29ubmVjdGlvbicpO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgTWV0YU1hc2stc3BlY2lmaWMgbG9jYWwgc3RvcmFnZSBkYXRhXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnV0FMTEVUQ09OTkVDVF9ERUVQTElOS19DSE9JQ0UnKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdtZXRhbWFzay1kaXNjb25uZWN0ZWQnKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IGZsYWcgdG8gaW5kaWNhdGUgdXNlciBoYXMgZXhwbGljaXRseSBkaXNjb25uZWN0ZWQgd2FsbGV0c1xuICAgICAgLy8gVGhpcyBwcmV2ZW50cyBhdXRvLXJlY29ubmVjdGlvbiBvbiBwYWdlIHJlZnJlc2hcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyX2Rpc2Nvbm5lY3RlZF93YWxsZXRzJywgJ3RydWUnKTtcbiAgICB9IGVsc2UgaWYgKHdhbGxldFR5cGUgPT09ICdwaGFudG9tJyB8fCB3YWxsZXRUeXBlID09PSAnc29sYW5hJykge1xuICAgICAgLy8gUmVtb3ZlIFBoYW50b20tc3BlY2lmaWMgc3RvcmFnZVxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3BoYW50b21EaXNjb3ZlcmVkV2FsbGV0cycpO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3BoYW50b21XYWxsZXRTdGF0ZScpO1xuICAgICAgXG4gICAgICAvLyBTZXQgZGlzY29ubmVjdGlvbiBmbGFnIGZvciBTb2xhbmEgd2FsbGV0cyB0b29cbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyX2Rpc2Nvbm5lY3RlZF93YWxsZXRzJywgJ3RydWUnKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYERpc2Nvbm5lY3RlZCB3YWxsZXQ6ICR7d2FsbGV0VHlwZX0gLSAke2FkZHJlc3N9YCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZW5oYW5jZWRFcnJvciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSB3YWxsZXQgZGF0YTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIGVuaGFuY2VkRXJyb3Iub3JpZ2luYWxFcnJvciA9IGVycm9yO1xuICAgIGVuaGFuY2VkRXJyb3Iud2FsbGV0VHlwZSA9IHdhbGxldFR5cGU7XG4gICAgZW5oYW5jZWRFcnJvci5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aHJvdyBlbmhhbmNlZEVycm9yO1xuICB9XG59XG5cbi8qKlxuICogU2NhbiBmb3IgYXNzZXRzIGFjcm9zcyBtdWx0aXBsZSBibG9ja2NoYWluc1xuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBBcnJheSBvZiBmb3VuZCBhc3NldHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzY2FubmluZyBmYWlsc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2Nhbk11bHRpQ2hhaW5Bc3NldHMoKSB7XG4gIHRocm93IG5ldyBFcnJvcignc2Nhbk11bHRpQ2hhaW5Bc3NldHMgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkJyk7XG59XG5cbi8qKlxuICogQ29udmVydCBjcnlwdG9jdXJyZW5jeSBhc3NldCB2YWx1ZXMgdG8gVVNEXG4gKiBAcGFyYW0ge09iamVjdH0gYXNzZXRzIC0gQXNzZXRzIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFVTRCB2YWx1ZXMgZm9yIGFzc2V0c1xuICogQHRocm93cyB7RXJyb3J9IElmIGNvbnZlcnNpb24gZmFpbHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRBc3NldHNUb1VTRChhc3NldHMpIHtcbiAgaWYgKCFhc3NldHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fzc2V0cyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBcbiAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0QXNzZXRzVG9VU0QgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkJyk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBwcm9vZiBoYXNoIGZvciB2ZXJpZmljYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBHZW5lcmF0ZWQgaGFzaFxuICogQHRocm93cyB7RXJyb3J9IElmIGhhc2ggZ2VuZXJhdGlvbiBmYWlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQcm9vZkhhc2goZGF0YSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgXG4gIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGVQcm9vZkhhc2ggZnVuY3Rpb24gbm90IGltcGxlbWVudGVkJyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgTWV0YU1hc2sgaXMgYXZhaWxhYmxlIGFuZCB3b3JraW5nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gdHJ1ZSBpZiBNZXRhTWFzayBpcyBhdmFpbGFibGUgYW5kIHJlc3BvbmRpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzTWV0YU1hc2tBdmFpbGFibGUoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgLy8gQ2hlY2sgZm9yIGV0aGVyZXVtIG9iamVjdFxuICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgLy8gRmluZCB0aGUgTWV0YU1hc2sgcHJvdmlkZXIgaWYgd2UgaGF2ZSBtdWx0aXBsZSBwcm92aWRlcnNcbiAgbGV0IHByb3ZpZGVyID0gd2luZG93LmV0aGVyZXVtO1xuICBpZiAod2luZG93LmV0aGVyZXVtLnByb3ZpZGVycykge1xuICAgIGNvbnN0IG1ldGFNYXNrUHJvdmlkZXIgPSB3aW5kb3cuZXRoZXJldW0ucHJvdmlkZXJzLmZpbmQocCA9PiBwLmlzTWV0YU1hc2spO1xuICAgIGlmIChtZXRhTWFza1Byb3ZpZGVyKSB7XG4gICAgICBwcm92aWRlciA9IG1ldGFNYXNrUHJvdmlkZXI7XG4gICAgfSBlbHNlIGlmICghd2luZG93LmV0aGVyZXVtLmlzTWV0YU1hc2spIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gTWV0YU1hc2sgcHJvdmlkZXIgZm91bmRcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXdpbmRvdy5ldGhlcmV1bS5pc01ldGFNYXNrKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBOb3QgTWV0YU1hc2tcbiAgfVxuICBcbiAgLy8gVGVzdCBpZiB0aGUgcHJvdmlkZXIgaXMgcmVzcG9uZGluZ1xuICB0cnkge1xuICAgIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybignTWV0YU1hc2sgaGVhbHRoIGNoZWNrIGZhaWxlZDonLCBlcnIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgdGVtcG9yYXJ5IHdhbGxldCBmb3IgcHJvb2Ygc3VibWlzc2lvblxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGVtcG9yYXJ5IHdhbGxldFxuICogQHRocm93cyB7RXJyb3J9IElmIHdhbGxldCBnZW5lcmF0aW9uIGZhaWxzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRlbXBvcmFyeVdhbGxldCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0ZVRlbXBvcmFyeVdhbGxldCBmdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQnKTtcbn0iXSwibmFtZXMiOlsiZ2V0Q29ubmVjdGVkV2FsbGV0cyIsImxvY2FsU3RvcmFnZSIsIndhbGxldERhdGEiLCJnZXRJdGVtIiwicGFyc2VkRGF0YSIsIkpTT04iLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsIndhbGxldHMiLCJyZXN1bHQiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsIndhbGxldFR5cGUiLCJ0eXBlV2FsbGV0cyIsIndhbGxldCIsImFkZHJlc3MiLCJkaXNwbGF5QWRkcmVzcyIsImxlbmd0aCIsInN1YnN0cmluZyIsInB1c2giLCJpZCIsImZ1bGxBZGRyZXNzIiwidHlwZSIsIm5hbWUiLCJjaGFpbiIsImNvbm5lY3RlZCIsImVycm9yIiwiY29uc29sZSIsInNhdmVXYWxsZXRDb25uZWN0aW9uIiwiYWNjb3VudHMiLCJFcnJvciIsImFjY291bnRzQXJyYXkiLCJzdG9yZWREYXRhIiwiZSIsIndhcm4iLCJhY2NvdW50IiwiYWNjb3VudFN0ciIsInB1YmxpY0tleSIsInRvU3RyaW5nIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJleGlzdGluZ0luZGV4IiwiZmluZEluZGV4IiwidW5pcXVlSWQiLCJ3YWxsZXRPYmoiLCJjb25uZWN0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInRpbWVzdGFtcCIsIm5vdyIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJsb2ciLCJlbmhhbmNlZEVycm9yIiwibWVzc2FnZSIsIm9yaWdpbmFsRXJyb3IiLCJjb25uZWN0TWV0YU1hc2siLCJ3aW5kb3ciLCJpc1NhZmFyaSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc01vYmlsZSIsImhhc0V0aGVyZXVtIiwiZXRoZXJldW0iLCJpc01ldGFNYXNrIiwiaGFzUHJvdmlkZXJzIiwicHJvdmlkZXJzIiwicHJvdmlkZXJDb3VudCIsInByb3ZpZGVyIiwibWV0YU1hc2tQcm92aWRlciIsImZpbmQiLCJwIiwiaXNDb25uZWN0ZWQiLCJkaXNjb25uZWN0IiwiZGlzY29ubmVjdEVycm9yIiwicmVxdWVzdCIsIm1ldGhvZCIsInBhcmFtcyIsImV0aF9hY2NvdW50cyIsInBlcm1FcnJvciIsInByZUNvbm5lY3RFcnIiLCJyZXF1ZXN0QWNjb3VudHNPcHRpb25zIiwiZm9yY2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjaGFpbklkSGV4IiwiY2hhaW5JZCIsInBhcnNlSW50IiwiY2hhaW5OYW1lIiwiY2hhaW5NYXAiLCJjb2RlIiwiaW5jbHVkZXMiLCJkaXNjb25uZWN0V2FsbGV0Iiwid2FnbWlEaXNjb25uZWN0Iiwic29sYW5hIiwid2FsbGV0RGF0YVN0ciIsInVwZGF0ZWRXYWxsZXRzIiwiZmlsdGVyIiwibm9ybWFsaXplZEFkZHJlc3MiLCJ3YWxsZXRBZGRyIiwicmVtb3ZlSXRlbSIsInNjYW5NdWx0aUNoYWluQXNzZXRzIiwiY29udmVydEFzc2V0c1RvVVNEIiwiYXNzZXRzIiwiZ2VuZXJhdGVQcm9vZkhhc2giLCJkYXRhIiwiaXNNZXRhTWFza0F2YWlsYWJsZSIsImVyciIsImdlbmVyYXRlVGVtcG9yYXJ5V2FsbGV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../common/dist/utils/walletHelpers.js\n"));

/***/ })

});