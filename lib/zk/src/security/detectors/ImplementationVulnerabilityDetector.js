/**
 * Implementation Vulnerability Detector
 * 
 * Identifies implementation-specific vulnerabilities in ZK proof systems such as:
 * - Logic errors in proof generation or validation
 * - Hard-coded test values that weren't removed
 * - Inadequate randomness sources
 * - Insufficient entropy in challenge generation
 * - Misuse of cryptographic primitives
 * - Platform-specific numeric handling issues
 */

import { RuleCategory, Severity } from '../AuditConfig.js';
import path from 'path';

/**
 * Detector for implementation-specific vulnerabilities
 */
export class ImplementationVulnerabilityDetector {
    /**
     * Constructor initializes the detector with default configuration
     * @param {Object} options - Configuration options
     * @param {boolean} [options.enabled=true] - Whether the detector is enabled
     * @param {Severity} [options.severity=Severity.HIGH] - Severity level of findings
     */
    constructor(options = {}) {
        this.id = 'implementation-vulnerability';
        this.name = 'Implementation Vulnerability Detector';
        this.description = 'Detects implementation-specific vulnerabilities in ZK proof systems';
        this.category = RuleCategory.IMPLEMENTATION;
        this.severity = options.severity || Severity.HIGH;
        this.enabled = options.enabled !== undefined ? options.enabled : true;

        // Define patterns to search for
        this.patterns = {
            hardcodedValues: /const\s+(?:secret|private|key|seed)\w*\s*=\s*['"`][0-9a-fA-F]{16,}['"`]/g,
            weakRandomness: /Math\.random\(\)/g,
            fixmeTodos: /(?:FIXME|TODO).*(?:randomness|entropy|security|vulnerability)/gi,
            debugMode: /(?:DEBUG_MODE|TESTING_MODE|BYPASS_CHECKS)\s*=[^=]\s*true/g,
            testingShortcuts: /\/\/\s*(?:skip|bypass)\s*(?:verification|validation|checks)/gi,
            unsafeTypeConversions: /(?:BigInt|Number|parseInt)\s*\(\s*(?:user|input|external|untrusted)/g,
            directMemoryAccess: /(?:Buffer|ArrayBuffer|Uint8Array)\.from\s*\(\s*(?:user|input|external|untrusted)/g,
            precisionIssues: /(?:\.toFixed\(|\.toPrecision\()/g,
            insecureHashFunctions: /(?:createHash|crypto\.createHash)\s*\(\s*['"`](?:md5|sha1)['"`]/g,
            nonConstantTimeComparison: /(?!crypto\.timingSafeEqual)(?:\w+\.equals?\(|\w+\s*===\s*|\w+\s*!==\s*|\w+\s*==\s*|\w+\s*!=\s*)(?:hash|signature|mac|tag|proof)/g
        };
    }

    /**
     * Evaluates a file for implementation vulnerabilities
     * @param {string} filePath - Path to the file
     * @param {string} content - File content
     * @returns {Array} - Array of findings
     */
    evaluate(filePath, content) {
        if (!this.isRelevantFile(filePath)) {
            return [];
        }

        const findings = [];
        const fileName = path.basename(filePath);

        // Check for each pattern
        for (const [key, pattern] of Object.entries(this.patterns)) {
            let match;
            while ((match = pattern.exec(content)) !== null) {
                // Avoid duplicate findings for the same issue
                if (!this.hasProtectiveMeasuresNearby(content, match.index)) {
                    const lineNumber = this.getLineNumber(content, match.index);
                    const lineContent = this.getLineContent(content, lineNumber);

                    findings.push({
                        id: `${this.id}-${key}-${findings.length + 1}`,
                        description: this.getDescriptionForPattern(key),
                        severity: this.getSeverityForPattern(key),
                        location: {
                            file: filePath,
                            line: lineNumber,
                            column: this.getColumnNumber(content, match.index, lineNumber)
                        },
                        evidence: match[0],
                        context: lineContent,
                        remediation: this.getRemediationForPattern(key)
                    });
                }
            }
        }

        // Advanced checks that can't be done with simple regex
        this.checkForAdvancedIssues(filePath, content, findings);

        return findings;
    }

    /**
     * Determines if a file is relevant for implementation vulnerability checks
     * @param {string} filePath - Path to the file
     * @returns {boolean} - Whether the file should be scanned
     */
    isRelevantFile(filePath) {
        const relevantExtensions = ['.js', '.mjs', '.cjs', '.ts', '.jsx', '.tsx'];
        const relevantPatterns = [
            /proof/i,
            /zkp/i,
            /verify/i,
            /crypto/i,
            /hash/i,
            /random/i,
            /generator/i,
            /commitment/i
        ];

        const ext = path.extname(filePath);
        const fileName = path.basename(filePath);

        if (!relevantExtensions.includes(ext)) {
            return false;
        }

        // Files matching relevant patterns are of high interest
        for (const pattern of relevantPatterns) {
            if (pattern.test(fileName)) {
                return true;
            }
        }

        // For other files, we need to check the content
        // This will be done in the evaluate method
        return true;
    }

    /**
     * Checks if there are protective measures near a matched pattern
     * @param {string} content - File content
     * @param {number} index - Match index
     * @returns {boolean} - Whether protective measures exist
     */
    hasProtectiveMeasuresNearby(content, index) {
        // Get context (100 characters before and after)
        const start = Math.max(0, index - 100);
        const end = Math.min(content.length, index + 100);
        const context = content.substring(start, end);

        // Protective patterns
        const protectivePatterns = [
            /\/\/\s*Security\s*:\s*(?:validated|checked|safe)/i,
            /\/\*\s*Security\s*:\s*(?:validated|checked|safe)/i,
            /verifySecurely/i,
            /safeImplementation/i,
            /secureOperation/i,
            /validatedInput/i
        ];

        for (const pattern of protectivePatterns) {
            if (pattern.test(context)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check for advanced implementation issues
     * @param {string} filePath - Path to the file
     * @param {string} content - File content
     * @param {Array} findings - Array to add findings to
     */
    checkForAdvancedIssues(filePath, content, findings) {
        // Check for inconsistent error handling
        this.checkInconsistentErrorHandling(filePath, content, findings);

        // Check for unused security features
        this.checkUnusedSecurityFeatures(filePath, content, findings);

        // Check for inconsistent validation
        this.checkInconsistentValidation(filePath, content, findings);

        // Check for timing side-channels
        this.checkForTimingSideChannels(filePath, content, findings);
    }

    /**
     * Check for inconsistent error handling
     * @param {string} filePath - Path to the file
     * @param {string} content - File content
     * @param {Array} findings - Array to add findings to
     */
    checkInconsistentErrorHandling(filePath, content, findings) {
        const functionBlocks = this.extractFunctionBlocks(content);

        for (const { name, body, start } of functionBlocks) {
            if (/(?:verify|validate|check|assert)/i.test(name)) {
                // Check if some paths throw errors while others return false
                const throwsErrors = /throw\s+new\s+Error/i.test(body);
                const returnsFalse = /return\s+false/i.test(body);

                if (throwsErrors && returnsFalse) {
                    const lineNumber = this.getLineNumber(content, start);
                    findings.push({
                        id: `${this.id}-inconsistent-error-${findings.length + 1}`,
                        description: 'Inconsistent error handling in verification function',
                        severity: Severity.MEDIUM,
                        location: {
                            file: filePath,
                            line: lineNumber
                        },
                        evidence: `Function ${name} uses both error throwing and false returns`,
                        context: this.getLineContent(content, lineNumber),
                        remediation: 'Standardize error handling approach. Either throw errors consistently or return status values consistently.'
                    });
                }
            }
        }
    }

    /**
     * Check for unused security features
     * @param {string} filePath - Path to the file
     * @param {string} content - File content
     * @param {Array} findings - Array to add findings to
     */
    checkUnusedSecurityFeatures(filePath, content, findings) {
        const securityFeatures = [
            { regex: /function\s+generateNonce/i, usage: /nonce/i },
            { regex: /function\s+validateChallenge/i, usage: /validateChallenge\s*\(/i },
            { regex: /function\s+verifyIntegrity/i, usage: /verifyIntegrity\s*\(/i }
        ];

        for (const { regex, usage } of securityFeatures) {
            const funcMatch = regex.exec(content);
            if (funcMatch && !usage.test(content.substring(funcMatch.index + funcMatch[0].length))) {
                const lineNumber = this.getLineNumber(content, funcMatch.index);
                findings.push({
                    id: `${this.id}-unused-security-${findings.length + 1}`,
                    description: 'Defined security feature is never used',
                    severity: Severity.MEDIUM,
                    location: {
                        file: filePath,
                        line: lineNumber
                    },
                    evidence: funcMatch[0],
                    context: this.getLineContent(content, lineNumber),
                    remediation: 'Either use the security feature or remove it if not needed.'
                });
            }
        }
    }

    /**
     * Check for inconsistent validation
     * @param {string} filePath - Path to the file
     * @param {string} content - File content
     * @param {Array} findings - Array to add findings to
     */
    checkInconsistentValidation(filePath, content, findings) {
        const functionBlocks = this.extractFunctionBlocks(content);
        const validationFunctions = functionBlocks.filter(f =>
            /(?:validate|verify|check)/i.test(f.name));

        const validationPatterns = [
            /typeof\s+\w+\s*===\s*['"](?:string|number|object)['"]/,
            /\w+\s+instanceof\s+\w+/,
            /\w+\s*\.\s*length\s*[<>=]/
        ];

        for (const { name, body, start } of validationFunctions) {
            const matches = validationPatterns.map(pattern => pattern.test(body));

            if (matches.some(Boolean) && !matches.every(Boolean)) {
                const lineNumber = this.getLineNumber(content, start);
                findings.push({
                    id: `${this.id}-inconsistent-validation-${findings.length + 1}`,
                    description: 'Inconsistent validation patterns across the function',
                    severity: Severity.MEDIUM,
                    location: {
                        file: filePath,
                        line: lineNumber
                    },
                    evidence: `Function ${name} has inconsistent validation patterns`,
                    context: this.getLineContent(content, lineNumber),
                    remediation: 'Apply consistent input validation patterns throughout the function.'
                });
            }
        }
    }

    /**
     * Check for potential timing side-channels
     * @param {string} filePath - Path to the file
     * @param {string} content - File content
     * @param {Array} findings - Array to add findings to
     */
    checkForTimingSideChannels(filePath, content, findings) {
        const functionBlocks = this.extractFunctionBlocks(content);

        for (const { name, body, start } of functionBlocks) {
            if (/(?:verify|validate|compare)/i.test(name)) {
                // Check for early returns in comparison functions
                const earlyReturnMatches = [...body.matchAll(/return\s+(?:true|false)/g)];

                if (earlyReturnMatches.length > 1) {
                    const lineNumber = this.getLineNumber(content, start);
                    findings.push({
                        id: `${this.id}-timing-side-channel-${findings.length + 1}`,
                        description: 'Potential timing side-channel in verification function',
                        severity: Severity.HIGH,
                        location: {
                            file: filePath,
                            line: lineNumber
                        },
                        evidence: `Function ${name} contains early returns that may create timing side-channels`,
                        context: this.getLineContent(content, lineNumber),
                        remediation: 'Use constant-time comparison functions like crypto.timingSafeEqual() or redesign the function to have constant execution time.'
                    });
                }
            }
        }
    }

    /**
     * Extract function blocks from content
     * @param {string} content - File content
     * @returns {Array} - Array of function blocks with name, body and start index
     */
    extractFunctionBlocks(content) {
        const functionBlocks = [];
        // Match various function declaration formats
        const functionPattern = /(?:function\s+(\w+)|const\s+(\w+)\s*=\s*(?:function|\([^)]*\)\s*=>)|(?:class|export)\s+(?:default\s+)?class\s+\w+\s*{[^}]*?(?:\s+|\t+)(\w+)\s*\([^)]*\)\s*{)/g;

        let match;
        while ((match = functionPattern.exec(content)) !== null) {
            const functionName = match[1] || match[2] || match[3] || 'anonymous';
            const startPos = match.index;

            // Find the end of the function body
            let braceCount = 0;
            let endPos = startPos;

            for (let i = startPos; i < content.length; i++) {
                if (content[i] === '{') {
                    braceCount++;
                } else if (content[i] === '}') {
                    braceCount--;
                    if (braceCount === 0) {
                        endPos = i + 1;
                        break;
                    }
                }
            }

            if (endPos > startPos) {
                const body = content.substring(startPos, endPos);
                functionBlocks.push({
                    name: functionName,
                    body,
                    start: startPos,
                    end: endPos
                });
            }
        }

        return functionBlocks;
    }

    /**
     * Get description for a specific pattern
     * @param {string} patternKey - Key of the pattern
     * @returns {string} - Description
     */
    getDescriptionForPattern(patternKey) {
        const descriptions = {
            hardcodedValues: 'Hard-coded cryptographic values detected',
            weakRandomness: 'Weak randomness source (Math.random()) detected',
            fixmeTodos: 'FIXME/TODO comments related to security issues',
            debugMode: 'Debug or testing mode flags may bypass security checks',
            testingShortcuts: 'Comments suggest verification checks are being bypassed',
            unsafeTypeConversions: 'Unsafe type conversions on untrusted input',
            directMemoryAccess: 'Direct memory access with untrusted input',
            precisionIssues: 'Potential precision issues in numeric operations',
            insecureHashFunctions: 'Insecure hash functions (MD5, SHA1) in use',
            nonConstantTimeComparison: 'Non-constant time comparison of sensitive values'
        };

        return descriptions[patternKey] || 'Implementation vulnerability detected';
    }

    /**
     * Get severity for a specific pattern
     * @param {string} patternKey - Key of the pattern
     * @returns {Severity} - Severity level
     */
    getSeverityForPattern(patternKey) {
        const severities = {
            hardcodedValues: Severity.HIGH,
            weakRandomness: Severity.HIGH,
            insecureHashFunctions: Severity.HIGH,
            nonConstantTimeComparison: Severity.HIGH,
            debugMode: Severity.HIGH,
            testingShortcuts: Severity.MEDIUM,
            unsafeTypeConversions: Severity.MEDIUM,
            directMemoryAccess: Severity.MEDIUM,
            precisionIssues: Severity.MEDIUM,
            fixmeTodos: Severity.LOW
        };

        return severities[patternKey] || this.severity;
    }

    /**
     * Get remediation advice for a specific pattern
     * @param {string} patternKey - Key of the pattern
     * @returns {string} - Remediation advice
     */
    getRemediationForPattern(patternKey) {
        const remediations = {
            hardcodedValues: 'Replace hard-coded values with values generated at runtime or stored securely in a configuration system.',
            weakRandomness: 'Replace Math.random() with cryptographically secure random number generation (e.g., crypto.randomBytes()).',
            fixmeTodos: 'Address the documented security concerns in the FIXME/TODO comments.',
            debugMode: 'Ensure debug/testing flags are disabled in production or remove them entirely.',
            testingShortcuts: 'Remove testing shortcuts that bypass verification checks.',
            unsafeTypeConversions: 'Validate and sanitize input before type conversion to prevent unexpected behavior.',
            directMemoryAccess: 'Validate and sanitize input before accessing memory to prevent buffer manipulation.',
            precisionIssues: 'Use appropriate numeric types (BigInt for large integers) and handle precision carefully.',
            insecureHashFunctions: 'Replace insecure hash functions with more secure alternatives (SHA-256, SHA-3).',
            nonConstantTimeComparison: 'Use constant-time comparison functions (crypto.timingSafeEqual()) to prevent timing attacks.'
        };

        return remediations[patternKey] || 'Review and fix the implementation vulnerability.';
    }

    /**
     * Get the line number for a position in the content
     * @param {string} content - File content
     * @param {number} position - Position in content
     * @returns {number} - Line number (1-based)
     */
    getLineNumber(content, position) {
        const lines = content.substring(0, position).split('\n');
        return lines.length;
    }

    /**
     * Get the column number for a position in the content
     * @param {string} content - File content
     * @param {number} position - Position in content
     * @param {number} lineNumber - Line number (1-based)
     * @returns {number} - Column number (1-based)
     */
    getColumnNumber(content, position, lineNumber) {
        const lines = content.substring(0, position).split('\n');
        return position - content.lastIndexOf('\n', position);
    }

    /**
     * Get the content of a specific line
     * @param {string} content - File content
     * @param {number} lineNumber - Line number (1-based)
     * @returns {string} - Line content
     */
    getLineContent(content, lineNumber) {
        const lines = content.split('\n');
        return lines[lineNumber - 1] || '';
    }

    /**
     * Returns a serialization-friendly representation of the detector
     * @returns {Object} - Detector representation
     */
    toJSON() {
        return {
            id: this.id,
            name: this.name,
            description: this.description,
            category: this.category,
            severity: this.severity,
            enabled: this.enabled
        };
    }
}

export default ImplementationVulnerabilityDetector; 