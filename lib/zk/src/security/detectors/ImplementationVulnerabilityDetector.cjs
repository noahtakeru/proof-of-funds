/**
 * Implementation Vulnerability Detector module
 * 
 * This module detects potential vulnerabilities in the ZK proof implementation
 * that could be exploited by malicious actors.
 * 
 * @module ImplementationVulnerabilityDetector
 */

// Import SecurityDetector base class (commented to avoid actual import issues in compatibility layer)
// const { SecurityDetector } = require('./SecurityDetectorFactory.js');

/**
 * Implementation Vulnerability Detector class
 * @extends SecurityDetector
 */
class ImplementationVulnerabilityDetector {
  /**
   * Create a new implementation vulnerability detector
   */
  constructor() {
    this.type = 'ImplementationVulnerability';
    this.enabled = true;
  }

  /**
   * Enable this detector
   * @returns {ImplementationVulnerabilityDetector} - This detector instance for method chaining
   */
  enable() {
    this.enabled = true;
    return this;
  }

  /**
   * Disable this detector
   * @returns {ImplementationVulnerabilityDetector} - This detector instance for method chaining
   */
  disable() {
    this.enabled = false;
    return this;
  }

  /**
   * Check if this detector is currently enabled
   * @returns {boolean} - Whether the detector is enabled
   */
  isEnabled() {
    return this.enabled;
  }

  /**
   * Check if a file is relevant for this detector
   * @param {Object} file - The file to check
   * @param {string} file.path - The file path
   * @param {string} file.content - The file content
   * @returns {boolean} True if the file is relevant for this detector
   */
  isRelevantFile(file) {
    if (!file || !file.path) return false;
    
    // Implementation vulnerability detector should focus on ZK implementation files
    const relevantPatterns = [
      /zkUtils/i,
      /circuit/i,
      /proof/i,
      /verify/i,
      /snark/i,
      /crypto/i,
      /security/i
    ];
    
    // Exclude test files
    const excludePatterns = [
      /\.test\./i,
      /\.spec\./i,
      /test\//i,
      /\/tests\//i
    ];
    
    const isRelevantMatch = relevantPatterns.some(pattern => pattern.test(file.path));
    const isExcluded = excludePatterns.some(pattern => pattern.test(file.path));
    
    return isRelevantMatch && !isExcluded;
  }
  
  /**
   * Check if the code has protective measures nearby potentially vulnerable code
   * @param {string} code - The code to analyze
   * @param {string} vulnerablePattern - Pattern identifying vulnerable code
   * @param {Array<RegExp>} protectivePatterns - Patterns that indicate protective measures
   * @param {number} contextSize - Number of lines to check for protective patterns
   * @returns {boolean} True if protective measures exist nearby
   */
  hasProtectiveMeasuresNearby(code, vulnerablePattern, protectivePatterns, contextSize = 10) {
    if (!code || typeof code !== 'string' || !vulnerablePattern || !protectivePatterns || !protectivePatterns.length) {
      return false;
    }
    
    // Find vulnerable code section
    const regex = new RegExp(vulnerablePattern, 'g');
    let match;
    
    while ((match = regex.exec(code)) !== null) {
      const matchPosition = match.index;
      
      // Establish context around the vulnerable code
      const startContext = Math.max(0, matchPosition - contextSize * 50); // ~50 chars per line
      const endContext = Math.min(code.length, matchPosition + match[0].length + contextSize * 50);
      const context = code.substring(startContext, endContext);
      
      // Check for protective patterns in context
      const hasProtection = protectivePatterns.some(pattern => pattern.test(context));
      
      if (!hasProtection) {
        return false;
      }
    }
    
    return true;
  }
  
  /**
   * Check for advanced implementation vulnerabilities
   * @param {string} code - The code to analyze
   * @returns {Array<Object>} - Detected vulnerabilities
   */
  checkForAdvancedIssues(code) {
    if (!code || typeof code !== 'string') {
      return [];
    }
    
    const issues = [];
    
    // Check for improper error handling in verification code
    const hasVerification = /verify\s*\(/i.test(code);
    const hasProperErrorHandling = /try\s*{[^}]*verify[^}]*}\s*catch/i.test(code);
    
    if (hasVerification && !hasProperErrorHandling) {
      issues.push({
        type: 'IMPROPER_ERROR_HANDLING',
        severity: 'HIGH',
        message: 'ZK verification without proper error handling',
        details: {
          recommendation: 'Wrap verification calls in try/catch blocks'
        }
      });
    }
    
    // Check for common ZK proof validation mistakes
    if (/verify\s*\([^)]*\)\s*===\s*true/i.test(code)) {
      issues.push({
        type: 'IMPROPER_VERIFICATION_CHECK',
        severity: 'HIGH',
        message: 'Improper verification check - ZK libraries may not return boolean true',
        details: {
          recommendation: 'Check library documentation for proper verification return values'
        }
      });
    }
    
    // Check for sufficient randomness in trusted setup
    if (/trusted\s*setup|ceremony/i.test(code) && 
        !/entropy|randomness|contributions/i.test(code)) {
      issues.push({
        type: 'INSUFFICIENT_RANDOMNESS',
        severity: 'MEDIUM',
        message: 'Trusted setup without explicit entropy/randomness considerations',
        details: {
          recommendation: 'Ensure multiple entropy sources in trusted setup ceremony'
        }
      });
    }
    
    // Check for timing attacks vectors
    if (/compare|verify|check/i.test(code) && 
        !/constant\s*time|timing\s*attack/i.test(code)) {
      const hasProtection = this.hasProtectiveMeasuresNearby(
        code, 
        'compare|verify|check', 
        [/crypto\.timingSafeEqual/, /constantTime/i],
        20
      );
      
      if (!hasProtection) {
        issues.push({
          type: 'TIMING_ATTACK_VECTOR',
          severity: 'MEDIUM',
          message: 'Potential timing attack vector in cryptographic verification',
          details: {
            recommendation: 'Use constant-time comparison functions'
          }
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Check for inconsistent error handling patterns in code
   * @param {string} code - The code to analyze
   * @returns {Array<Object>} - Detected issues
   */
  checkInconsistentErrorHandling(code) {
    if (!code || typeof code !== 'string') {
      return [];
    }
    
    const issues = [];
    
    // Check for inconsistent error handling patterns in verification code
    const verifyFunctionMatches = code.match(/function\s+\w+Verify\w*\s*\([^)]*\)\s*{[^}]*}/g) || [];
    let tryCatchCount = 0;
    
    for (const verifyFunction of verifyFunctionMatches) {
      if (/try\s*{[^}]*}\s*catch/.test(verifyFunction)) {
        tryCatchCount++;
      }
    }
    
    // If we have multiple verification functions with inconsistent error handling
    if (verifyFunctionMatches.length > 1 && tryCatchCount > 0 && tryCatchCount < verifyFunctionMatches.length) {
      issues.push({
        type: 'INCONSISTENT_ERROR_HANDLING',
        severity: 'MEDIUM',
        message: 'Inconsistent error handling in verification functions',
        details: {
          totalFunctions: verifyFunctionMatches.length,
          functionsWithTryCatch: tryCatchCount,
          recommendation: 'Ensure all verification functions have consistent error handling'
        }
      });
    }
    
    // Check for different error handling strategies within the same module
    const hasPromiseReject = /Promise\.reject\(|reject\(/i.test(code);
    const hasErrorEmit = /emit\(['"]error/i.test(code);
    const hasErrorCallback = /callback\(error|callback\(null,\s*error/i.test(code);
    const hasErrorThrow = /throw\s+new\s+Error/i.test(code);
    
    // Count the different error handling strategies
    const errorHandlingStyles = [
      hasPromiseReject, 
      hasErrorEmit, 
      hasErrorCallback, 
      hasErrorThrow
    ].filter(Boolean).length;
    
    if (errorHandlingStyles > 1) {
      issues.push({
        type: 'MIXED_ERROR_HANDLING_STYLES',
        severity: 'LOW',
        message: 'Mixed error handling styles within the same module',
        details: {
          recommendation: 'Standardize error handling approach for consistency'
        }
      });
    }
    
    return issues;
  }
  
  /**
   * Evaluate a file for implementation vulnerabilities
   * @param {Object} file - The file to evaluate
   * @param {string} file.path - The file path
   * @param {string} file.content - The file content
   * @returns {Array} An array of findings/issues identified
   */
  evaluate(file) {
    if (!file || !file.path || !file.content) {
      return [{
        detector: this.type,
        severity: 'MEDIUM',
        message: 'Invalid file object provided for evaluation',
        location: 'unknown'
      }];
    }

    if (!this.isRelevantFile(file)) {
      return [];
    }

    const findings = [];
    const content = file.content;

    // Check for use of unsafe cryptographic practices
    if (/Math\.random\(\)/.test(content)) {
      findings.push({
        detector: this.type,
        severity: 'HIGH',
        message: 'Using Math.random() for cryptographic purposes is insecure',
        location: file.path,
        details: {
          recommendation: 'Use crypto.getRandomValues() or a secure random number generator'
        }
      });
    }

    // Check for hardcoded verification keys/parameters
    if (/const\s+(verificationKey|circuit|vKey)\s*=\s*['"]/i.test(content)) {
      findings.push({
        detector: this.type,
        severity: 'HIGH',
        message: 'Hardcoded verification key or circuit parameters detected',
        location: file.path,
        details: {
          recommendation: 'Load verification keys from secure storage'
        }
      });
    }

    // Check for missing input validation
    if (/(verify|validate|check)\s*\(/i.test(content) && 
        !/(input|parameter)\s*validation/i.test(content)) {
      findings.push({
        detector: this.type,
        severity: 'MEDIUM',
        message: 'Possible missing input validation in verification function',
        location: file.path,
        details: {
          recommendation: 'Implement proper input validation before verification'
        }
      });
    }

    // Check for unsafe string concatenation in sensitive contexts
    if (/(proof|key|secret|credential|password|token).*\+\s*/.test(content)) {
      findings.push({
        detector: this.type,
        severity: 'MEDIUM',
        message: 'Unsafe string concatenation with sensitive data',
        location: file.path,
        details: {
          recommendation: 'Use a secure templating mechanism instead of direct concatenation'
        }
      });
    }

    return findings;
  }

  /**
   * Detect implementation vulnerabilities in ZK proof implementations
   * @param {Object} target - The target to check for vulnerabilities
   * @returns {Array<Object>} - List of detected vulnerabilities
   */
  detect(target) {
    const vulnerabilities = [];
    
    // Check for implementation vulnerabilities
    if (target && typeof target === 'object') {
      // Check for improper validation
      if (target.validate && typeof target.validate === 'function') {
        try {
          // Test validation with empty input
          const emptyValidation = target.validate({});
          if (emptyValidation === true) {
            vulnerabilities.push({
              type: 'VALIDATION_BYPASS',
              severity: 'HIGH',
              description: 'Validation function accepts empty input',
              mitigation: 'Add proper input validation'
            });
          }
        } catch (e) {
          // Expected to throw on invalid input
        }
      }
      
      // Check for insecure randomness sources
      if (target.generateRandomness && typeof target.generateRandomness === 'function') {
        try {
          const source = target.getRandomnessSource ? target.getRandomnessSource() : null;
          if (source === 'Math.random') {
            vulnerabilities.push({
              type: 'INSECURE_RANDOMNESS',
              severity: 'HIGH',
              description: 'Using insecure Math.random() for cryptographic randomness',
              mitigation: 'Use crypto.getRandomValues() instead'
            });
          }
        } catch (e) {
          // Cannot determine randomness source
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Get detector metadata
   * @returns {Object} - Detector metadata
   */
  getMetadata() {
    return {
      type: this.type,
      enabled: this.enabled
    };
  }
}

/**
 * Create and return a new ImplementationVulnerabilityDetector instance
 * @returns {ImplementationVulnerabilityDetector}
 */
function createImplementationVulnerabilityDetector() {
  return new ImplementationVulnerabilityDetector();
}

// Export for CommonJS
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    ImplementationVulnerabilityDetector,
    createImplementationVulnerabilityDetector
  };
}
