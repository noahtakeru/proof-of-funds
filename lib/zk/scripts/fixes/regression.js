/**
 * Regression test fixes utility
 * Extracted from direct-fix.js, complete-fix.js, and final-fix.js
 * 
 * Creates standalone, self-contained test files for regression tests
 * that don't rely on module format compatibility.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import logger from '../common/logger.js';

// Get dirname for ESM
const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * Test dependencies template for standalone tests
 */
const STANDALONE_TEST_DEPS = `
// Standalone test dependencies
const assert = require('assert');
const path = require('path');
const fs = require('fs');
`;

/**
 * Template for standalone regression test
 */
const STANDALONE_TEST_TEMPLATE = `/**
 * Standalone regression test
 * Automatically generated by regression.js
 * Original file: $ORIGINAL_FILE
 */

$IMPORTS

// Utility functions
function isObject(item) {
  return (item && typeof item === 'object' && !Array.isArray(item));
}

function deepMerge(target, ...sources) {
  if (!sources.length) return target;
  const source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, { [key]: {} });
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }

  return deepMerge(target, ...sources);
}

// Test implementation
$TEST_CONTENT

// Execute test if this file is run directly
if (require.main === module) {
  console.log('Running standalone regression test: $TEST_NAME');
  $TEST_RUNNER
}

// Export test for test runners
module.exports = {
  $EXPORTS
};
`;

/**
 * Self-contained test template with browser compatibility
 */
const SELF_CONTAINED_TEMPLATE = `/**
 * Self-contained test with browser compatibility
 * Automatically generated by regression.js
 * Original file: $ORIGINAL_FILE
 */

(function(global) {
  // Environment detection
  const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
  const isNode = typeof process !== 'undefined' && process.versions && process.versions.node;
  
  // Dependency handling
  let assert, fs, path;
  
  if (isNode) {
    // Node.js dependencies
    assert = require('assert');
    fs = require('fs');
    path = require('path');
  } else {
    // Browser polyfills
    assert = {
      strictEqual: function(actual, expected, message) {
        if (actual !== expected) {
          throw new Error(message || \`Expected \${expected} but got \${actual}\`);
        }
      },
      deepStrictEqual: function(actual, expected, message) {
        const actualStr = JSON.stringify(actual);
        const expectedStr = JSON.stringify(expected);
        if (actualStr !== expectedStr) {
          throw new Error(message || \`Expected \${expectedStr} but got \${actualStr}\`);
        }
      }
    };
    
    // Minimal file system simulation for browser
    fs = {
      readFileSync: function(path) {
        throw new Error('File system operations not supported in browser');
      },
      existsSync: function(path) {
        return false;
      }
    };
    
    path = {
      join: function() {
        return Array.prototype.join.call(arguments, '/').replace(/\\/+/g, '/');
      },
      resolve: function() {
        return Array.prototype.join.call(arguments, '/').replace(/\\/+/g, '/');
      }
    };
  }
  
  // Utility functions
  function isObject(item) {
    return (item && typeof item === 'object' && !Array.isArray(item));
  }
  
  function deepMerge(target, ...sources) {
    if (!sources.length) return target;
    const source = sources.shift();
  
    if (isObject(target) && isObject(source)) {
      for (const key in source) {
        if (isObject(source[key])) {
          if (!target[key]) Object.assign(target, { [key]: {} });
          deepMerge(target[key], source[key]);
        } else {
          Object.assign(target, { [key]: source[key] });
        }
      }
    }
  
    return deepMerge(target, ...sources);
  }
  
  // Test implementation
  $TEST_CONTENT
  
  // Execute test
  function runTest() {
    console.log('Running self-contained test: $TEST_NAME');
    try {
      $TEST_RUNNER
      console.log('Test passed!');
      return true;
    } catch (error) {
      console.error('Test failed:', error);
      return false;
    }
  }
  
  // Export or execute based on environment
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
      $EXPORTS
    };
    
    // Execute if run directly
    if (require.main === module) {
      runTest();
    }
  } else if (isBrowser) {
    // Browser execution - attach to global
    global.$GLOBAL_NAME = {
      $EXPORTS,
      runTest: runTest
    };
    
    // Auto-run if requested
    if (global.RUN_TESTS_AUTOMATICALLY) {
      runTest();
    }
  }
})(typeof window !== 'undefined' ? window : global);
`;

/**
 * Regression test fixer class
 */
export class RegressionTestFixer {
    /**
     * Create a new RegressionTestFixer
     * @param {Object} options - Options
     * @param {boolean} options.verbose - Enable verbose logging
     * @param {boolean} options.dryRun - Don't actually modify files
     * @param {boolean} options.backup - Create backups of modified files
     * @param {string} options.outputDir - Output directory for new test files
     * @param {boolean} options.standalone - Create standalone test files
     * @param {boolean} options.selfContained - Create self-contained browser-compatible tests
     * @param {string[]} options.ignoreDirs - Directories to ignore
     */
    constructor(options = {}) {
        this.verbose = options.verbose || false;
        this.dryRun = options.dryRun || false;
        this.backup = options.backup !== false;
        this.outputDir = options.outputDir || '';
        this.standalone = options.standalone !== false;
        this.selfContained = options.selfContained || false;
        this.ignoreDirs = options.ignoreDirs || ['node_modules', 'dist', 'build', '.git'];

        // Configure logger
        this.logger = this.verbose ? logger : {
            info: () => { },
            debug: () => { },
            warn: logger.warn,
            error: logger.error
        };
    }

    /**
     * Create a backup of a file
     * @param {string} filePath - File path
     * @returns {boolean} True if backup was created or not needed
     */
    createBackup(filePath) {
        if (!this.backup || this.dryRun) return true;

        try {
            const backupPath = `${filePath}.bak`;
            fs.copyFileSync(filePath, backupPath);
            this.logger.debug(`Created backup: ${backupPath}`);
            return true;
        } catch (error) {
            this.logger.error(`Failed to create backup for ${filePath}:`, error.message);
            return false;
        }
    }

    /**
     * Extract import statements from test file
     * @param {string} content - File content
     * @returns {Object} Import information
     */
    extractImports(content) {
        const imports = {
            requireStatements: [],
            importStatements: [],
            dependencies: []
        };

        // Extract require statements
        const requireRegex = /\brequire\s*\(\s*['"](.*?)['"]\s*\)/g;
        const requireMatches = content.matchAll(requireRegex);

        for (const match of requireMatches) {
            imports.requireStatements.push(match[0]);
            imports.dependencies.push(match[1]);
        }

        // Extract import statements
        const importRegex = /\bimport\s+.*?\s+from\s+['"](.*?)['"]/g;
        const importMatches = content.matchAll(importRegex);

        for (const match of importMatches) {
            imports.importStatements.push(match[0]);
            imports.dependencies.push(match[1]);
        }

        return imports;
    }

    /**
     * Extract test functions from content
     * @param {string} content - File content
     * @returns {Object} Test functions
     */
    extractTestFunctions(content) {
        const tests = {
            functions: [],
            describe: [],
            it: [],
            hasRunner: false
        };

        // Extract describe blocks
        const describeRegex = /\bdescribe\s*\(\s*['"]([^'"]*)['"]/g;
        const describeMatches = content.matchAll(describeRegex);

        for (const match of describeMatches) {
            tests.describe.push(match[1]);
        }

        // Extract it blocks
        const itRegex = /\bit\s*\(\s*['"]([^'"]*)['"]/g;
        const itMatches = content.matchAll(itRegex);

        for (const match of itMatches) {
            tests.it.push(match[1]);
        }

        // Extract function declarations
        const functionRegex = /\bfunction\s+(\w+)\s*\(/g;
        const functionMatches = content.matchAll(functionRegex);

        for (const match of functionMatches) {
            tests.functions.push(match[1]);
        }

        // Check if file has a test runner
        tests.hasRunner = content.includes('describe(') || content.includes('it(') ||
            content.includes('test(') || content.includes('assert.');

        return tests;
    }

    /**
     * Create a standalone test file from the original
     * @param {string} filePath - Original test file path
     * @param {string} outputPath - Output file path (optional)
     * @returns {boolean} True if successful
     */
    createStandaloneTest(filePath, outputPath) {
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const fileName = path.basename(filePath);

            // Generate output path if not provided
            if (!outputPath) {
                const dir = this.outputDir || path.dirname(filePath);
                const baseName = path.basename(filePath, path.extname(filePath));
                outputPath = path.join(dir, `${baseName}.standalone.js`);
            }

            // Extract imports and test functions
            const imports = this.extractImports(content);
            const tests = this.extractTestFunctions(content);

            // Create export list from found functions
            const exportList = tests.functions
                .filter(fn => !['describe', 'it', 'beforeEach', 'afterEach'].includes(fn))
                .map(fn => `${fn}: ${fn}`)
                .join(',\n  ');

            // Determine test runner code
            let testRunner = '';

            if (tests.describe.length > 0) {
                // Mocha-style tests
                testRunner = 'runTests();';
            } else if (tests.functions.length > 0 && tests.functions.includes('main')) {
                // Main function
                testRunner = 'main();';
            } else if (tests.functions.length > 0 && tests.functions.includes('test')) {
                // Test function
                testRunner = 'test();';
            } else if (tests.functions.length > 0) {
                // Use first function as runner
                testRunner = `${tests.functions[0]}();`;
            } else {
                // No functions found, run the script as is
                testRunner = '// No explicit test runner function found';
            }

            // Create test name
            const testName = tests.describe[0] || path.basename(filePath, path.extname(filePath));

            // Generate standalone test
            const standaloneContent = STANDALONE_TEST_TEMPLATE
                .replace('$ORIGINAL_FILE', filePath)
                .replace('$IMPORTS', STANDALONE_TEST_DEPS)
                .replace('$TEST_CONTENT', content)
                .replace(/\$TEST_NAME/g, testName)
                .replace('$TEST_RUNNER', testRunner)
                .replace('$EXPORTS', exportList || 'test: runTest');

            if (!this.dryRun) {
                // Create output directory if it doesn't exist
                const outputDir = path.dirname(outputPath);
                if (!fs.existsSync(outputDir)) {
                    fs.mkdirSync(outputDir, { recursive: true });
                }

                // Write the new file
                fs.writeFileSync(outputPath, standaloneContent, 'utf8');
                this.logger.info(`Created standalone test file: ${outputPath}`);
            } else {
                this.logger.info(`[DRY RUN] Would create standalone test file: ${outputPath}`);
            }

            return true;
        } catch (error) {
            this.logger.error(`Error creating standalone test for ${filePath}:`, error.message);
            return false;
        }
    }

    /**
     * Create a self-contained browser-compatible test
     * @param {string} filePath - Original test file path
     * @param {string} outputPath - Output file path (optional)
     * @returns {boolean} True if successful
     */
    createSelfContainedTest(filePath, outputPath) {
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const fileName = path.basename(filePath);

            // Generate output path if not provided
            if (!outputPath) {
                const dir = this.outputDir || path.dirname(filePath);
                const baseName = path.basename(filePath, path.extname(filePath));
                outputPath = path.join(dir, `${baseName}.self-contained.js`);
            }

            // Extract imports and test functions
            const imports = this.extractImports(content);
            const tests = this.extractTestFunctions(content);

            // Create export list from found functions
            const exportList = tests.functions
                .filter(fn => !['describe', 'it', 'beforeEach', 'afterEach'].includes(fn))
                .map(fn => `${fn}: ${fn}`)
                .join(',\n    ');

            // Determine test runner code
            let testRunner = '';

            if (tests.describe.length > 0) {
                // Mocha-style tests
                testRunner = 'runTests();';
            } else if (tests.functions.length > 0 && tests.functions.includes('main')) {
                // Main function
                testRunner = 'main();';
            } else if (tests.functions.length > 0 && tests.functions.includes('test')) {
                // Test function
                testRunner = 'test();';
            } else if (tests.functions.length > 0) {
                // Use first function as runner
                testRunner = `${tests.functions[0]}();`;
            } else {
                // No functions found, run the script as is
                testRunner = '// No explicit test runner function found';
            }

            // Create test name and global name
            const testName = tests.describe[0] || path.basename(filePath, path.extname(filePath));
            const globalName = testName.replace(/[^a-zA-Z0-9]/g, '') + 'Test';

            // Generate self-contained test
            const selfContainedContent = SELF_CONTAINED_TEMPLATE
                .replace('$ORIGINAL_FILE', filePath)
                .replace('$TEST_CONTENT', content)
                .replace(/\$TEST_NAME/g, testName)
                .replace('$TEST_RUNNER', testRunner)
                .replace(/\$EXPORTS/g, exportList || 'test: runTest')
                .replace('$GLOBAL_NAME', globalName);

            if (!this.dryRun) {
                // Create output directory if it doesn't exist
                const outputDir = path.dirname(outputPath);
                if (!fs.existsSync(outputDir)) {
                    fs.mkdirSync(outputDir, { recursive: true });
                }

                // Write the new file
                fs.writeFileSync(outputPath, selfContainedContent, 'utf8');
                this.logger.info(`Created self-contained test file: ${outputPath}`);
            } else {
                this.logger.info(`[DRY RUN] Would create self-contained test file: ${outputPath}`);
            }

            return true;
        } catch (error) {
            this.logger.error(`Error creating self-contained test for ${filePath}:`, error.message);
            return false;
        }
    }

    /**
     * Process regression test files in a directory recursively
     * @param {string} dirPath - Directory path
     * @returns {Object} Results of the operation
     */
    processDirectory(dirPath) {
        const results = {
            processed: 0,
            created: 0,
            errors: 0,
            skipped: 0
        };

        try {
            const entries = fs.readdirSync(dirPath, { withFileTypes: true });

            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry.name);

                if (entry.isDirectory()) {
                    // Skip ignored directories
                    if (this.ignoreDirs.includes(entry.name)) {
                        this.logger.debug(`Skipping directory: ${fullPath}`);
                        continue;
                    }

                    // Process subdirectory recursively
                    const subResults = this.processDirectory(fullPath);

                    // Aggregate results
                    results.processed += subResults.processed;
                    results.created += subResults.created;
                    results.errors += subResults.errors;
                    results.skipped += subResults.skipped;
                } else if (entry.isFile() && (
                    entry.name.includes('test') ||
                    entry.name.includes('spec') ||
                    fullPath.includes('/tests/') ||
                    fullPath.includes('/test/')
                ) && entry.name.endsWith('.js')) {
                    // Only process JS test files
                    results.processed++;

                    let success = true;

                    // Create standalone test if enabled
                    if (this.standalone) {
                        success = this.createStandaloneTest(fullPath) && success;
                        if (success) results.created++;
                    }

                    // Create self-contained test if enabled
                    if (this.selfContained) {
                        success = this.createSelfContainedTest(fullPath) && success;
                        if (success) results.created++;
                    }

                    if (!success) {
                        results.errors++;
                    }
                } else {
                    results.skipped++;
                }
            }
        } catch (error) {
            this.logger.error(`Error processing directory ${dirPath}:`, error.message);
            results.errors++;
        }

        return results;
    }
}

/**
 * Fix regression test files
 * @param {Object} options - Options
 * @returns {Promise<Object>} Results of the operation
 */
export async function fixRegression(options = {}) {
    const fixer = new RegressionTestFixer(options);
    const targetPath = options.path || path.resolve(__dirname, '../../tests/regression');

    fixer.logger.info(`Starting regression test fixes for ${targetPath}`);

    let results;
    if (fs.statSync(targetPath).isDirectory()) {
        results = fixer.processDirectory(targetPath);
    } else {
        // Process single file
        let success = true;
        let created = 0;

        if (fixer.standalone) {
            success = fixer.createStandaloneTest(targetPath);
            if (success) created++;
        }

        if (fixer.selfContained) {
            success = fixer.createSelfContainedTest(targetPath) && success;
            if (success) created++;
        }

        results = {
            processed: 1,
            created,
            errors: success ? 0 : 1,
            skipped: 0
        };
    }

    fixer.logger.info(`Regression test fixes completed: processed=${results.processed}, created=${results.created}, errors=${results.errors}, skipped=${results.skipped}`);

    return results;
}

export default fixRegression; 