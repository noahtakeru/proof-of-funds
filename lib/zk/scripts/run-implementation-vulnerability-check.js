#!/usr/bin/env node

/**
 * ZK Implementation Vulnerability Check
 * 
 * Script to run the ImplementationVulnerabilityDetector against codebase files
 * to identify potential implementation vulnerabilities in ZK proof systems.
 * 
 * Usage: node run-implementation-vulnerability-check.js [--target=<path>] [--verbose] [--output=<dir>] [--format=json|text]
 */

import path from 'path';
import fs from 'fs/promises';
import { fileURLToPath } from 'url';
import glob from 'glob';
import { SecurityDetectorFactory } from '../src/security/detectors/SecurityDetectorFactory.js';
import { ImplementationVulnerabilityDetector } from '../src/security/detectors/ImplementationVulnerabilityDetector.js';
import { SecurityRuleRunner, CryptographicWeaknessRule, ParameterTamperingRule } from '../src/security/index.js';

// Get directory name for the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Parse command-line arguments
const args = process.argv.slice(2).reduce((acc, arg) => {
    const [key, value] = arg.split('=');
    const cleanKey = key.replace(/^--/, '');
    acc[cleanKey] = value || true;
    return acc;
}, {});

// Default values
const rootDir = path.resolve(__dirname, '../../..');
const defaultTargetPath = path.join(rootDir, 'lib/zk');
const options = {
    target: args.target || args._?.[0] || defaultTargetPath,
    verbose: args.verbose || false,
    output: args.output || path.join(rootDir, 'reports/security'),
    format: args.format || 'json',
    excludePatterns: [
        'node_modules',
        'dist',
        'build',
        'coverage',
        'tests/fixtures',
        '.git'
    ],
    includeExtensions: ['.js', '.mjs', '.cjs', '.ts', '.jsx', '.tsx']
};

/**
 * Check if a file should be excluded based on exclude patterns
 * @param {string} filePath - File path
 * @param {Array<string>} excludePatterns - Patterns to exclude
 * @returns {boolean} - Whether the file should be excluded
 */
function shouldExcludeFile(filePath, excludePatterns) {
    return excludePatterns.some(pattern => filePath.includes(pattern));
}

/**
 * Read file content
 * @param {string} filePath - Path to the file
 * @returns {Promise<string>} - File content
 */
async function readFile(filePath) {
    try {
        return await fs.readFile(filePath, 'utf8');
    } catch (error) {
        console.error(`Error reading file ${filePath}:`, error.message);
        return null;
    }
}

/**
 * Find files to check
 * @param {string} targetPath - Target path
 * @param {Array<string>} excludePatterns - Patterns to exclude
 * @returns {Promise<Array<string>>} - Array of file paths
 */
function findFiles(targetPath, excludePatterns) {
    return new Promise((resolve, reject) => {
        const pattern = path.join(targetPath, '**/*.{js,mjs,cjs,ts,jsx,tsx}');

        glob(pattern, { nodir: true }, (err, files) => {
            if (err) {
                reject(err);
                return;
            }

            const filteredFiles = files.filter(file => !shouldExcludeFile(file, excludePatterns));
            resolve(filteredFiles);
        });
    });
}

/**
 * Format findings based on specified format
 * @param {Array} findings - Array of findings
 * @param {string} format - Output format (json or text)
 * @returns {string} - Formatted findings
 */
function formatFindings(findings, format) {
    if (format.toLowerCase() === 'json') {
        return JSON.stringify(findings, null, 2);
    } else if (format.toLowerCase() === 'html') {
        // Simple HTML formatting
        let html = '<html><head><title>Vulnerability Report</title>';
        html += '<style>body{font-family:sans-serif;margin:2em}h1{color:#333}';
        html += '.critical{color:#ff0000}.high{color:#ff6600}.medium{color:#ffcc00}.low{color:#00cc00}';
        html += 'table{border-collapse:collapse;width:100%}th,td{border:1px solid #ddd;padding:8px}';
        html += 'th{background-color:#f2f2f2}</style></head><body>';
        html += '<h1>Vulnerability Report</h1>';

        // Summary
        html += '<h2>Summary</h2>';
        html += `<p>Found ${findings.totalIssues} issues in ${findings.filesWithIssues.length} files</p>`;

        // Issues by severity
        html += '<h3>Issues by Severity</h3><ul>';
        for (const [severity, count] of Object.entries(findings.issuesBySeverity)) {
            html += `<li class="${severity.toLowerCase()}">${severity}: ${count}</li>`;
        }
        html += '</ul>';

        // Issues by rule
        html += '<h3>Issues by Rule</h3><ul>';
        for (const [rule, count] of Object.entries(findings.issuesByRule)) {
            html += `<li>${rule}: ${count}</li>`;
        }
        html += '</ul>';

        // Detailed findings
        html += '<h2>Detailed Findings</h2>';
        html += '<table><tr><th>File</th><th>Line</th><th>Rule</th><th>Severity</th><th>Message</th></tr>';

        findings.issues.forEach(issue => {
            html += `<tr>`;
            html += `<td>${issue.filePath}</td>`;
            html += `<td>${issue.line || 'N/A'}</td>`;
            html += `<td>${issue.rule}</td>`;
            html += `<td class="${issue.severity.toLowerCase()}">${issue.severity}</td>`;
            html += `<td>${issue.message}</td>`;
            html += `</tr>`;
        });

        html += '</table></body></html>';
        return html;
    } else {
        // Text format
    }

    // Text format
    let output = '';

    if (findings.length === 0) {
        return 'No implementation vulnerabilities found.\n';
    }

    // Group by severity
    const groupedFindings = findings.reduce((acc, finding) => {
        acc[finding.severity] = acc[finding.severity] || [];
        acc[finding.severity].push(finding);
        return acc;
    }, {});

    // Order by severity
    const severityOrder = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'];

    for (const severity of severityOrder) {
        const severityFindings = groupedFindings[severity];

        if (severityFindings && severityFindings.length > 0) {
            output += `\n${severity} SEVERITY (${severityFindings.length} findings)\n`;
            output += '='.repeat(40) + '\n\n';

            severityFindings.forEach((finding, index) => {
                output += `[${index + 1}] ${finding.description}\n`;
                output += `    File: ${finding.location.file}\n`;
                output += `    Line: ${finding.location.line}\n`;
                output += `    Evidence: ${finding.evidence}\n`;

                if (finding.remediation) {
                    output += `    Remediation: ${finding.remediation}\n`;
                }

                output += '\n';
            });
        }
    }

    return output;
}

/**
 * Save findings to a file
 * @param {Array} findings - Array of findings
 * @param {string} outputDir - Output directory
 * @param {string} format - Output format
 * @returns {Promise<string>} - Path to the output file
 */
async function saveFindings(findings, outputDir, format) {
    try {
        await fs.mkdir(outputDir, { recursive: true });

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `implementation-vulnerabilities-${timestamp}.${format === 'json' ? 'json' : 'txt'}`;
        const outputPath = path.join(outputDir, fileName);

        await fs.writeFile(outputPath, formatFindings(findings, format));

        return outputPath;
    } catch (error) {
        console.error('Error saving findings:', error.message);
        return null;
    }
}

/**
 * Generate summary of findings
 * @param {Array} findings - Array of findings
 * @returns {Object} - Summary object
 */
function generateSummary(findings) {
    // Count findings by severity
    const findingsBySeverity = findings.reduce((acc, finding) => {
        acc[finding.severity] = (acc[finding.severity] || 0) + 1;
        return acc;
    }, {});

    return {
        totalFindings: findings.length,
        findingsBySeverity,
        timestamp: new Date().toISOString()
    };
}

/**
 * Run implementation vulnerability check
 */
async function runImplementationVulnerabilityCheck() {
    console.log('🔍 Starting ZK implementation vulnerability check...');
    console.log(`Target: ${options.target}`);

    // Ensure output directory exists
    try {
        await fs.mkdir(options.output, { recursive: true });
    } catch (error) {
        console.error('Error creating output directory:', error.message);
        process.exit(1);
    }

    // Start timer
    const startTime = process.hrtime();

    try {
        // Find files to check
        const files = await findFiles(options.target, options.excludePatterns);
        console.log(`Found ${files.length} files to check.`);

        // Get implementation vulnerability detector
        const detector = new ImplementationVulnerabilityDetector();

        // Check each file
        const allFindings = [];

        for (const filePath of files) {
            if (options.verbose) {
                console.log(`Checking ${filePath}...`);
            }

            const content = await readFile(filePath);

            if (content) {
                const findings = detector.evaluate(filePath, content);

                if (findings.length > 0) {
                    allFindings.push(...findings);

                    if (options.verbose) {
                        console.log(`  Found ${findings.length} issues.`);
                    }
                }
            }
        }

        // Calculate elapsed time
        const elapsedTime = process.hrtime(startTime);
        const seconds = (elapsedTime[0] + (elapsedTime[1] / 1e9)).toFixed(2);

        // Generate summary
        const summary = generateSummary(allFindings);

        // Save findings
        const outputPath = await saveFindings(allFindings, options.output, options.format);

        // Print summary
        console.log('\n📊 Implementation Vulnerability Check Results:');
        console.log(`Total findings: ${summary.totalFindings}`);

        // Print findings by severity
        if (summary.findingsBySeverity) {
            console.log('\nFindings by severity:');
            const severities = Object.keys(summary.findingsBySeverity).sort((a, b) => {
                // Sort order: CRITICAL, HIGH, MEDIUM, LOW, INFO, others
                const order = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3, INFO: 4 };
                return (order[a] || 99) - (order[b] || 99);
            });

            for (const severity of severities) {
                const count = summary.findingsBySeverity[severity];
                let icon = '📌';

                // Different icons for different severities
                if (severity === 'CRITICAL') icon = '🚨';
                if (severity === 'HIGH') icon = '⚠️';
                if (severity === 'MEDIUM') icon = '⚡';
                if (severity === 'LOW') icon = '📝';
                if (severity === 'INFO') icon = 'ℹ️';

                console.log(`  ${icon} ${severity}: ${count}`);
            }
        }

        if (outputPath) {
            console.log(`\nReport saved to: ${outputPath}`);
        }

        console.log(`Implementation vulnerability check completed in ${seconds}s`);

        // Return non-zero exit code if critical or high findings
        const criticalCount = summary.findingsBySeverity.CRITICAL || 0;
        const highCount = summary.findingsBySeverity.HIGH || 0;

        if (criticalCount > 0 || highCount > 0) {
            process.exit(1);
        }
    } catch (error) {
        console.error('❌ Error running implementation vulnerability check:', error);
        process.exit(1);
    }
}

// Run the check
runImplementationVulnerabilityCheck().catch(error => {
    console.error('❌ Fatal error:', error);
    process.exit(1);
}); 