<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZK Proxy Client Fallback Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        select, input {
            padding: 8px;
            margin: 8px 0;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .progress-bar {
            width: 100%;
            background-color: #e0e0e0;
            padding: 3px;
            border-radius: 3px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,.2);
        }
        .progress-bar-fill {
            display: block;
            height: 22px;
            background-color: #4CAF50;
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .status {
            font-weight: bold;
        }
        .panel {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <h1>ZK Proxy Client Fallback Test</h1>
    <p>This page allows you to test the server-side fallback functionality for ZK operations.</p>
    
    <div class="card">
        <h2>Device Capabilities</h2>
        <div id="capabilities">Loading...</div>
    </div>
    
    <div class="card">
        <h2>Execution Settings</h2>
        <div>
            <label for="execution-mode">Execution Mode:</label>
            <select id="execution-mode">
                <option value="auto">Auto (based on capabilities)</option>
                <option value="client">Client-side only</option>
                <option value="server">Server-side only</option>
                <option value="hybrid">Hybrid execution</option>
            </select>
        </div>
        <div>
            <label><input type="checkbox" id="allow-fallback" checked> Allow fallback to server if client-side fails</label>
        </div>
        <div>
            <label><input type="checkbox" id="force-failure"> Force client-side failure (for testing fallback)</label>
        </div>
    </div>
    
    <div class="card">
        <h2>Generate Proof</h2>
        <div>
            <label for="wallet-address">Wallet Address:</label>
            <input type="text" id="wallet-address" value="0x1234567890abcdef1234567890abcdef12345678" style="width: 350px;">
        </div>
        <div>
            <label for="amount">Amount:</label>
            <input type="text" id="amount" value="1000">
        </div>
        <div>
            <label for="proof-type">Proof Type:</label>
            <select id="proof-type">
                <option value="0">Standard Proof (Simpler)</option>
                <option value="1">Threshold Proof (Medium)</option>
                <option value="2">Maximum Proof (Complex)</option>
            </select>
        </div>
        <div style="margin-top: 10px;">
            <button id="generate-btn">Generate Proof</button>
        </div>
        
        <div class="panel">
            <h3>Progress</h3>
            <div class="progress-bar">
                <span class="progress-bar-fill" id="progress-bar"></span>
            </div>
            <p class="status" id="status-message">Waiting to start...</p>
        </div>
        
        <div class="panel">
            <h3>Result</h3>
            <pre id="result">No operation performed yet.</pre>
        </div>
    </div>
    
    <div class="card">
        <h2>Execution Log</h2>
        <pre id="log"></pre>
        <button id="clear-log">Clear Log</button>
    </div>

    <script>
        // Mock ZK Proxy Client for testing
        const EXECUTION_MODES = {
            CLIENT_SIDE: 'client',
            SERVER_SIDE: 'server',
            HYBRID: 'hybrid',
            AUTO: 'auto'
        };
        
        class RequestQueue {
            constructor() {
                this.queue = [];
            }
            
            // For testing, just execute immediately
            enqueue(operation) {
                return operation();
            }
            
            getStatus() {
                return {
                    queuedRequests: 0,
                    activeOperations: 0
                };
            }
        }
        
        class RateLimiter {
            constructor() {}
            
            checkRateLimit() {
                return { allowed: true };
            }
            
            releaseRequest() {}
        }
        
        // Mock functions that would normally make actual API calls
        async function mockServerRequest(endpoint, data, delay = 1000) {
            // Log the request
            addToLog(`üì§ Request to ${endpoint}:`);
            addToLog(JSON.stringify(data, null, 2));
            
            // Simulate network delay
            await new Promise(resolve => setTimeout(resolve, delay));
            
            // Generate mock response
            const response = {
                proof: {
                    pi_a: ['1', '2', '3'],
                    pi_b: [['4', '5'], ['6', '7']],
                    pi_c: ['8', '9', '10']
                },
                publicSignals: ['11', '12', '13'],
                executionTimeMs: 1500,
                operationId: data.clientInfo?.operationId || 'server-op-id'
            };
            
            // Log the response
            addToLog(`üì• Response from ${endpoint}:`);
            addToLog(JSON.stringify(response, null, 2));
            
            return response;
        }
        
        async function mockClientSideComputation(params, delay = 2000, shouldFail = false) {
            addToLog(`üñ•Ô∏è Client-side computation starting for ${params.proofType === 0 ? 'Standard' : params.proofType === 1 ? 'Threshold' : 'Maximum'} proof`);
            
            // Simulate computation delay
            await new Promise(resolve => setTimeout(resolve, delay));
            
            if (shouldFail) {
                addToLog(`‚ùå Client-side computation failed!`);
                throw new Error('Simulated client-side failure');
            }
            
            const result = {
                proof: {
                    pi_a: ['1', '2', '3'],
                    pi_b: [['4', '5'], ['6', '7']],
                    pi_c: ['8', '9', '10']
                },
                publicSignals: ['11', '12', '13'],
                executionTimeMs: 2000
            };
            
            addToLog(`‚úÖ Client-side computation completed`);
            return result;
        }
        
        // Detect Device Capabilities
        function detectCapabilities() {
            const capabilities = {
                features: {
                    webAssembly: typeof WebAssembly !== 'undefined',
                    webCrypto: typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined',
                    indexedDB: typeof indexedDB !== 'undefined',
                    webWorkers: typeof Worker !== 'undefined',
                    sharedArrayBuffer: typeof SharedArrayBuffer !== 'undefined'
                },
                performance: {
                    // Simple mock performance scores
                    memory: 75,
                    cpu: 80,
                    webAssembly: 70,
                    overall: 75
                },
                browser: {
                    name: getBrowserName(),
                    version: getBrowserVersion(),
                    isMobile: /Mobi|Android/i.test(navigator.userAgent)
                },
                compatibility: {
                    level: 'high',
                    recommendedPath: 'clientSide'
                }
            };
            
            // Adjust for browser features
            if (!capabilities.features.webAssembly) {
                capabilities.compatibility.level = 'incompatible';
                capabilities.compatibility.recommendedPath = 'serverSide';
                capabilities.performance.overall = 10;
            } else if (
                !capabilities.features.webCrypto || 
                navigator.deviceMemory < 4 ||
                /iPhone|iPad|iPod/.test(navigator.userAgent)
            ) {
                capabilities.compatibility.level = 'medium';
                capabilities.compatibility.recommendedPath = 'hybrid';
                capabilities.performance.overall = 50;
            }
            
            return capabilities;
        }
        
        function getBrowserName() {
            const userAgent = navigator.userAgent;
            if (userAgent.indexOf("Firefox") > -1) return "firefox";
            if (userAgent.indexOf("SamsungBrowser") > -1) return "samsung";
            if (userAgent.indexOf("Opera") > -1 || userAgent.indexOf("OPR") > -1) return "opera";
            if (userAgent.indexOf("Trident") > -1) return "ie";
            if (userAgent.indexOf("Edge") > -1) return "edge";
            if (userAgent.indexOf("Chrome") > -1) return "chrome";
            if (userAgent.indexOf("Safari") > -1) return "safari";
            return "unknown";
        }
        
        function getBrowserVersion() {
            // This is a very simplified version - production code would have better detection
            const ua = navigator.userAgent;
            let version = "unknown";
            
            if (ua.indexOf("Chrome") > -1) {
                version = ua.match(/Chrome\/(\d+\.\d+)/)[1];
            } else if (ua.indexOf("Firefox") > -1) {
                version = ua.match(/Firefox\/(\d+\.\d+)/)[1];
            } else if (ua.indexOf("Safari") > -1) {
                version = ua.match(/Version\/(\d+\.\d+)/)[1];
            }
            
            return version;
        }
        
        // ZK Proxy Client Implementation
        class ZKProxyClient {
            constructor() {
                this.capabilities = null;
                this.executionMode = EXECUTION_MODES.AUTO;
                this.operationQueue = new RequestQueue();
                this.rateLimiter = new RateLimiter();
                this.serverAvailable = true;
                this.userPreferences = {
                    preferClientSide: false,
                    preferServerSide: false,
                    allowFallback: true
                };
                this.apiBaseUrl = '/api/zk';
                this.progressCallbacks = new Map();
                this.isInitialized = false;
                
                // For testing only
                this.forceClientFailure = false;
            }
            
            async initialize() {
                this.capabilities = detectCapabilities();
                await this.checkServerStatus();
                
                if (this.executionMode === EXECUTION_MODES.AUTO) {
                    this.determineOptimalExecutionMode();
                }
                
                this.isInitialized = true;
                return true;
            }
            
            async checkServerStatus() {
                // Simulate server status check
                await new Promise(resolve => setTimeout(resolve, 300));
                this.serverAvailable = true;
                return true;
            }
            
            determineOptimalExecutionMode() {
                // User preferences take precedence
                if (this.userPreferences.preferServerSide) {
                    this.executionMode = EXECUTION_MODES.SERVER_SIDE;
                    return;
                }
                
                if (this.userPreferences.preferClientSide && 
                    this.capabilities.features.webAssembly) {
                    this.executionMode = EXECUTION_MODES.CLIENT_SIDE;
                    return;
                }
                
                // Capability-based decision
                if (!this.capabilities.features.webAssembly) {
                    this.executionMode = EXECUTION_MODES.SERVER_SIDE;
                    return;
                }
                
                switch (this.capabilities.compatibility.recommendedPath) {
                    case 'clientSide':
                        this.executionMode = EXECUTION_MODES.CLIENT_SIDE;
                        break;
                    case 'serverSide':
                        this.executionMode = EXECUTION_MODES.SERVER_SIDE;
                        break;
                    case 'hybrid':
                        this.executionMode = EXECUTION_MODES.HYBRID;
                        break;
                    default:
                        this.executionMode = EXECUTION_MODES.SERVER_SIDE;
                }
            }
            
            registerProgressCallback(operationId, callback) {
                this.progressCallbacks.set(operationId, callback);
            }
            
            reportProgress(operationId, progress, status) {
                if (this.progressCallbacks.has(operationId)) {
                    this.progressCallbacks.get(operationId)({
                        operationId,
                        progress,
                        status,
                        timestamp: Date.now()
                    });
                }
            }
            
            async generateProofClientSide(params, operationId) {
                // Simulate client-side computation
                this.reportProgress(operationId, 10, 'Starting client-side proof generation');
                this.reportProgress(operationId, 20, 'Initializing cryptographic environment');
                this.reportProgress(operationId, 30, 'Setting up circuits');
                
                await new Promise(resolve => setTimeout(resolve, 400));
                
                this.reportProgress(operationId, 40, 'Calculating witness');
                this.reportProgress(operationId, 50, 'Computing ZK proof');
                
                // This will be replaced with actual client-side computation
                try {
                    const result = await mockClientSideComputation(
                        params, 
                        params.proofType === 0 ? 1500 : params.proofType === 1 ? 2000 : 3000,
                        this.forceClientFailure
                    );
                    
                    this.reportProgress(operationId, 90, 'Finalizing proof');
                    
                    return {
                        ...result,
                        operationId,
                        isClientSide: true
                    };
                } catch (error) {
                    addToLog(`‚ùå Error in client-side computation: ${error.message}`);
                    throw error;
                }
            }
            
            async generateProofServerSide(params, operationId) {
                this.reportProgress(operationId, 10, 'Starting server-side proof generation');
                this.reportProgress(operationId, 20, 'Preparing request data');
                
                // Prepare the request
                const requestData = {
                    input: {
                        walletAddress: params.walletAddress,
                        amount: params.amount,
                        proofType: params.proofType
                    },
                    circuitWasmPath: `/circuits/${params.proofType === 0 ? 'standardProof' : params.proofType === 1 ? 'thresholdProof' : 'maximumProof'}.wasm`,
                    zkeyPath: `/circuits/${params.proofType === 0 ? 'standardProof' : params.proofType === 1 ? 'thresholdProof' : 'maximumProof'}.zkey`,
                    clientInfo: {
                        operationId,
                        userAgent: navigator.userAgent,
                        wasmSupported: this.capabilities.features.webAssembly
                    }
                };
                
                this.reportProgress(operationId, 30, 'Sending request to server');
                
                // Simulate server request
                const result = await mockServerRequest(
                    '/api/zk/fullProve', 
                    requestData,
                    params.proofType === 0 ? 1000 : params.proofType === 1 ? 1500 : 2000
                );
                
                this.reportProgress(operationId, 90, 'Processing server response');
                
                return {
                    ...result,
                    isServerSide: true
                };
            }
            
            async generateProofHybrid(params, operationId) {
                this.reportProgress(operationId, 10, 'Starting hybrid proof generation');
                
                // Based on proof complexity and device capabilities,
                // choose whether to compute on client or server
                if (params.proofType === 2 || !this.capabilities.features.webAssembly) {
                    this.reportProgress(operationId, 20, 'Using server for complex proof generation');
                    return this.generateProofServerSide(params, operationId);
                } else {
                    this.reportProgress(operationId, 20, 'Using client for proof generation');
                    return this.generateProofClientSide(params, operationId);
                }
            }
            
            async generateProof(params, options = {}) {
                if (!this.isInitialized) {
                    await this.initialize();
                }
                
                const operationId = options.operationId || `proof_${Date.now()}_${Math.random().toString(16).slice(2)}`;
                
                if (options.onProgress) {
                    this.registerProgressCallback(operationId, options.onProgress);
                }
                
                this.reportProgress(operationId, 0, 'Starting proof generation');
                
                try {
                    let result;
                    const executionMode = options.executionMode || this.executionMode;
                    
                    addToLog(`üöÄ Starting proof generation using ${executionMode} mode`);
                    
                    switch (executionMode) {
                        case EXECUTION_MODES.CLIENT_SIDE:
                            try {
                                result = await this.generateProofClientSide(params, operationId);
                            } catch (error) {
                                // If client-side fails and fallback is allowed, try server-side
                                if (this.userPreferences.allowFallback && this.serverAvailable) {
                                    addToLog(`üîÑ Falling back to server-side execution after client error: ${error.message}`);
                                    this.reportProgress(operationId, 10, 'Falling back to server-side execution');
                                    result = await this.generateProofServerSide(params, operationId);
                                } else {
                                    throw error;
                                }
                            }
                            break;
                        case EXECUTION_MODES.SERVER_SIDE:
                            result = await this.generateProofServerSide(params, operationId);
                            break;
                        case EXECUTION_MODES.HYBRID:
                            result = await this.generateProofHybrid(params, operationId);
                            break;
                        default:
                            result = await this.generateProofServerSide(params, operationId);
                    }
                    
                    this.reportProgress(operationId, 100, 'Proof generation completed');
                    this.progressCallbacks.delete(operationId);
                    
                    addToLog(`‚úÖ Proof generation completed successfully (${result.isClientSide ? 'client-side' : 'server-side'})`);
                    
                    return result;
                } catch (error) {
                    this.reportProgress(operationId, 0, `Error: ${error.message}`);
                    this.progressCallbacks.delete(operationId);
                    
                    addToLog(`‚ùå Proof generation failed: ${error.message}`);
                    throw error;
                }
            }
            
            setUserPreferences(preferences) {
                this.userPreferences = {
                    ...this.userPreferences,
                    ...preferences
                };
                
                if (this.executionMode === EXECUTION_MODES.AUTO) {
                    this.determineOptimalExecutionMode();
                }
            }
            
            setExecutionMode(mode) {
                if (Object.values(EXECUTION_MODES).includes(mode)) {
                    this.executionMode = mode;
                    return true;
                }
                return false;
            }
        }
        
        // Initialize the client
        const zkProxyClient = new ZKProxyClient();
        
        // UI Helpers
        function updateProgressBar(progress) {
            document.getElementById('progress-bar').style.width = `${progress}%`;
        }
        
        function updateStatusMessage(message) {
            document.getElementById('status-message').textContent = message;
        }
        
        function updateResult(result) {
            document.getElementById('result').textContent = 
                typeof result === 'object' ? JSON.stringify(result, null, 2) : String(result);
        }
        
        function addToLog(message) {
            const logEl = document.getElementById('log');
            logEl.textContent = `${new Date().toLocaleTimeString()} - ${message}\n${logEl.textContent}`;
        }
        
        // Display device capabilities
        async function displayCapabilities() {
            const capabilities = detectCapabilities();
            const capabilitiesDiv = document.getElementById('capabilities');
            
            const features = Object.entries(capabilities.features)
                .map(([key, value]) => `<li><strong>${key}:</strong> ${value ? '‚úÖ' : '‚ùå'}</li>`)
                .join('');
            
            const performance = Object.entries(capabilities.performance)
                .map(([key, value]) => `<li><strong>${key}:</strong> ${value}/100</li>`)
                .join('');
            
            capabilitiesDiv.innerHTML = `
                <p><strong>Browser:</strong> ${capabilities.browser.name} ${capabilities.browser.version}</p>
                <p><strong>Mobile Device:</strong> ${capabilities.browser.isMobile ? 'Yes' : 'No'}</p>
                <p><strong>Compatibility Level:</strong> ${capabilities.compatibility.level}</p>
                <p><strong>Recommended Execution Path:</strong> ${capabilities.compatibility.recommendedPath}</p>
                
                <h3>Features</h3>
                <ul>${features}</ul>
                
                <h3>Performance Scores</h3>
                <ul>${performance}</ul>
            `;
        }
        
        // Initialize the page
        async function init() {
            await zkProxyClient.initialize();
            await displayCapabilities();
            
            addToLog(`üîç Device detected as: ${zkProxyClient.capabilities.browser.name} ${zkProxyClient.capabilities.browser.version}`);
            addToLog(`üîß Optimal execution mode determined to be: ${zkProxyClient.executionMode}`);
            
            // Set up UI event handlers
            document.getElementById('execution-mode').addEventListener('change', function() {
                zkProxyClient.setExecutionMode(this.value);
                addToLog(`üîÑ Execution mode changed to: ${this.value}`);
            });
            
            document.getElementById('allow-fallback').addEventListener('change', function() {
                zkProxyClient.setUserPreferences({ allowFallback: this.checked });
                addToLog(`üîÑ Fallback ${this.checked ? 'enabled' : 'disabled'}`);
            });
            
            document.getElementById('force-failure').addEventListener('change', function() {
                zkProxyClient.forceClientFailure = this.checked;
                addToLog(`üîÑ Force client failure ${this.checked ? 'enabled' : 'disabled'}`);
            });
            
            document.getElementById('generate-btn').addEventListener('click', async function() {
                this.disabled = true;
                updateResult('Operation in progress...');
                
                try {
                    const params = {
                        walletAddress: document.getElementById('wallet-address').value,
                        amount: document.getElementById('amount').value,
                        proofType: parseInt(document.getElementById('proof-type').value, 10)
                    };
                    
                    const result = await zkProxyClient.generateProof(params, {
                        onProgress: function(progress) {
                            updateProgressBar(progress.progress);
                            updateStatusMessage(progress.status);
                        }
                    });
                    
                    updateResult(result);
                } catch (error) {
                    updateResult(`Error: ${error.message}`);
                } finally {
                    this.disabled = false;
                }
            });
            
            document.getElementById('clear-log').addEventListener('click', function() {
                document.getElementById('log').textContent = '';
            });
        }
        
        // Start initialization when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>