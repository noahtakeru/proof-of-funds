<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temporary Wallet Manager Test</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        button {
            padding: 8px 16px;
            margin-right: 8px;
            margin-bottom: 8px;
            background-color: #0070f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0051a8;
        }
        pre {
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        #log {
            margin-top: 20px;
            height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
    </style>
</head>
<body>
    <h1>Temporary Wallet Manager Test</h1>
    <p>This is a simple test page for the Temporary Wallet Manager implementation. Click the buttons below to test different functionality.</p>
    
    <div>
        <button id="createWallet">Create Wallet</button>
        <button id="createCustomWallet">Create Custom Wallet</button>
        <button id="listWallets">List Wallets</button>
        <button id="destroyWallet">Destroy Selected Wallet</button>
        <button id="extendWallet">Extend Selected Wallet</button>
        <button id="makeWalletPersistent">Make Selected Persistent</button>
        <button id="makeWalletTemporary">Make Selected Temporary</button>
        <button id="purgeAll">Purge All Wallets</button>
    </div>
    
    <div id="log"></div>
    
    <script type="module">
        // Mock dependencies for testing in standalone page
        // These would normally be imported from actual modules
        
        // Mock ethersUtils
        window.ethersModule = {
            utils: {
                entropyToMnemonic: (entropy, wordlist) => {
                    // Simple mock that returns a deterministic mnemonic
                    return "test test test test test test test test test test test junk";
                },
                randomBytes: (size) => {
                    // Generate random bytes
                    return new Uint8Array(size);
                },
                HDNode: {
                    fromMnemonic: (mnemonic) => ({
                        derivePath: (path) => {
                            // Extract index from path
                            const index = parseInt(path.split('/').pop(), 10);
                            // Create deterministic address and key based on index
                            return {
                                address: `0x${index.toString().padStart(40, '0')}`,
                                privateKey: `0x${index.toString().padStart(64, '0')}`
                            };
                        }
                    })
                }
            },
            Wallet: function(privateKey) {
                return {
                    address: `0x${privateKey.substring(privateKey.length - 40)}`,
                    signMessage: async (message) => `0xsignature_${message.substring(0, 10)}`,
                    signTransaction: async (tx) => `0xtxsignature_${JSON.stringify(tx).substring(0, 10)}`
                };
            },
            wordlists: { en: {} }
        };
        
        // Mock getEthers
        const getEthers = async () => ({ ethers: window.ethersModule });
        
        // Mock wallet helpers
        const getBIP44Path = (chain, index) => {
            // Standard BIP44 derivation path
            const chainCode = chain === 'ethereum' ? '60' : 
                            chain === 'polygon' ? '966' : 
                            chain === 'solana' ? '501' : '60';
            return `m/44'/${chainCode}'/0'/0/${index}`;
        };
        
        const deriveWalletFromMnemonic = async (mnemonic, path) => {
            // Mock derivation by extracting index from path
            const index = parseInt(path.split('/').pop(), 10);
            return {
                address: `0x${index.toString().padStart(40, '0')}`,
                privateKey: `0x${index.toString().padStart(64, '0')}`
            };
        };
        
        // Now implement the actual temporaryWalletManager code
        // (This is a simplified version for testing, the full version is in temporaryWalletManager.js)
        
        // Constants for wallet configuration
        const DEFAULT_TEMP_WALLET_LIFETIME_MS = 15 * 60 * 1000; // 15 minutes
        const DEFAULT_WALLET_CLEANUP_INTERVAL_MS = 60 * 1000; // 1 minute
        const MIN_ENTROPY_BITS = 128; // Minimum entropy for wallet generation
        const ENTROPY_BYTES = MIN_ENTROPY_BITS / 8; // Convert bits to bytes
        
        // In-memory wallet registry (never stored to localStorage/disk)
        const walletRegistry = new Map();
        
        // Set up cleanup interval
        let cleanupInterval = null;
        
        /**
         * Securely generates cryptographically strong random bytes
         */
        const getSecureRandomBytes = (numBytes = ENTROPY_BYTES) => {
            if (numBytes < ENTROPY_BYTES) {
                numBytes = ENTROPY_BYTES;
            }
            
            const buffer = new Uint8Array(numBytes);
            window.crypto.getRandomValues(buffer);
            return buffer;
        };
        
        /**
         * Converts random bytes to a mnemonic phrase
         */
        const entropyToMnemonic = async (entropyBytes) => {
            try {
                const { ethers } = await getEthers();
                const wordlist = ethers.wordlists.en;
                return ethers.utils.entropyToMnemonic(entropyBytes, wordlist);
            } catch (error) {
                throw new Error(`Failed to generate mnemonic: ${error.message}`);
            }
        };
        
        /**
         * Securely wipes sensitive data from memory
         */
        const wipeFromMemory = (data) => {
            if (data instanceof Uint8Array) {
                data.fill(0);
            } else if (typeof data === 'object' && data !== null) {
                Object.keys(data).forEach(key => {
                    wipeFromMemory(data[key]);
                    data[key] = null;
                });
            }
        };
        
        /**
         * Generates a temporary wallet with maximum security
         */
        const createTemporaryWallet = async (options = {}) => {
            try {
                ensureCleanupInterval();
                
                const entropyBytes = getSecureRandomBytes();
                const mnemonic = await entropyToMnemonic(entropyBytes);
                
                const chain = options.chain || 'ethereum';
                const index = options.index || Math.floor(Math.random() * 100);
                const path = getBIP44Path(chain, index);
                const lifetimeMs = options.lifetimeMs || DEFAULT_TEMP_WALLET_LIFETIME_MS;
                const persistent = !!options.persistent;
                const creationTime = Date.now();
                const expirationTime = creationTime + lifetimeMs;
                
                const walletInfo = await deriveWalletFromMnemonic(mnemonic, path);
                const { address, privateKey } = walletInfo;
                
                const walletMetadata = {
                    address,
                    chain,
                    path,
                    index,
                    creationTime,
                    expirationTime,
                    persistent,
                };
                
                const privateWalletData = {
                    privateKey,
                    mnemonic,
                    onExpiration: options.onExpiration
                };
                
                walletRegistry.set(address, {
                    public: walletMetadata,
                    private: privateWalletData
                });
                
                setupWalletExpiration(address, expirationTime);
                
                wipeFromMemory(entropyBytes);
                wipeFromMemory(walletInfo);
                
                return { ...walletMetadata };
            } catch (error) {
                throw new Error(`Temporary wallet creation failed: ${error.message}`);
            }
        };
        
        /**
         * Sets up automatic wallet expiration
         */
        const setupWalletExpiration = (address, expirationTime) => {
            const now = Date.now();
            const timeUntilExpiration = Math.max(0, expirationTime - now);
            
            setTimeout(() => {
                destroyWallet(address, 'expired');
            }, timeUntilExpiration);
        };
        
        /**
         * Ensures the wallet cleanup interval is running
         */
        const ensureCleanupInterval = () => {
            if (!cleanupInterval) {
                cleanupInterval = setInterval(() => {
                    checkForExpiredWallets();
                }, DEFAULT_WALLET_CLEANUP_INTERVAL_MS);
                
                window.addEventListener('beforeunload', () => {
                    clearInterval(cleanupInterval);
                    purgeAllWallets('page_closed');
                });
            }
        };
        
        /**
         * Checks for and removes expired wallets
         */
        const checkForExpiredWallets = () => {
            const now = Date.now();
            const expiredWallets = [];
            
            walletRegistry.forEach((wallet, address) => {
                if (wallet.public.expirationTime <= now && !wallet.public.persistent) {
                    expiredWallets.push(address);
                }
            });
            
            expiredWallets.forEach(address => {
                destroyWallet(address, 'expired');
            });
        };
        
        /**
         * Destroys a specific wallet and removes it from registry
         */
        const destroyWallet = (address, reason = 'manual') => {
            const wallet = walletRegistry.get(address);
            if (!wallet) {
                return false;
            }
            
            if (wallet.private.onExpiration && typeof wallet.private.onExpiration === 'function') {
                try {
                    wallet.private.onExpiration(address, reason);
                } catch (err) {
                    console.error('Error in wallet expiration callback:', err);
                }
            }
            
            wipeFromMemory(wallet.private);
            walletRegistry.delete(address);
            
            return true;
        };
        
        /**
         * Immediately destroys all temporary wallets
         */
        const purgeAllWallets = (reason = 'emergency_purge') => {
            let purgedCount = 0;
            
            walletRegistry.forEach((_, address) => {
                const destroyed = destroyWallet(address, reason);
                if (destroyed) {
                    purgedCount++;
                }
            });
            
            return purgedCount;
        };
        
        /**
         * Gets a list of active temporary wallets
         */
        const listTemporaryWallets = () => {
            const wallets = [];
            
            walletRegistry.forEach(wallet => {
                wallets.push({ ...wallet.public });
            });
            
            return wallets;
        };
        
        /**
         * Gets metadata for a specific temporary wallet by address
         */
        const getWalletMetadata = (address) => {
            const wallet = walletRegistry.get(address);
            if (!wallet) {
                return null;
            }
            
            return { ...wallet.public };
        };
        
        /**
         * Extends the lifetime of a temporary wallet
         */
        const extendWalletLifetime = (address, additionalTimeMs) => {
            const wallet = walletRegistry.get(address);
            if (!wallet) {
                return null;
            }
            
            const newExpirationTime = Math.max(
                wallet.public.expirationTime,
                Date.now() + additionalTimeMs
            );
            
            wallet.public.expirationTime = newExpirationTime;
            
            setupWalletExpiration(address, newExpirationTime);
            
            return { ...wallet.public };
        };
        
        /**
         * Uses a wallet's private key to sign a message or transaction
         */
        const signWithWallet = async (address, payload, payloadType = 'message') => {
            const wallet = walletRegistry.get(address);
            if (!wallet) {
                throw new Error(`Wallet not found: ${address}`);
            }
            
            try {
                const { ethers } = await getEthers();
                
                const signer = new ethers.Wallet(wallet.private.privateKey);
                
                if (payloadType === 'message') {
                    return await signer.signMessage(payload);
                } else if (payloadType === 'transaction') {
                    return await signer.signTransaction(payload);
                } else {
                    throw new Error(`Unknown payload type: ${payloadType}`);
                }
            } catch (error) {
                throw new Error(`Failed to sign with wallet: ${error.message}`);
            }
        };
        
        /**
         * Makes a wallet persistent (won't expire automatically)
         */
        const makeWalletPersistent = (address) => {
            const wallet = walletRegistry.get(address);
            if (!wallet) {
                return false;
            }
            
            wallet.public.persistent = true;
            return true;
        };
        
        /**
         * Makes a persistent wallet temporary again
         */
        const makeWalletTemporary = (address, lifetimeMs = DEFAULT_TEMP_WALLET_LIFETIME_MS) => {
            const wallet = walletRegistry.get(address);
            if (!wallet) {
                return false;
            }
            
            wallet.public.persistent = false;
            
            const expirationTime = Date.now() + lifetimeMs;
            wallet.public.expirationTime = expirationTime;
            
            setupWalletExpiration(address, expirationTime);
            
            return true;
        };
        
        // Testing code
        // UI interaction and logging
        
        let selectedWallet = null;
        
        // Logging function
        function log(message, type = 'info') {
            const logElem = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = type;
            
            // If it's an object, stringify it
            if (typeof message === 'object') {
                message = JSON.stringify(message, null, 2);
                entry.innerHTML = `<pre>${message}</pre>`;
            } else {
                entry.textContent = message;
            }
            
            logElem.appendChild(entry);
            logElem.scrollTop = logElem.scrollHeight; // Scroll to bottom
        }
        
        // Button handlers
        document.getElementById('createWallet').addEventListener('click', async () => {
            try {
                log('Creating new temporary wallet...');
                const wallet = await createTemporaryWallet({
                    onExpiration: (address, reason) => {
                        log(`Wallet ${address.substring(0, 10)}... expired (${reason})`, 'info');
                    }
                });
                selectedWallet = wallet.address;
                log(`Created wallet: ${wallet.address}`, 'success');
                log(`Expiration: ${new Date(wallet.expirationTime).toLocaleString()}`);
                log(`Chain: ${wallet.chain}, Path: ${wallet.path}`);
                
                // Check for private key exposure
                const metadata = getWalletMetadata(wallet.address);
                log('Private key exposed in wallet? ' + (wallet.privateKey ? 'YES (BAD!)' : 'No (Good)'));
                log('Private key exposed in metadata? ' + (metadata.privateKey ? 'YES (BAD!)' : 'No (Good)'));
                
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('createCustomWallet').addEventListener('click', async () => {
            try {
                log('Creating custom temporary wallet...');
                const wallet = await createTemporaryWallet({
                    chain: 'polygon',
                    index: 5,
                    lifetimeMs: 2 * 60 * 1000, // 2 minutes
                    onExpiration: (address, reason) => {
                        log(`Wallet ${address.substring(0, 10)}... expired (${reason})`, 'info');
                    }
                });
                selectedWallet = wallet.address;
                log(`Created custom wallet: ${wallet.address}`, 'success');
                log(`Expiration: ${new Date(wallet.expirationTime).toLocaleString()}`);
                log(`Chain: ${wallet.chain}, Path: ${wallet.path}`);
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('listWallets').addEventListener('click', () => {
            const wallets = listTemporaryWallets();
            log(`Found ${wallets.length} active wallets:`);
            wallets.forEach(wallet => {
                const expiresIn = Math.ceil((wallet.expirationTime - Date.now()) / 1000);
                log(`- ${wallet.address} (${wallet.chain}) - ${wallet.persistent ? 'Persistent' : `Expires in ${expiresIn}s`}`);
            });
            
            if (wallets.length === 0) {
                log('No active wallets found.');
            }
        });
        
        document.getElementById('destroyWallet').addEventListener('click', () => {
            if (!selectedWallet) {
                log('No wallet selected. Create one first.', 'error');
                return;
            }
            
            const result = destroyWallet(selectedWallet);
            if (result) {
                log(`Destroyed wallet: ${selectedWallet}`, 'success');
                selectedWallet = null;
            } else {
                log(`Failed to destroy wallet: ${selectedWallet}`, 'error');
            }
        });
        
        document.getElementById('extendWallet').addEventListener('click', () => {
            if (!selectedWallet) {
                log('No wallet selected. Create one first.', 'error');
                return;
            }
            
            const result = extendWalletLifetime(selectedWallet, 5 * 60 * 1000); // 5 minutes
            if (result) {
                log(`Extended wallet lifetime: ${selectedWallet}`, 'success');
                log(`New expiration: ${new Date(result.expirationTime).toLocaleString()}`);
            } else {
                log(`Failed to extend wallet lifetime: ${selectedWallet}`, 'error');
            }
        });
        
        document.getElementById('makeWalletPersistent').addEventListener('click', () => {
            if (!selectedWallet) {
                log('No wallet selected. Create one first.', 'error');
                return;
            }
            
            const result = makeWalletPersistent(selectedWallet);
            if (result) {
                log(`Made wallet persistent: ${selectedWallet}`, 'success');
            } else {
                log(`Failed to make wallet persistent: ${selectedWallet}`, 'error');
            }
        });
        
        document.getElementById('makeWalletTemporary').addEventListener('click', () => {
            if (!selectedWallet) {
                log('No wallet selected. Create one first.', 'error');
                return;
            }
            
            const result = makeWalletTemporary(selectedWallet, 2 * 60 * 1000); // 2 minutes
            if (result) {
                log(`Made wallet temporary: ${selectedWallet}`, 'success');
                const metadata = getWalletMetadata(selectedWallet);
                log(`New expiration: ${new Date(metadata.expirationTime).toLocaleString()}`);
            } else {
                log(`Failed to make wallet temporary: ${selectedWallet}`, 'error');
            }
        });
        
        document.getElementById('purgeAll').addEventListener('click', () => {
            const count = purgeAllWallets('user_requested');
            log(`Purged ${count} wallets`, 'info');
            selectedWallet = null;
        });
        
        // Run initial test
        log('Temporary Wallet Manager Test Page');
        log('Click "Create Wallet" to begin testing.');
        
        // Test to verify Web Crypto availability
        try {
            const testBytes = getSecureRandomBytes(16);
            log(`Web Crypto is available. Generated ${testBytes.length} secure random bytes.`, 'success');
        } catch (error) {
            log(`Web Crypto is NOT available! This is a security risk. Error: ${error.message}`, 'error');
        }
    </script>
</body>
</html>